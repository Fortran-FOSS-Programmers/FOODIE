var tipuesearch = {"pages":[{"text":"FOODIE FOODIE FOODIE, Fortran Object-Oriented Differential-equations Integration Environment FOODIE is a pure Fortran (KISS) library providing an awesome environment for the numerical integration of Differential-equations (ODE, PDE); FOODIE is Fortran 2008+ standard compliant; FOODIE is OOP designed; FOODIE is a Free, Open Source Project. Table of Contents What is FOODIE? Main features Status Copyrights Documentation What is FOODIE? Modern Fortran standards (2003+) have introduced support for Object-Oriented Programming (OOP). Exploiting new features like Abstract Data Type (ADT) is now possible to develop a KISS library providing an awesome environment for the numerical integration of Differential-equations such as Ordinary and Partial Differential Eqautions (ODE, PDE). FOODIE is tailored to the systems arising from the semi-discretization of PDEs, but it is not limited to them. The FOODIE environment allows the (numerical) solution of general, non linear differential equations system of the form: where: U_t = dU/dt ; U is the vector of state variables being a function of the time-like independent variable t ; R is the (vectorial) residual function, it could be a non linear function of the solution U itself; F is the (vectorial) initial conditions function. The FOODIE has two main purposes: for developers devising new schemes for the numerical integrations of differential equations (DE): provide a concise, clear, robust and comprehensive abstract environment by means of which: express the solvers formulae with a very high-level language, it being close as much as possible to their natual mathematical formulations; this ensures: clearness, conciseness and robustness; fast-developing; for clients that must solve a differential equations system: provide a simple, standard API for many built-in DE solvers out-of-the-box, thus allowing: fast-solution of new problems; robustness: the same DE solver is applied to different problems, i.e. cross-validation; Go to Top Main features FOODIE is aimed to be a KISS-pure-Fortran library for integrating Ordinary Differential Equations (ODE), it being: Pure Fortran implementation; KISS and user-friendly: simple API, presently based on the Rouson's Abstract Data Type Pattern [8]; easy building and porting on heterogeneous architectures; comprehensive solvers set out-of-the-box: explicit schemes: Adams-Bashforth schemes see [7, 12]: 1 step, namely the forward explicit Euler scheme, 1st order accurate; 2 to 16 steps, 2nd to 16th accurate, respectively; Euler (forward explicit) scheme, 1st order accurate; Leapfrog , 2nd order accurate: unfiltered leapfrog, 2nd order accurate, mostly unstable, see [4]; Robert-Asselin filtered leapfrog, 1st order accurate, see [4, 5, 6]; Robert-Asselin-Williams filtered leapfrog, 3rd order accurate, see [5, 6]; Runge-Kutta schemes: low-storage schemes, see [1, 2, 3]: 1 stage, namely the forward explicit Euler scheme, 1st order accurate; 2 stages; 3 stages; 4 stages; 5 stages, 4th order accurate, 2N registers, see [3]; 6 stages, 4th order accurate, 2N registers, see [9]; 7 stages, 4th order accurate, 2N registers, see [9]; 12 stages, 4th order accurate, 2N registers, see [10]; 13 stages, 4th order accurate, 2N registers, see [10]; 14 stages, 4th order accurate, 2N registers, see [10]; TVD/SSP schemes, see [1]: 1 stage, namely the forward explicit Euler scheme, 1st order accurate; 2 stages, 2nd order accurate; 3 stages, 3rd order accurate; 4 stages; 5 stages, 4th order accurate; embedded (adaptive) schemes: Heun-Euler, 2 stages, 2nd order accurate; Runge-Kutta-Fehlberg, 5 stages, 4th order accurate; Runge-Kutta-Cash-Karp, 6 stages, 5th order accurate, see [13]; Prince-Dormand, 7 stages, 4th order accurate, see [11]; Calvo, 9 stages, 6th order accurate, see [14]; Feagin, 17 stages, 10th order accurate, see [15]; implicit schemes: Runge-Kutta schemes; Adams-Moulton schemes: 0 step, 1st order accurate; 1 step, 2nd accurate; 2 steps, 3rd accurate; 3 steps, 4th accurate; Backward Differentiation Formula schemes: 1 step, namely the backward implicit Euler scheme, 1st order accurate; 2 to 6 steps, 2nd to 6th accurate, respectively; predictor-corrector schemes: Adams-Bashforth-Moulton schemes: 1 step, AB(1)-AM(0), 1st order accurate; 2 steps, AB(2)-AM(1), 2nd accurate; 3 steps, AB(3)-AM(2), 3rd accurate; 4 steps, AB(4)-AM(3), 4th accurate; efficient and non intrusive : FOODIE environment is unaware of any eventual parallel paradigms the clients used, but it is proved to preserve high scalability on parallel architectures such as: OpenMP directive-based codes on shared memory multi/many cores architectures; CoArray Fortran (CAF) based codes for Partitioned Global Address Space (PGAS) programming model; MPI based code on distributed memory clusters; GPGPU/accelerators device enabled codes; Tests-Driven Developed ( TDD ): well documented: clear documentation of schemes implementations, e.g. see Adams-Bashforth API documentation ; complete API reference; comprehensive wiki : collaborative developed on GitHub ; FOSS licensed ; Any feature request is welcome. Bibliography [1] High Order Strong Stability Preserving Time Discretizations , Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of Scientific Computing, vol. 38, N. 3, 2009, pp. 251–289. [2] Low-Storage Runge-Kutta Schemes , J. H. Williamson, Journal of Computational Physics, vol. 35, 1980, pp. 48–56. [3] Fourth-Order 2N-Storage Runge-Kutta Schemes , Mark H. Carpenter, Christopher A. Kennedy, NASA Technical Memorandum 109112, June 1994. [4] Numerical methods used in atmospheric models , Mesinger F. and A. Arakawa, Global Atmospheric Research Programme (GARP), Technical Report , 1976. [5] A Proposed Modification to the Robert-Asselin Time Filter , Williams, P. D., Mon. Wea. Rev., vol. 137, pp. 2538–2546, 2009, doi: http://dx.doi.org/10.1175/2009MWR2724.1. [6] The RAW filter: An improvement to the Robert-Asselin filter in semi-implicit integrations , Williams, P.D., Monthly Weather Review, vol. 139(6), pages 1996–2007, June 2011. [7] Linear multistep method , wikipedia article . [8] Scientific Software Design: The Object-Oriented Way , Rouson, Damian and Xia, Jim and Xu, Xiaofeng, 2011, ISBN 9780521888134, Cambridge University Press, New York, NY, USA. [9] High-accuracy large-step explicit Runge–Kutta (HALE-RK) schemes for computational aeroacoustics , Vasanth Allampalli and Ray Hixon and M. Nallasamy and Scott D. Sawyer, Journal of Computational Physics, vol. 228, 2009, pp. 3837–3850. [10] Efficient low-storage Runge–Kutta schemes with optimized stability regions , Jens Niegemann and Richard Diehl and Kurt Busch, Journal of Computational Physics, vol. 231, 2012, pp. 364–372. [11] A family of embedded Runge-Kutta formulae , Dormand, J. R.; Prince, P. J. (1980), , Journal of Computational and Applied Mathematics 6 (1): 19–26, doi:10.1016/0771-050X(80)90013-3. [12] Cowell Type Numerical Integration As Applied to Satellite Orbit Computation , J. L. Maury Jr., G. P. Segal, X-553-69-46, April 1969, NASA-TM-X-63542 . [13] A variable order Runge-Kutta method for initial value problems with rapidly varying right-hand sides , J. R. Cash, A. H. Karp, ACM Transactions on Mathematical Software, vol. 16,  pp. 201–222, 1990, doi:10.1145/79505.79507. [14] A New Embedded Pair of Runge-Kutta Formulas of orders 5 and 6 , M. Calvo, J.I. Montijano, L. Randez, Computers & Mathematics with Applications, Volume 20, Issue 1, 1990, Pages 15–24, ISSN 0898-1221, http://dx.doi.org/10.1016/0898-1221(90)90064-Q. [15] A tenth-order Runge-Kutta method with error estimate , Feagin, T., Proceedings of the IAENG Conf. on Scientific Computing. 2007. Go to Top Status FOODIE project is young, but developed with love. Many integrators have been implemented using the Rouson's Abstract Data Type Pattern and tested with complex problems, but the library API is still in beta testing status. Nevertheless, FOODIE is already proven to be able to integrate a wide range of different ODE problems, from pure ODEs (Lorenz and inertial oscillations equations) to complex PDEs (Burgers and Euler equations), see the documentation. We are searching for Fortraners enthusiast joining our team! Copyrights FOODIE is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to FOODIE is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the FOODIE documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . Go to Top Developer Info Fortran-FOSS-Programmers Group","tags":"","loc":"index.html","title":" FOODIE "},{"text":"FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. Source Code !< FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. module foodie !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. !< !< FOODIE is a KISS library for solving systems of Ordinary Differential Equation (ODE) into the Initial Values Problems (IVP) !< contest. The mathematical formulation of the problem is: !< !< U_t = R(t,U) !< U_0 = F(0) !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function and *F* is the (vectorial) initial conditions function. !< !< FOODIE is aimed to the time-like integration of the above system of ODE. To this aim, different numerical schemes are provided: !< !<+ *explicit Adams-Bashforth* class of schemes: !<    + 1 step, namely the explicit forward Euler scheme, 1st order accurate; !<    + 2 steps, 2nd order accurate; !<    + 3 steps, 3rd order accurate; !<    + 4 steps, 4th order accurate; !<+ *forward explicit Euler* scheme, a 1st order accurate; !<+ *explicit Leapfrog*: !<    + Unfiltered, 2nd order accurate, (mostly) unstable; !<    + Robert-Asselin filtered, 1st order accurate; !<    + Robert-Asselin-Williams filter, 2nd order accurate; !<+ *explicit low storage Runge-Kutta 2N* class schemes: !<    + LS(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; !<    + LS(5,4): 5 stages, 4th order accurate; !<+ *explicit TVD or SSP Runge-Kutta* class schemes: !<    + TVD(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; !<    + SSP(2,2): 2 stages, 2nd order accurate; !<    + SSP(3,3): 3 stages, 3rd order accurate; !<    + SSP(5,4): 5 stages, 4th order accurate; !<+ *explicit embedded Runge-Kutta* class schemes: !<    + DP(7,4): 7 stages, 4th order accurate, Dormand and Prince scheme; !<+ *implicit Adams-Moulton* class of schemes: !<    + 0 step, namely the implicit backward Euler scheme, 1st order accurate; !<    + 1 step, 2nd order accurate; !<    + 2 steps, 3rd order accurate; !<    + 3 steps, 4th order accurate; !<+ *predictor-corrector Adams-Bashforth-Moulton* class of schemes: !<    + P=AB(1)-C=AM(0) step, namely the explicit/implicit forward/backward Euler scheme, 1st order accurate; !<    + P=AB(2)-C=AM(1) step, 2nd order accurate; !<    + P=AB(3)-C=AM(2) steps, 3rd order accurate; !<    + P=AB(4)-C=AM(3) steps, 4th order accurate; !< !<### Usage !< !< FOODIE schemes must be applied to only subclass extensions of the abstract class *integrand*. !< !< To use FOODIE you must: !< !<#### extend integrand abstract class provided by FOODIE implementing your concrete integrand field !< !< For example for the Lorenz' ODE system !< !<```fortran !< type, extends(integrand) :: lorenz !<   !< Lorenz equations field. !<   !< !<   !< It is a FOODIE integrand class. !<   private !<   real(R_P), dimension(:), allocatable :: state        !< Solution vector. !<   real(R_P)                            :: sigma=0._R_P !< Lorenz \\sigma. !<   real(R_P)                            :: rho=0._R_P   !< Lorenz \\rho. !<   real(R_P)                            :: beta=0._R_P  !< Lorenz \\beta. !<   contains !<     procedure, pass(self), public :: t => dLorenz_dt                                 !< Time derivate, resiuduals function. !<     procedure, pass(lhs),  public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. !<     procedure, pass(rhs),  public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. !<     procedure, pass(lhs),  public :: add => add_lorenz                               !< Lorenz + Lorenz oprator. !<     procedure, pass(lhs),  public :: assign_integrand => lorenz_assign_lorenz        !< Lorenz = Lorenz. !<     procedure, pass(lhs),  public :: assign_real => lorenz_assign_real               !< Lorenz = real. !<     ... !< endtype lorenz !<``` !< !<#### use one of the provided FOODIE integrator !< !< For example using the forward explicit Euler scheme to the above Lorenz' ODE system !< !<```fortran !< use foodie, only : euler_explicit_integrator !< use type_lorenz, only : lorenz !< type(euler_explicit_integrator) :: euler_integrator !< type(lorenz)                    :: attractor !< real                            :: dt=0.01 !< do step = 1, num_steps !<   call euler_integrator%integrate(field=attractor, dt=dt) !< enddo !<``` !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_integrator_adams_bashforth , only : adams_bashforth_integrator use foodie_integrator_adams_bashforth_moulton , only : adams_bashforth_moulton_integrator use foodie_integrator_adams_moulton , only : adams_moulton_integrator use foodie_integrator_backward_differentiation_formula , only : back_df_integrator use foodie_integrator_emd_runge_kutta , only : emd_runge_kutta_integrator use foodie_integrator_euler_explicit , only : euler_explicit_integrator use foodie_integrator_leapfrog , only : leapfrog_integrator use foodie_integrator_low_storage_runge_kutta , only : ls_runge_kutta_integrator use foodie_integrator_tvd_runge_kutta , only : tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: integrand public :: adams_bashforth_integrator public :: adams_bashforth_moulton_integrator public :: adams_moulton_integrator public :: back_df_integrator public :: emd_runge_kutta_integrator public :: euler_explicit_integrator public :: leapfrog_integrator public :: ls_runge_kutta_integrator public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- endmodule foodie","tags":"","loc":"sourcefile/foodie.f90.html","title":"foodie.f90 – FOODIE"},{"text":"Define the abstract type integrand for building FOODIE ODE integrators. Source Code !< Define the abstract type *integrand* for building FOODIE ODE integrators. module foodie_adt_integrand !----------------------------------------------------------------------------------------------------------------------------------- !< Define the abstract type *integrand* for building FOODIE ODE integrators. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , abstract :: integrand !< Abstract type for building FOODIE ODE integrators. #ifdef CAF class ( * ), allocatable :: dummy_to_allow_extensions [:] !< Dummy member to allow concrete extensions with coarray members. #endif contains ! public deferred procedures that concrete integrand-field must implement procedure ( time_derivative ), pass ( self ), deferred , public :: t !< Time derivative, residuals. ! operators procedure ( local_error_operator ), pass ( lhs ), deferred , public :: local_error !< ||integrand - integrand||. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_multiply_integrand !< Integrand * integrand operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_multiply_real !< Integrand * real operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_multiply_integrand !< Real * integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: add !< Integrand + integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: sub !< Integrand - integrand operator. procedure ( assignment_integrand ), pass ( lhs ), deferred , public :: assign_integrand !< Integrand = integrand. ! operators overloading generic , public :: operator (. lterror .) => local_error !< Estimate local truncation error. generic , public :: operator ( + ) => add !< Overloading + operator. generic , public :: operator ( - ) => sub !< Overloading - operator. generic , public :: operator ( * ) => integrand_multiply_integrand , & real_multiply_integrand , & integrand_multiply_real !< Overloading * operator. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. endtype integrand abstract interface !< Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). function time_derivative ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative function of integrand class, i.e. the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( IN ) :: self !< Integrand field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Result of the time derivative function of integrand field. !--------------------------------------------------------------------------------------------------------------------------------- endfunction time_derivative function local_error_operator ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 solution approximations. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. !--------------------------------------------------------------------------------------------------------------------------------- endfunction local_error_operator function integrand_op_real ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Asymmetric type operator integrand.op.real. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction integrand_op_real function real_op_integrand ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Asymmetric type operator real.op.integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_op_integrand function symmetric_operator ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Symmetric type operator integrand.op.integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand class ( integrand ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction symmetric_operator #ifdef PURE ! declare this pure should not be necessary, but this is a temporary workaround for a possible GNU gfortran bug. pure subroutine assignment_integrand ( lhs , rhs ) #else subroutine assignment_integrand ( lhs , rhs ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Symmetric assignment integrand = integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand class ( integrand ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assignment_integrand endinterface !----------------------------------------------------------------------------------------------------------------------------------- endmodule foodie_adt_integrand","tags":"","loc":"sourcefile/foodie_adt_integrand.f90.html","title":"foodie_adt_integrand.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. Source Code !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. module foodie_integrator_adams_bashforth !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Adams-Bashforth class scheme implemented is: !< !<  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s}{ b_s \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  !< !<where N_s is the number of previous steps considered. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit. The coefficients *b* define the actual scheme, that is selected accordingly to the number of !< **steps** used. Currently, the schemes provided have steps number in *[1, 16]*. Note that the scheme using only 1 step reverts !< to Explicit Forward Euler. The formal order of accuracy varies consistently in *[1st, 16th]* order. !< !<#### Bibliography !< [1] *Cowell Type Numerical Integration As Applied to Satellite Orbit Computation*, J. L. Maury Jr., !< G. P. Segal, X-553-69-46, April 1969, [NASA-TM-X-63542](http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19690017325.pdf). !< !< [2] *Linear multistep method*, [wikipedia article](https://en.wikipedia.org/wiki/Linear_multistep_method). !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : I_P , R_P use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: adams_bashforth_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- character ( len = 99 ), parameter :: supported_steps = '1-16' !< List of supported steps number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 1 !< Minimum number of steps supported. integer ( I_P ), parameter :: max_ss = 16 !< Maximum number of steps supported. type :: adams_bashforth_integrator !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required time steps; private integer ( I_P ) :: steps = 0 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< *b* coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. final :: finalize !< Finalize object. endtype adams_bashforth_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth integrator: initialize the *b* coefficients. !< !< @note If the integrator is initialized with a bad (unsupported) number of required time steps the initialization fails and !< the integrator error status is updated consistently for external-provided errors handling. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( steps )) then self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 1 : steps )) ; self % b = 0.0_R_P select case ( steps ) case ( 1 ) ! AB(1) Forward-Euler self % b ( 1 ) = 1.0_R_P case ( 2 ) self % b ( 1 ) = - 1.0_R_P / 2.0_R_P self % b ( 2 ) = 3.0_R_P / 2.0_R_P case ( 3 ) self % b ( 1 ) = 5.0_R_P / 1 2.0_R_P self % b ( 2 ) = - 1 6.0_R_P / 1 2.0_R_P self % b ( 3 ) = 2 3.0_R_P / 1 2.0_R_P case ( 4 ) self % b ( 1 ) = - 9.0_R_P / 2 4.0_R_P self % b ( 2 ) = 3 7.0_R_P / 2 4.0_R_P self % b ( 3 ) = - 5 9.0_R_P / 2 4.0_R_P self % b ( 4 ) = 5 5.0_R_P / 2 4.0_R_P case ( 5 ) self % b ( 1 ) = 25 1.0_R_P / 72 0.0_R_P self % b ( 2 ) = - 127 4.0_R_P / 72 0.0_R_P self % b ( 3 ) = 261 6.0_R_P / 72 0.0_R_P self % b ( 4 ) = - 277 4.0_R_P / 72 0.0_R_P self % b ( 5 ) = 190 1.0_R_P / 72 0.0_R_P case ( 6 ) self % b ( 1 ) = - 47 5.0_R_P / 144 0.0_R_P self % b ( 2 ) = 287 7.0_R_P / 144 0.0_R_P self % b ( 3 ) = - 729 8.0_R_P / 144 0.0_R_P self % b ( 4 ) = 998 2.0_R_P / 144 0.0_R_P self % b ( 5 ) = - 792 3.0_R_P / 144 0.0_R_P self % b ( 6 ) = 427 7.0_R_P / 144 0.0_R_P case ( 7 ) self % b ( 1 ) = 1908 7.0_R_P / 6048 0.0_R_P self % b ( 2 ) = - 13447 2.0_R_P / 6048 0.0_R_P self % b ( 3 ) = 40713 9.0_R_P / 6048 0.0_R_P self % b ( 4 ) = - 68825 6.0_R_P / 6048 0.0_R_P self % b ( 5 ) = 70554 9.0_R_P / 6048 0.0_R_P self % b ( 6 ) = - 44728 8.0_R_P / 6048 0.0_R_P self % b ( 7 ) = 19872 1.0_R_P / 6048 0.0_R_P case ( 8 ) self % b ( 1 ) = - 3679 9.0_R_P / 12096 0.0_R_P self % b ( 2 ) = 29576 7.0_R_P / 12096 0.0_R_P self % b ( 3 ) = - 104172 3.0_R_P / 12096 0.0_R_P self % b ( 4 ) = 210224 3.0_R_P / 12096 0.0_R_P self % b ( 5 ) = - 266447 7.0_R_P / 12096 0.0_R_P self % b ( 6 ) = 218387 7.0_R_P / 12096 0.0_R_P self % b ( 7 ) = - 115216 9.0_R_P / 12096 0.0_R_P self % b ( 8 ) = 43424 1.0_R_P / 12096 0.0_R_P case ( 9 ) self % b ( 1 ) = 107001 7.0_R_P / 362880 0.0_R_P self % b ( 2 ) = - 966410 6.0_R_P / 362880 0.0_R_P self % b ( 3 ) = 3883348 6.0_R_P / 362880 0.0_R_P self % b ( 4 ) = - 9117264 2.0_R_P / 362880 0.0_R_P self % b ( 5 ) = 13796848 0.0_R_P / 362880 0.0_R_P self % b ( 6 ) = - 13985526 2.0_R_P / 362880 0.0_R_P self % b ( 7 ) = 9547678 6.0_R_P / 362880 0.0_R_P self % b ( 8 ) = - 4312520 6.0_R_P / 362880 0.0_R_P self % b ( 9 ) = 1409724 7.0_R_P / 362880 0.0_R_P case ( 10 ) self % b ( 1 ) = - 208275 3.0_R_P / 725760 0.0_R_P self % b ( 2 ) = 2088481 1.0_R_P / 725760 0.0_R_P self % b ( 3 ) = - 9430732 0.0_R_P / 725760 0.0_R_P self % b ( 4 ) = 25261822 4.0_R_P / 725760 0.0_R_P self % b ( 5 ) = - 44477216 2.0_R_P / 725760 0.0_R_P self % b ( 6 ) = 53836383 8.0_R_P / 725760 0.0_R_P self % b ( 7 ) = - 45466177 6.0_R_P / 725760 0.0_R_P self % b ( 8 ) = 26593268 0.0_R_P / 725760 0.0_R_P self % b ( 9 ) = - 10499518 9.0_R_P / 725760 0.0_R_P self % b ( 10 ) = 3027724 7.0_R_P / 725760 0.0_R_P case ( 11 ) self % b ( 1 ) = 13421126 5.0_R_P / 47900160 0.0_R_P self % b ( 2 ) = - 147957434 8.0_R_P / 47900160 0.0_R_P self % b ( 3 ) = 741790445 1.0_R_P / 47900160 0.0_R_P self % b ( 4 ) = - 2232963492 0.0_R_P / 47900160 0.0_R_P self % b ( 5 ) = 4485716843 4.0_R_P / 47900160 0.0_R_P self % b ( 6 ) = - 6317620147 2.0_R_P / 47900160 0.0_R_P self % b ( 7 ) = 6371637895 8.0_R_P / 47900160 0.0_R_P self % b ( 8 ) = - 4611302901 6.0_R_P / 47900160 0.0_R_P self % b ( 9 ) = 2359106380 5.0_R_P / 47900160 0.0_R_P self % b ( 10 ) = - 827179512 4.0_R_P / 47900160 0.0_R_P self % b ( 11 ) = 213250956 7.0_R_P / 47900160 0.0_R_P case ( 12 ) self % b ( 1 ) = - 26274726 5.0_R_P / 95800320 0.0_R_P self % b ( 2 ) = 315864244 5.0_R_P / 95800320 0.0_R_P self % b ( 3 ) = - 1741024827 1.0_R_P / 95800320 0.0_R_P self % b ( 4 ) = 5818910762 7.0_R_P / 95800320 0.0_R_P self % b ( 5 ) = - 13136586729 0.0_R_P / 95800320 0.0_R_P self % b ( 6 ) = 21110357329 8.0_R_P / 95800320 0.0_R_P self % b ( 7 ) = - 24774163937 4.0_R_P / 95800320 0.0_R_P self % b ( 8 ) = 21413935536 6.0_R_P / 95800320 0.0_R_P self % b ( 9 ) = - 13557935675 7.0_R_P / 95800320 0.0_R_P self % b ( 10 ) = 6163322718 5.0_R_P / 95800320 0.0_R_P self % b ( 11 ) = - 1943381016 3.0_R_P / 95800320 0.0_R_P self % b ( 12 ) = 452776639 9.0_R_P / 95800320 0.0_R_P case ( 13 ) self % b ( 1 ) = 70360425435 7.0_R_P / 261534873600 0.0_R_P self % b ( 2 ) = - 916055108573 4.0_R_P / 261534873600 0.0_R_P self % b ( 3 ) = 5506097466241 2.0_R_P / 261534873600 0.0_R_P self % b ( 4 ) = - 20232291373837 0.0_R_P / 261534873600 0.0_R_P self % b ( 5 ) = 50714036972842 5.0_R_P / 261534873600 0.0_R_P self % b ( 6 ) = - 91588338715244 4.0_R_P / 261534873600 0.0_R_P self % b ( 7 ) = 122644308612940 8.0_R_P / 261534873600 0.0_R_P self % b ( 8 ) = - 123358924494176 4.0_R_P / 261534873600 0.0_R_P self % b ( 9 ) = 93288454605589 5.0_R_P / 261534873600 0.0_R_P self % b ( 10 ) = - 52492457990515 0.0_R_P / 261534873600 0.0_R_P self % b ( 11 ) = 21469659100261 2.0_R_P / 261534873600 0.0_R_P self % b ( 12 ) = - 6149755279727 4.0_R_P / 261534873600 0.0_R_P self % b ( 13 ) = 1306440652362 7.0_R_P / 261534873600 0.0_R_P case ( 14 ) self % b ( 1 ) = - 138274192962 1.0_R_P / 523069747200 0.0_R_P self % b ( 2 ) = 1938285359378 7.0_R_P / 523069747200 0.0_R_P self % b ( 3 ) = - 12617497268190 6.0_R_P / 523069747200 0.0_R_P self % b ( 4 ) = 50558614119643 0.0_R_P / 523069747200 0.0_R_P self % b ( 5 ) = - 139330630715575 5.0_R_P / 523069747200 0.0_R_P self % b ( 6 ) = 279386960287907 7.0_R_P / 523069747200 0.0_R_P self % b ( 7 ) = - 420455192553452 4.0_R_P / 523069747200 0.0_R_P self % b ( 8 ) = 482567132348845 2.0_R_P / 523069747200 0.0_R_P self % b ( 9 ) = - 424676735330575 5.0_R_P / 523069747200 0.0_R_P self % b ( 10 ) = 285442957179080 5.0_R_P / 523069747200 0.0_R_P self % b ( 11 ) = - 144531335168190 6.0_R_P / 523069747200 0.0_R_P self % b ( 12 ) = 53724705251566 2.0_R_P / 523069747200 0.0_R_P self % b ( 13 ) = - 14097075067962 1.0_R_P / 523069747200 0.0_R_P self % b ( 14 ) = 2751155497687 5.0_R_P / 523069747200 0.0_R_P case ( 15 ) self % b ( 1 ) = 816416873759 9.0_R_P / 3138418483200 0.0_R_P self % b ( 2 ) = - 12259481390411 2.0_R_P / 3138418483200 0.0_R_P self % b ( 3 ) = 85923647668423 1.0_R_P / 3138418483200 0.0_R_P self % b ( 4 ) = - 372880725657747 2.0_R_P / 3138418483200 0.0_R_P self % b ( 5 ) = 1120584975351517 9.0_R_P / 3138418483200 0.0_R_P self % b ( 6 ) = - 2470450365560772 8.0_R_P / 3138418483200 0.0_R_P self % b ( 7 ) = 4128021633628425 9.0_R_P / 3138418483200 0.0_R_P self % b ( 8 ) = - 5324673866064691 2.0_R_P / 3138418483200 0.0_R_P self % b ( 9 ) = 5347102665994050 9.0_R_P / 3138418483200 0.0_R_P self % b ( 10 ) = - 4182526993250772 8.0_R_P / 3138418483200 0.0_R_P self % b ( 11 ) = 2529891033708142 9.0_R_P / 3138418483200 0.0_R_P self % b ( 12 ) = - 1164363753057747 2.0_R_P / 3138418483200 0.0_R_P self % b ( 13 ) = 396642167021548 1.0_R_P / 3138418483200 0.0_R_P self % b ( 14 ) = - 96012286640411 2.0_R_P / 3138418483200 0.0_R_P self % b ( 15 ) = 17323349859884 9.0_R_P / 3138418483200 0.0_R_P case ( 16 ) self % b ( 1 ) = - 1608812922937 5.0_R_P / 6276836966400 0.0_R_P self % b ( 2 ) = 25765027591582 3.0_R_P / 6276836966400 0.0_R_P self % b ( 3 ) = - 193444319689259 9.0_R_P / 6276836966400 0.0_R_P self % b ( 4 ) = 903857175273408 7.0_R_P / 6276836966400 0.0_R_P self % b ( 5 ) = - 2941791091125181 9.0_R_P / 6276836966400 0.0_R_P self % b ( 6 ) = 7072435158284348 3.0_R_P / 6276836966400 0.0_R_P self % b ( 7 ) = - 12993009410423733 1.0_R_P / 6276836966400 0.0_R_P self % b ( 8 ) = 18608754426359664 3.0_R_P / 6276836966400 0.0_R_P self % b ( 9 ) = - 21002058891232194 9.0_R_P / 6276836966400 0.0_R_P self % b ( 10 ) = 18746314011290289 3.0_R_P / 6276836966400 0.0_R_P self % b ( 11 ) = - 13196319194082858 1.0_R_P / 6276836966400 0.0_R_P self % b ( 12 ) = 7255811707225973 3.0_R_P / 6276836966400 0.0_R_P self % b ( 13 ) = - 3060737386052056 9.0_R_P / 6276836966400 0.0_R_P self % b ( 14 ) = 962209690951533 7.0_R_P / 6276836966400 0.0_R_P self % b ( 15 ) = - 216156767124884 9.0_R_P / 6276836966400 0.0_R_P self % b ( 16 ) = 36255512642707 3.0_R_P / 6276836966400 0.0_R_P endselect self % error = 0 else ! bad (unsupported) number of required time steps self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 if ( allocated ( self % b )) deallocate ( self % b ) self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , previous , Dt , t , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate do s = 1 , self % steps U = U + previous ( s )% t ( t = t ( s )) * ( Dt * self % b ( s )) enddo if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do s = 1 , self % steps - 1 previous ( s ) = previous ( s + 1 ) enddo previous ( self % steps ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous elemental function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps elemental function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_adams_bashforth","tags":"","loc":"sourcefile/foodie_integrator_adams_bashforth.f90.html","title":"foodie_integrator_adams_bashforth.f90 – FOODIE"},{"text":"FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order\n accurate. Source Code !< FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order !< accurate. module foodie_integrator_adams_bashforth_moulton !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order !< accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Adams-Bashforth-Moulton class scheme implemented is: !< !<##### predictor !<  U&#94;{n+N_s&#94;p} = U&#94;{n+N_s&#94;p-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s&#94;p}{ b_s&#94;p \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  !<##### corrector !<  U&#94;{n+N_s&#94;c} = U&#94;{n+N_s&#94;c-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s&#94;c}{ b_s&#94;c \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } \\right]  !< !<where N_s&#94;p is the number of previous steps considered for the predictor and N_s&#94;c is the number of previous steps !<considered for the corrector. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The coefficients b_s&#94;{p,c} define the actual scheme, that is selected accordingly to the number of !< **steps** used. The predictor and corrector schemes should have the same formal order of accuracy, thus N_s&#94;p=N_s&#94;c+1 !< should hold. !< !< Currently, the following schemes are available: !<##### P=AB(1)-C=AM(0) step, Explicit/Implicit Farward/Backward Euler, 1st order !< This scheme is TVD and reverts to Explicit/Implicit Farward/Backward Euler, it being 1st order. !< The *b* coefficient is: !< b&#94;p = \\left[b_1\\right] = \\left[1\\right] !< b&#94;c = \\left[b_0\\right] = \\left[1\\right] !< The scheme is: !<  U&#94;{n+1,p} = U&#94;{n} + \\Delta t R(t&#94;{n},U&#94;{n})  !<  U&#94;{n+1,c} = U&#94;{n} + \\Delta t R(t&#94;{n+1},U&#94;{n+1,p})  !< !<##### P=AB(2)-C=AM(1) steps !< This scheme is 2nd order. !< The *b* coefficients are: !< b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right] !< b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2} & \\frac{1}{2} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+2,p} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right]  !<  U&#94;{n+2,c} = U&#94;{n+1} +\\Delta t \\left[ \\frac{1}{2} R(t&#94;{n+2,p}, U&#94;{n+2})+\\frac{1}{2} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  !< !<##### P=AB(3)-C=AM(2) steps !< This scheme is 3rd order. !< The *b* coefficients are: !< b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right] !< b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{12} & \\frac{2}{3} & \\frac{5}{12} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+3,p} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1}) !< +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right]  !<  U&#94;{n+3,c} = U&#94;{n+2} +\\Delta t \\left[ \\frac{5}{12}R(t&#94;{n+3}, U&#94;{n+3,p}) + \\frac{2}{3}R(t&#94;{n+2}, U&#94;{n+2}) !< -\\frac{1}{12} R(t&#94;{n+1}, U&#94;{n+1})  \\right]  !< !<##### P=AB(4)-C=AM(3) steps !< This scheme is 4th order. !< The *b* coefficients are: !< b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 & b_4 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} -\\frac{9}{24} & \\frac{37}{24} & -\\frac{59}{24} & \\frac{55}{24} \\end{array}} \\right] !< b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 & b_3 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{24} & -\\frac{5}{24} & \\frac{19}{24} & \\frac{9}{24} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+4,p} = U&#94;{n+3} +\\Delta t \\left[ \\frac{55}{24}R(t&#94;{n+3}, U&#94;{n+3}) - \\frac{59}{24}R(t&#94;{n+2}, U&#94;{n+2}) !< +\\frac{37}{24} R(t&#94;{n+1}, U&#94;{n+1}) - \\frac{9}{24} R(t&#94;{n}, U&#94;{n}) \\right]  !<  U&#94;{n+4,c} = U&#94;{n+3} +\\Delta t \\left[ \\frac{9}{24}R(t&#94;{n+4}, U&#94;{n+4,p}) + \\frac{19}{24}R(t&#94;{n+3}, U&#94;{n+3}) !< -\\frac{5}{24} R(t&#94;{n+2}, U&#94;{n+2}) + \\frac{1}{24} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  !< !<#### Bibliography !< !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : I_P , R_P use foodie_integrator_adams_bashforth , only : adams_bashforth_integrator use foodie_integrator_adams_moulton , only : adams_moulton_integrator use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: adams_bashforth_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- character ( len = 99 ), parameter :: supported_steps = '1-16' !< List of supported steps number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 1 !< Minimum number of steps supported. integer ( I_P ), parameter :: max_ss = 16 !< Maximum number of steps supported. type :: adams_bashforth_moulton_integrator !< FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. !< !< @note The integrator must be created or initialized (predictor and corrector schemes selection) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required time steps; private integer ( I_P ) :: steps =- 1 !< Number of time steps. type ( adams_bashforth_integrator ) :: predictor !< Predictor solver. type ( adams_moulton_integrator ) :: corrector !< Corrector solver. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. final :: finalize !< Finalize object. endtype adams_bashforth_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth-Moulton integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( steps )) then self % steps = steps call self % predictor % init ( steps = steps ) call self % corrector % init ( steps = steps - 1 ) self % error = 0 else ! bad (unsupported) number of required time steps self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = - 1 call self % predictor % destroy call self % corrector % destroy self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , previous , Dt , t , iterations ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth-Moulton class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( IN ) :: self !< Actual ABM integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations of AM scheme. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % predictor % integrate ( U = U , previous = previous , Dt = Dt , t = t , autoupdate = . false .) call self % corrector % integrate ( U = U , previous = previous ( 2 :), Dt = Dt , t = t , iterations = iterations , autoupdate = . false .) call self % predictor % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate elemental function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps elemental function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_adams_bashforth_moulton","tags":"","loc":"sourcefile/foodie_integrator_adams_bashforth_moulton.f90.html","title":"foodie_integrator_adams_bashforth_moulton.f90 – FOODIE"},{"text":"FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 16th order accurate. Source Code !< FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 16th order accurate. module foodie_integrator_adams_moulton !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 16th order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Adams-Moulton class scheme implemented is: !< !<  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s-1}{ b_s \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } + !< b_{N_S}\\cdot R(t&#94;{n+N_s}, U&#94;{n+N_s}) \\right]  !< !<where N_s is the number of previous steps considered. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are implicit. The coefficients *b* define the actual scheme, that is selected accordingly to the number of !< **steps** used. Currently, the schemes provided have steps number in *[0, 15]*. Note that the scheme using only 1 step reverts !< to Implciti Backwarad Euler. The formal order of accuracy varies consistently in *[1st, 16th]* order. !< !<#### Bibliography !< [1] *Cowell Type Numerical Integration As Applied to Satellite Orbit Computation*, J. L. Maury Jr., !< G. P. Segal, X-553-69-46, April 1969, [NASA-TM-X-63542](http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19690017325.pdf). !< !< [2] *Linear multistep method*, [wikipedia article](https://en.wikipedia.org/wiki/Linear_multistep_method). !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : I_P , R_P use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: adams_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- character ( len = 99 ), parameter :: supported_steps = '0-15' !< List of supported steps number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 0 !< Minimum number of steps supported. integer ( I_P ), parameter :: max_ss = 15 !< Maximum number of steps supported. type :: adams_moulton_integrator !< FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 16th order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required time steps; private integer ( I_P ) :: steps =- 1 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< b coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. final :: finalize !< Finalize object. endtype adams_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Moulton integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( steps )) then self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 0 : steps )) ; self % b = 0.0_R_P select case ( steps ) case ( 0 ) ! AM(0) Bacward-Euler self % b ( 0 ) = 1.0_R_P case ( 1 ) self % b ( 0 ) = 1.0_R_P / 2.0_R_P self % b ( 1 ) = 1.0_R_P / 2.0_R_P case ( 2 ) self % b ( 0 ) = - 1.0_R_P / 1 2.0_R_P self % b ( 1 ) = 8.0_R_P / 1 2.0_R_P self % b ( 2 ) = 5.0_R_P / 1 2.0_R_P case ( 3 ) self % b ( 0 ) = 1.0_R_P / 2 4.0_R_P self % b ( 1 ) = - 5.0_R_P / 2 4.0_R_P self % b ( 2 ) = 1 9.0_R_P / 2 4.0_R_P self % b ( 3 ) = 9.0_R_P / 2 4.0_R_P case ( 4 ) self % b ( 0 ) = - 1 9.0_R_P / 72 0.0_R_P self % b ( 1 ) = 10 6.0_R_P / 72 0.0_R_P self % b ( 2 ) = - 26 4.0_R_P / 72 0.0_R_P self % b ( 3 ) = 64 6.0_R_P / 72 0.0_R_P self % b ( 4 ) = 25 1.0_R_P / 72 0.0_R_P case ( 5 ) self % b ( 0 ) = 2 7.0_R_P / 144 0.0_R_P self % b ( 1 ) = - 17 3.0_R_P / 144 0.0_R_P self % b ( 2 ) = 48 2.0_R_P / 144 0.0_R_P self % b ( 3 ) = - 79 8.0_R_P / 144 0.0_R_P self % b ( 4 ) = 142 7.0_R_P / 144 0.0_R_P self % b ( 5 ) = 47 5.0_R_P / 144 0.0_R_P case ( 6 ) self % b ( 0 ) = - 86 3.0_R_P / 6048 0.0_R_P self % b ( 1 ) = 631 2.0_R_P / 6048 0.0_R_P self % b ( 2 ) = - 2021 1.0_R_P / 6048 0.0_R_P self % b ( 3 ) = 3750 4.0_R_P / 6048 0.0_R_P self % b ( 4 ) = - 4646 1.0_R_P / 6048 0.0_R_P self % b ( 5 ) = 6511 2.0_R_P / 6048 0.0_R_P self % b ( 6 ) = 1908 7.0_R_P / 6048 0.0_R_P case ( 7 ) self % b ( 0 ) = 137 5.0_R_P / 12096 0.0_R_P self % b ( 1 ) = - 1135 1.0_R_P / 12096 0.0_R_P self % b ( 2 ) = 4149 9.0_R_P / 12096 0.0_R_P self % b ( 3 ) = - 8854 7.0_R_P / 12096 0.0_R_P self % b ( 4 ) = 12313 3.0_R_P / 12096 0.0_R_P self % b ( 5 ) = - 12179 7.0_R_P / 12096 0.0_R_P self % b ( 6 ) = 13984 9.0_R_P / 12096 0.0_R_P self % b ( 7 ) = 3679 9.0_R_P / 12096 0.0_R_P case ( 8 ) self % b ( 0 ) = - 3395 3.0_R_P / 362880 0.0_R_P self % b ( 1 ) = 31287 4.0_R_P / 362880 0.0_R_P self % b ( 2 ) = - 129121 4.0_R_P / 362880 0.0_R_P self % b ( 3 ) = 314633 8.0_R_P / 362880 0.0_R_P self % b ( 4 ) = - 503312 0.0_R_P / 362880 0.0_R_P self % b ( 5 ) = 559535 8.0_R_P / 362880 0.0_R_P self % b ( 6 ) = - 460459 4.0_R_P / 362880 0.0_R_P self % b ( 7 ) = 446709 4.0_R_P / 362880 0.0_R_P self % b ( 8 ) = 107001 7.0_R_P / 362880 0.0_R_P case ( 9 ) self % b ( 0 ) = 5728 1.0_R_P / 725760 0.0_R_P self % b ( 1 ) = - 58343 5.0_R_P / 725760 0.0_R_P self % b ( 2 ) = 268786 4.0_R_P / 725760 0.0_R_P self % b ( 3 ) = - 739403 2.0_R_P / 725760 0.0_R_P self % b ( 4 ) = 1351008 2.0_R_P / 725760 0.0_R_P self % b ( 5 ) = - 1728364 6.0_R_P / 725760 0.0_R_P self % b ( 6 ) = 1600232 0.0_R_P / 725760 0.0_R_P self % b ( 7 ) = - 1127130 4.0_R_P / 725760 0.0_R_P self % b ( 8 ) = 944971 7.0_R_P / 725760 0.0_R_P self % b ( 9 ) = 208275 3.0_R_P / 725760 0.0_R_P case ( 10 ) self % b ( 0 ) = - 325043 3.0_R_P / 47900160 0.0_R_P self % b ( 1 ) = 3628487 6.0_R_P / 47900160 0.0_R_P self % b ( 2 ) = - 18477619 5.0_R_P / 47900160 0.0_R_P self % b ( 3 ) = 56745098 4.0_R_P / 47900160 0.0_R_P self % b ( 4 ) = - 117059704 2.0_R_P / 47900160 0.0_R_P self % b ( 5 ) = 171077452 8.0_R_P / 47900160 0.0_R_P self % b ( 6 ) = - 182331156 6.0_R_P / 47900160 0.0_R_P self % b ( 7 ) = 144620508 0.0_R_P / 47900160 0.0_R_P self % b ( 8 ) = - 89017554 9.0_R_P / 47900160 0.0_R_P self % b ( 9 ) = 65618565 2.0_R_P / 47900160 0.0_R_P self % b ( 10 ) = 13421126 5.0_R_P / 47900160 0.0_R_P case ( 11 ) self % b ( 0 ) = 567526 5.0_R_P / 95800320 0.0_R_P self % b ( 1 ) = - 6892878 1.0_R_P / 95800320 0.0_R_P self % b ( 2 ) = 38470932 7.0_R_P / 95800320 0.0_R_P self % b ( 3 ) = - 130597111 5.0_R_P / 95800320 0.0_R_P self % b ( 4 ) = 300773941 8.0_R_P / 95800320 0.0_R_P self % b ( 5 ) = - 496316651 4.0_R_P / 95800320 0.0_R_P self % b ( 6 ) = 604352148 6.0_R_P / 95800320 0.0_R_P self % b ( 7 ) = - 551946058 2.0_R_P / 95800320 0.0_R_P self % b ( 8 ) = 382882888 5.0_R_P / 95800320 0.0_R_P self % b ( 9 ) = - 209249067 3.0_R_P / 95800320 0.0_R_P self % b ( 10 ) = 137479921 9.0_R_P / 95800320 0.0_R_P self % b ( 11 ) = 26274726 5.0_R_P / 95800320 0.0_R_P case ( 12 ) self % b ( 0 ) = - 1369577909 3.0_R_P / 261534873600 0.0_R_P self % b ( 1 ) = 17984282256 6.0_R_P / 261534873600 0.0_R_P self % b ( 2 ) = - 109209699226 8.0_R_P / 261534873600 0.0_R_P self % b ( 3 ) = 406332786317 0.0_R_P / 261534873600 0.0_R_P self % b ( 4 ) = - 1034471179498 5.0_R_P / 261534873600 0.0_R_P self % b ( 5 ) = 1905818565279 6.0_R_P / 261534873600 0.0_R_P self % b ( 6 ) = - 2620434446515 2.0_R_P / 261534873600 0.0_R_P self % b ( 7 ) = 2734587069843 6.0_R_P / 261534873600 0.0_R_P self % b ( 8 ) = - 2184753803989 5.0_R_P / 261534873600 0.0_R_P self % b ( 9 ) = 1346577425651 0.0_R_P / 261534873600 0.0_R_P self % b ( 10 ) = - 661642095742 8.0_R_P / 261534873600 0.0_R_P self % b ( 11 ) = 391755121698 6.0_R_P / 261534873600 0.0_R_P self % b ( 12 ) = 70360425435 7.0_R_P / 261534873600 0.0_R_P case ( 13 ) self % b ( 0 ) = 2446657909 3.0_R_P / 523069747200 0.0_R_P self % b ( 1 ) = - 34545708639 5.0_R_P / 523069747200 0.0_R_P self % b ( 2 ) = 226807881438 6.0_R_P / 523069747200 0.0_R_P self % b ( 3 ) = - 918163560513 4.0_R_P / 523069747200 0.0_R_P self % b ( 4 ) = 2562025977783 5.0_R_P / 523069747200 0.0_R_P self % b ( 5 ) = - 5217791088266 1.0_R_P / 523069747200 0.0_R_P self % b ( 6 ) = 8010102102918 0.0_R_P / 523069747200 0.0_R_P self % b ( 7 ) = - 9439333865389 2.0_R_P / 523069747200 0.0_R_P self % b ( 8 ) = 8618022868956 3.0_R_P / 523069747200 0.0_R_P self % b ( 9 ) = - 6118868013128 5.0_R_P / 523069747200 0.0_R_P self % b ( 10 ) = 3392899013361 8.0_R_P / 523069747200 0.0_R_P self % b ( 11 ) = - 1514123508411 0.0_R_P / 523069747200 0.0_R_P self % b ( 12 ) = 815316796218 1.0_R_P / 523069747200 0.0_R_P self % b ( 13 ) = 138274192962 1.0_R_P / 523069747200 0.0_R_P case ( 14 ) self % b ( 0 ) = - 13228284012 7.0_R_P / 3138418483200 0.0_R_P self % b ( 1 ) = 199875923633 6.0_R_P / 3138418483200 0.0_R_P self % b ( 2 ) = - 1411048096992 7.0_R_P / 3138418483200 0.0_R_P self % b ( 3 ) = 6175942669254 4.0_R_P / 3138418483200 0.0_R_P self % b ( 4 ) = - 18750493659793 1.0_R_P / 3138418483200 0.0_R_P self % b ( 5 ) = 41855180460126 4.0_R_P / 3138418483200 0.0_R_P self % b ( 6 ) = - 71031283419734 7.0_R_P / 3138418483200 0.0_R_P self % b ( 7 ) = 93460083349094 4.0_R_P / 3138418483200 0.0_R_P self % b ( 8 ) = - 96360540082473 3.0_R_P / 3138418483200 0.0_R_P self % b ( 9 ) = 78191161807163 2.0_R_P / 3138418483200 0.0_R_P self % b ( 10 ) = - 49954720375483 7.0_R_P / 3138418483200 0.0_R_P self % b ( 11 ) = 25172489460793 6.0_R_P / 3138418483200 0.0_R_P self % b ( 12 ) = - 10288514895621 7.0_R_P / 3138418483200 0.0_R_P self % b ( 13 ) = 5077096753486 4.0_R_P / 3138418483200 0.0_R_P self % b ( 14 ) = 816416873759 9.0_R_P / 3138418483200 0.0_R_P case ( 15 ) self % b ( 0 ) = 24020824582 3.0_R_P / 6276836966400 0.0_R_P self % b ( 1 ) = - 386768936759 9.0_R_P / 6276836966400 0.0_R_P self % b ( 2 ) = 2921938428408 7.0_R_P / 6276836966400 0.0_R_P self % b ( 3 ) = - 13751571378931 9.0_R_P / 6276836966400 0.0_R_P self % b ( 4 ) = 45140310893348 3.0_R_P / 6276836966400 0.0_R_P self % b ( 5 ) = - 109635523540233 1.0_R_P / 6276836966400 0.0_R_P self % b ( 6 ) = 203934587954664 3.0_R_P / 6276836966400 0.0_R_P self % b ( 7 ) = - 296636573026569 9.0_R_P / 6276836966400 0.0_R_P self % b ( 8 ) = 341494172885289 3.0_R_P / 6276836966400 0.0_R_P self % b ( 9 ) = - 312945307199358 1.0_R_P / 6276836966400 0.0_R_P self % b ( 10 ) = 228516859834973 3.0_R_P / 6276836966400 0.0_R_P self % b ( 11 ) = - 132697866305806 9.0_R_P / 6276836966400 0.0_R_P self % b ( 12 ) = 61274454106533 7.0_R_P / 6276836966400 0.0_R_P self % b ( 13 ) = - 23099216372384 9.0_R_P / 6276836966400 0.0_R_P self % b ( 14 ) = 10514505875707 3.0_R_P / 6276836966400 0.0_R_P self % b ( 15 ) = 1608812922937 5.0_R_P / 6276836966400 0.0_R_P endselect self % error = 0 else ! bad (unsupported) number of required time steps self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = - 1 if ( allocated ( self % b )) deallocate ( self % b ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , previous , Dt , t , iterations , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Moulton class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. class ( integrand ), allocatable :: delta !< Delta RHS for fixed point iterations. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate if ( self % steps > 0 ) then if ( present ( iterations )) then ! perform fixed point iterations allocate ( delta , source = previous ( self % steps )) do s = 0 , self % steps - 1 delta = delta + previous ( s + 1 )% t ( t = t ( s + 1 )) * ( Dt * self % b ( s )) enddo do s = 1 , iterations U = delta + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps )) enddo else U = previous ( self % steps ) + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps )) do s = 0 , self % steps - 1 U = U + previous ( s + 1 )% t ( t = t ( s + 1 )) * ( Dt * self % b ( s )) enddo endif if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) else U = U + U % t ( t = t ( 1 )) * ( Dt * self % b ( 0 )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 0 , self % steps - 2 previous ( s + 1 ) = previous ( s + 2 ) enddo previous ( self % steps ) = U endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous elemental function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps elemental function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_adams_moulton","tags":"","loc":"sourcefile/foodie_integrator_adams_moulton.f90.html","title":"foodie_integrator_adams_moulton.f90 – FOODIE"},{"text":"FOODIE integrator: provide an implicit class of Backward Differentiation Formula schemes, from 1st to 6th order accurate. Source Code !< FOODIE integrator: provide an implicit class of Backward Differentiation Formula schemes, from 1st to 6th order accurate. module foodie_integrator_backward_differentiation_formula !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an implicit class of Backward Differentiation Formula schemes, from 1st to 6th order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Backward Differentiation Formula class scheme implemented is: !< !<  U&#94;{n+N_s} + \\sum_{s=1}&#94;{N_s} \\alpha_s U&#94;{n+N_s-s} = \\Delta t \\left[ \\beta R(t&#94;{n+N_s}, U&#94;{n+N_s}) \\right]  !< !< where N_s is the number of previous steps considered. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are implicit. The coefficients \\alpha_s and \\beta define the actual scheme, that is selected accordingly !< to the number of *steps* used. !< !< Currently, the following schemes are available: !< !< | ` Step ` | ` beta `   | ` alpha 1 `  | ` alpha 2 ` | ` alpha 3 `  | ` alpha 4 ` | ` alpha 5 ` | ` alpha 6 ` | !< |----------|------------|--------------|-------------|--------------|-------------|-------------|-------------| !< | ` 1 `    | `  1 `     | ` -1 `       |             |              |             |             |             | !< | ` 2 `    | ` 2/3 `    | ` -4/3 `     | ` 1/3 `     |              |             |             |             | !< | ` 3 `    | ` 6/11 `   | ` -18/11 `   | ` 9/11  `   | ` -2/11 `    |             |             |             | !< | ` 4 `    | ` 12/25 `  | ` -48/25 `   | ` 36/25 `   | ` -16/25 `   | ` 3/25 `    |             |             | !< | ` 5 `    | ` 60/137 ` | ` -300/137 ` | ` 300/137 ` | ` -200/137 ` | ` 75/137 `  | ` -12/137 ` |             | !< | ` 6 `    | ` 60/147 ` | ` -360/147 ` | ` 450/147 ` | ` -400/147 ` | ` 225/147 ` | ` -72/147 ` | ` 10/147 `  | !< !<#### Bibliography !< !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : I_P , R_P use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: back_df_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- character ( len = 99 ), parameter :: supported_steps = '1-6' !< List of supported steps number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 1 !< Minimum number of steps supported. integer ( I_P ), parameter :: max_ss = 6 !< Maximum number of steps supported. type :: back_df_integrator !< FOODIE integrator: provide an implicit class of Backward-Differentiation-Formula multi-step schemes, from 1st to 6th order !< accurate. !< !< @note The integrator must be created or initialized (initialize the *alpha* and *beta* coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required time steps; private integer ( I_P ) :: steps = 0 !< Number of time steps. real ( R_P ), allocatable :: a (:) !< \\alpha coefficients. real ( R_P ) :: b = 0.0_R_P !< \\beta coefficient. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. final :: finalize !< Finalize object. endtype back_df_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual BDF integrator: initialize the *alpha* and *beta* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( back_df_integrator ), intent ( INOUT ) :: self !< BDF integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps if ( allocated ( self % a )) deallocate ( self % a ) ; allocate ( self % a ( 1 : steps )) ; self % a = 0.0_R_P select case ( steps ) case ( 1 ) self % a ( 1 ) = - 1.0_R_P self % b = 1.0_R_P case ( 2 ) self % a ( 1 ) = 1.0_R_P / 3.0_R_P self % a ( 2 ) = - 4.0_R_P / 3.0_R_P self % b = 2.0_R_P / 3.0_R_P case ( 3 ) self % a ( 1 ) = - 2.0_R_P / 1 1.0_R_P self % a ( 2 ) = 9.0_R_P / 1 1.0_R_P self % a ( 3 ) = - 1 8.0_R_P / 1 1.0_R_P self % b = 6.0_R_P / 1 1.0_R_P case ( 4 ) self % a ( 1 ) = 3.0_R_P / 2 5.0_R_P self % a ( 2 ) = - 1 6.0_R_P / 2 5.0_R_P self % a ( 3 ) = 3 6.0_R_P / 2 5.0_R_P self % a ( 4 ) = - 4 8.0_R_P / 2 5.0_R_P self % b = 1 2.0_R_P / 2 5.0_R_P case ( 5 ) self % a ( 1 ) = - 1 2.0_R_P / 13 7.0_R_P self % a ( 2 ) = 7 5.0_R_P / 13 7.0_R_P self % a ( 3 ) = - 20 0.0_R_P / 13 7.0_R_P self % a ( 4 ) = 30 0.0_R_P / 13 7.0_R_P self % a ( 5 ) = - 30 0.0_R_P / 13 7.0_R_P self % b = 6 0.0_R_P / 13 7.0_R_P case ( 6 ) self % a ( 1 ) = 1 0.0_R_P / 14 7.0_R_P self % a ( 2 ) = - 7 2.0_R_P / 14 7.0_R_P self % a ( 3 ) = 22 5.0_R_P / 14 7.0_R_P self % a ( 4 ) = - 40 0.0_R_P / 14 7.0_R_P self % a ( 5 ) = 45 0.0_R_P / 14 7.0_R_P self % a ( 6 ) = - 36 0.0_R_P / 14 7.0_R_P self % b = 6 0.0_R_P / 14 7.0_R_P case default ! bad (unsupported) number of required time steps self % error = 1 endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( back_df_integrator ), intent ( INOUT ) :: self !< BDF integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 1 if ( allocated ( self % a )) deallocate ( self % a ) self % b = 0.0_R_P self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , previous , Dt , t , iterations , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with BDF class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( back_df_integrator ), intent ( IN ) :: self !< Actual BDF integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. integer ( I_P ) :: iterations_ !< Fixed point iterations. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. class ( integrand ), allocatable :: delta !< Delta RHS for fixed point iterations. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate iterations_ = 1 ; if ( present ( iterations )) iterations_ = iterations allocate ( delta , source = previous ( self % steps ) * ( - self % a ( self % steps ))) do s = 1 , self % steps - 1 delta = delta + previous ( s ) * ( - self % a ( s )) enddo do s = 1 , iterations U = delta + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ) enddo if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate elemental function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps elemental function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( back_df_integrator ), intent ( IN ) :: self !< Actual BDF integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do s = 1 , self % steps - 1 previous ( s ) = previous ( s + 1 ) enddo previous ( self % steps ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( back_df_integrator ), intent ( INOUT ) :: self !< BDF integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_backward_differentiation_formula","tags":"","loc":"sourcefile/foodie_integrator_backward_differentiation_formula.f90.html","title":"foodie_integrator_backward_differentiation_formula.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 6th order accurate. Source Code !< FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 6th order accurate. module foodie_integrator_emd_runge_kutta !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 6th order accurate. !< !< The integrators provided have the embedded pairs property allowing for automatic step size control. !< The schemes are explicit and defined through the extended Butcher's table syntax, see[1] . !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<  U_p&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_p&#94;s K&#94;s  !<  U_{p+1}&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_{p+1}&#94;s K&#94;s  !< !< *p* is the lower accuracy order scheme and *p+1* is the higher one; Ns is the number of stages used and K&#94;s is !< the s&#94;{th} stage computed as: !< !<  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are !< given in the extended Butcher table form: !< !<``` !<  gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns} !<  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns} !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns} !< ------------|------------------------------------------------------------- !<             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns} !<             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} !<``` !< !< Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: !< !<``` !<  gamma&#94;1    | 0                 0                 ...        0 !<  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0 !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0 !< ------------|------------------------------------------------------------- !<             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns} !<             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} !<``` !< !< Moreover the following relation always holds: !<  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !< @bug Presently, the 2 stages Heun-Euler seems to not work, **do not use it**. !< !<##### 2 stages, 2th order !< This scheme is due to Heun-Euler. !<``` !<  0  | 0 !<  1  | 1     0 !< ---------------- !<     | 1/2   1/2 !<     | 1      0 !<``` !< !<##### 6 stages, 5th order !< This scheme is due to Cash and Karp, see [3]. !<``` !<  0    | 0 !<  1/5\t | 1/5 !<  3/10 | 3/40\t         9/40 !<  3/5\t | 3/10\t         -9/10\t      6/5 !<  1\t   | -11/54\t       5/2\t        -70/27\t    35/27 !<  7/8\t | 1631/55296    175/512      575/13824   44275/110592     253/4096     0 !< ---------------------------------------------------------------------------------------- !<       | 37/378        0           250/621      125/594          0            512/1771 !<       | 2825/27648    0           18575/48384  13525/55296      277/14336    1/4 !<``` !< !<##### 7 stages, 4th order !< This scheme is due to Dormand and Prince, see [1]. !<``` !<  0    | 0 !<  1/5  | 1/5 !<  3/10 | 3/40          9/40 !<  4/5  | 44/45        -56/15        32/9 !<  8/9  | 19372/6561   -25360/2187   64448/6561   -212/729 !<  1    | 9017/3168    -355/33       46732/5247    49/176      -5103/18656 !<  1    | 35/384        0            500/1113      125/192     -2187/6784      11/84      0 !< -------------------------------------------------------------------------------------------- !<       | 5179/57600    0            7571/16695    393/640     -92097/339200   187/2100   1/40 !<       | 35/384        0            500/1113      125/192     -2187/6784      11/84      0 !<``` !< !<##### 9 stages, 6th order !< This scheme is due to Calvo et al., see [2]. !<``` !<  0                 | 0 !<  2/15              | 2/15 !<  1/5               | 1/20                  3/20 !<  3/10              | 3/40                  0                      9/40 !<  14/25             | 86727015/196851553    -60129073/52624712     957436434/1378352377    83886832/147842441 !<  19/25             | -86860849/45628967    111022885/25716487     108046682/101167669     -141756746/36005461 !<  35226607/35688279 | 77759591/16096467     -49252809/6452555      -381680111/51572984     879269579/66788831 !<  1                 | 237564263/39280295    -100523239/10677940    -265574846/27330247     317978411/18988713 !<  1                 | 17572349/289262523    0                      57513011/201864250      15587306/354501571 !< -------------------------------------------------------------------------------------------------------------- !<                    | 17572349/289262523    0                      57513011/201864250      15587306/354501571 !<                    | 15231665/510830334    0                      59452991/116050448      -28398517/122437738 !< ...continued... !<  0                 | !<  2/15              | !<  1/5               | !<  3/10              | !<  14/25             | !<  19/25             | 73139862/60170633 !<  35226607/35688279 | -90453121/33722162     111179552/157155827 !<  1                 | -124494385/35453627    86822444/100138635     -12873523/724232625 !<  1                 | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0 !< ----------------------------------------------------------------------------------------------------------------------- !<                    | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0 !<                    | 56673824/137010559     68003849/426673583     7097631/37564021       -71226429/583093742    1/20 !<``` !< !<##### 17 stages, 10th order !< This scheme is due to Feagin, see [4]. !<``` !<  0                        |  0 !<  0.1                      |  0.1 !<  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052 !<  0.809036761204472681298  |  0.202259190301118170324  0                        0.606777570903354510974 !<  0.309036761204472681298  |  0.184024714708643575149  0                        0.197966831227192369068 !<  0.981074190219795268254  |  0.087900734020668133731  0                        0 !<  0.833333333333333333333  |  0.085970050490246030218  0                        0 !<  0.354017365856802376329  |  0.120930449125333720660  0                        0 !<  0.882527661964732346425  |  0.110854379580391483508  0                        0 !<  0.642615758240322548157  |  0.112054414752879004829  0                        0 !<  0.357384241759677451842  |  0.113976783964185986138  0                        0 !<  0.117472338035267653574  |  0.079831452828019604635  0                        0 !<  0.833333333333333333333  |  0.985115610164857280120  0                        0 !<  0.309036761204472681298  |  0.895080295771632891049  0                        0.197966831227192369068 !<  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052  0 !<  0.1                      |  0.1                      0                       -0.157178665799771163367 !<  1                        |  0.181781300700095283888  0.675                    0.342758159847189839942 !< ------------------------------------------------------------------------------------------------------ !<                           |  0.033333333333333333333  0.025                    0.033333333333333333333 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | -0.072954784731363262918 !<  0.981074190219795268254  |  0.410459702520260645318  0.482713753678866489204 !<  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -0.073185637507085073678 !<  0.354017365856802376329  |  0                        0.260124675758295622809  0.032540262154909133015 !<  0.882527661964732346425  |  0                        0                       -0.060576148825500558762 !<  0.642615758240322548157  |  0                        0                       -0.144942775902865915672 !<  0.357384241759677451842  |  0                        0                       -0.076881336420335693858 !<  0.117472338035267653574  |  0                        0                       -0.052032968680060307651 !<  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -1.378964865748435675821 !<  0.309036761204472681298  | -0.072954784731363262918  0                       -0.851236239662007619739 !<  0.539357840802981787532  |  0                       -0.777333643644968233538  0 !<  0.1                      |  0                        0                        0 !<  1                        |  0                        0.259111214548322744512 -0.358278966717952089048 !< ------------------------------------------------------------------------------------------------------ !<                           |  0                        0.05                     0 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | -0.059578021181736100156 !<  0.882527661964732346425  |  0.321763705601778390100  0.510485725608063031577 !<  0.642615758240322548157  | -0.333269719096256706589  0.499269229556880061353  0.509504608929686104236 !<  0.357384241759677451842  |  0.239527360324390649107  0.397774662368094639047  0.010755895687360745555 !<  0.117472338035267653574  | -0.057695414616854888173  0.194781915712104164976  0.145384923188325069727 !<  0.833333333333333333333  | -0.861164195027635666673  5.784288136375372200229  3.288077619851035668904 !<  0.309036761204472681298  |  0.398320112318533301719  3.639372631810356060294  1.548228770398303223653 !<  0.539357840802981787532  | -0.091089566215517606959  0                        0 !<  0.1                      |  0                        0                        0 !<  1                        | -1.045948959408833060950  0.930327845415626983292  1.779509594317081024461 !< ------------------------------------------------------------------------------------------------------ !<                           |  0.04                     0                        0.189237478148923490158 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | !<  0.882527661964732346425  | !<  0.642615758240322548157  | !<  0.357384241759677451842  | -0.327769124164018874147 !<  0.117472338035267653574  | -0.078294271035167077755 -0.114503299361098912184 !<  0.833333333333333333333  | -2.386339050931363840134 -3.254793424836439186545 -2.163435416864229823539 !<  0.309036761204472681298  | -2.122217147040537160260 -1.583503985453261727133 -1.715616082859362649220 !<  0.539357840802981787532  |  0                        0                        0 !<  0.1                      |  0                        0                        0 !<  1                        |  0.1                     -0.282547569539044081612 -0.159327350119972549169 !< ------------------------------------------------------------------------------------------------------ !<                           |  0.277429188517743176508  0.277429188517743176508  0.189237478148923490158 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | !<  0.882527661964732346425  | !<  0.642615758240322548157  | !<  0.357384241759677451842  | !<  0.117472338035267653574  | !<  0.833333333333333333333  | !<  0.309036761204472681298  | -0.024403640575012745213 !<  0.539357840802981787532  |  0.091089566215517606959  0.777333643644968233538 !<  0.1                      |  0                        0                        0.157178665799771163367 !<  1                        | -0.145515894647001510860 -0.259111214548322744512 -0.342758159847189839942 -0.675 !< ------------------------------------------------------------------------------------------------------------- !<                           | -0.04                    -0.05                    -0.033333333333333333333 -0.025 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | !<  0.882527661964732346425  | !<  0.642615758240322548157  | !<  0.357384241759677451842  | !<  0.117472338035267653574  | !<  0.833333333333333333333  | !<  0.309036761204472681298  | !<  0.539357840802981787532  | !<  0.1                      | !<  1                        | !< --------------------------------------------------- !<                           | 0.033333333333333333333 !<``` !< !<#### Bibliography !< !< [1] *A family of embedded Runge-Kutta formulae*, Dormand, J. R., Prince, P. J. (1980), Journal of Computational and !< Applied Mathematics 6 (1): 19--26, doi:10.1016/0771-050X(80)90013-3. !< !< [2] *A New Embedded Pair of Runge-Kutta Formulas of orders 5 and 6*, M. Calvo, J.I. Montijano, L. Randez, Computers & Mathematics !< with Applications, Volume 20, Issue 1, 1990, Pages 15--24, ISSN 0898-1221, http://dx.doi.org/10.1016/0898-1221(90)90064-Q. !< !< [3] *A variable order Runge-Kutta method for initial value problems with rapidly varying right-hand sides*, J. R. Cash, !< A. H. Karp, ACM Transactions on Mathematical Software, vol. 16,  pp. 201--222, 1990, doi:10.1145/79505.79507. !< !< [4] *A tenth-order Runge-Kutta method with error estimate*, Feagin, T., Proceedings of the IAENG Conf. on Scientific !< Computing. 2007. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : I_P , R_P use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: emd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- character ( len = 99 ), parameter :: supported_stages = '6,7,9,17' !< List of supported stages number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 6 !< Minimum number of stages supported. integer ( I_P ), parameter :: max_ss = 17 !< Maximum number of stages supported. type :: emd_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required stages; private real ( R_P ) :: tolerance = 0._R_P !< Tolerance on the local truncation error. real ( R_P ) :: pp1_inv = 0._R_P !< 1/(p+1) where p is the accuracy order of the lower accurate scheme of the pair. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:,:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_stages !< Return the minimum number of stages supported. procedure , nopass , public :: max_stages !< Return the maximum number of stages supported. procedure , nopass , public :: is_supported !< Check if the queried number of stages is supported or not. procedure , pass ( self ), private :: new_Dt !< Compute new estimation of the time step Dt. final :: finalize !< Finalize object. endtype emd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , stages , tolerance ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. real ( R_P ), optional , intent ( IN ) :: tolerance !< Tolerance on the local truncation error (default 0.01). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( stages )) then if ( present ( tolerance )) then self % tolerance = tolerance else self % tolerance = 0.01_R_P endif self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages , 1 : 2 )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 2 ) ! do not use, seems to not work! ! HERK(2,2) self % pp1_inv = 1._R_P / ( 2._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.5_R_P ; self % beta ( 1 , 2 ) = 5._R_P self % beta ( 2 , 1 ) = 1._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 6 ) ! CKRK(6,5) self % pp1_inv = 1._R_P / ( 5._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 7._R_P / 37 8._R_P ; self % beta ( 1 , 2 ) = 282 5._R_P / 2764 8._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 25 0._R_P / 62 1._R_P ; self % beta ( 3 , 2 ) = 1857 5._R_P / 4838 4._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 59 4._R_P ; self % beta ( 4 , 2 ) = 1352 5._R_P / 5529 6._R_P self % beta ( 5 , 1 ) = 0._R_P ; self % beta ( 5 , 2 ) = 27 7._R_P / 1433 6._R_P self % beta ( 6 , 1 ) = 51 2._R_P / 177 1._R_P ; self % beta ( 6 , 2 ) = 1._R_P / 4._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 1 0._R_P ; self % alph ( 4 , 2 ) = - 9._R_P / 1 0._R_P ; self % alph ( 4 , 3 ) = 6._R_P / 5._R_P self % alph ( 5 , 1 ) =- 1 1._R_P / 5 4._R_P ; self % alph ( 5 , 2 ) = 5._R_P / 2._R_P ; self % alph ( 5 , 3 ) =- 7 0._R_P / 2 7._R_P self % alph ( 6 , 1 ) = 163 1._R_P / 5529 6._R_P ; self % alph ( 6 , 2 ) = 17 5._R_P / 51 2._R_P ; self % alph ( 6 , 3 ) = 57 5._R_P / 1382 4._R_P self % alph ( 5 , 4 ) = 3 5._R_P / 2 7._R_P self % alph ( 6 , 4 ) = 4427 5._R_P / 11059 2._R_P ; self % alph ( 6 , 5 ) = 25 3._R_P / 409 6._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 3._R_P / 5._R_P self % gamm ( 5 ) = 1._R_P self % gamm ( 6 ) = 7._R_P / 8._R_P case ( 7 ) ! DPRK(7,4) self % pp1_inv = 1._R_P / ( 4._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 5._R_P / 38 4._R_P ; self % beta ( 1 , 2 ) = 517 9._R_P / 5760 0._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 50 0._R_P / 111 3._R_P ; self % beta ( 3 , 2 ) = 757 1._R_P / 1669 5._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 19 2._R_P ; self % beta ( 4 , 2 ) = 39 3._R_P / 64 0._R_P self % beta ( 5 , 1 ) = - 218 7._R_P / 678 4._R_P ; self % beta ( 5 , 2 ) = - 9209 7._R_P / 33920 0._R_P self % beta ( 6 , 1 ) = 1 1._R_P / 8 4._R_P ; self % beta ( 6 , 2 ) = 18 7._R_P / 210 0._R_P self % beta ( 7 , 1 ) = 0._R_P ; self % beta ( 7 , 2 ) = 1._R_P / 4 0._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 4 4._R_P / 4 5._R_P ; self % alph ( 4 , 2 ) =- 5 6._R_P / 1 5._R_P ; self % alph ( 4 , 3 ) = 3 2._R_P / 9._R_P self % alph ( 5 , 1 ) = 1937 2._R_P / 656 1._R_P ; self % alph ( 5 , 2 ) =- 2536 0._R_P / 218 7._R_P ; self % alph ( 5 , 3 ) = 6444 8._R_P / 656 1._R_P self % alph ( 6 , 1 ) = 901 7._R_P / 316 8._R_P ; self % alph ( 6 , 2 ) =- 35 5._R_P / 3 3._R_P ; self % alph ( 6 , 3 ) = 4673 2._R_P / 524 7._R_P self % alph ( 7 , 1 ) = 3 5._R_P / 38 4._R_P ; self % alph ( 7 , 2 ) = 0._R_P ; self % alph ( 7 , 3 ) = 50 0._R_P / 111 3._R_P self % alph ( 5 , 4 ) =- 21 2._R_P / 72 9._R_P self % alph ( 6 , 4 ) = 4 9._R_P / 17 6._R_P ; self % alph ( 6 , 5 ) =- 510 3._R_P / 1865 6._R_P self % alph ( 7 , 4 ) = 12 5._R_P / 19 2._R_P ; self % alph ( 7 , 5 ) =- 218 7._R_P / 678 4._R_P ; self % alph ( 7 , 6 ) = 1 1._R_P / 8 4._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 4._R_P / 5._R_P self % gamm ( 5 ) = 8._R_P / 9._R_P self % gamm ( 6 ) = 1._R_P self % gamm ( 7 ) = 1._R_P case ( 9 ) ! CMRK(9,6) self % pp1_inv = 1._R_P / ( 6._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % beta ( 1 , 2 ) = 1523166 5._R_P / 51083033 4._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 5751301 1._R_P / 20186425 0._R_P ; self % beta ( 3 , 2 ) = 5945299 1._R_P / 11605044 8._R_P self % beta ( 4 , 1 ) = 1558730 6._R_P / 35450157 1._R_P ; self % beta ( 4 , 2 ) = - 2839851 7._R_P / 12243773 8._R_P self % beta ( 5 , 1 ) = 7178302 1._R_P / 23498286 5._R_P ; self % beta ( 5 , 2 ) = 5667382 4._R_P / 13701055 9._R_P self % beta ( 6 , 1 ) = 2967200 0._R_P / 18048016 7._R_P ; self % beta ( 6 , 2 ) = 6800384 9._R_P / 42667358 3._R_P self % beta ( 7 , 1 ) = 6556762 1._R_P / 12706095 2._R_P ; self % beta ( 7 , 2 ) = 709763 1._R_P / 3756402 1._R_P self % beta ( 8 , 1 ) = - 7907457 0._R_P / 21055759 7._R_P ; self % beta ( 8 , 2 ) = - 7122642 9._R_P / 58309374 2._R_P self % beta ( 9 , 1 ) = 0._R_P ; self % beta ( 9 , 2 ) = 1._R_P / 2 0._R_P self % alph ( 2 , 1 ) = 2._R_P / 1 5._R_P self % alph ( 3 , 1 ) = 1._R_P / 2 0._R_P ; self % alph ( 3 , 2 ) = 3._R_P / 2 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 8672701 5._R_P / 19685155 3._R_P ; self % alph ( 5 , 2 ) =- 6012907 3._R_P / 5262471 2._R_P self % alph ( 6 , 1 ) =- 8686084 9._R_P / 4562896 7._R_P ; self % alph ( 6 , 2 ) = 11102288 5._R_P / 2571648 7._R_P self % alph ( 7 , 1 ) = 7775959 1._R_P / 1609646 7._R_P ; self % alph ( 7 , 2 ) =- 4925280 9._R_P / 645255 5._R_P self % alph ( 8 , 1 ) = 23756426 3._R_P / 3928029 5._R_P ; self % alph ( 8 , 2 ) =- 10052323 9._R_P / 1067794 0._R_P self % alph ( 9 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 4 , 3 ) = 9._R_P / 4 0._R_P self % alph ( 5 , 3 ) = 95743643 4._R_P / 137835237 7._R_P ; self % alph ( 5 , 4 ) = 8388683 2._R_P / 14784244 1._R_P self % alph ( 6 , 3 ) = 10804668 2._R_P / 10116766 9._R_P ; self % alph ( 6 , 4 ) =- 14175674 6._R_P / 3600546 1._R_P self % alph ( 7 , 3 ) =- 38168011 1._R_P / 5157298 4._R_P ; self % alph ( 7 , 4 ) = 87926957 9._R_P / 6678883 1._R_P self % alph ( 8 , 3 ) =- 26557484 6._R_P / 2733024 7._R_P ; self % alph ( 8 , 4 ) = 31797841 1._R_P / 1898871 3._R_P self % alph ( 9 , 3 ) = 5751301 1._R_P / 20186425 0._R_P ; self % alph ( 9 , 4 ) = 1558730 6._R_P / 35450157 1._R_P self % alph ( 6 , 5 ) = 7313986 2._R_P / 6017063 3._R_P self % alph ( 7 , 5 ) =- 9045312 1._R_P / 3372216 2._R_P ; self % alph ( 7 , 6 ) = 11117955 2._R_P / 15715582 7._R_P self % alph ( 8 , 5 ) =- 12449438 5._R_P / 3545362 7._R_P ; self % alph ( 8 , 6 ) = 8682244 4._R_P / 10013863 5._R_P self % alph ( 9 , 5 ) = 7178302 1._R_P / 23498286 5._R_P ; self % alph ( 9 , 6 ) = 2967200 0._R_P / 18048016 7._R_P self % alph ( 8 , 7 ) =- 1287352 3._R_P / 72423262 5._R_P self % alph ( 9 , 7 ) = 6556762 1._R_P / 12706095 2._R_P ; self % alph ( 9 , 8 ) =- 7907457 0._R_P / 21055759 7._R_P self % gamm ( 2 ) = 2._R_P / 1 5._R_P self % gamm ( 3 ) = 1._R_P / 5._R_P self % gamm ( 4 ) = 3._R_P / 1 0._R_P self % gamm ( 5 ) = 1 4._R_P / 2 5._R_P self % gamm ( 6 ) = 1 9._R_P / 2 5._R_P self % gamm ( 7 ) = 3522660 7._R_P / 3568827 9._R_P self % gamm ( 8 ) = 1._R_P self % gamm ( 9 ) = 1._R_P case ( 17 ) ! FRK(17,10) self % pp1_inv = 1._R_P / ( 1 0._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 1 , 2 ) = 0.033333333333333333333_R_P self % beta ( 2 , 1 ) = 0.025_R_P ; self % beta ( 2 , 2 ) = 1._R_P / 3 6._R_P self % beta ( 3 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 3 , 2 ) = 0.033333333333333333333_R_P self % beta ( 4 , 1 ) = 0._R_P ; self % beta ( 4 , 2 ) = 0._R_P self % beta ( 5 , 1 ) = 0.05_R_P ; self % beta ( 5 , 2 ) = 0.05_R_P self % beta ( 6 , 1 ) = 0._R_P ; self % beta ( 6 , 2 ) = 0._R_P self % beta ( 7 , 1 ) = 0.04_R_P ; self % beta ( 7 , 2 ) = 0.04_R_P self % beta ( 8 , 1 ) = 0._R_P ; self % beta ( 8 , 2 ) = 0._R_P self % beta ( 9 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 9 , 2 ) = 0.189237478148923490158_R_P self % beta ( 10 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 10 , 2 ) = 0.277429188517743176508_R_P self % beta ( 11 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 11 , 2 ) = 0.277429188517743176508_R_P self % beta ( 12 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 12 , 2 ) = 0.189237478148923490158_R_P self % beta ( 13 , 1 ) =- 0.04_R_P ; self % beta ( 13 , 2 ) =- 0.04_R_P self % beta ( 14 , 1 ) =- 0.05_R_P ; self % beta ( 14 , 2 ) =- 0.05_R_P self % beta ( 15 , 1 ) =- 0.033333333333333333333_R_P ; self % beta ( 15 , 2 ) =- 0.033333333333333333333_R_P self % beta ( 16 , 1 ) =- 0.025_R_P ; self % beta ( 16 , 2 ) =- 1._R_P / 3 6._R_P self % beta ( 17 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 17 , 2 ) = 0.033333333333333333333_R_P self % alph ( 2 , 1 ) = 0.1_R_P self % alph ( 3 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 3 , 2 ) = 1.454534402178273228052_R_P self % alph ( 4 , 1 ) = 0.202259190301118170324_R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 0.184024714708643575149_R_P ; self % alph ( 5 , 2 ) = 0._R_P self % alph ( 6 , 1 ) = 0.087900734020668133731_R_P ; self % alph ( 6 , 2 ) = 0._R_P self % alph ( 7 , 1 ) = 0.085970050490246030218_R_P ; self % alph ( 7 , 2 ) = 0._R_P self % alph ( 8 , 1 ) = 0.120930449125333720660_R_P ; self % alph ( 8 , 2 ) = 0._R_P self % alph ( 9 , 1 ) = 0.110854379580391483508_R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 10 , 1 ) = 0.112054414752879004829_R_P ; self % alph ( 10 , 2 ) = 0._R_P self % alph ( 11 , 1 ) = 0.113976783964185986138_R_P ; self % alph ( 11 , 2 ) = 0._R_P self % alph ( 12 , 1 ) = 0.079831452828019604635_R_P ; self % alph ( 12 , 2 ) = 0._R_P self % alph ( 13 , 1 ) = 0.985115610164857280120_R_P ; self % alph ( 13 , 2 ) = 0._R_P self % alph ( 14 , 1 ) = 0.895080295771632891049_R_P ; self % alph ( 14 , 2 ) = 0._R_P self % alph ( 15 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 15 , 2 ) = 1.454534402178273228052_R_P self % alph ( 16 , 1 ) = 0.1_R_P ; self % alph ( 16 , 2 ) = 0._R_P self % alph ( 17 , 1 ) = 0.181781300700095283888_R_P ; self % alph ( 17 , 2 ) = 0.675_R_P self % alph ( 4 , 3 ) = 0.606777570903354510974_R_P self % alph ( 5 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 5 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 6 , 3 ) = 0._R_P ; self % alph ( 6 , 4 ) = 0.410459702520260645318_R_P self % alph ( 7 , 3 ) = 0._R_P ; self % alph ( 7 , 4 ) = 0.330885963040722183948_R_P self % alph ( 8 , 3 ) = 0._R_P ; self % alph ( 8 , 4 ) = 0._R_P self % alph ( 9 , 3 ) = 0._R_P ; self % alph ( 9 , 4 ) = 0._R_P self % alph ( 10 , 3 ) = 0._R_P ; self % alph ( 10 , 4 ) = 0._R_P self % alph ( 11 , 3 ) = 0._R_P ; self % alph ( 11 , 4 ) = 0._R_P self % alph ( 12 , 3 ) = 0._R_P ; self % alph ( 12 , 4 ) = 0._R_P self % alph ( 13 , 3 ) = 0._R_P ; self % alph ( 13 , 4 ) = 0.330885963040722183948_R_P self % alph ( 14 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 14 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 15 , 3 ) = 0._R_P ; self % alph ( 15 , 4 ) = 0._R_P self % alph ( 16 , 3 ) =- 0.157178665799771163367_R_P ; self % alph ( 16 , 4 ) = 0._R_P self % alph ( 17 , 3 ) = 0.342758159847189839942_R_P ; self % alph ( 17 , 4 ) = 0._R_P self % alph ( 6 , 5 ) = 0.482713753678866489204_R_P self % alph ( 7 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 7 , 6 ) =- 0.073185637507085073678_R_P self % alph ( 8 , 5 ) = 0.260124675758295622809_R_P ; self % alph ( 8 , 6 ) = 0.032540262154909133015_R_P self % alph ( 9 , 5 ) = 0._R_P ; self % alph ( 9 , 6 ) =- 0.060576148825500558762_R_P self % alph ( 10 , 5 ) = 0._R_P ; self % alph ( 10 , 6 ) =- 0.144942775902865915672_R_P self % alph ( 11 , 5 ) = 0._R_P ; self % alph ( 11 , 6 ) =- 0.076881336420335693858_R_P self % alph ( 12 , 5 ) = 0._R_P ; self % alph ( 12 , 6 ) =- 0.052032968680060307651_R_P self % alph ( 13 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 13 , 6 ) =- 1.378964865748435675821_R_P self % alph ( 14 , 5 ) = 0._R_P ; self % alph ( 14 , 6 ) =- 0.851236239662007619739_R_P self % alph ( 15 , 5 ) =- 0.777333643644968233538_R_P ; self % alph ( 15 , 6 ) = 0._R_P self % alph ( 16 , 5 ) = 0._R_P ; self % alph ( 16 , 6 ) = 0._R_P self % alph ( 17 , 5 ) = 0.259111214548322744512_R_P ; self % alph ( 17 , 6 ) =- 0.358278966717952089048_R_P self % alph ( 8 , 7 ) =- 0.059578021181736100156_R_P self % alph ( 9 , 7 ) = 0.321763705601778390100_R_P ; self % alph ( 9 , 8 ) = 0.510485725608063031577_R_P self % alph ( 10 , 7 ) =- 0.333269719096256706589_R_P ; self % alph ( 10 , 8 ) = 0.499269229556880061353_R_P self % alph ( 11 , 7 ) = 0.239527360324390649107_R_P ; self % alph ( 11 , 8 ) = 0.397774662368094639047_R_P self % alph ( 12 , 7 ) =- 0.057695414616854888173_R_P ; self % alph ( 12 , 8 ) = 0.194781915712104164976_R_P self % alph ( 13 , 7 ) =- 0.861164195027635666673_R_P ; self % alph ( 13 , 8 ) = 5.784288136375372200229_R_P self % alph ( 14 , 7 ) = 0.398320112318533301719_R_P ; self % alph ( 14 , 8 ) = 3.639372631810356060294_R_P self % alph ( 15 , 7 ) =- 0.091089566215517606959_R_P ; self % alph ( 15 , 8 ) = 0._R_P self % alph ( 16 , 7 ) = 0._R_P ; self % alph ( 16 , 8 ) = 0._R_P self % alph ( 17 , 7 ) =- 1.045948959408833060950_R_P ; self % alph ( 17 , 8 ) = 0.930327845415626983292_R_P self % alph ( 10 , 9 ) = 0.509504608929686104236_R_P self % alph ( 11 , 9 ) = 0.010755895687360745555_R_P ; self % alph ( 11 , 10 ) =- 0.327769124164018874147_R_P self % alph ( 12 , 9 ) = 0.145384923188325069727_R_P ; self % alph ( 12 , 10 ) =- 0.078294271035167077755_R_P self % alph ( 13 , 9 ) = 3.288077619851035668904_R_P ; self % alph ( 13 , 10 ) =- 2.386339050931363840134_R_P self % alph ( 14 , 9 ) = 1.548228770398303223653_R_P ; self % alph ( 14 , 10 ) =- 2.122217147040537160260_R_P self % alph ( 15 , 9 ) = 0._R_P ; self % alph ( 15 , 10 ) = 0._R_P self % alph ( 16 , 9 ) = 0._R_P ; self % alph ( 16 , 10 ) = 0._R_P self % alph ( 17 , 9 ) = 1.779509594317081024461_R_P ; self % alph ( 17 , 10 ) = 0.1_R_P self % alph ( 12 , 11 ) =- 0.114503299361098912184_R_P self % alph ( 13 , 11 ) =- 3.254793424836439186545_R_P ; self % alph ( 13 , 12 ) =- 2.163435416864229823539_R_P self % alph ( 14 , 11 ) =- 1.583503985453261727133_R_P ; self % alph ( 14 , 12 ) =- 1.715616082859362649220_R_P self % alph ( 15 , 11 ) = 0._R_P ; self % alph ( 15 , 12 ) = 0._R_P self % alph ( 16 , 11 ) = 0._R_P ; self % alph ( 16 , 12 ) = 0._R_P self % alph ( 17 , 11 ) =- 0.282547569539044081612_R_P ; self % alph ( 17 , 12 ) =- 0.159327350119972549169_R_P self % alph ( 14 , 13 ) =- 0.024403640575012745213_R_P self % alph ( 15 , 13 ) = 0.091089566215517606959_R_P ; self % alph ( 15 , 14 ) = 0.777333643644968233538_R_P self % alph ( 16 , 13 ) = 0._R_P ; self % alph ( 16 , 14 ) = 0._R_P self % alph ( 17 , 13 ) =- 0.145515894647001510860_R_P ; self % alph ( 17 , 14 ) =- 0.259111214548322744512_R_P self % alph ( 16 , 15 ) = 0.157178665799771163367_R_P self % alph ( 17 , 15 ) =- 0.342758159847189839942_R_P ; self % alph ( 17 , 16 ) =- 0.675_R_P self % gamm ( 2 ) = 0.1_R_P self % gamm ( 3 ) = 0.539357840802981787532_R_P self % gamm ( 4 ) = 0.809036761204472681298_R_P self % gamm ( 5 ) = 0.309036761204472681298_R_P self % gamm ( 6 ) = 0.981074190219795268254_R_P self % gamm ( 7 ) = 0.833333333333333333333_R_P self % gamm ( 8 ) = 0.354017365856802376329_R_P self % gamm ( 9 ) = 0.882527661964732346425_R_P self % gamm ( 10 ) = 0.642615758240322548157_R_P self % gamm ( 11 ) = 0.357384241759677451842_R_P self % gamm ( 12 ) = 0.117472338035267653574_R_P self % gamm ( 13 ) = 0.833333333333333333333_R_P self % gamm ( 14 ) = 0.309036761204472681298_R_P self % gamm ( 15 ) = 0.539357840802981787532_R_P self % gamm ( 16 ) = 0.1_R_P self % gamm ( 17 ) = 1._R_P endselect self % error = 0 else ! bad (unsupported) number of required stages self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % tolerance = 0._R_P self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit embedded Runge-Kutta scheme. !< !< The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( INOUT ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: U1 !< First U evaluation. class ( integrand ), allocatable :: U2 !< Second U evaluation. real ( R_P ) :: error !< Local truncation error estimation. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( U1 , source = U ) allocate ( U2 , source = U ) error = 1 e6 do while ( error > self % tolerance ) ! compute stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! compute new time step U1 = U U2 = U do s = 1 , self % stages U1 = U1 + stage ( s ) * ( Dt * self % beta ( s , 1 )) U2 = U2 + stage ( s ) * ( Dt * self % beta ( s , 2 )) enddo error = U2 . lterror . U1 call self % new_Dt ( error = error , Dt = Dt ) enddo U = U1 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate elemental function min_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_stages !< Minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_stages = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_stages elemental function max_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_stages !< Maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_stages = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_stages elemental function is_supported ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of stages is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. logical :: is_supported !< Is true is the stages number is in *supported_stages*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = stages , adm_range = trim ( supported_stages )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported ! private methods elemental subroutine new_Dt ( self , error , Dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute new estimation of the time step Dt. !< !< The formula employed is: !< !<  Dt_{new} = 0.9 Dt_{old} \\left( \\frac{tolerance}{error} \\right)&#94;{\\frac{1}{p+1}}  !< !< @note 0.9 is a safety factor. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( IN ) :: self !< Integrator. real ( R_P ), intent ( IN ) :: error !< Local truncation error estimation. real ( R_P ), intent ( INOUT ) :: Dt !< Time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( error > self % tolerance ) Dt = 0.9_R_P * Dt * ( self % tolerance / error ) ** self % pp1_inv return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine new_Dt elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_emd_runge_kutta","tags":"","loc":"sourcefile/foodie_integrator_embedded_runge_kutta.f90.html","title":"foodie_integrator_embedded_runge_kutta.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. Source Code !< FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. module foodie_integrator_euler_explicit !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Forward Explicit Euler scheme implemented is: !< !<  U&#94;{n+1} = U&#94;n +\\Delta t R(t, U&#94;n)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : I_P , R_P use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_explicit_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- character ( len = 1 ), parameter :: supported_stages_steps = '1' !< List of supported stages/steps number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 1 !< Minimum number of stages/steps supported. integer ( I_P ), parameter :: max_ss = 1 !< Maximum number of stages/steps supported. type :: euler_explicit_integrator !< FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< @note The integrator can be used directly without any initialization. private contains private procedure , nopass , public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_stages_steps !< Return the minimum number of stages/steps supported. procedure , nopass , public :: max_stages_steps !< Return the maximum number of stages/steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of stages/steps is supported or not. endtype euler_explicit_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine integrate ( U , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit Euler scheme, 1st order. !--------------------------------------------------------------------------------------------------------------------------------- class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), optional , intent ( IN ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- U = U + U % t ( t = t ) * Dt return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate elemental function min_stages_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of stages/steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_stages_steps !< Minimum number of stages/steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_stages_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_stages_steps elemental function max_stages_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of stages/steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_stages_steps !< Maximum number of stages/steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_stages_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_stages_steps elemental function is_supported ( stages_steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of stages/steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages_steps !< Number of stages/steps used. logical :: is_supported !< Is true is the stages number is in *supported_stages_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = stages_steps , adm_range = trim ( supported_stages_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported endmodule foodie_integrator_euler_explicit","tags":"","loc":"sourcefile/foodie_integrator_euler_explicit.f90.html","title":"foodie_integrator_euler_explicit.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Source Code !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. module foodie_integrator_leapfrog !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the leapfrog class scheme implemented (see [3]) is: !< !<  U&#94;{n+2} = U&#94;{n} + 2\\Delta t \\cdot R(t&#94;{n+1}, U&#94;{n+1})  !< !< Optionally, the Robert-Asselin-Williams (RAW) filter (see [3]) is applied to the computed integration steps: !<  \\Delta = \\frac{\\nu}{2}(U&#94;{n} - 2 U&#94;{n+1} + U&#94;{n+2})  !<  U&#94;{n+1} = U&#94;{n+1} + \\Delta * \\alpha  !<  U&#94;{n+2} = U&#94;{n+2} + \\Delta * (\\alpha-1)  !< Note that for \\alpha=1 the filter reverts back to the standard Robert-Asselin scheme. !< The filter coefficients should be taken as \\nu \\in (0,1] and \\alpha \\in (0.5,1]. The default values are !< !<  + \\nu=0.01 !<  + \\alpha=0.53 !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit. The filter coefficients \\nu,\\,\\alpha  define the actual scheme. !< !<#### Bibliography !< !< [1] *The integration of a low order spectral form of the primitive meteorological equations*, Robert, A. J., J. Meteor. Soc. !< Japan,vol. 44, pages 237--245, 1966. !< !< [2] *Frequency filter for time integrations*, Asselin, R., Monthly Weather Review, vol. 100, pages 487--490, 1972. !< !< [3] *The RAW filter: An improvement to the Robert–Asselin filter in semi-implicit integrations*, Williams, P.D., Monthly !< Weather Review, vol. 139(6), pages 1996--2007, June 2011. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : I_P , R_P use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: leapfrog_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- character ( len = 99 ), parameter :: supported_steps = '2' !< List of supported steps number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 2 !< Minimum number of steps supported. integer ( I_P ), parameter :: max_ss = 2 !< Maximum number of steps supported. type :: leapfrog_integrator !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. !< !< @note The integrator could be used without initialialization (initialize the time filter coefficients) if the defulat values !< are suitable for the problem. private real ( R_P ) :: nu = 0.01_R_P !< Robert-Asselin filter coefficient. real ( R_P ) :: alpha = 0.53_R_P !< Robert-Asselin-Williams filter coefficient. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. endtype leapfrog_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , nu , alpha ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual leapfrog integrator: initialize the filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( INOUT ) :: self !< LF integrator. real ( R_P ), optional , intent ( IN ) :: nu !< Williams-Robert-Asselin filter coefficient. real ( R_P ), optional , intent ( IN ) :: alpha !< Robert-Asselin filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % nu = 0.01_R_P self % alpha = 0.53_R_P if ( present ( nu )) self % nu = nu if ( present ( alpha )) self % alpha = alpha return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine integrate ( self , U , previous , Dt , t , filter ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with leapfrog class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( IN ) :: self !< LF integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 : 2 ) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. class ( integrand ), optional , intent ( INOUT ) :: filter !< Filter field displacement. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- U = previous ( 1 ) + previous ( 2 )% t ( t = t ) * ( Dt * 2._R_P ) if ( present ( filter )) then filter = ( previous ( 1 ) - previous ( 2 ) * 2._R_P + U ) * self % nu * 0.5_R_P previous ( 2 ) = previous ( 2 ) + filter * self % alpha U = U + filter * ( self % alpha - 1._R_P ) endif previous ( 1 ) = previous ( 2 ) previous ( 2 ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate elemental function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps elemental function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported endmodule foodie_integrator_leapfrog","tags":"","loc":"sourcefile/foodie_integrator_leapfrog.f90.html","title":"foodie_integrator_leapfrog.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. Source Code !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. module foodie_integrator_low_storage_runge_kutta !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< The integrators provided have the low storage property allowing for an efficient use of the memory. !< Following Williamson approach [1], the LSRK(5,4)2N (solution 3) scheme of Carpenter et al. [2] is implemented. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<\\begin{matrix} !< K_1 = U&#94;n \\\\ !< K_2 = 0 \\\\ !<\\left.\\begin{matrix} !< K_2 = A_s K_2 + \\Delta t R(t&#94;n + C_s \\Delta t, K_1) \\\\ !< K_1 = K_1 + B_s K_2 !<\\end{matrix}\\right\\} s=1,2,...N_s\\\\ !<U&#94;{n+1} = K_1 !<\\end{matrix} !< !< where *Ns* is the number of stages used and K_1, K_2 are the 2 registers used for stages computation. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus A_1=C_1=0. The coefficients A_s, B_s, C_s are given in the Williamson low storage table !< form. !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !<#### 1 stage, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. It is not a real low storage scheme, this being !< meaningless for a first order scheme. However it is added for safety reason. !< !< | ` Stage ` | ` A ` | ` B ` | ` C ` | !< |-----------|-------|-------|-------| !< | ` 1 `     | ` 0 ` | ` 1 ` | ` 0 ` | !< !<#### 5 stages, SSP, 4th order !< This scheme is a low storage RK(5, 4), based on the *solution 3* proposed in [2]. !< !< | ` Stage ` | ` A `                            | ` B `                            | ` C `                           | !< |-----------|----------------------------------|----------------------------------|---------------------------------| !< | ` 1 `     | `  0                           ` | ` 1432997174477/9575080441755  ` | ` 0                           ` | !< | ` 2 `     | ` -567301805773 /1357537059087 ` | ` 5161836677717/13612068292357 ` | ` 1432997174477/9575080441755 ` | !< | ` 3 `     | ` -2404267990393/2016746695238 ` | ` 1720146321549/2090206949498  ` | ` 2526269341429/6820363962896 ` | !< | ` 4 `     | ` -3550918686646/2091501179385 ` | ` 3134564353537/4481467310338  ` | ` 2006345519317/3224310063776 ` | !< | ` 5 `     | ` -1275806237668/842570457699  ` | ` 2277821191437/14882151754819 ` | ` 2802321613138/2924317926251 ` | !< !< !<#### 6 stages, 4th order !< This scheme is a low storage RK(6, 4), by [3]. !< !< | ` Stage ` | ` A `               | ` B `              | ` C `              | !< |-----------|---------------------|--------------------|--------------------| !< | ` 1 `     | `  0              ` | ` 0.122000000000 ` | ` 0              ` | !< | ` 2 `     | ` -0.691750960670 ` | ` 0.477263056358 ` | ` 0.122000000000 ` | !< | ` 3 `     | ` -1.727127405211 ` | ` 0.381941220320 ` | ` 0.269115878630 ` | !< | ` 4 `     | ` -0.694890150986 ` | ` 0.447757195744 ` | ` 0.447717183551 ` | !< | ` 5 `     | ` -1.039942756197 ` | ` 0.498614246822 ` | ` 0.749979795490 ` | !< | ` 6 `     | ` -1.531977447611 ` | ` 0.186648570846 ` | ` 0.898555413085 ` | !< !<#### 7 stages, 4th order !< This scheme is a low storage RK(7, 4), by [3]. !< !< | ` Stage ` | ` A `               | ` B `              | ` C `              | !< |-----------|---------------------|--------------------|--------------------| !< | ` 1 `     | `  0              ` | ` 0.117322146869 ` | ` 0              ` | !< | ` 2 `     | ` -0.647900745934 ` | ` 0.503270262127 ` | ` 0.117322146869 ` | !< | ` 3 `     | ` -2.704760863204 ` | ` 0.233663281658 ` | ` 0.294523230758 ` | !< | ` 4 `     | ` -0.460080550118 ` | ` 0.283419634625 ` | ` 0.305658622131 ` | !< | ` 5 `     | ` -0.500581787785 ` | ` 0.540367414023 ` | ` 0.582864148403 ` | !< | ` 6 `     | ` -1.906532255913 ` | ` 0.371499414620 ` | ` 0.858664273599 ` | !< | ` 7 `     | ` -1.450000000000 ` | ` 0.136670099385 ` | ` 0.868664273599 ` | !< !<#### 12 stages, 4th order !< This scheme is a low storage RK(12, 4), by [4]. !< !< | ` Stage ` | ` A `                   | ` B `                  | ` C `                  | !< |-----------|-------------------------|------------------------|------------------------| !< | ` 1  `    | `  0                  ` | ` 0.0650008435125904 ` | ` 0                  ` | !< | ` 2  `    | ` -0.0923311242368072 ` | ` 0.0161459902249842 ` | ` 0.0650008435125904 ` | !< | ` 3  `    | ` -0.9441056581158819 ` | ` 0.5758627178358159 ` | ` 0.0796560563081853 ` | !< | ` 4  `    | ` -4.3271273247576394 ` | ` 0.1649758848361671 ` | ` 0.1620416710085376 ` | !< | ` 5  `    | ` -2.1557771329026072 ` | ` 0.3934619494248182 ` | ` 0.2248877362907778 ` | !< | ` 6  `    | ` -0.9770727190189062 ` | ` 0.0443509641602719 ` | ` 0.2952293985641261 ` | !< | ` 7  `    | ` -0.7581835342571139 ` | ` 0.2074504268408778 ` | ` 0.3318332506149405 ` | !< | ` 8  `    | ` -1.7977525470825499 ` | ` 0.6914247433015102 ` | ` 0.4094724050198658 ` | !< | ` 9  `    | ` -2.6915667972700770 ` | ` 0.3766646883450449 ` | ` 0.6356954475753369 ` | !< | ` 10 `    | ` -4.6466798960268143 ` | ` 0.0757190350155483 ` | ` 0.6806551557645497 ` | !< | ` 11 `    | ` -0.1539613783825189 ` | ` 0.2027862031054088 ` | ` 0.7143773712418350 ` | !< | ` 12 `    | ` -0.5943293901830616 ` | ` 0.2167029365631842 ` | ` 0.9032588871651854 ` | !< !<#### 13 stages, 4th order !< This scheme is a low storage RK(13, 4), by [4]. !< !< | ` Stage ` | ` A `                   | ` B `                  | ` C `                  | !< |-----------|-------------------------|------------------------|------------------------| !< | ` 1  `    | `  0                  ` | ` 0.0271990297818803 ` | ` 0                  ` | !< | ` 2  `    | ` -0.6160178650170565 ` | ` 0.1772488819905108 ` | ` 0.0271990297818803 ` | !< | ` 3  `    | ` -0.4449487060774118 ` | ` 0.0378528418949694 ` | ` 0.0952594339119365 ` | !< | ` 4  `    | ` -1.0952033345276178 ` | ` 0.6086431830142991 ` | ` 0.1266450286591127 ` | !< | ` 5  `    | ` -1.2256030785959187 ` | ` 0.2154313974316100 ` | ` 0.1825883045699772 ` | !< | ` 6  `    | ` -0.2740182222332805 ` | ` 0.2066152563885843 ` | ` 0.3737511439063931 ` | !< | ` 7  `    | ` -0.0411952089052647 ` | ` 0.0415864076069797 ` | ` 0.5301279418422206 ` | !< | ` 8  `    | ` -0.1797084899153560 ` | ` 0.0219891884310925 ` | ` 0.5704177433952291 ` | !< | ` 9  `    | ` -1.1771530652064288 ` | ` 0.9893081222650993 ` | ` 0.5885784947099155 ` | !< | ` 10 `    | ` -0.4078831463120878 ` | ` 0.0063199019859826 ` | ` 0.6160769826246714 ` | !< | ` 11 `    | ` -0.8295636426191777 ` | ` 0.3749640721105318 ` | ` 0.6223252334314046 ` | !< | ` 12 `    | ` -4.7895970584252288 ` | ` 1.6080235151003195 ` | ` 0.6897593128753419 ` | !< | ` 13 `    | ` -0.6606671432964504 ` | ` 0.0961209123818189 ` | ` 0.9126827615920843 ` | !< !<#### 14 stages, 4th order !< This scheme is a low storage RK(14, 4), by [4]. !< !< | ` Stage ` | ` A `                   | ` B `                  | ` C `                  | !< |-----------|-------------------------|------------------------|------------------------| !< | ` 1  `    | `  0                  ` | ` 0.0367762454319673 ` | ` 0                  ` | !< | ` 2  `    | ` -0.7188012108672410 ` | ` 0.3136296607553959 ` | ` 0.0367762454319673 ` | !< | ` 3  `    | ` -0.7785331173421570 ` | ` 0.1531848691869027 ` | ` 0.1249685262725025 ` | !< | ` 4  `    | ` -0.0053282796654044 ` | ` 0.0030097086818182 ` | ` 0.2446177702277698 ` | !< | ` 5  `    | ` -0.8552979934029281 ` | ` 0.3326293790646110 ` | ` 0.2476149531070420 ` | !< | ` 6  `    | ` -3.9564138245774565 ` | ` 0.2440251405350864 ` | ` 0.2969311120382472 ` | !< | ` 7  `    | ` -1.5780575380587385 ` | ` 0.3718879239592277 ` | ` 0.3978149645802642 ` | !< | ` 8  `    | ` -2.0837094552574054 ` | ` 0.6204126221582444 ` | ` 0.5270854589440328 ` | !< | ` 9  `    | ` -0.7483334182761610 ` | ` 0.1524043173028741 ` | ` 0.6981269994175695 ` | !< | ` 10 `    | ` -0.7032861106563359 ` | ` 0.0760894927419266 ` | ` 0.8190890835352128 ` | !< | ` 11 `    | `  0.0013917096117681 ` | ` 0.0077604214040978 ` | ` 0.8527059887098624 ` | !< | ` 12 `    | ` -0.0932075369637460 ` | ` 0.0024647284755382 ` | ` 0.8604711817462826 ` | !< | ` 13 `    | ` -0.9514200470875948 ` | ` 0.0780348340049386 ` | ` 0.8627060376969976 ` | !< | ` 14 `    | ` -7.1151571693922548 ` | ` 5.5059777270269628 ` | ` 0.8734213127600976 ` | !< !<#### Bibliography !< !< [1] *Low-Storage Runge-Kutta Schemes*, J. H. Williamson, Journal of Computational Physics, vol. 35, 1980, pp. 48--56. !< !< [2] *Fourth-Order 2N-Storage Runge-Kutta Schemes*, Mark H. Carpenter, Christopher A. Kennedy, NASA Technical Memorandum 109112, !< June 1994. !< !< [3] *High-accuracy large-step explicit Runge–Kutta (HALE-RK) schemes for computational aeroacoustics*, Vasanth Allampalli and !< Ray Hixon and M. Nallasamy and Scott D. Sawyer, Journal of Computational Physics, vol. 228, 2009, pp. 3837--3850. !< !< [4] *Efficient low-storage Runge–Kutta schemes with optimized stability regions*, Jens Niegemann and Richard Diehl and Kurt !< Busch, Journal of Computational Physics, vol. 231, 2012, pp. 364--372. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : I_P , I8P , R_P use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: ls_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), parameter :: registers = 2 !< Registers used (2N schemes). character ( len = 99 ), parameter :: supported_stages = '1,5-7,12-14' !< List of supported stages number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 1 !< Minimum number of stages supported. integer ( I_P ), parameter :: max_ss = 14 !< Maximum number of stages supported. type :: ls_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required stages; private integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: A (:) !< Low storage *A* coefficients. real ( R_P ), allocatable :: B (:) !< Low storage *B* coefficients. real ( R_P ), allocatable :: C (:) !< Low storage *C* coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: used_registers !< Return the number of registers used. procedure , nopass , public :: min_stages !< Return the minimum number of stages supported. procedure , nopass , public :: max_stages !< Return the maximum number of stages supported. procedure , nopass , public :: is_supported !< Check if the queried number of stages is supported or not. final :: finalize !< Finalize object. endtype ls_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' low storage table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( stages )) then self % stages = stages if ( allocated ( self % A )) deallocate ( self % A ) ; allocate ( self % A ( 1 : stages )) ; self % A = 0._R_P if ( allocated ( self % B )) deallocate ( self % B ) ; allocate ( self % B ( 1 : stages )) ; self % B = 0._R_P if ( allocated ( self % C )) deallocate ( self % C ) ; allocate ( self % C ( 1 : stages )) ; self % C = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % B ( 1 ) = 1._R_P case ( 5 ) ! LSRK(5,4) self % A ( 1 ) = 0._R_P self % A ( 2 ) = - real ( 567301805773_I8P , kind = R_P ) / real ( 1357537059087_I8P , kind = R_P ) self % A ( 3 ) = - real ( 2404267990393_I8P , kind = R_P ) / real ( 2016746695238_I8P , kind = R_P ) self % A ( 4 ) = - real ( 3550918686646_I8P , kind = R_P ) / real ( 2091501179385_I8P , kind = R_P ) self % A ( 5 ) = - real ( 1275806237668_I8P , kind = R_P ) / real ( 842570457699_I8P , kind = R_P ) self % B ( 1 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % B ( 2 ) = real ( 5161836677717_I8P , kind = R_P ) / real ( 13612068292357_I8P , kind = R_P ) self % B ( 3 ) = real ( 1720146321549_I8P , kind = R_P ) / real ( 2090206949498_I8P , kind = R_P ) self % B ( 4 ) = real ( 3134564353537_I8P , kind = R_P ) / real ( 4481467310338_I8P , kind = R_P ) self % B ( 5 ) = real ( 2277821191437_I8P , kind = R_P ) / real ( 14882151754819_I8P , kind = R_P ) self % C ( 1 ) = 0._R_P self % C ( 2 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % C ( 3 ) = real ( 2526269341429_I8P , kind = R_P ) / real ( 6820363962896_I8P , kind = R_P ) self % C ( 4 ) = real ( 2006345519317_I8P , kind = R_P ) / real ( 3224310063776_I8P , kind = R_P ) self % C ( 5 ) = real ( 2802321613138_I8P , kind = R_P ) / real ( 2924317926251_I8P , kind = R_P ) case ( 6 ) ! LSRK(6,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.122000000000_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.691750960670_R_P ; self % B ( 2 ) = 0.477263056358_R_P ; self % C ( 2 ) = 0.122000000000_R_P self % A ( 3 ) = - 1.727127405211_R_P ; self % B ( 3 ) = 0.381941220320_R_P ; self % C ( 3 ) = 0.269115878630_R_P self % A ( 4 ) = - 0.694890150986_R_P ; self % B ( 4 ) = 0.447757195744_R_P ; self % C ( 4 ) = 0.447717183551_R_P self % A ( 5 ) = - 1.039942756197_R_P ; self % B ( 5 ) = 0.498614246822_R_P ; self % C ( 5 ) = 0.749979795490_R_P self % A ( 6 ) = - 1.531977447611_R_P ; self % B ( 6 ) = 0.186648570846_R_P ; self % C ( 6 ) = 0.898555413085_R_P case ( 7 ) ! LSRK(7,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.117322146869_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.647900745934_R_P ; self % B ( 2 ) = 0.503270262127_R_P ; self % C ( 2 ) = 0.117322146869_R_P self % A ( 3 ) = - 2.704760863204_R_P ; self % B ( 3 ) = 0.233663281658_R_P ; self % C ( 3 ) = 0.294523230758_R_P self % A ( 4 ) = - 0.460080550118_R_P ; self % B ( 4 ) = 0.283419634625_R_P ; self % C ( 4 ) = 0.305658622131_R_P self % A ( 5 ) = - 0.500581787785_R_P ; self % B ( 5 ) = 0.540367414023_R_P ; self % C ( 5 ) = 0.582864148403_R_P self % A ( 6 ) = - 1.906532255913_R_P ; self % B ( 6 ) = 0.371499414620_R_P ; self % C ( 6 ) = 0.858664273599_R_P self % A ( 7 ) = - 1.450000000000_R_P ; self % B ( 7 ) = 0.136670099385_R_P ; self % C ( 7 ) = 0.868664273599_R_P case ( 12 ) ! LSRK(12,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0650008435125904_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.0923311242368072_R_P ; self % B ( 2 ) = 0.0161459902249842_R_P ; self % C ( 2 ) = 0.0650008435125904_R_P self % A ( 3 ) = - 0.9441056581158819_R_P ; self % B ( 3 ) = 0.5758627178358159_R_P ; self % C ( 3 ) = 0.0796560563081853_R_P self % A ( 4 ) = - 4.3271273247576394_R_P ; self % B ( 4 ) = 0.1649758848361671_R_P ; self % C ( 4 ) = 0.1620416710085376_R_P self % A ( 5 ) = - 2.1557771329026072_R_P ; self % B ( 5 ) = 0.3934619494248182_R_P ; self % C ( 5 ) = 0.2248877362907778_R_P self % A ( 6 ) = - 0.9770727190189062_R_P ; self % B ( 6 ) = 0.0443509641602719_R_P ; self % C ( 6 ) = 0.2952293985641261_R_P self % A ( 7 ) = - 0.7581835342571139_R_P ; self % B ( 7 ) = 0.2074504268408778_R_P ; self % C ( 7 ) = 0.3318332506149405_R_P self % A ( 8 ) = - 1.7977525470825499_R_P ; self % B ( 8 ) = 0.6914247433015102_R_P ; self % C ( 8 ) = 0.4094724050198658_R_P self % A ( 9 ) = - 2.6915667972700770_R_P ; self % B ( 9 ) = 0.3766646883450449_R_P ; self % C ( 9 ) = 0.6356954475753369_R_P self % A ( 10 ) = - 4.6466798960268143_R_P ; self % B ( 10 ) = 0.0757190350155483_R_P ; self % C ( 10 ) = 0.6806551557645497_R_P self % A ( 11 ) = - 0.1539613783825189_R_P ; self % B ( 11 ) = 0.2027862031054088_R_P ; self % C ( 11 ) = 0.7143773712418350_R_P self % A ( 12 ) = - 0.5943293901830616_R_P ; self % B ( 12 ) = 0.2167029365631842_R_P ; self % C ( 12 ) = 0.9032588871651854_R_P case ( 13 ) ! LSRK(13,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0271990297818803_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.6160178650170565_R_P ; self % B ( 2 ) = 0.1772488819905108_R_P ; self % C ( 2 ) = 0.0271990297818803_R_P self % A ( 3 ) = - 0.4449487060774118_R_P ; self % B ( 3 ) = 0.0378528418949694_R_P ; self % C ( 3 ) = 0.0952594339119365_R_P self % A ( 4 ) = - 1.0952033345276178_R_P ; self % B ( 4 ) = 0.6086431830142991_R_P ; self % C ( 4 ) = 0.1266450286591127_R_P self % A ( 5 ) = - 1.2256030785959187_R_P ; self % B ( 5 ) = 0.2154313974316100_R_P ; self % C ( 5 ) = 0.1825883045699772_R_P self % A ( 6 ) = - 0.2740182222332805_R_P ; self % B ( 6 ) = 0.2066152563885843_R_P ; self % C ( 6 ) = 0.3737511439063931_R_P self % A ( 7 ) = - 0.0411952089052647_R_P ; self % B ( 7 ) = 0.0415864076069797_R_P ; self % C ( 7 ) = 0.5301279418422206_R_P self % A ( 8 ) = - 0.1797084899153560_R_P ; self % B ( 8 ) = 0.0219891884310925_R_P ; self % C ( 8 ) = 0.5704177433952291_R_P self % A ( 9 ) = - 1.1771530652064288_R_P ; self % B ( 9 ) = 0.9893081222650993_R_P ; self % C ( 9 ) = 0.5885784947099155_R_P self % A ( 10 ) = - 0.4078831463120878_R_P ; self % B ( 10 ) = 0.0063199019859826_R_P ; self % C ( 10 ) = 0.6160769826246714_R_P self % A ( 11 ) = - 0.8295636426191777_R_P ; self % B ( 11 ) = 0.3749640721105318_R_P ; self % C ( 11 ) = 0.6223252334314046_R_P self % A ( 12 ) = - 4.7895970584252288_R_P ; self % B ( 12 ) = 1.6080235151003195_R_P ; self % C ( 12 ) = 0.6897593128753419_R_P self % A ( 13 ) = - 0.6606671432964504_R_P ; self % B ( 13 ) = 0.0961209123818189_R_P ; self % C ( 13 ) = 0.9126827615920843_R_P case ( 14 ) ! LSRK(14,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0367762454319673_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.7188012108672410_R_P ; self % B ( 2 ) = 0.3136296607553959_R_P ; self % C ( 2 ) = 0.0367762454319673_R_P self % A ( 3 ) = - 0.7785331173421570_R_P ; self % B ( 3 ) = 0.1531848691869027_R_P ; self % C ( 3 ) = 0.1249685262725025_R_P self % A ( 4 ) = - 0.0053282796654044_R_P ; self % B ( 4 ) = 0.0030097086818182_R_P ; self % C ( 4 ) = 0.2446177702277698_R_P self % A ( 5 ) = - 0.8552979934029281_R_P ; self % B ( 5 ) = 0.3326293790646110_R_P ; self % C ( 5 ) = 0.2476149531070420_R_P self % A ( 6 ) = - 3.9564138245774565_R_P ; self % B ( 6 ) = 0.2440251405350864_R_P ; self % C ( 6 ) = 0.2969311120382472_R_P self % A ( 7 ) = - 1.5780575380587385_R_P ; self % B ( 7 ) = 0.3718879239592277_R_P ; self % C ( 7 ) = 0.3978149645802642_R_P self % A ( 8 ) = - 2.0837094552574054_R_P ; self % B ( 8 ) = 0.6204126221582444_R_P ; self % C ( 8 ) = 0.5270854589440328_R_P self % A ( 9 ) = - 0.7483334182761610_R_P ; self % B ( 9 ) = 0.1524043173028741_R_P ; self % C ( 9 ) = 0.6981269994175695_R_P self % A ( 10 ) = - 0.7032861106563359_R_P ; self % B ( 10 ) = 0.0760894927419266_R_P ; self % C ( 10 ) = 0.8190890835352128_R_P self % A ( 11 ) = 0.0013917096117681_R_P ; self % B ( 11 ) = 0.0077604214040978_R_P ; self % C ( 11 ) = 0.8527059887098624_R_P self % A ( 12 ) = - 0.0932075369637460_R_P ; self % B ( 12 ) = 0.0024647284755382_R_P ; self % C ( 12 ) = 0.8604711817462826_R_P self % A ( 13 ) = - 0.9514200470875948_R_P ; self % B ( 13 ) = 0.0780348340049386_R_P ; self % C ( 13 ) = 0.8627060376969976_R_P self % A ( 14 ) = - 7.1151571693922548_R_P ; self % B ( 14 ) = 5.5059777270269628_R_P ; self % C ( 14 ) = 0.8734213127600976_R_P endselect self % error = 0 else ! bad (unsupported) number of required stages self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % A )) deallocate ( self % A ) if ( allocated ( self % B )) deallocate ( self % B ) if ( allocated ( self % C )) deallocate ( self % C ) self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit low storage Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 : registers ) !< Runge-Kutta registers. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages stage ( 1 ) = U stage ( 2 ) = U * 0._R_P do s = 1 , self % stages stage ( 2 ) = stage ( 2 ) * self % A ( s ) + stage ( 1 )% t ( t = t + self % C ( s ) * Dt ) * Dt stage ( 1 ) = stage ( 1 ) + stage ( 2 ) * self % B ( s ) enddo U = stage ( 1 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate elemental function used_registers () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the number of registers used. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: used_registers !< Number of registers used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- used_registers = registers return !--------------------------------------------------------------------------------------------------------------------------------- endfunction used_registers elemental function min_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_stages !< Minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_stages = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_stages elemental function max_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_stages !< Maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_stages = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_stages elemental function is_supported ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of stages is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. logical :: is_supported !< Is true is the stages number is in *supported_stages*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = stages , adm_range = trim ( supported_stages )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_low_storage_runge_kutta","tags":"","loc":"sourcefile/foodie_integrator_low_storage_runge_kutta.f90.html","title":"foodie_integrator_low_storage_runge_kutta.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. Source Code !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. module foodie_integrator_tvd_runge_kutta !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< The integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP) !< one. The schemes are explicit and defined through the Butcher's table syntax, see[1] . !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<  U&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta&#94;s K&#94;s  !< !< where Ns is the number of stages used and K&#94;s is the s&#94;{th} stage computed as: !< !<  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are !< given in the Butcher table form: !< !<``` !<  gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns} !<  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns} !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns} !< ------------|------------------------------------------------------------- !<             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} !<``` !< !< Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: !< !<``` !<  gamma&#94;1    | 0                 0                 ...        0 !<  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0 !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0 !< ------------|------------------------------------------------------------- !<             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} !<``` !< !< Moreover the following relation always holds: !<  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !<##### 1 stage, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. !<``` !<  0 | 0 !< ---|--- !<    | 1 !<``` !< !<##### 2 stages, SSP, 2nd order !< This scheme is an optmial SSP(2, 2) without low-storage algorithm, see [2]. !<``` !<  0 | 0     0 !<  1 | 1     0 !< ---|----------- !<    | 1/2   1/2 !<``` !< !<##### 3 stages, SSP, 3rd order !< This scheme is an optmial SSP(3, 3) without low-storage algorithm, see [2]. !<``` !<  0   | 0     0     0 !<  1   | 1     0     0 !<  1/2 | 1/4   1/4   0 !< -----|----------------- !<      | 1/6   1/6   1/3 !<``` !< !<##### 5 stages, SSP, 4th order !< This scheme is an optmial SSP(5, 4) without low-storage algorithm, see [2]. !<``` !<  0                | 0                  0                  0                  0                  0 !<  0.39175222700392 | 0.39175222700392   0                  0                  0                  0 !<  0.58607968896780 | 0.21766909633821   0.36841059262959   0                  0                  0 !<  0.47454236302687 | 0.08269208670950   0.13995850206999   0.25189177424738   0                  0 !<  0.93501063100924 | 0.06796628370320   0.11503469844438   0.20703489864929   0.54497475021237   0 !< ------------------|--------------------------------------------------------------------------------------------- !<                   | 0.14681187618661   0.24848290924556   0.10425883036650   0.27443890091960   0.22600748319395 !<``` !< !<#### Bibliography !< !< [1] *Coefficients for the study of Runge-Kutta integration processes*, Butcher, J.C., J. Austral. Math. Soc., Vol. 3, !< pages: 185--201, 1963. !< !< [2] *High Order Strong Stability Preserving Time Discretizations*, Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of !< Scientific Computing, vol. 38, N. 3, 2009, pp. 251-289. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : R_P , I_P use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- character ( len = 99 ), parameter :: supported_stages = '1-3,5' !< List of supported stages number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 1 !< Minimum number of stages supported. integer ( I_P ), parameter :: max_ss = 5 !< Maximum number of stages supported. type :: tvd_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required stages; private integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_stages !< Return the minimum number of stages supported. procedure , nopass , public :: max_stages !< Return the maximum number of stages supported. procedure , nopass , public :: is_supported !< Check if the queried number of stages is supported or not. final :: finalize !< Finalize object. endtype tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( stages )) then self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect self % error = 0 else ! bad (unsupported) number of required stages self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! computing new time step do s = 1 , self % stages U = U + stage ( s ) * ( Dt * self % beta ( s )) enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate elemental function min_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_stages !< Minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_stages = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_stages elemental function max_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_stages !< Maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_stages = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_stages elemental function is_supported ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of stages is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. logical :: is_supported !< Is true is the stages number is in *supported_stages*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = stages , adm_range = trim ( supported_stages )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_tvd_runge_kutta","tags":"","loc":"sourcefile/foodie_integrator_tvd_runge_kutta.f90.html","title":"foodie_integrator_tvd_runge_kutta.f90 – FOODIE"},{"text":"FOODIE kinds: definition of reals and integer kind parameters of FOODIE library. Source Code !< FOODIE kinds: definition of reals and integer kind parameters of FOODIE library. module foodie_kinds !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE kinds: definition of reals and integer kind parameters of FOODIE library. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: R8P public :: R4P public :: R_P public :: I8P public :: I4P public :: I2P public :: I1P public :: I_P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. !----------------------------------------------------------------------------------------------------------------------------------- endmodule foodie_kinds","tags":"","loc":"sourcefile/foodie_kinds.f90.html","title":"foodie_kinds.f90 – FOODIE"},{"text":"FOODIE utils: module of (possible) unrelated utilities of FOODIE library. Source Code !< FOODIE utils: module of (possible) unrelated utilities of FOODIE library. module foodie_utils !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE utils: module of (possible) unrelated utilities of FOODIE library. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : I_P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: is_admissible !----------------------------------------------------------------------------------------------------------------------------------- contains ! public procedures elemental function is_admissible ( n , adm_range ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number *n* is admitted by the *admissible* range list *adm_range*. !< !< The admissible range list must be formatted as string containing admissible numbers; valid list are: !<+ `adm_range = '1-5'` => 1, 2, 3, 4, 5 are admissible numbers; !<+ `adm_range = '1,3,5,10-12'` => 1, 3, 5, 10, 11, 12 are admissible numbers; !<+ `adm_range = '1-4,8,21-22'` => 1, 2, 3, 4, 8, 21, 22 are admissible numbers; !< !< You can mix any number of range (`min-max` format) and/or single number (`,` comma separated) entries. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: n !< Number queried. character ( * ), intent ( IN ) :: adm_range !< Admissible range string. logical :: is_admissible !< Is true is the number is in *adm_range*. character ( len ( adm_range )), allocatable :: tokens (:) !< Tokens for parsing *adm_range* string. character ( len ( adm_range )), allocatable :: subtokens (:) !< Tokens for parsing *adm_range* string. integer ( I_P ) :: t !< Counter. integer ( I_P ) :: n_parsed ( 1 : 2 ) !< Values parsed from *adm_range*.. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_admissible = . false . call tokenize ( string = adm_range , delimiter = ',' , toks = tokens ) search_me : do t = 1 , size ( tokens ) if ( index ( tokens ( t ), '-' ) > 0 ) then call tokenize ( string = tokens ( t ), delimiter = '-' , toks = subtokens ) read ( subtokens ( 1 ), * ) n_parsed ( 1 ) read ( subtokens ( 2 ), * ) n_parsed ( 2 ) is_admissible = ( n_parsed ( 1 ) <= n . and . n <= n_parsed ( 2 )) else read ( tokens ( t ), * ) n_parsed ( 1 ) is_admissible = ( n_parsed ( 1 ) == n ) endif if ( is_admissible ) exit search_me enddo search_me return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_admissible ! private procedures pure subroutine tokenize ( string , delimiter , toks , Nt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must be allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to char(0). !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( IN ) :: string !< String to be tokenized. character ( len =* ), intent ( IN ) :: delimiter !< Delimiter of tokens. character ( len = len ( string )), allocatable , intent ( OUT ) :: toks (:) !< Tokens. integer ( I_P ), optional , intent ( OUT ) :: Nt !< Number of tokens. character ( len = len ( string )) :: strsub !< Temporary string. integer ( I_P ) :: dlen !< Delimiter length. integer ( I_P ) :: c !< Counter. integer ( I_P ) :: n !< Counter. integer ( I_P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialize if ( allocated ( toks )) deallocate ( toks ) strsub = string dlen = len ( delimiter ) if ( dlen > len ( string )) then allocate ( toks ( 1 : 1 )) toks ( 1 ) = char ( 0 ) if ( present ( Nt )) Nt = 1 return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenize do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tokenize endmodule foodie_utils","tags":"","loc":"sourcefile/foodie_utils.f90.html","title":"foodie_utils.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Oscillation equations. Source Code !< Test FOODIE with the integration of Oscillation equations. module oscillation_test_t !----------------------------------------------------------------------------------------------------------------------------------- !< Oscillation test handler definition. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & adams_bashforth_moulton_integrator , & adams_moulton_integrator , & back_df_integrator , & emd_runge_kutta_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use IR_Precision , only : I_P , R_P , FR_P , str , strz use oscillation_t , only : oscillation use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: oscillation_test !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- integer , parameter :: space_dimension = 2 !< Space dimensions. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 0._R_P , 1._R_P ] !< Initial state. character ( 99 ), parameter :: solvers ( 1 : 10 ) = [ \"adams-bashforth        \" , & \"adams-bashforth-moulton\" , & \"adams-moulton          \" , & \"backward-diff-formula  \" , & \"emd-runge-kutta        \" , & \"euler                  \" , & \"leapfrog               \" , & \"leapfrog-raw           \" , & \"ls-runge-kutta         \" , & \"tvd-runge-kutta        \" ] !< List of available solvers. type :: oscillation_test !< Class to handle oscillation test(s). !< !< Test is driven by the Command Line Interface (CLI) options. !< !< Test has only 1 public method `execute`: it executes test(s) accordingly to cli options. private type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. integer ( I_P ) :: error = 0 !< Error handler. logical :: errors_analysis = . false . !< Flag for activating errors analysis. real ( R_P ) :: frequency = 0.0_R_P !< Oscillation frequency. real ( R_P ) :: final_time = 0.0_R_P !< Final integration time. integer ( I_P ) :: implicit_iterations = 0 !< Number of iterations (implicit solvers). character ( 99 ) :: output_cli = 'unset' !< Output files basename. logical :: plots = . false . !< Flag for activating plots saving. logical :: results = . false . !< Flag for activating results saving. character ( 99 ) :: solver = 'adams-bashforth' !< Solver used. integer ( I_P ), allocatable :: stages_steps (:) !< Number of stages/steps used. real ( R_P ), allocatable :: Dt (:) !< Time step(s) exercised. real ( R_P ), allocatable :: tolerance (:) !< Tolerance(s) exercised on local truncation error. contains private ! Public methods procedure , pass ( self ), public :: execute !< Execute selected test(s). ! Private methods procedure , pass ( self ), private :: init !< Initialize test: set Command Line Interface, parse it and check its validity. procedure , pass ( self ), private :: test !< Perform the test. endtype oscillation_test !----------------------------------------------------------------------------------------------------------------------------------- contains ! Public methods subroutine execute ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Execute test(s). !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation_test ), intent ( inout ) :: self !< Test. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % init if ( trim ( adjustl ( self % solver )) /= 'all' ) then call self % test ( solver = self % solver ) else do s = 1 , ubound ( solvers , dim = 1 ) self % solver = solvers ( s ) call self % test ( solver = self % solver ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine execute ! Private methods subroutine init ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize test: set Command Line Interface, parse it and check its validity. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation_test ), intent ( inout ) :: self !< Test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call set_cli call parse_cli return !--------------------------------------------------------------------------------------------------------------------------------- contains subroutine set_cli () !------------------------------------------------------------------------------------------------------------------------------- !< set Command Line Interface. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- associate ( cli => self % cli ) call cli % init ( progname = 'oscillation' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Oscillation equations integration' , & examples = [ \"oscillation --solver euler --results  \" , & \"oscillation --solver ls-runge-kutta -r\" , & \"oscillation --solver adams-bashforth  \" , & \"oscillation --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . false ., def = 'all' , act = 'store' ) call cli % add ( switch = '--iterations' , help = 'Number of iterations for implicit solvers' , required = . false ., act = 'store' , def = '5' ) call cli % add ( switch = '--frequency' , switch_ab = '-f' , help = 'Oscillation frequency' , required = . false ., def = '1e-4' , act = 'store' ) call cli % add ( switch = '--ss' , nargs = '+' , help = 'Stages/steps used' , required = . false ., def = '-1' , act = 'store' ) call cli % add ( switch = '--time_step' , switch_ab = '-Dt' , nargs = '+' , help = 'Time step' , required = . false ., def = '100.d0' , act = 'store' ) call cli % add ( switch = '--tolerance' , switch_ab = '-tol' , nargs = '+' , help = 'Error Tolerance' , required = . false ., def = '0.001d0' , & act = 'store' ) call cli % add ( switch = '--t_final' , switch_ab = '-tf' , help = 'Final integration time' , required = . false ., def = '1e6' , act = 'store' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--output' , help = 'Output files basename' , required = . false ., act = 'store' , def = 'unset' ) call cli % add ( switch = '--errors_analysis' , help = 'Peform errors analysis' , required = . false ., act = 'store_true' , def = '.false.' ) endassociate return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_cli subroutine parse_cli () !------------------------------------------------------------------------------------------------------------------------------- !< Parse Command Line Interface and check its validity. !------------------------------------------------------------------------------------------------------------------------------- character ( len = :), allocatable :: valid_solvers_list !< Pretty printed list of available solvers. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- associate ( cli => self % cli , error => self % error ) call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = self % solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--iterations' , val = self % implicit_iterations , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-f' , val = self % frequency , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '--ss' , val = self % stages_steps , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-Dt' , val = self % Dt , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-tol' , val = self % tolerance , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-tf' , val = self % final_time , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = self % results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = self % plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--output' , val = self % output_cli , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--errors_analysis' , val = self % errors_analysis , error = error ) ; if ( error /= 0 ) stop endassociate if (. not . is_solver_valid ()) then print \"(A)\" , 'Error: the solver \"' // trim ( adjustl ( self % solver )) // '\" is unknown!' valid_solvers_list = list_solvers () print \"(A)\" , valid_solvers_list stop endif if (. not . is_dt_valid ()) then print \"(A)\" , 'Error: the final integration time must be an exact multiple of the time step used!' print \"(A)\" , 'Final integration time: ' // str (. true ., self % final_time ) print \"(A)\" , 'Time step: ' // str (. true ., self % Dt ) stop endif if ( size ( self % stages_steps ) == 2 ) then if (. not .( self % stages_steps ( 2 ) > self % stages_steps ( 1 ). and . self % stages_steps ( 1 ) >= 0 )) then print \"(A)\" , 'Error: when passing a range of stages/steps the valid format must be lower-upper (both positive)!' print \"(A)\" , 'Range passed: ' // trim ( str (. true ., self % stages_steps ( 1 ))) // '-' // trim ( str (. true ., self % stages_steps ( 2 ))) stop endif endif return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_cli function is_solver_valid () !------------------------------------------------------------------------------------------------------------------------------- !< Verify if the selected solver is valid. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_solver_valid !< Return true is the selected solver is available. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- is_solver_valid = . false . do s = 1 , ubound ( solvers , dim = 1 ) is_solver_valid = ( trim ( adjustl ( self % solver )) == trim ( adjustl ( solvers ( s )))) if ( is_solver_valid ) exit enddo return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_solver_valid function is_dt_valid () !------------------------------------------------------------------------------------------------------------------------------- !< Verify if the selected time step Dt is valid. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_dt_valid !< Return true is the selected time step Dt is valid. integer ( I_P ) :: t !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- is_dt_valid = . true . do t = 1 , size ( self % Dt ) is_dt_valid = (( self % final_time - int ( self % final_time / self % Dt ( t ), I_P ) * self % Dt ( t )) == 0 ) if (. not . is_dt_valid ) exit enddo return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_dt_valid function list_solvers () result ( list ) !------------------------------------------------------------------------------------------------------------------------------- !< List available solvers. !------------------------------------------------------------------------------------------------------------------------------- character ( len = :), allocatable :: list !< Pretty printed list of available solvers. integer ( I_P ) :: s !< Solvers counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- list = 'Valid solver names are:' // new_line ( 'a' ) do s = 1 , ubound ( solvers , dim = 1 ) list = list // '  + ' // trim ( adjustl ( solvers ( s ))) // new_line ( 'a' ) enddo list = list // '  + all' return !------------------------------------------------------------------------------------------------------------------------------- endfunction list_solvers endsubroutine init subroutine test ( self , solver ) !--------------------------------------------------------------------------------------------------------------------------------- !< Perform the test. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation_test ), intent ( in ) :: self !< Test. character ( * ), intent ( in ) :: solver !< Selected solver. ! FOODIE integrators type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. type ( adams_bashforth_moulton_integrator ) :: abm_integrator !< Adams-Bashforth-Moulton integrator. type ( adams_moulton_integrator ) :: am_integrator !< Adams-Moulton integrator. type ( back_df_integrator ) :: bdf_integrator !< BDF integrator. type ( emd_runge_kutta_integrator ) :: emd_rk_integrator !< Runge-Kutta integrator. type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( ls_runge_kutta_integrator ) :: ls_rk_integrator !< Low Storage Runge-Kutta integrator. type ( tvd_runge_kutta_integrator ) :: tvd_rk_integrator !< TVD Runge-Kutta integrator. ! Auxiliary variables real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. real ( R_P ), allocatable :: error (:,:) !< Error (norm L2) with respect the exact solution. real ( R_P ), allocatable :: order (:,:) !< Observed order based on subsequent refined solutions. real ( R_P ), allocatable :: Dt_mean (:) !< Mean time steps used for adaptive solver solutions. logical :: analyze_errors !< Flag for activating errors analysis for the current tests set. integer ( I_P ) :: stages_steps_range ( 1 : 2 ) !< Stages/Steps used. integer ( I_P ) :: last_step !< Last time step computed. integer ( I_P ) :: s !< Counter. integer ( I_P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialize stages/steps range if ( size ( self % stages_steps ) == 2 ) then if ( self % stages_steps ( 2 ) > self % stages_steps ( 1 ). and . self % stages_steps ( 1 ) >= 0 ) then stages_steps_range = [ self % stages_steps ( 1 ), self % stages_steps ( 2 )] endif elseif ( self % stages_steps ( 1 ) >= 0 ) then stages_steps_range = self % stages_steps ( 1 ) else select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) stages_steps_range = [ ab_integrator % min_steps (), ab_integrator % max_steps ()] case ( 'adams-bashforth-moulton' ) stages_steps_range = [ abm_integrator % min_steps (), abm_integrator % max_steps ()] case ( 'adams-moulton' ) stages_steps_range = [ am_integrator % min_steps (), am_integrator % max_steps ()] case ( 'backward-diff-formula' ) stages_steps_range = [ bdf_integrator % min_steps (), bdf_integrator % max_steps ()] case ( 'emd-runge-kutta' ) stages_steps_range = [ emd_rk_integrator % min_stages (), emd_rk_integrator % max_stages ()] case ( 'euler' ) stages_steps_range = [ euler_integrator % min_stages_steps (), euler_integrator % max_stages_steps ()] case ( 'leapfrog' ) stages_steps_range = [ lf_integrator % min_steps (), lf_integrator % max_steps ()] case ( 'leapfrog-raw' ) stages_steps_range = [ lf_integrator % min_steps (), lf_integrator % max_steps ()] case ( 'ls-runge-kutta' ) stages_steps_range = [ ls_rk_integrator % min_stages (), ls_rk_integrator % max_stages ()] case ( 'tvd-runge-kutta' ) stages_steps_range = [ tvd_rk_integrator % min_stages (), tvd_rk_integrator % max_stages ()] endselect endif if ( trim ( adjustl ( solver )) == 'emd-runge-kutta' ) then if ( allocated ( error )) deallocate ( error ) ; allocate ( error ( 1 : space_dimension , 1 : size ( self % tolerance ))) if ( allocated ( Dt_mean )) deallocate ( Dt_mean ) ; allocate ( Dt_mean ( 1 : size ( error , dim = 2 ))) else if ( allocated ( error )) deallocate ( error ) ; allocate ( error ( 1 : space_dimension , 1 : size ( self % Dt ))) endif error = 0.0_R_P analyze_errors = . false . if ( trim ( adjustl ( solver )) == 'emd-runge-kutta' ) then if ( size ( self % tolerance ) > 1. and . self % errors_analysis ) then if ( allocated ( order )) deallocate ( order ) ; allocate ( order ( 1 : space_dimension , 1 : size ( self % tolerance ) - 1 )) analyze_errors = . true . endif else if ( size ( self % Dt ) > 1. and . self % errors_analysis ) then if ( allocated ( order )) deallocate ( order ) ; allocate ( order ( 1 : space_dimension , 1 : size ( self % Dt ) - 1 )) analyze_errors = . true . endif endif ! test(s) print \"(A)\" , trim ( adjustl ( solver )) do s = stages_steps_range ( 1 ), stages_steps_range ( 2 ) print \"(A)\" , '  stages/steps ' // trim ( str (. true ., s )) if ( trim ( adjustl ( solver )) == 'emd-runge-kutta' ) then do t = 1 , size ( self % tolerance ) call solve ( solver = solver , & frequency = self % frequency , & final_time = self % final_time , & stages_steps = s , & iterations = self % implicit_iterations , & solution = solution , & error = error (:, t ), & last_step = last_step , & tolerance = self % tolerance ( t )) Dt_mean ( t ) = self % final_time / real ( last_step , kind = R_P ) if ( allocated ( solution )) then print \"(A,I10,A,F10.3,A,F10.3,A,E10.3,A,E10.3)\" , \"    steps: \" , last_step , & \"    Dt: \" , Dt_mean ( t ), & \", f*Dt: \" , self % frequency * Dt_mean ( t ), & \", E(x): \" , error ( 1 , t ), \", E(y): \" , error ( 2 , t ) if ( analyze_errors . and . t > 1 ) then order (:, t - 1 ) = observed_order ( error = error (:, t - 1 : t ), Dt = Dt_mean ( t - 1 : t )) print \"(A,F10.2,A,F10.2)\" , \"      Observed order, O(x): \" , order ( 1 , t - 1 ), \", O(y): \" , order ( 2 , t - 1 ) endif call save_results ( results = self % results , & plots = self % plots , & output_cli = self % output_cli , & solver = trim ( adjustl ( solver )) // '-' // trim ( str (. true ., s )), & frequency = self % frequency , & solution = solution (:, 0 : last_step )) endif enddo else do t = 1 , size ( self % Dt ) call solve ( solver = solver , & frequency = self % frequency , & final_time = self % final_time , & stages_steps = s , & iterations = self % implicit_iterations , & solution = solution , & error = error (:, t ), & last_step = last_step , & Dt = self % Dt ( t )) if ( allocated ( solution )) then print \"(A,I10,A,F10.3,A,F10.3,A,E10.3,A,E10.3)\" , \"    steps: \" , last_step , & \"    Dt: \" , self % Dt ( t ), & \", f*Dt: \" , self % frequency * self % Dt ( t ), & \", E(x): \" , error ( 1 , t ), \", E(y): \" , error ( 2 , t ) if ( analyze_errors . and . t > 1 ) then order (:, t - 1 ) = observed_order ( error = error (:, t - 1 : t ), Dt = self % Dt ( t - 1 : t )) print \"(A,F10.2,A,F10.2)\" , \"      Observed order, O(x): \" , order ( 1 , t - 1 ), \", O(y): \" , order ( 2 , t - 1 ) endif call save_results ( results = self % results , & plots = self % plots , & output_cli = self % output_cli , & solver = trim ( adjustl ( solver )) // '-' // trim ( str (. true ., s )), & frequency = self % frequency , & solution = solution (:, 0 : last_step )) endif enddo endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test ! non type bound procedures subroutine solve ( solver , frequency , final_time , stages_steps , iterations , solution , error , last_step , Dt , tolerance ) !--------------------------------------------------------------------------------------------------------------------------------- !< Rune the solver selected. !< !< The actual solver is selected by means of the *solver* input string that must be a valid string as defined into *solvers* !< parameter list. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: solver !< Selected solver: must be defined into *solvers*. real ( R_P ), intent ( in ) :: frequency !< Oscillation frequency. real ( R_P ), intent ( in ) :: final_time !< Final integration time. integer ( I_P ), intent ( in ) :: stages_steps !< Number of stages/steps used. integer ( I_P ), intent ( in ) :: iterations !< Number of fixed point iterations. real ( R_P ), allocatable , intent ( out ) :: solution (:,:) !< Solution at each time step, X-Y. real ( R_P ), intent ( out ) :: error ( 1 :) !< Error (norm L2) with respect the exact solution. integer ( I_P ), intent ( out ) :: last_step !< Last time step computed. real ( R_P ), optional , intent ( in ) :: Dt !< Time step. real ( R_P ), optional , intent ( in ) :: tolerance !< Local error tolerance. ! FOODIE integrators type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. type ( adams_bashforth_moulton_integrator ) :: abm_integrator !< Adams-Bashforth-Moulton integrator. type ( adams_moulton_integrator ) :: am_integrator !< Adams-Moulton integrator. type ( back_df_integrator ) :: bdf_integrator !< BDF integrator. type ( emd_runge_kutta_integrator ) :: emd_rk_integrator !< Runge-Kutta integrator. type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( ls_runge_kutta_integrator ) :: ls_rk_integrator !< Low Storage Runge-Kutta integrator. type ( tvd_runge_kutta_integrator ) :: tvd_rk_integrator !< TVD Runge-Kutta integrator. ! Auxiliary variables integer ( I_P ), parameter :: max_rk_stages = 5 !< Max RK stages used to init high order multi-step solver. type ( oscillation ) :: oscillator !< Oscillation field. logical :: supported !< Flag for checking if the selected solver is supported. logical :: multistep !< Flag for tagging multi-step class of solvers. integer :: step_offset !< Time steps counter offset for slicing previous data array. logical :: adaptive !< Flag for tagging time step adaptive class of solvers. real ( R_P ) :: Dt_a !< Adaptive time step. type ( oscillation ), allocatable :: rk_stage (:) !< Runge-Kutta stages. type ( oscillation ), allocatable :: previous (:) !< Previous time steps solutions. type ( oscillation ) :: filter !< Filter displacement. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initizialize call oscillator % init ( initial_state = initial_state , frequency = frequency ) supported = . true . ! assume that selected solver is supported multistep = . false . ! assume multi-stage solver by default if ( stages_steps == 0 ) then step_offset = 1 ! for 0 step-(a convention)-solver offset is 1 else step_offset = stages_steps ! for >0 step-solver offset is steps endif adaptive = . false . ! assume fixed time step by default Dt_a = 1000 0._R_P ! initial step very large to trigger adaptation if ( present ( Dt )) then if ( allocated ( solution )) deallocate ( solution ) ; allocate ( solution ( 0 : space_dimension , 0 : int ( final_time / Dt ))) else if ( allocated ( solution )) deallocate ( solution ) ; allocate ( solution ( 0 : space_dimension , 0 : int ( final_time / 10 ))) ! hope is enough endif solution = 0.0_R_P solution ( 1 :, 0 ) = oscillator % output () select case ( trim ( adjustl ( solver ))) case ( \"adams-bashforth\" ) supported = ab_integrator % is_supported ( stages_steps ) multistep = . true . call ab_integrator % init ( steps = stages_steps ) if ( allocated ( previous )) deallocate ( previous ) ; allocate ( previous ( 1 : stages_steps )) case ( \"adams-bashforth-moulton\" ) supported = abm_integrator % is_supported ( stages_steps ) multistep = . true . call abm_integrator % init ( steps = stages_steps ) if ( allocated ( previous )) deallocate ( previous ) ; allocate ( previous ( 1 : stages_steps )) case ( \"adams-moulton\" ) supported = am_integrator % is_supported ( stages_steps ) multistep = . true . call am_integrator % init ( steps = stages_steps ) if ( allocated ( previous )) deallocate ( previous ) ; allocate ( previous ( 1 : stages_steps + 1 )) case ( \"backward-diff-formula\" ) supported = bdf_integrator % is_supported ( stages_steps ) multistep = . true . call bdf_integrator % init ( steps = stages_steps ) if ( allocated ( previous )) deallocate ( previous ) ; allocate ( previous ( 1 : stages_steps + 1 )) case ( \"emd-runge-kutta\" ) supported = emd_rk_integrator % is_supported ( stages_steps ) adaptive = . true . call emd_rk_integrator % init ( stages = stages_steps , tolerance = tolerance ) if ( allocated ( rk_stage )) deallocate ( rk_stage ) ; allocate ( rk_stage ( 1 : stages_steps )) case ( \"euler\" ) supported = euler_integrator % is_supported ( stages_steps ) case ( \"leapfrog\" ) supported = lf_integrator % is_supported ( stages_steps ) multistep = . true . call lf_integrator % init () if ( allocated ( previous )) deallocate ( previous ) ; allocate ( previous ( 1 : stages_steps )) case ( \"leapfrog-raw\" ) supported = lf_integrator % is_supported ( stages_steps ) multistep = . true . call lf_integrator % init () if ( allocated ( previous )) deallocate ( previous ) ; allocate ( previous ( 1 : stages_steps )) case ( \"ls-runge-kutta\" ) supported = ls_rk_integrator % is_supported ( stages_steps ) call ls_rk_integrator % init ( stages = stages_steps ) if ( allocated ( rk_stage )) deallocate ( rk_stage ) ; allocate ( rk_stage ( 1 : ls_rk_integrator % used_registers ())) case ( \"tvd-runge-kutta\" ) supported = tvd_rk_integrator % is_supported ( stages_steps ) call tvd_rk_integrator % init ( stages = stages_steps ) if ( allocated ( rk_stage )) deallocate ( rk_stage ) ; allocate ( rk_stage ( 1 : stages_steps )) endselect if ( multistep ) then call tvd_rk_integrator % init ( stages = max_rk_stages ) if ( allocated ( rk_stage )) deallocate ( rk_stage ) ; allocate ( rk_stage ( 1 : max_rk_stages )) endif if (. not . supported ) then print \"(A)\" , 'The solver ' // trim ( adjustl ( solver )) // ' does not support ' // trim ( str (. true ., stages_steps )) // ' stages/steps' if ( allocated ( solution )) deallocate ( solution ) return endif ! integrate step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 ! advance oscillator if ( multistep ) then if ( stages_steps >= step ) then call tvd_rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) previous ( step ) = oscillator else select case ( trim ( adjustl ( solver ))) case ( \"adams-bashforth\" ) call ab_integrator % integrate ( U = oscillator , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 )) case ( \"adams-bashforth-moulton\" ) call abm_integrator % integrate ( U = oscillator , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 )) case ( \"adams-moulton\" ) if ( iterations > 1 ) then call am_integrator % integrate ( U = oscillator , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 ), & iterations = iterations ) else call am_integrator % integrate ( U = oscillator , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 )) endif case ( \"backward-diff-formula\" ) if ( iterations > 1 ) then call bdf_integrator % integrate ( U = oscillator , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 ), & iterations = iterations ) else call bdf_integrator % integrate ( U = oscillator , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 )) endif case ( \"leapfrog\" ) call lf_integrator % integrate ( U = oscillator , & previous = previous , & Dt = Dt , & t = solution ( 0 , step )) case ( \"leapfrog-raw\" ) call lf_integrator % integrate ( U = oscillator , & previous = previous , & Dt = Dt , & t = solution ( 0 , step ), & filter = filter ) endselect endif else select case ( trim ( adjustl ( solver ))) case ( \"emd-runge-kutta\" ) call emd_rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt_a , t = solution ( 0 , step )) case ( \"euler\" ) call euler_integrator % integrate ( U = oscillator , Dt = Dt , t = solution ( 0 , step )) case ( \"ls-runge-kutta\" ) call ls_rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) case ( \"tvd-runge-kutta\" ) call tvd_rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) endselect endif ! update time if ( adaptive ) then solution ( 0 , step ) = solution ( 0 , step - 1 ) + Dt_a else solution ( 0 , step ) = step * Dt endif ! store step solution solution ( 1 :, step ) = oscillator % output () enddo last_step = step error = error_L2 ( frequency = frequency , solution = solution (:, 0 : last_step )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine solve subroutine save_results ( results , plots , output_cli , solver , frequency , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results (and plots). !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: results !< Flag for activating results saving. logical , intent ( in ) :: plots !< Flag for activating plots saving. character ( * ), intent ( in ) :: output_cli !< Output files basename coming from CLI. character ( * ), intent ( in ) :: solver !< Selected solver: must be defined into *solvers*. real ( R_P ), intent ( in ) :: frequency !< Oscillation frequency. real ( R_P ), intent ( IN ) :: solution ( 0 :, 0 :) !< Solution at each time step. character ( len = :), allocatable :: title !< Output files title. character ( len = :), allocatable :: basename !< Output files basename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. real ( R_P ) :: ex_sol ( 1 : space_dimension ) !< Exact solution. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- title = 'Oscillation equations integration, solver=' // trim ( adjustl ( solver )) if ( trim ( adjustl ( output_cli )) /= 'unset' ) then basename = trim ( adjustl ( output_cli )) // '-' // trim ( strz ( 10 , ubound ( solution , dim = 2 ))) // '-time_steps-' // trim ( adjustl ( solver )) else basename = 'oscillation_test-' // trim ( strz ( 10 , ubound ( solution , dim = 2 ))) // '-time_steps-' // trim ( adjustl ( solver )) endif if ( results ) then open ( newunit = rawfile , file = basename // '.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) 'VARIABLES=\"t\" \"x\" \"y\" \"amplitude\" \"phase\"' write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE time serie\"' do s = 0 , ubound ( solution , dim = 2 ) write ( rawfile , '(5(' // FR_P // ',1X))' ) solution (:, s ), amplitude_phase ( solution ( 1 : 2 , s )) enddo write ( rawfile , '(A)' ) 'ZONE T=\"Exact solution\"' do s = 0 , ubound ( solution , dim = 2 ) ex_sol = exact_solution_xy ( frequency = frequency , t = solution ( 0 , s )) write ( rawfile , '(5(' // FR_P // ',1X))' ) solution ( 0 , s ), ex_sol , amplitude_phase ( ex_sol ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'v' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( basename // '.png' ) call plt % initialize ( grid = . true ., xlabel = 'v1' , ylabel = 'v2' , title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'path' , linestyle = 'r-' , linewidth = 1 ) call plt % savefig ( 'path-' // basename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- contains function amplitude_phase ( sol ) result ( ap ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute amplitude and phase of the solution provided in X-Y domain. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: sol ( 1 :) !< Solution in X-Y domain. real ( R_P ) :: ap ( 1 : 2 ) !< Amplitude and phase solution. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- ap ( 1 ) = sqrt ( sol ( 1 ) ** 2 + sol ( 2 ) ** 2 ) ap ( 2 ) = atan ( - sol ( 1 ) / sol ( 2 )) return !------------------------------------------------------------------------------------------------------------------------------- endfunction amplitude_phase endsubroutine save_results pure function exact_solution_xy ( frequency , t ) result ( ex_sol ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the exact solution on X-Y domain. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( in ) :: frequency !< Oscillation frequency. real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ) :: ex_sol ( 1 : 2 ) !< Exact solution. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ex_sol ( 1 ) = initial_state ( 1 ) * cos ( frequency * t ) - initial_state ( 2 ) * sin ( frequency * t ) ex_sol ( 2 ) = initial_state ( 1 ) * sin ( frequency * t ) + initial_state ( 2 ) * cos ( frequency * t ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction exact_solution_xy pure function error_L2 ( frequency , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the L2 norm of numerical error with respect the exact solution. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( in ) :: frequency !< Oscillation frequency. real ( R_P ), intent ( IN ) :: solution ( 0 :, 0 :) !< Solution at each time step. real ( R_P ) :: error_L2 ( 1 : space_dimension ) !< L2 norm of the numerical error. real ( R_P ) :: ex_sol ( 1 : space_dimension ) !< Exact solution. integer ( I_P ) :: s !< Steps/stages counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- error_L2 = 0._R_P do s = 0 , ubound ( solution , dim = 2 ) ex_sol = exact_solution_xy ( frequency = frequency , t = solution ( 0 , s )) do v = 1 , space_dimension error_L2 ( v ) = error_L2 ( v ) + ( solution ( v , s ) - ex_sol ( v )) * ( solution ( v , s ) - ex_sol ( v )) enddo enddo error_L2 = sqrt ( error_L2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction error_L2 pure function observed_order ( error , Dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate the order of accuracy using 2 subsequent refined numerical solutions. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: error ( 1 : space_dimension , 1 : 2 ) !< Computed errors. real ( R_P ), intent ( IN ) :: Dt ( 1 : 2 ) !< Time steps used. real ( R_P ) :: observed_order ( 1 : space_dimension ) !< Estimation of the order of accuracy. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do v = 1 , space_dimension observed_order ( v ) = log ( error ( v , 1 ) / error ( v , 2 )) / log ( Dt ( 1 ) / Dt ( 2 )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction observed_order endmodule oscillation_test_t program integrate_oscillation !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Oscillation equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use oscillation_test_t , only : oscillation_test !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( oscillation_test ) :: test !< Oscillation test. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call test % execute stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram integrate_oscillation","tags":"","loc":"sourcefile/oscillation.f90.html","title":"oscillation.f90 – FOODIE"},{"text":"Define Oscillation field that is a concrete extension of the abstract integrand type. Source Code !< Define Oscillation field that is a concrete extension of the abstract integrand type. module oscillation_t !----------------------------------------------------------------------------------------------------------------------------------- !< Define Oscillation field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: oscillation !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: oscillation !< Oscillation equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Oscillation ODEs system !<The (inertial) Oscillation equations system is a non linear system of pure ODEs and it can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< v_1 \\\\ !< v_2 !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< -f v_2 \\\\ !< f v_1 !< \\end{bmatrix} !<\\end{matrix} !< !<The frequency *f* is constant and it is here selected as *f=10&#94;-4*. !< !<In the space *v1-v2* the path of the oscillation must be a circle, but for the frequency selected some ODE solvers are not !<stable leading to a wrong path, see [1]. !< !<#### Bibliography !< !<[1] *Numerical Methods for Fluid Dynamics With Applications to Geophysics*, Dale R. Durran, Springer, 2010. !< !<#### State variables organization !< State variables are organized as an array (rank 1) of reals of *dims* elements, in this case 2 elements. private integer ( I_P ) :: dims = 0 !< Space dimensions. real ( R_P ) :: f = 0._R_P !< Oscillation frequency (Hz). real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, [1:dims]. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Oscillation field. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dOscillation_dt !< Time derivative, residuals. procedure , pass ( lhs ), public :: local_error => oscillation_local_error !<||Oscillation-oscillation||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => oscillation_multiply_oscillation !< Oscillation * oscillation. procedure , pass ( lhs ), public :: integrand_multiply_real => oscillation_multiply_real !< Oscillation * real. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_oscillation !< Real * Oscillation. procedure , pass ( lhs ), public :: add => add_oscillation !< Oscillation + Oscillation. procedure , pass ( lhs ), public :: sub => sub_oscillation !< Oscillation - Oscillation. procedure , pass ( lhs ), public :: assign_integrand => oscillation_assign_oscillation !< Oscillation = Oscillation. endtype oscillation !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods pure subroutine init ( self , initial_state , frequency ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: self !< Oscillation field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Initial state of the Oscillation field vector. real ( R_P ), intent ( IN ) :: frequency !< Frequency of oscillation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % f = frequency if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % dims )) ; self % U = initial_state return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Oscillation field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. real ( R_P ), dimension (:), allocatable :: state !< Oscillation state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output ! ADT integrand deferred methods #ifdef PURE pure function dOscillation_dt ( self , t ) result ( dState_dt ) #else function dOscillation_dt ( self , t ) result ( dState_dt ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Oscillation field time derivative. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: dState_dt ) select type ( dState_dt ) class is ( oscillation ) dState_dt = self dState_dt % U ( 1 ) = - self % f * self % U ( 2 ) dState_dt % U ( 2 ) = self % f * self % U ( 1 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dOscillation_dt #ifdef PURE pure function oscillation_local_error ( lhs , rhs ) result ( error ) #else function oscillation_local_error ( lhs , rhs ) result ( error ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 oscillation approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( oscillation ) error = 0._R_P do i = 1 , lhs % dims error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_local_error #ifdef PURE pure function oscillation_multiply_oscillation ( lhs , rhs ) result ( opr ) #else function oscillation_multiply_oscillation ( lhs , rhs ) result ( opr ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a oscillation field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_multiply_oscillation #ifdef PURE pure function oscillation_multiply_real ( lhs , rhs ) result ( opr ) #else function oscillation_multiply_real ( lhs , rhs ) result ( opr ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Oscillation field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_multiply_real #ifdef PURE pure function real_multiply_oscillation ( lhs , rhs ) result ( opr ) #else function real_multiply_oscillation ( lhs , rhs ) result ( opr ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( oscillation ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_oscillation #ifdef PURE pure function add_oscillation ( lhs , rhs ) result ( opr ) #else function add_oscillation ( lhs , rhs ) result ( opr ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Oscillation fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Oscillation #ifdef PURE pure function sub_oscillation ( lhs , rhs ) result ( opr ) #else function sub_oscillation ( lhs , rhs ) result ( opr ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Oscillation fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_Oscillation #ifdef PURE pure subroutine oscillation_assign_oscillation ( lhs , rhs ) #else subroutine oscillation_assign_oscillation ( lhs , rhs ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Oscillation field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( oscillation ) lhs % dims = rhs % dims lhs % f = rhs % f if ( allocated ( rhs % U )) lhs % U = rhs % U endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine oscillation_assign_oscillation endmodule oscillation_t","tags":"","loc":"sourcefile/oscillation_t.f90.html","title":"oscillation_t.f90 – FOODIE"},{"text":"Test without FOODIE with the integration of Euler 1D PDEs system by CAF paradigm. Source Code !< Test without FOODIE with the integration of Euler 1D PDEs system by CAF paradigm. program integrate_euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !< Test without FOODIE with the integration of Euler 1D PDEs system by CAF paradigm. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str , strz use type_euler_1D_caf_no_foodie , only : euler_1D_caf_nf , tvd_runge_kutta_integrator use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_caf_nf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer , parameter :: ord = 7 !< Space reconstruciton order, real ( R_P ) :: t !< Time. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( len = :), allocatable :: BC_L !< Left boundary condition type. character ( len = :), allocatable :: BC_R !< Right boundary condition type. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. type ( euler_1D_caf_nf ) :: domain !< Domain of Euler equations. ! coarrays-related variables integer ( I_P ) :: Ni_image !< Space dimension of local image. #ifdef CAF integer ( I_P ) :: Ni [ * ] !< Number of grid cells. integer ( I_P ) :: steps_max [ * ] !< Maximum number of time steps. logical :: results [ * ] !< Flag for activating results saving. logical :: plots [ * ] !< Flag for activating plots saving. logical :: time_serie [ * ] !< Flag for activating time serie-results saving. logical :: verbose [ * ] !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:)[:] !< Time step. #else integer ( I_P ) :: Ni !< Number of grid cells. integer ( I_P ) :: steps_max !< Maximum number of time steps. logical :: results !< Flag for activating results saving. logical :: plots !< Flag for activating plots saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:) !< Time step. #endif integer ( I_P ) :: me !< ID of this_image() integer ( I_P ) :: we !< Number of CAF images used. character ( len = :), allocatable :: id !< My ID. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF me = this_image () we = num_images () #else me = 1 we = 1 #endif id = trim ( strz ( 3 , me )) // '> ' ! setting Command Line Interface call cli % init ( progname = 'euler-1D-caf-no-foodie' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test 1D Euler equations integration without FOODIE, CAF enabled' , & examples = [ \"euler-1D-caf-no-foodie --results  \" , & \"euler-1D-caf-no-foodie -r -t -v -p\" , & \"euler-1D-caf-no-foodie            \" , & \"euler-1D-caf-no-foodie --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) ! parsing Command Line Interface if ( me == 1 ) then ! only master image do CLI stuffs call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop endif call init () system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) Dt ( me ) = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call synchronize call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , Dt = Dt ( me ), t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + Dt ( me ) call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-image-' // trim ( strz ( 3 , me ))) print \"(A,I5,A,F23.15)\" , id , we , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_caf","tags":"","loc":"sourcefile/euler-1d-caf_no_foodie.f90.html","title":"euler-1D-caf_no_foodie.f90 – FOODIE"},{"text":"Define Euler 1D (CAF enabled) field without extending FOODIE integrand. Source Code !< Define Euler 1D (CAF enabled) field without extending FOODIE integrand. module type_euler_1D_caf_no_foodie !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D (CAF enabled) field without extending FOODIE integrand. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D_caf_nf public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: euler_1D_caf_nf !< Euler 1D (CAF enabled) PDEs system field. !< !< @note This object does not use FOODIE. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. integer ( I_P ) :: me = 0 !< ID of this_image(). integer ( I_P ) :: we = 0 !< Number of CAF images used. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. ! private methods procedure , pass ( self ), private :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), private :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: synchronize !< Synchronize CAF images. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_caf_nf type :: tvd_runge_kutta_integrator !< TVD RK integrator. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy => destroy_rk !< Destroy the integrator. procedure , pass ( self ), public :: init => init_rk !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate => integrate_rk !< Integrate integrand field. final :: finalize_rk !< Finalize object. endtype tvd_runge_kutta_integrator #ifdef CAF real ( R_P ), allocatable :: remote_U (:,:)[:] !< CAF buffer for sharing remote conservative variables. #else real ( R_P ), allocatable :: remote_U (:,:) !< CAF buffer for sharing remote conservative variables. #endif real ( R_P ), allocatable :: U_L (:,:) !< Integrand (state) variables, left ghost cells [1:Nc,1:Ng]. real ( R_P ), allocatable :: U_R (:,:) !< Integrand (state) variables, right ghost cells [1:Nc,Ni-Ng+1:Ni]. !----------------------------------------------------------------------------------------------------------------------------------- contains ! type bound procedures of tvd_runge_kutta_integrator ! public methods elemental subroutine init_rk ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init_rk elemental subroutine destroy_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy_rk subroutine integrate_rk ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( euler_1D_caf_nf ), intent ( INOUT ) :: U !< Field to be integrated. class ( euler_1D_caf_nf ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s )% U = stage ( s )% U + stage ( ss )% U * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t () enddo ! computing new time step do s = 1 , self % stages U % U = U % U + stage ( s )% U * ( Dt * self % beta ( s )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate_rk ! private methods elemental subroutine finalize_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_rk ! type bound procedures of euler_1D_caf_nf ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , me , we , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension (local image). integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), intent ( IN ) :: me !< ID of this_image(). integer ( I_P ), intent ( IN ) :: we !< Number of CAF images used. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo self % me = me self % we = we #ifdef CAF if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )[ * ]) #else if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )) #endif if ( allocated ( U_L )) deallocate ( U_L ) ; allocate ( U_L ( 1 : self % Nc , 1 : self % Ni )) if ( allocated ( U_R )) deallocate ( U_R ) ; allocate ( U_R ( 1 : self % Nc , 1 : self % Ni )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) self % me = 0 self % we = 0 if ( allocated ( remote_U )) deallocate ( remote_U ) if ( allocated ( U_L )) deallocate ( U_L ) if ( allocated ( U_R )) deallocate ( U_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self , conservative ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. logical , optional , intent ( IN ) :: conservative !< Output conservative variables instead of primitive. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( conservative )) then state = self % U else allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! ADT integrand deferred methods function dEuler_dt ( self ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. type ( euler_1D_caf_nf ) :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals dState_dt = self do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: lhs !< Left hand side. class ( euler_1D_caf_nf ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf_nf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R lhs % me = rhs % me lhs % we = rhs % we endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive subroutine synchronize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( self % we > 1 ) then remote_U = self % U if ( self % me == 1 ) then sync images ( self % me + 1 ) U_R (:,:) = remote_U (:,:)[ self % me + 1 ] else if ( self % me == self % we ) then sync images ( self % me - 1 ) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] else sync images ([ self % me - 1 , self % me + 1 ]) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] U_R (:,:) = remote_U (:,:)[ self % me + 1 ] endif endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. character ( len = :), allocatable :: bc_type !< String containing BC type. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- call self % synchronize bc_type = trim ( adjustl ( self % BC_L )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = 1 - self % Ng , 0 primitive (:, i ) = self % conservative2primitive ( U_L (:, self % Ni + i )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect endif bc_type = trim ( adjustl ( self % BC_R )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = self % conservative2primitive ( U_R (:, i - self % Ni )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect endif return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D_caf_no_foodie","tags":"","loc":"sourcefile/type_euler-1d-caf_no_foodie.f90.html","title":"type_euler-1D-caf_no_foodie.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Euler 1D PDEs system. Source Code !< Test FOODIE with the integration of Euler 1D PDEs system. program integrate_euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str , strz use type_euler_1D_caf , only : euler_1D_caf use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_caf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer , parameter :: ord = 7 !< Space reconstruciton order, real ( R_P ) :: t !< Time. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( len = :), allocatable :: BC_L !< Left boundary condition type. character ( len = :), allocatable :: BC_R !< Right boundary condition type. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. type ( euler_1D_caf ) :: domain !< Domain of Euler equations. ! coarrays-related variables integer ( I_P ) :: Ni_image !< Space dimension of local image. #ifdef CAF integer ( I_P ) :: Ni [ * ] !< Number of grid cells. integer ( I_P ) :: steps_max [ * ] !< Maximum number of time steps. logical :: results [ * ] !< Flag for activating results saving. logical :: plots [ * ] !< Flag for activating plots saving. logical :: time_serie [ * ] !< Flag for activating time serie-results saving. logical :: verbose [ * ] !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:)[:] !< Time step. #else integer ( I_P ) :: Ni !< Number of grid cells. integer ( I_P ) :: steps_max !< Maximum number of time steps. logical :: results !< Flag for activating results saving. logical :: plots !< Flag for activating plots saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:) !< Time step. #endif integer ( I_P ) :: me !< ID of this_image() integer ( I_P ) :: we !< Number of CAF images used. character ( len = :), allocatable :: id !< My ID. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF me = this_image () we = num_images () #else me = 1 we = 1 #endif id = trim ( strz ( 3 , me )) // '> ' ! setting Command Line Interface call cli % init ( progname = 'euler-1D-caf' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration, CAF enabled' , & examples = [ \"euler-1D-caf --results  \" , & \"euler-1D-caf -r -t -v -p\" , & \"euler-1D-caf            \" , & \"euler-1D-caf --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) ! parsing Command Line Interface if ( me == 1 ) then ! only master image do CLI stuffs call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop endif call init () system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) Dt ( me ) = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call synchronize call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , Dt = Dt ( me ), t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + Dt ( me ) call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-image-' // trim ( strz ( 3 , me ))) print \"(A,I5,A,F23.15)\" , id , we , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_caf","tags":"","loc":"sourcefile/euler-1d-caf.f90.html","title":"euler-1D-caf.f90 – FOODIE"},{"text":"Define Euler 1D (CAF enabled) field that is a concrete extension of the abstract integrand type. Source Code !< Define Euler 1D (CAF enabled) field that is a concrete extension of the abstract integrand type. module type_euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D (CAF enabled) field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: euler_1D_caf !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. integer ( I_P ) :: me = 0 !< ID of this_image(). integer ( I_P ) :: we = 0 !< Number of CAF images used. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !<||euler-euler||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: synchronize !< Synchronize CAF images. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_caf #ifdef CAF real ( R_P ), allocatable :: remote_U (:,:)[:] !< CAF buffer for sharing remote conservative variables. #else real ( R_P ), allocatable :: remote_U (:,:) !< CAF buffer for sharing remote conservative variables. #endif real ( R_P ), allocatable :: U_L (:,:) !< Integrand (state) variables, left ghost cells [1:Nc,1:Ng]. real ( R_P ), allocatable :: U_R (:,:) !< Integrand (state) variables, right ghost cells [1:Nc,Ni-Ng+1:Ni]. !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , me , we , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension (local image). integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), intent ( IN ) :: me !< ID of this_image(). integer ( I_P ), intent ( IN ) :: we !< Number of CAF images used. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo self % me = me self % we = we #ifdef CAF if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )[ * ]) #else if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )) #endif if ( allocated ( U_L )) deallocate ( U_L ) ; allocate ( U_L ( 1 : self % Nc , 1 : self % Ni )) if ( allocated ( U_R )) deallocate ( U_R ) ; allocate ( U_R ( 1 : self % Nc , 1 : self % Ni )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) self % me = 0 self % we = 0 if ( allocated ( remote_U )) deallocate ( remote_U ) if ( allocated ( U_L )) deallocate ( U_L ) if ( allocated ( U_R )) deallocate ( U_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self , conservative ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. logical , optional , intent ( IN ) :: conservative !< Output conservative variables instead of primitive. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( conservative )) then state = self % U else allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! ADT integrand deferred methods function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D_caf :: dState_dt ) select type ( dState_dt ) class is ( euler_1D_caf ) dState_dt = self endselect select type ( dState_dt ) class is ( euler_1D_caf ) do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf ) error = 0._R_P do i = 1 , lhs % Ni do v = 1 , lhs % Nc error = error + ( lhs % U ( v , i ) - rhs % U ( v , i )) ** 2 / lhs % U ( v , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D_caf ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = rhs endselect select type ( opr ) class is ( euler_1D_caf ) opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R lhs % me = rhs % me lhs % we = rhs % we endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real ! private methods pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive subroutine synchronize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( self % we > 1 ) then remote_U = self % U if ( self % me == 1 ) then sync images ( self % me + 1 ) U_R (:,:) = remote_U (:,:)[ self % me + 1 ] else if ( self % me == self % we ) then sync images ( self % me - 1 ) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] else sync images ([ self % me - 1 , self % me + 1 ]) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] U_R (:,:) = remote_U (:,:)[ self % me + 1 ] endif endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. character ( len = :), allocatable :: bc_type !< String containing BC type. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- call self % synchronize bc_type = trim ( adjustl ( self % BC_L )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = 1 - self % Ng , 0 primitive (:, i ) = self % conservative2primitive ( U_L (:, self % Ni + i )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect endif bc_type = trim ( adjustl ( self % BC_R )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = self % conservative2primitive ( U_R (:, i - self % Ni )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect endif return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D_caf","tags":"","loc":"sourcefile/type_euler-1d-caf.f90.html","title":"type_euler-1D-caf.f90 – FOODIE"},{"text":"Test without FOODIE with the integration of Euler 1D PDEs system by OpenMP paradigm. Source Code !< Test without FOODIE with the integration of Euler 1D PDEs system by OpenMP paradigm. program integrate_euler_1D_openmp_no_foodie !----------------------------------------------------------------------------------------------------------------------------------- !< Test without FOODIE with the integration of Euler 1D PDEs system by OpenMP paradigm. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D_openmp_no_foodie , only : euler_1D_omp_nf , tvd_runge_kutta_integrator use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use pyplot_module , only : pyplot #ifdef OPENMP use OMP_LIB #endif !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_omp_nf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. type ( euler_1D_omp_nf ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: steps_max !< Maximum number of time steps. integer ( I_P ) :: omp_threads !< Number of OpenMP threads. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D-openmp-no-foodie' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test 1D Euler equations integration without FOODIE, OpenMP enabled' , & examples = [ \"euler-1D-openmp-no-foodie --results  \" , & \"euler-1D-openmp-no-foodie -r -t -v -p\" , & \"euler-1D-openmp-no-foodie            \" , & \"euler-1D-openmp-no-foodie --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) call cli % add ( switch = '--omp_threads' , help = 'Number of OpenMP threads used' , required = . false ., act = 'store' , def = '1' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--omp_threads' , val = omp_threads , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop #ifdef OPENMP call omp_set_dynamic (. false .) call omp_set_num_threads ( omp_threads ) ! check OpenMP parallel environment correctness !$OMP PARALLEL      & !$OMP DEFAULT(none) & !$OMP SHARED(omp_threads) omp_threads = omp_get_num_threads () !$OMP END PARALLEL #endif call init () call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) t = 0._R_P call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_omp_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-time_serie.dat' , & t = t ) system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + dt call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_omp_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages ))) print \"(I5,A,F23.15)\" , omp_threads , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_openmp_no_foodie","tags":"","loc":"sourcefile/euler-1d-openmp_no_foodie.f90.html","title":"euler-1D-openmp_no_foodie.f90 – FOODIE"},{"text":"Define Euler 1D (OpenMP enabled) field without extending FOODIE integrand. Source Code !< Define Euler 1D (OpenMP enabled) field without extending FOODIE integrand. module type_euler_1D_openmp_no_foodie !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D (OpenMP enabled) field without extending FOODIE integrand. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D_omp_nf public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: euler_1D_omp_nf !< Euler 1D (OpenMP enabled) PDEs system field. !< !< @note This object does not use FOODIE. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. ! private methods procedure , pass ( self ), private :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), private :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_omp_nf type :: tvd_runge_kutta_integrator !< TVD RK integrator. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy => destroy_rk !< Destroy the integrator. procedure , pass ( self ), public :: init => init_rk !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate => integrate_rk !< Integrate integrand field. final :: finalize_rk !< Finalize object. endtype tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! type bound procedures of tvd_runge_kutta_integrator ! public methods elemental subroutine init_rk ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init_rk elemental subroutine destroy_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy_rk subroutine integrate_rk ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( euler_1D_omp_nf ), intent ( INOUT ) :: U !< Field to be integrated. class ( euler_1D_omp_nf ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s )% U = stage ( s )% U + stage ( ss )% U * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t () enddo ! computing new time step do s = 1 , self % stages U % U = U % U + stage ( s )% U * ( Dt * self % beta ( s )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate_rk ! private methods elemental subroutine finalize_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_rk ! type bound procedures of euler_1D_omp_nf ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! private methods function dEuler_dt ( self ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. type ( euler_1D_omp_nf ) :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F, PR) do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals dState_dt = self !$OMP PARALLEL PRIVATE(i) SHARED(self, dState_dt, F) !$OMP DO do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: lhs !< Left hand side. class ( euler_1D_omp_nf ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_omp_nf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Nc , 1 : lhs % Ni )) endif if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) if ( allocated ( rhs % U )) then !$OMP DO do i = 1 , lhs % Ni lhs % U (:, i ) = rhs % U (:, i ) enddo endif !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- !$OMP PARALLEL PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) SHARED(self, primitive, r_primitive) select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction !$OMP DO do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction !$OMP DO do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect !$OMP END PARALLEL return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D_openmp_no_foodie","tags":"","loc":"sourcefile/type_euler-1d-openmp_no_foodie.f90.html","title":"type_euler-1D-openmp_no_foodie.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Euler 1D PDEs system. Source Code !< Test FOODIE with the integration of Euler 1D PDEs system. program integrate_euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D_openmp , only : euler_1D_openmp use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot #ifdef OPENMP use OMP_LIB #endif !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_openmp ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. type ( euler_1D_openmp ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: steps_max !< Maximum number of time steps. integer ( I_P ) :: omp_threads !< Number of OpenMP threads. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D-openmp' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration, OpenMP enabled' , & examples = [ \"euler-1D-openmp --results  \" , & \"euler-1D-openmp -r -t -v -p\" , & \"euler-1D-openmp            \" , & \"euler-1D-openmp --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) call cli % add ( switch = '--omp_threads' , help = 'Number of OpenMP threads used' , required = . false ., act = 'store' , def = '1' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--omp_threads' , val = omp_threads , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop #ifdef OPENMP call omp_set_dynamic (. false .) call omp_set_num_threads ( omp_threads ) ! check OpenMP parallel environment correctness !$OMP PARALLEL      & !$OMP DEFAULT(none) & !$OMP SHARED(omp_threads, verbose) omp_threads = omp_get_num_threads () if ( verbose ) print \"(A)\" , ' Thread ' // trim ( str (. true ., omp_get_thread_num ())) // ' of: ' // trim ( str (. true ., omp_threads )) // ' is alive!' !$OMP END PARALLEL #endif call init () call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) t = 0._R_P call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_openmp_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-time_serie.dat' , & t = t ) system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + dt call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_openmp_integration-tvdrk-' // trim ( str (. true ., rk_stages ))) print \"(I5,A,F23.15)\" , omp_threads , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_openmp","tags":"","loc":"sourcefile/euler-1d-openmp.f90.html","title":"euler-1D-openmp.f90 – FOODIE"},{"text":"Define Euler 1D (OpenMP enabled) field that is a concrete extension of the abstract integrand type. Source Code !< Define Euler 1D (OpenMP enabled) field that is a concrete extension of the abstract integrand type. module type_euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D (OpenMP enabled) field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: euler_1D_openmp !< Euler 1D (OpenMP enabled) PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !<||euler-euler||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! ADT integrand deferred methods function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F, PR) do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D_openmp :: dState_dt ) select type ( dState_dt ) class is ( euler_1D_openmp ) dState_dt = self endselect !$OMP PARALLEL PRIVATE(i) SHARED(self, dState_dt, F) select type ( dState_dt ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_openmp ) error = 0._R_P do i = 1 , lhs % Ni do v = 1 , lhs % Nc error = error + ( lhs % U ( v , i ) - rhs % U ( v , i )) ** 2 / lhs % U ( v , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) * rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) * rhs enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D_openmp ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = rhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , rhs % Ni opr % U (:, i ) = rhs % U (:, i ) * lhs enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) + rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) - rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_openmp ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Nc , 1 : lhs % Ni )) endif if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) select type ( rhs ) class is ( euler_1D_openmp ) if ( allocated ( rhs % U )) then !$OMP DO do i = 1 , lhs % Ni lhs % U (:, i ) = rhs % U (:, i ) enddo endif endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) then !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) do i = 1 , lhs % Ni lhs % U (:, i ) = rhs enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real ! private methods pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- !$OMP PARALLEL PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) SHARED(self, primitive, r_primitive) select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction !$OMP DO do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction !$OMP DO do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect !$OMP END PARALLEL return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D_openmp","tags":"","loc":"sourcefile/type_euler-1d-openmp.f90.html","title":"type_euler-1D-openmp.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Burgers equation. Source Code !< Test FOODIE with the integration of Burgers equation. program integrate_burgers !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Burgers equation. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_burgers , only : burgers use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( burgers ) :: domain !< Burgers field domain. real ( R_P ), parameter :: CFL = 0.1_R_P !< CFL value. real ( R_P ), parameter :: t_final = 0.6_R_P !< Final time. real ( R_P ), parameter :: nu = 1._R_P !< Viscosity. integer ( I_P ), parameter :: Ni = 100 !< Number of grid nodes. real ( R_P ) :: h !< Space step discretization. real ( R_P ) :: initial_state ( 1 : Ni ) !< Initial state. real ( R_P ) :: x ( 1 : Ni ) !< Nodes values. real ( R_P ), allocatable :: final_state (:) !< Final state. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'burgers' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Burgers equation integration' , & examples = [ \"burgers --solver euler --results  \" , & \"burgers --solver ls-runge-kutta -r\" , & \"burgers --solver adams-bashforth  \" , & \"burgers --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! create Burgers field initial state call init () ! integrate Burgers equation select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- h = 2._R_P * pi / Ni do i = 1 , Ni x ( i ) = h * ( i - 1 ) initial_state ( i ) = 1 0._R_P * sin ( x ( i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"U\"' do i = 1 , Ni write ( rawfile , '(2(' // FR_P // ',1X))' ) x ( i ), final_state ( i ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) call plt % add_plot ( x = x , y = final_state , label = 'U' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( burgers ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = s ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t ( s ) < t_final ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), Dt = Dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit ' // & 'Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'burgers_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of explicit Euler solver' call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit Euler' , & filename = 'burgers_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( burgers ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( burgers ) :: previous ( 1 : 2 ) !< Previous time steps solutions. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = 2 ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t < t_final ) if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit leapfrog scheme' ,& filename = 'burgers_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit low storage Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit TVD Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_burgers","tags":"","loc":"sourcefile/burgers.f90.html","title":"burgers.f90 – FOODIE"},{"text":"Define Burgers field that is a concrete extension of the abstract integrand type. Source Code !< Define Burgers field that is a concrete extension of the abstract integrand type. module type_burgers !----------------------------------------------------------------------------------------------------------------------------------- !< Define Burgers field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: burgers !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: burgers !< Burgers equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Burgers PDE equation !<The Burgers PDE equation is a non linear PDE widely used as numerical benchmark that can be applied to describe !<a wide range of different problems, from fluid dynamics to traffic flows, see [1]. !< !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = [u]\\;\\;\\; !<F(U) = [-\\frac{1}{2}u&#94;2+\\nu u_x] !<\\end{matrix} !< !< !<This is the viscous Burgers' equation, \\nu being the viscosity. This equation is of paramount relevance because it retains !<complex aspects such as the hyperbolic nature of the convection term (allowing discontinuous solutions) and the diffusive nature !<of the viscous term. !< !<#### Bibliography !< !<[1] *The partial differential equation ut + uux = nuxx*, Hopf, Eberhard, Communications on Pure and Applied Mathematics, !< vol 3, issue 3, doi 10.1002/cpa.3160030302, pp. 201--230, 1950. !< !<#### State variables organization !< State variable is organized as an array (rank 1) for whole physical domain. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: Ni = 0 !< Number of grid nodes. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ) :: h = 0._R_P !< Space step discretization. real ( R_P ) :: nu = 0._R_P !< Viscosity. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, whole physical domain, [1:Ni]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:Ni,1:steps]. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Burgers field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dBurgers_dt !< Time derivative, residuals func. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: local_error => burgers_local_error !< Local error. procedure , pass ( lhs ), public :: integrand_multiply_integrand => burgers_multiply_burgers !< Burgers * burgers operator. procedure , pass ( lhs ), public :: integrand_multiply_real => burgers_multiply_real !< Burgers * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_burgers !< Real * Burgers operator. procedure , pass ( lhs ), public :: add => add_burgers !< Burgers + Burgers operator. procedure , pass ( lhs ), public :: sub => sub_burgers !< Burgers - Burgers operator. procedure , pass ( lhs ), public :: assign_integrand => burgers_assign_burgers !< Burgers = Burgers. procedure , pass ( lhs ), public :: assign_real => burgers_assign_real !< Burgers = real. ! private methods procedure , pass ( self ), private :: x => dBurgers_dx !< 1st derivative. procedure , pass ( self ), private :: xx => d2Burgers_dx2 !< 2nd derivative. endtype burgers !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , initial_state , Ni , h , nu , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: Ni !< Number of grid nodes. real ( R_P ), dimension ( 1 : Ni ), intent ( IN ) :: initial_state !< Initial state of Burgers field domain. real ( R_P ), intent ( IN ) :: h !< Space step discretization. real ( R_P ), intent ( IN ) :: nu !< Viscosity. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : Ni , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % Ni = Ni self % h = h self % nu = nu return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Burgers field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), dimension (:), allocatable :: state !< Burgers state variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , CFL ) result ( dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step, by means of CFL condition. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), intent ( IN ) :: CFL !< Courant-Friedricks-Lewi stability coefficient. real ( R_P ) :: dt !< Current time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dt = CFL * self % h ** 2 / self % nu return !--------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! ADT integrand deferred methods function dBurgers_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Burgers field, residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Burgers field time derivative. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: dState_dt ) select type ( dState_dt ) class is ( burgers ) dState_dt = self dState_dt = self % xx () * self % nu dState_dt = dState_dt - self * self % x () endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dBurgers_dt subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( burgers ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: previous ) select type ( previous ) class is ( burgers ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step function burgers_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 burgers approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( burgers ) error = 0._R_P do i = 1 , lhs % dims error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_local_error function burgers_multiply_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_burgers function burgers_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_real function real_multiply_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( burgers ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_burgers function add_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_burgers function sub_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_burgers subroutine burgers_assign_burgers ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Burgers field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( burgers ) lhs % Ni = rhs % Ni lhs % steps = rhs % steps lhs % h = rhs % h lhs % nu = rhs % nu if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_burgers subroutine burgers_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_real ! private methods function dBurgers_dx ( self ) result ( derivative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the first order spatial derivative of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. type ( burgers ) :: derivative !< Burgers field derivative. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- derivative = self do i = 2 , self % Ni - 1 derivative % U ( i ) = ( self % U ( i + 1 ) - self % U ( i - 1 )) / ( 2._R_P * self % h ) enddo derivative % U ( 1 ) = ( self % U ( 2 ) - self % U ( self % Ni )) / ( 2._R_P * self % h ) derivative % U ( self % Ni ) = ( self % U ( 1 ) - self % U ( self % Ni - 1 )) / ( 2._R_P * self % h ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction function d2Burgers_dx2 ( self ) result ( derivative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the second order spatial derivative of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. type ( burgers ) :: derivative !< Burgers field derivative. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- derivative = self do i = 2 , self % Ni - 1 derivative % U ( i ) = ( self % U ( i + 1 ) - 2._R_P * self % U ( i ) + self % U ( i - 1 )) / ( self % h ** 2 ) enddo derivative % U ( 1 ) = ( self % U ( 2 ) - 2._R_P * self % U ( 1 ) + self % U ( self % Ni )) / ( self % h ** 2 ) derivative % U ( self % Ni ) = ( self % U ( 1 ) - 2._R_P * self % U ( self % Ni ) + self % U ( self % Ni - 1 )) / ( self % h ** 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction endmodule type_burgers","tags":"","loc":"sourcefile/type_burgers.f90.html","title":"type_burgers.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Euler 1D PDEs system. Source Code !< Test FOODIE with the integration of Euler 1D PDEs system. program integrate_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D , only : euler_1D use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( euler_1D ) :: domain !< Domain of Euler equations. integer ( I_P ) :: Ns !< Number of differnt initial gas species. integer ( I_P ) :: Nc !< Number of conservative variables, Nc=Ns+2. integer ( I_P ) :: Np !< Number of primitive variables, Np=Ns+4. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: CFL !< CFL value. real ( R_P ) :: t_final !< Final time. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. real ( R_P ), allocatable :: cp0 (:) !< Specific heat at constant pressure [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat at constant volume [1:Ns]. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables [1:Np,1:Ni]. real ( R_P ), allocatable :: xcenter (:) !< Cell center x-abscissa values, [1:Ni]. real ( R_P ), allocatable :: xnode (:) !< Cell node x-abscissa values, [0:Ni]. real ( R_P ), allocatable :: av_xnode (:) !< Average-grid cell node x-abscissa values, [0:Ni]. real ( R_P ), allocatable :: final_state (:,:) !< Final state. real ( R_P ), allocatable :: av_state (:,:) !< Average-grid final state. character ( len = :), allocatable :: variables !< Variables names list. character ( len = :), allocatable :: output !< Output files basename. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: stages_steps !< Number of stages/steps used. character ( 99 ) :: solver !< Solver used. character ( 99 ) :: problem !< Problem solved. character ( 99 ) :: output_cli !< Output files basename. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: av_Ni !< Average the solution over an average-grid. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration' , & examples = [ \"euler-1D --solver euler --results  \" , & \"euler-1D --solver ls-runge-kutta -r\" , & \"euler-1D --solver adams-bashforth  \" , & \"euler-1D --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver' , required = . true ., act = 'store' ) call cli % add ( switch = '--problem' , help = 'Problem solved' , required = . false ., def = 'sod' , act = 'store' , choices = 'sod,smooth' ) call cli % add ( switch = '--Ni' , help = 'Number finite volumes' , required = . false ., act = 'store' , def = '100' ) call cli % add ( switch = '--av_Ni' , help = 'Number finite volumes over average the solution' , required = . false ., act = 'store' , def = '-1' ) call cli % add ( switch = '--ss' , help = 'Stages/steps used' , required = . false ., act = 'store' , def = '-1' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--output' , help = 'Output files basename' , required = . false ., act = 'store' , def = 'unset' ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--solver' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--problem' , val = problem , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--av_Ni' , val = av_Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--ss' , val = stages_steps , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--results' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--plots' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--tserie' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--output' , val = output_cli , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop ! create Euler field initial state call init () ! integrate Euler equation select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Species counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( xcenter ( 1 : Ni )) allocate ( xnode ( 0 : Ni )) Dx = 1._R_P / Ni do i = 1 , Ni xcenter ( i ) = Dx * i - 0.5_R_P * Dx enddo do i = 0 , Ni xnode ( i ) = Dx * i enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then allocate ( av_xnode ( 0 : av_Ni )) do i = 0 , av_Ni av_xnode ( i ) = 1._R_P / av_Ni * i enddo endif select case ( trim ( adjustl ( problem ))) case ( 'sod' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.2_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str (. true ., s )) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case ( 'smooth' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.1_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str (. true ., s )) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni initial_state (:, i ) = [ 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! rho(s) 0.5_R_P * ( xcenter ( i ) - 0.5_R_P ) ** 4 , & ! u 1 0._R_P + 2._R_P * xcenter ( i ) ** 4 , & ! p 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case default print \"(A)\" , 'Error: unknown problem \"' // trim ( adjustl ( problem )) // '\"' print \"(A)\" , 'Valid problem names are:' print \"(A)\" , '  + sod' print \"(A)\" , '  + smooth' stop endselect if ( trim ( adjustl ( output_cli )) /= 'unset' ) then output = trim ( adjustl ( output_cli )) // '-' // trim ( adjustl ( solver )) else output = 'euler_1D_integration-' // trim ( adjustl ( solver )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine average_solution () !--------------------------------------------------------------------------------------------------------------------------------- !< Average the solution over an average grid. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i , ii , i1 , i2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then if ( allocated ( av_state )) deallocate ( av_state ) ; allocate ( av_state ( 1 : Np , 1 : av_Ni )) do i = 1 , av_Ni i1 = minloc ( array = xcenter , dim = 1 , mask = ( xcenter >= av_xnode ( i - 1 ))) i2 = maxloc ( array = xcenter , dim = 1 , mask = ( xcenter <= av_xnode ( i ))) av_state (:, i ) = 0._R_P do ii = i1 , i2 av_state (:, i ) = av_state (:, i ) + final_state (:, ii ) enddo av_state (:, i ) = av_state (:, i ) / ( i2 - i1 + 1 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine average_solution subroutine save_results ( title , basename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: basename !< Output basename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = basename // '-' // trim ( str (. true ., Ni )) // '_cells.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) variables write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str (. true ., Ni )) // ' cells\", I=' // trim ( str (. true ., Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 1 )) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str (. true ., Ni + 1 )) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( rawfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then print \"(A)\" , ' Average solution from Ni: ' // trim ( str (. true ., Ni )) // ' to av_Ni: ' // trim ( str (. true ., av_Ni )) call average_solution write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str (. true ., Ni )) // ' cells averaged over ' // trim ( str (. true ., av_Ni )) // & ' cells\", I=' // trim ( str (. true ., av_Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 1 )) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str (. true ., av_Ni + 1 )) // '(' // FR_P // ',1X))' ) av_xnode do v = 1 , Np write ( rawfile , '(' // trim ( str (. true ., av_Ni )) // '(' // FR_P // ',1X))' ) av_state ( v , :) enddo endif close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = xcenter , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = xcenter , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( basename // '-' // trim ( str (. true ., Ni )) // '_cells.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) 'TITLE=\"' // title // '\"' endif write ( tsfile , '(A)' ) variables // ' \"t\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\", I=' // trim ( str (. true ., Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 2 )) // ']=CELLCENTERED)' write ( tsfile , '(' // trim ( str (. true ., Ni + 1 )) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( tsfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo write ( tsfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' )( t , v = 1 , Ni ) if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( euler_1D ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of Adams-Bashforth class of solvers' steps_range = [ 1 , ab_steps ] ; if ( stages_steps > 0 ) steps_range = [ stages_steps , stages_steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' AB-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' steps' call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 1 ) call rk_integrator % init ( stages = s ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 3 ) call rk_integrator % init ( stages = s ) case ( 4 , 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 7 ) call rk_integrator % init ( stages = 5 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , t = t ( s )) step = 1 do while ( t ( s ) < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t ( s ), CFL = 0.1_R_P * CFL ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), dt = dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 call save_time_serie ( t = t ( s )) enddo call save_time_serie ( t = t ( s ), finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of explicit Euler solver' title = '1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '  Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( euler_1D ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( euler_1D ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of leapfrog (RAW filtered) class of solvers' title = '1D Euler equations integration, explicit leapfrog (RAW filtered), t=' // str ( n = t_final ) call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = 2 , ord = 3 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) step = 1 do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = 0.1_R_P * CFL ) if ( 2 >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of low storage (2N) Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of TVD/SSP Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit TVD/SSP Runge-Kutta, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_euler_1D","tags":"","loc":"sourcefile/euler-1d.f90.html","title":"euler-1D.f90 – FOODIE"},{"text":"Define Euler 1D field that is a concrete extension of the abstract integrand type. Source Code !< Define Euler 1D field that is a concrete extension of the abstract integrand type. module type_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: euler_1D !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: steps = 0 !< Number of time steps stored. integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real ( R_P ), allocatable :: previous (:,:,:) !< Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !< Local error. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , steps , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 ; if ( present ( steps )) self % steps = steps self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % Nc , 1 : Ni , 1 : self % steps )) endif self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo if ( self % steps > 0 ) then do s = 1 , self % steps do i = 1 , Ni self % previous (:, i , s ) = self % primitive2conservative ( initial_state (:, i )) enddo enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % previous )) deallocate ( self % previous ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! ADT integrand deferred methods function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Nc => self % Nc , Np => self % Np , Ns => self % Ns , U => self % U , previous => self % previous ) ! allocate temporary arrays allocate ( F ( 1 : Nc , 0 : Ni )) ; F = 0._R_P allocate ( P ( 1 : Np , 1 - Ng : Ni + Ng )) ; P = 0._R_P allocate ( PR ( 1 : Np , 1 : 2 , 0 : Ni + 1 )) ; PR = 0._R_P ! compute primitive variables do i = 1 , Ni P (:, i ) = self % conservative2primitive ( U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , Ni call self % riemann_solver ( r1 = PR ( Ns + 3 , 2 , i ), u1 = PR ( Ns + 1 , 2 , i ), p1 = PR ( Ns + 2 , 2 , i ), g1 = PR ( Ns + 4 , 2 , i ), & r4 = PR ( Ns + 3 , 1 , i + 1 ), u4 = PR ( Ns + 1 , 1 , i + 1 ), p4 = PR ( Ns + 2 , 1 , i + 1 ), g4 = PR ( Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : Ns , 2 , i ) / PR ( Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : Ns , 1 , i + 1 ) / PR ( Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D :: dState_dt ) select type ( dState_dt ) class is ( euler_1D ) dState_dt = self do i = 1 , Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, :, s ) = self % previous (:, :, s + 1 ) enddo self % previous (:, :, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( euler_1D ) do s = 1 , self % steps self % previous (:, :, s ) = self % previous (:, :, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: previous ) select type ( previous ) class is ( euler_1D ) previous = self previous % U = self % previous (:, :, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: j !< Species counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) error = 0._R_P do i = 1 , lhs % Ni do j = 1 , lhs % Nc error = error + ( lhs % U ( j , i ) - rhs % U ( j , i )) ** 2 / lhs % U ( j , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) lhs % steps = rhs % steps lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real ! private methods pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions pure subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Ns => self % Ns , Np => self % Np , ord => self % ord , cv0 => self % cv0 , cp0 => self % cp0 , weno => self % weno ) select case ( ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = Ns , Np = Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = Ns , Np = Np , primitive = Pm (:, f )) enddo do j = i + 1 - Ng , i - 1 + Ng do f = 1 , 2 do v = 1 , Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : Ns + 2 , f ), primitive ( 1 : Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , Ns + 2 call weno % interpolate ( S = Ng , & stencil = C ( 1 : 2 , 1 - Ng : - 1 + Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : Ns + 2 , f ), CR ( 1 : Ns + 2 , f )) enddo r_primitive ( Ns + 3 , f , i ) = sum ( r_primitive ( 1 : Ns , f , i )) r_primitive ( Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cp0 ) / & dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cv0 ) enddo enddo endselect endassociate return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D","tags":"","loc":"sourcefile/type_euler-1d.f90.html","title":"type_euler-1D.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Lorenz equations. Source Code !< Test FOODIE with the integration of Lorenz equations. program integrate_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Lorenz equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_lorenz , only : lorenz use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( lorenz ) :: attractor !< Lorenz field. integer , parameter :: num_steps = 2000 !< Maximum time steps. integer , parameter :: space_dimension = 3 !< Space dimensions. real ( R_P ), parameter :: sigma = 1 0._R_P !< Lorenz' \\sigma. real ( R_P ), parameter :: rho = 2 8._R_P !< Lorenz' \\rho. real ( R_P ), parameter :: beta = 8._R_P / 3._R_P !< Lorenz' \\beta. real ( R_P ), parameter :: dt = 0.01_R_P !< Time step. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 1. , 1. , 1. ] !< Initial state. real ( R_P ) :: solution ( 0 : space_dimension , 0 : num_steps ) !< Solution at each time step. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'lorenz' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Lorenz equations integration' , & examples = [ \"lorenz --solver euler --results  \" , & \"lorenz --solver ls-runge-kutta -r\" , & \"lorenz --solver adams-bashforth  \" , & \"lorenz --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! integrate Lorenz equations select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\" \"z\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 3 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'x' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'y' , linestyle = 'b-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 3 , :), label = 'z' , linestyle = 'g-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'x-y path' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 3 , :), label = 'x-z path' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 2 , :), y = solution ( 3 , :), label = 'y-z path' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( lorenz ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call ab_integrator % integrate ( U = attractor , previous = previous ( 1 : s ), dt = dt , t = solution ( 0 , step - s : step - 1 )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'lorenz_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of explicit Euler solver' call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call euler_integrator % integrate ( U = attractor , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Euler' , & filename = 'lorenz_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( lorenz ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( lorenz ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = 2 ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call lf_integrator % integrate ( U = attractor , previous = previous , dt = dt , t = solution ( 0 , step ), filter = filter ) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit leapfrog scheme' ,& filename = 'lorenz_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit low storage Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'lorenz_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit TVD Runge-Kutta ' // trim ( str (. true ., s )) // ' stages' ,& filename = 'lorenz_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_lorenz","tags":"","loc":"sourcefile/lorenz.f90.html","title":"lorenz.f90 – FOODIE"},{"text":"Define Lorenz field that is a concrete extension of the abstract integrand type. Source Code !< Define Lorenz field that is a concrete extension of the abstract integrand type. module type_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Define Lorenz field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: lorenz !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Lorenz ODEs system !<The Lorenz' equations system [1] is a non linear system of pure ODEs that retains a reasonable-complex behaviour: such a !<system, for a certain parameters-region exhibits a chaotic dynamics useful for testing FOODIE solvers. !< !<The Lorenz' ODEs system can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< v_1 \\\\ !< v_2 \\\\ !< v_3 !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< \\sigma (v_2-v_1) \\\\ !< v_1(\\rho - v_3) -v_2 \\\\ !< v_1 v_2 - \\beta v_3 !< \\end{bmatrix} !<\\end{matrix} !< !<The parameters set is constant and it is here selected as: !< !<\\begin{matrix} !< \\sigma = 10 \\\\ !< \\rho = 28 \\\\ !< \\beta = \\frac{8}{3} !<\\end{matrix} !< !<These values are chaos-inducing thus they magnify the eventual numerical inaccuracies of FOODIE solvers, see [2]. !< !<#### Bibliography !< !<[1] *Deterministic Nonperiodic Flow*, Lorenz E.N., Journal of the Atmospheric Sciences, 1963, vol. 20, pp. 130--141, !<doi: http://dx.doi.org/10.1175/1520-0469(1963)020<0130:DNF>2.0.CO;2 !< !<[2] *Scientific software design: the object-oriented way*, Rouson, Damian, Jim Xia, and Xiaofeng Xu, !<Cambridge University Press, 2011 !< !<#### State variables organization !< State variables are organized as an array (rank 1) of reals of *dims* elements, in this case 3 elements. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, [1:dims]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:dims,1:steps]. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Lorenz field. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => lorenz_local_error !< Local error. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => lorenz_multiply_lorenz !< Lorenz * Lorenz operator. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< Lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz operator. procedure , pass ( lhs ), public :: sub => sub_lorenz !< Lorenz - Lorenz. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. endtype lorenz !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , initial_state , sigma , rho , beta , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Initial state of Lorenz field vector. real ( R_P ), intent ( IN ) :: sigma !< Lorenz  \\sigma. real ( R_P ), intent ( IN ) :: rho !< Lorenz  \\rho. real ( R_P ), intent ( IN ) :: beta !< Lorenz  \\beta. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % dims )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % dims , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % sigma = sigma self % rho = rho self % beta = beta return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Lorenz field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), dimension (:), allocatable :: state !< Lorenz state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output ! ADT integrand deferred methods function dLorenz_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Lorenz field time derivative. integer ( I_P ) :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: dState_dt ) select type ( dState_dt ) class is ( lorenz ) dState_dt = self dState_dt % U ( 1 ) = self % sigma * ( self % U ( 2 ) - self % U ( 1 )) dState_dt % U ( 2 ) = self % U ( 1 ) * ( self % rho - self % U ( 3 )) - self % U ( 2 ) dState_dt % U ( 3 ) = self % U ( 1 ) * self % U ( 2 ) - self % beta * self % U ( 3 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dLorenz_dt subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( lorenz ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: previous ) select type ( previous ) class is ( lorenz ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step function lorenz_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 lorenz approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) error = 0._R_P do i = 1 , lhs % dims error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_local_error function lorenz_multiply_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a lorenz field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_lorenz function lorenz_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Lorenz field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_real function real_multiply_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( lorenz ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_lorenz function add_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Lorenz function sub_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_lorenz subroutine lorenz_assign_lorenz ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Lorenz field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) lhs % dims = rhs % dims lhs % steps = rhs % steps if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous lhs % sigma = rhs % sigma lhs % rho = rhs % rho lhs % beta = rhs % beta endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_lorenz subroutine lorenz_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_real endmodule type_lorenz","tags":"","loc":"sourcefile/type_lorenz.f90.html","title":"type_lorenz.f90 – FOODIE"},{"text":"Testing program for IR_Precision, Pure Fortran (2003+) library for ensuring codes portability Source Code !< Testing program for IR_Precision, Pure Fortran (2003+) library for ensuring codes portability program Test_Driver !----------------------------------------------------------------------------------------------------------------------------------- !< Testing program for IR_Precision, Pure Fortran (2003+) library for ensuring codes portability !< !<### Usage !<```bash !< ./Test_Driver !<``` !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision USE , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! initialize IR_Precision call IR_Init ! print main IR_Precision values call IR_Print ( unit = stdout ) print \"(A)\" , '' print \"(A)\" , 'Testing IR_Precision tools' print \"(A)\" , 'Casting real-to-string: ' // str ( n = 1._R8P ) print \"(A)\" , 'Casting integer-to-string: ' // str ( n = 11_I8P ) print \"(A,\" // FR8P // \")\" , 'Casting string-to-real: ' , cton ( str = '2.2d0' , knd = 1._R8P ) print \"(A,\" // FI4P // \")\" , 'Casting integer-to-string: ' , cton ( str = '43' , knd = 1_I4P ) print \"(A)\" , 'Casting integer-to-string with zero padding: ' // trim ( strz ( nz_pad = 3 , n = 34_I8P )) ! print \"(A)\", 'Casting real-to-bit_string: '//bstr(n=1._R4P) print \"(A)\" , 'Casting integer-to-bit_string: ' // bstr ( n = 1_I4P ) ! print \"(A,\"//FR4P//\")\", 'Casting bit_string-to-real: ',bcton(bstr='00111111100000000000000000000000',knd=1._R4P) print \"(A,\" // FI4P // \")\" , 'Casting bit_string-to-integer: ' , bcton ( bstr = '00000000000000000000000000000001' , knd = 1_I4P ) print \"(A)\" , 'Number of digit of 1023: ' // str ( n = digit ( 1023_I4P )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram Test_Driver","tags":"","loc":"sourcefile/test_driver.f90.html","title":"Test_Driver.f90 – FOODIE"},{"text":"FLAP, Fortran command Line Arguments Parser for poor people Source Code !< FLAP, Fortran command Line Arguments Parser for poor people module Data_Type_Command_Line_Interface !----------------------------------------------------------------------------------------------------------------------------------- !< FLAP, Fortran command Line Arguments Parser for poor people !<{!README-FLAP.md!} !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT , stderr => ERROR_UNIT ! Standard output/error logical units. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , abstract :: Type_Object !< Abstract object defining data and methods that are common to CLA, CLAG and CLI. private character ( len = :), public , allocatable :: progname !< Program name. character ( len = :), public , allocatable :: version !< Program version. character ( len = :), allocatable :: help !< Help message. character ( len = :), public , allocatable :: description !< Detailed description. character ( len = :), public , allocatable :: license !< License description. character ( len = :), public , allocatable :: authors !< Authors list. character ( len = :), public , allocatable :: epilog !< Epilog message. character ( len = :), public , allocatable :: m_exclude !< Mutually exclude other CLA(s group). integer ( I4P ), public :: error = 0_I4P !< Error traping flag. contains procedure :: free_object !< Free dynamic memory. procedure :: errored !< Trig error occurence and print meaningful message. procedure :: print_version !< Print version. procedure :: assign_object !< Assignment overloading. endtype Type_Object type , extends ( Type_Object ) :: Type_Command_Line_Argument !< Command line arguments (CLA). !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value. private character ( len = :), allocatable :: switch !< Switch name. character ( len = :), allocatable :: switch_ab !< Abbreviated switch name. logical :: required = . false . !< Flag for set required argument. logical :: positional = . false . !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ) :: position = 0_I4P !< Position of positional CLA. logical :: passed = . false . !< Flag for checking if CLA has been passed to CLI. logical :: hidden = . false . !< Flag for hiding CLA, thus it does not compare into help. character ( len = :), allocatable :: act !< CLA value action. character ( len = :), allocatable :: def !< Default value. character ( len = :), allocatable :: nargs !< Number of arguments consumed by CLA. character ( len = :), allocatable :: choices !< List (comma separated) of allowable values for the argument. character ( len = :), allocatable :: val !< CLA value. character ( len = :), allocatable :: envvar !< Environment variable from which take value. contains ! public methods procedure , public :: free => free_cla !< Free dynamic memory. procedure , public :: check => check_cla !< Check CLA data consistency. procedure , public :: check_choices => check_choices_cla !< Check if CLA value is in allowed choices. procedure , public :: check_list_size => check_list_size_cla !< Check CLA multiple values list size consistency. generic , public :: get => get_cla , get_cla_list !< Get CLA value(s). generic , public :: get_varying => & !< Get CLA value(s) from CLAs list parsedi, varying size list. #ifdef r16p get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char procedure , public :: usage => usage_cla !< Get correct CLA usage. procedure , public :: signature => signature_cla !< Get CLA signature for adding to CLI one. ! private methods procedure , private :: get_cla !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: assign_cla !< CLA assignment overloading. generic , private :: assignment ( = ) => assign_cla !< CLA assignment overloading. final :: finalize_cla !< Free dynamic memory when finalizing. endtype Type_Command_Line_Argument type , extends ( Type_Object ) :: Type_Command_Line_Arguments_Group !< Group of CLAs for building nested commands. private character ( len = :), allocatable :: group !< Group name (command). integer ( I4P ) :: Na = 0_I4P !< Number of CLA. integer ( I4P ) :: Na_required = 0_I4P !< Number of command line arguments that CLI requires. integer ( I4P ) :: Na_optional = 0_I4P !< Number of command line arguments that are optional for CLI. type ( Type_Command_Line_Argument ), allocatable :: cla (:) !< CLA list [1:Na]. logical :: called = . false . !< Flag for checking if CLAs group has been passed to CLI. contains ! public methods procedure , public :: free => free_clasg !< Free dynamic memory. procedure , public :: check => check_clasg !< Check CLAs data consistency. procedure , public :: check_required => check_required_clasg !< Check if required CLAs are passed. procedure , public :: check_m_exclusive => check_m_exclusive_clasg !< Check if two mutually exclusive CLAs have been passed. procedure , public :: add => add_cla_clasg !< Add CLA to CLAs group. procedure , public :: passed => passed_clasg !< Check if a CLA has been passed. procedure , public :: defined => defined_clasg !< Check if a CLA has been defined. procedure , public :: parse => parse_clasg !< Parse CLAs group arguments. procedure , public :: usage => usage_clasg !< Get correct CLAs group usage. procedure , public :: signature => signature_clasg !< Get CLAs group signature for adding to the CLI one. ! private methods procedure , private :: assign_clasg !< CLAs group assignment overloading. generic , private :: assignment ( = ) => assign_clasg !< CLAs group assignment overloading. final :: finalize_clasg !< Free dynamic memory when finalizing. endtype Type_Command_Line_Arguments_Group type , extends ( Type_Object ), public :: Type_Command_Line_Interface !< Command Line Interface (CLI). private type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg (:) !< CLA list [1:Na]. #ifdef __GFORTRAN__ character ( 512 ), allocatable :: args (:) !< Actually passed command line arguments. character ( 512 ), allocatable :: examples (:) !< Examples of correct usage. #else character ( len = :), allocatable :: args (:) !< Actually passed command line arguments. character ( len = :), allocatable :: examples (:) !< Examples of correct usage (not work with gfortran). #endif logical :: disable_hv = . false . !< Disable automatic 'help' and 'version' CLAs. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: init !< Initialize CLI. procedure , public :: add_group !< Add CLAs group CLI. procedure , public :: add !< Add CLA to CLI. procedure , public :: passed !< Check if a CLA has been passed. procedure , public :: defined !< Check if a CLA has been defined. procedure , public :: defined_group !< Check if a CLAs group has been defined. procedure , public :: set_mutually_exclusive_groups !< Set two CLAs group as mutually exclusive. procedure , public :: run_command => called_group !< Check if a CLAs group has been runned. procedure , public :: parse !< Parse Command Line Interfaces. generic , public :: get => get_cla_cli , get_cla_list_cli !< Get CLA value(s) from CLAs list parsed. generic , public :: get_varying => & !< Get CLA value(s) from CLAs list parsedi, varying size list. #ifdef r16p get_cla_list_varying_R16P_cli , & #endif get_cla_list_varying_R8P_cli , & get_cla_list_varying_R4P_cli , & get_cla_list_varying_I8P_cli , & get_cla_list_varying_I4P_cli , & get_cla_list_varying_I2P_cli , & get_cla_list_varying_I1P_cli , & get_cla_list_varying_logical_cli , & get_cla_list_varying_char_cli procedure , public :: usage !< Get CLI usage. procedure , public :: signature !< Get CLI signature. procedure , public :: print_usage !< Print correct usage of CLI. procedure , public :: save_man_page !< Save man page build on CLI. ! private methods procedure , private :: check !< Check CLAs data consistenc. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs group have been called. procedure , private :: get_clasg_indexes !< Get CLAs groups indexes. generic , private :: get_args => get_args_from_string ,& !< Get CLAs from string. get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_args_from_string !< Get CLAs from string. procedure , private :: get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_cla_cli !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list_cli !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R16P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R16P. procedure , private :: get_cla_list_varying_R8P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical_cli !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char_cli !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: assign_cli !< CLI assignment overloading. generic , private :: assignment ( = ) => assign_cli !< CLI assignment overloading. final :: finalize !< Free dynamic memory when finalizing. endtype Type_Command_Line_Interface ! parameters integer ( I4P ), parameter :: max_val_len = 1000 !< Maximum number of characters of CLA value. character ( len =* ), parameter :: action_store = 'STORE' !< CLA that stores value (if invoked a value must be passed). character ( len =* ), parameter :: action_store_star = 'STORE*' !< CLA that stores value or revert on default is invoked alone. character ( len =* ), parameter :: action_store_true = 'STORE_TRUE' !< CLA that stores .true. without the necessity of a value. character ( len =* ), parameter :: action_store_false = 'STORE_FALSE' !< CLA that stores .false. without the necessity of a value. character ( len =* ), parameter :: action_print_help = 'PRINT_HELP' !< CLA that print help message. character ( len =* ), parameter :: action_print_vers = 'PRINT_VERSION' !< CLA that print version. character ( len =* ), parameter :: args_sep = '||!||' !< Arguments separator for multiple valued (list) CLA. ! code errors and status integer ( I4P ), parameter :: error_cla_optional_no_def = 1 !< Optional CLA without default value. integer ( I4P ), parameter :: error_cla_required_m_exclude = 2 !< Required CLA cannot exclude others. integer ( I4P ), parameter :: error_cla_positional_m_exclude = 3 !< Positional CLA cannot exclude others. integer ( I4P ), parameter :: error_cla_named_no_name = 4 !< Named CLA without switch name. integer ( I4P ), parameter :: error_cla_positional_no_position = 5 !< Positional CLA without position. integer ( I4P ), parameter :: error_cla_positional_no_store = 6 !< Positional CLA without action_store. integer ( I4P ), parameter :: error_cla_not_in_choices = 7 !< CLA value out of a specified choices. integer ( I4P ), parameter :: error_cla_missing_required = 8 !< Missing required CLA. integer ( I4P ), parameter :: error_cla_m_exclude = 9 !< Two mutually exclusive CLAs have been passed. integer ( I4P ), parameter :: error_cla_casting_logical = 10 !< Error casting CLA value to logical type. integer ( I4P ), parameter :: error_cla_choices_logical = 11 !< Error adding choices check for CLA value of logical type. integer ( I4P ), parameter :: error_cla_no_list = 12 !< Actual CLA is not list-values. integer ( I4P ), parameter :: error_cla_nargs_insufficient = 13 !< Multi-valued CLA with insufficient arguments. integer ( I4P ), parameter :: error_cla_value_missing = 14 !< Missing value of CLA. integer ( I4P ), parameter :: error_cla_unknown = 15 !< Unknown CLA (switch name). integer ( I4P ), parameter :: error_cla_envvar_positional = 16 !< Envvar not allowed for positional CLA. integer ( I4P ), parameter :: error_cla_envvar_not_store = 17 !< Envvar not allowed action different from store; integer ( I4P ), parameter :: error_cla_envvar_nargs = 18 !< Envvar not allowed for list-values CLA. integer ( I4P ), parameter :: error_cla_store_star_positional = 19 !< Action store* not allowed for positional CLA. integer ( I4P ), parameter :: error_cla_store_star_nargs = 20 !< Action store* not allowed for list-values CLA. integer ( I4P ), parameter :: error_cla_store_star_envvar = 21 !< Action store* not allowed for environment variable CLA. integer ( I4P ), parameter :: error_cla_action_unknown = 22 !< Unknown CLA (switch name). integer ( I4P ), parameter :: error_clasg_consistency = 23 !< CLAs group consistency error. integer ( I4P ), parameter :: error_clasg_m_exclude = 24 !< Two mutually exclusive CLAs group have been called. integer ( I4P ), parameter :: error_cli_missing_cla = 25 !< CLA not found in CLI. integer ( I4P ), parameter :: error_cli_missing_group = 26 !< Group not found in CLI. integer ( I4P ), parameter :: error_cli_missing_selection_cla = 27 !< CLA selection in CLI failing. integer ( I4P ), parameter :: error_cli_too_few_clas = 28 !< Insufficient arguments for CLI. integer ( I4P ), parameter :: status_clasg_print_v = - 1 !< Print version status. integer ( I4P ), parameter :: status_clasg_print_h = - 2 !< Print help status. !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary procedures pure function Upper_Case ( string ) ! elemental function Upper_Case(string) ! 1513-209 (S) The result of an elemental function must be a nonpointer, nonallocatable scalar, and its type parameters must be constant expressions. !--------------------------------------------------------------------------------------------------------------------------------- !< Convert the lower case characters of a string to upper case one. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len =* ), intent ( IN ) :: string !< String to be converted. character ( len = len ( string )) :: Upper_Case !< Converted string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. character ( len = 26 ), parameter :: upper_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( len = 26 ), parameter :: lower_alphabet = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Upper_Case = string do n1 = 1 , len ( string ) n2 = index ( lower_alphabet , string ( n1 : n1 )) if ( n2 > 0 ) Upper_Case ( n1 : n1 ) = upper_alphabet ( n2 : n2 ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction Upper_Case pure subroutine tokenize ( strin , delimiter , toks , Nt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to char(0). !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( IN ) :: strin !< String to be tokenized. character ( len =* ), intent ( IN ) :: delimiter !< Delimiter of tokens. character ( len = len ( strin )), intent ( OUT ), allocatable :: toks (:) !< Tokens. integer ( I4P ), intent ( OUT ), optional :: Nt !< Number of tokens. character ( len = len ( strin )) :: strsub !< Temporary string. integer ( I4P ) :: dlen !< Delimiter length. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: n !< Counter. integer ( I4P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialization if ( allocated ( toks )) deallocate ( toks ) strsub = strin dlen = len ( delimiter ) if ( dlen > len ( strin )) then allocate ( toks ( 1 : 1 )) ; toks ( 1 ) = char ( 0 ) ; if ( present ( Nt )) Nt = 1 ; return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenization do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tokenize ! Type_Object procedures elemental subroutine free_object ( obj ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: obj !< Object data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( obj % progname )) deallocate ( obj % progname ) if ( allocated ( obj % version )) deallocate ( obj % version ) if ( allocated ( obj % help )) deallocate ( obj % help ) if ( allocated ( obj % description )) deallocate ( obj % description ) if ( allocated ( obj % license )) deallocate ( obj % license ) if ( allocated ( obj % authors )) deallocate ( obj % authors ) if ( allocated ( obj % epilog )) deallocate ( obj % epilog ) if ( allocated ( obj % m_exclude )) deallocate ( obj % m_exclude ) obj % error = 0_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_object subroutine errored ( obj , error , pref , group , switch , val_str , log_value , a1 , a2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Trig error occurence and print meaningful message. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: obj !< Object data. integer ( I4P ), intent ( IN ) :: error !< Error occurred. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Group name. character ( * ), optional , intent ( IN ) :: switch !< CLA switch name. character ( * ), optional , intent ( IN ) :: val_str !< Value string. character ( * ), optional , intent ( IN ) :: log_value !< Logical value to be casted. integer ( I4P ), optional , intent ( IN ) :: a1 !< First index CLAs group inconsistent. integer ( I4P ), optional , intent ( IN ) :: a2 !< Second index CLAs group inconsistent. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- obj % error = error if ( obj % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref select type ( obj ) class is ( Type_Command_Line_Argument ) select case ( obj % error ) case ( error_cla_optional_no_def ) if ( obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str ( n = obj % position )) // & '-th\" positional option has not a default value!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // obj % switch // '\" has not a default value!' endif case ( error_cla_required_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // obj % switch // '\" cannot exclude others' // & ', it being requiredi, only optional ones can!' case ( error_cla_positional_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str ( n = obj % position )) // & '-th\" positional option cannot exclude others, only optional named options can!' case ( error_cla_named_no_name ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a non positional optiona must have a switch name!' case ( error_cla_positional_no_position ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a positional option must have a position number different from 0!' case ( error_cla_positional_no_store ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a positional option must have action set to \"' // action_store // '\"!' case ( error_cla_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: the options \"' // obj % switch // '\" and \"' // obj % m_exclude // '\" are mutually' // & ' exclusive, but both have been passed!' case ( error_cla_not_in_choices ) if ( obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: value of \"' // trim ( str ( n = obj % position )) // & '-th\" positional option must be chosen in:' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: value of named option \"' // obj % switch // '\" must be chosen in:' endif write ( stderr , '(A)' ) prefd // '(' // obj % choices // ')' write ( stderr , '(A)' ) prefd // '\"' // trim ( val_str ) // '\" has been passed!' case ( error_cla_missing_required ) if (. not . obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" is required!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option is required!' endif case ( error_cla_casting_logical ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: cannot convert \"' // log_value // '\" of option \"' // obj % switch // & '\" to logical type!' case ( error_cla_choices_logical ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: cannot use \"choices\" value check for option \"' // obj % switch // & '\" it being of logical type! The choices is, by definition of logical, limited to \".true.\" or \".false.\"' case ( error_cla_no_list ) if (. not . obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" has not \"nargs\" value' // & ' but an array has been passed to \"get\" method!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has not \"nargs\" value but an array has been passed to \"get\" method!' endif case ( error_cla_nargs_insufficient ) if (. not . obj % positional ) then if ( obj % nargs == '+' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" requires at least ' // & '1 argument but no one remains!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" requires ' // & trim ( adjustl ( obj % nargs )) // ' arguments but no enough ones remain!' endif else if ( obj % nargs == '+' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option requires at least 1 argument but no one remains' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option requires ' // & trim ( adjustl ( obj % nargs )) // ' arguments but no enough ones remain!' endif endif case ( error_cla_value_missing ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" needs a value that is not passed!' case ( error_cla_unknown ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: switch \"' // trim ( adjustl ( switch )) // '\" is unknown!' case ( error_cla_envvar_positional ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has \"envvar\" value that is not allowed for positional option!' case ( error_cla_envvar_not_store ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" is an envvar with action different from \"' // action_store // '\" that is not allowed!' case ( error_cla_envvar_nargs ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" is an envvar that is not allowed for list valued option!' case ( error_cla_store_star_positional ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has \"' // action_store_star // '\" action that is not allowed for positional option!' case ( error_cla_store_star_nargs ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for list valued option!' case ( error_cla_store_star_envvar ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for environment variable option!' case ( error_cla_action_unknown ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has unknown \"' // obj % act // '\" action!' endselect class is ( Type_Command_Line_Arguments_Group ) select case ( obj % error ) case ( error_clasg_consistency ) if ( obj % group /= '' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: group (command) name: \"' // obj % group // '\" consistency error:' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: consistency error:' endif write ( stderr , '(A)' ) prefd // ' \"' // trim ( str (. true ., a1 )) // '-th\" option has the same switch or abbreviated switch of \"' & // trim ( str (. true ., a2 )) // '-th\" option:' write ( stderr , '(A)' ) prefd // ' CLA(' // trim ( str (. true ., a1 )) // ') switches = ' // obj % cla ( a1 )% switch // ' ' // & obj % cla ( a1 )% switch_ab write ( stderr , '(A)' ) prefd // ' CLA(' // trim ( str (. true ., a2 )) // ') switches = ' // obj % cla ( a2 )% switch // ' ' // & obj % cla ( a2 )% switch_ab case ( error_clasg_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: the group \"' // obj % group // '\" and \"' // obj % m_exclude // '\" are mutually' // & ' exclusive, but both have been called!' endselect class is ( Type_Command_Line_Interface ) select case ( obj % error ) case ( error_cli_missing_cla ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: there is no option \"' // trim ( adjustl ( switch )) // '\"!' case ( error_cli_missing_selection_cla ) write ( stderr , '(A)' ) prefd // obj % progname // & ': error: to get an option value one of switch \"name\" or \"position\" must be provided!' case ( error_cli_missing_group ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: ther is no group (command) named \"' // trim ( adjustl ( group )) // '\"!' case ( error_cli_too_few_clas ) ! write(stderr,'(A)')prefd//obj%progname//': error: too few arguments ('//trim(str(.true.,Na))//')'//& ! ' respect the required ('//trim(str(.true.,obj%Na_required))//')' endselect endselect write ( stderr , '(A)' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine errored subroutine print_version ( obj , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print version. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( IN ) :: obj !< Object data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref write ( stdout , '(A)' ) prefd // obj % progname // ' version ' // obj % version if ( obj % license /= '' ) then write ( stdout , '(A)' ) prefd // obj % license endif if ( obj % authors /= '' ) then write ( stdout , '(A)' ) prefd // obj % authors endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_version elemental subroutine assign_object ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign two abstract objects. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: lhs !< Left hand side. class ( Type_Object ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members if ( allocated ( rhs % progname )) lhs % progname = rhs % progname if ( allocated ( rhs % version )) lhs % version = rhs % version if ( allocated ( rhs % help )) lhs % help = rhs % help if ( allocated ( rhs % description )) lhs % description = rhs % description if ( allocated ( rhs % license )) lhs % license = rhs % license if ( allocated ( rhs % authors )) lhs % authors = rhs % authors if ( allocated ( rhs % epilog )) lhs % epilog = rhs % epilog if ( allocated ( rhs % m_exclude )) lhs % m_exclude = rhs % m_exclude lhs % error = rhs % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_object ! Type_Command_Line_Argument procedures elemental subroutine free_cla ( cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cla % free_object ! Type_Command_Line_Argument members if ( allocated ( cla % switch )) deallocate ( cla % switch ) if ( allocated ( cla % switch_ab )) deallocate ( cla % switch_ab ) if ( allocated ( cla % act )) deallocate ( cla % act ) if ( allocated ( cla % def )) deallocate ( cla % def ) if ( allocated ( cla % nargs )) deallocate ( cla % nargs ) if ( allocated ( cla % choices )) deallocate ( cla % choices ) if ( allocated ( cla % val )) deallocate ( cla % val ) if ( allocated ( cla % envvar )) deallocate ( cla % envvar ) cla % required = . false . cla % positional = . false . cla % position = 0_I4P cla % passed = . false . cla % hidden = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_cla elemental subroutine finalize_cla ( cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cla % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_cla subroutine check_cla ( cla , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( allocated ( cla % envvar )) then if ( cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_envvar_positional ) return endif if (. not . allocated ( cla % act )) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return else if ( cla % act /= action_store ) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return endif endif if ( allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_envvar_nargs ) return endif endif if ( allocated ( cla % act )) then if ( cla % act == action_store_star . and . cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_store_star_positional ) return endif if ( cla % act == action_store_star . and . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_store_star_nargs ) return endif if ( cla % act == action_store_star . and . allocated ( cla % envvar )) then call cla % errored ( pref = prefd , error = error_cla_store_star_envvar ) return endif if ( cla % act /= action_store . and . & cla % act /= action_store_star . and . & cla % act /= action_store_true . and . & cla % act /= action_store_false . and .& cla % act /= action_print_help . and . & cla % act /= action_print_vers ) then call cla % errored ( pref = prefd , error = error_cla_action_unknown ) return endif endif if ((. not . cla % required ). and .(. not . allocated ( cla % def ))) then call cla % errored ( pref = prefd , error = error_cla_optional_no_def ) return endif if (( cla % required ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_required_m_exclude ) return endif if (( cla % positional ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_positional_m_exclude ) return endif if ((. not . cla % positional ). and .(. not . allocated ( cla % switch ))) then call cla % errored ( pref = prefd , error = error_cla_named_no_name ) return elseif (( cla % positional ). and .( cla % position == 0_I4P )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_position ) return elseif (( cla % positional ). and .( cla % act /= action_store )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_store ) return endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_cla subroutine check_choices_cla ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if CLA value is in allowed choices. !< !< @note This procedure can be called if and only if cla%choices has been allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. class ( * ), intent ( IN ) :: val !< CLA value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len ( cla % choices )), allocatable :: toks (:) !< Tokens for parsing choices list. integer ( I4P ) :: Nc !< Number of choices. logical :: val_in !< Flag for checking if val is in the choosen range. character ( len = :), allocatable :: val_str !< Value in string form. character ( len = :), allocatable :: tmp !< Temporary string for avoiding GNU gfrotran bug. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- val_in = . false . val_str = '' tmp = cla % choices call tokenize ( strin = tmp , delimiter = ',' , toks = toks , Nt = Nc ) select type ( val ) #ifdef r16p type is ( real ( R16P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R16P )) val_in = . true . enddo #endif type is ( real ( R8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R8P )) val_in = . true . enddo type is ( real ( R4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R4P )) val_in = . true . enddo type is ( integer ( I8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I8P )) val_in = . true . enddo type is ( integer ( I4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I4P )) val_in = . true . enddo type is ( integer ( I2P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I2P )) val_in = . true . enddo type is ( integer ( I1P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I1P )) val_in = . true . enddo type is ( character ( * )) val_str = val do c = 1 , Nc if ( val == toks ( c )) val_in = . true . enddo type is ( logical ) prefd = '' ; if ( present ( pref )) prefd = pref call cla % errored ( pref = prefd , error = error_cla_choices_logical ) endselect if (. not . val_in . and .( cla % error == 0 )) then prefd = '' ; if ( present ( pref )) prefd = pref call cla % errored ( pref = prefd , error = error_cla_not_in_choices , val_str = val_str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_choices_cla subroutine get_cla ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val !< CLA value. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if ( cla % act == action_store . or . cla % act == action_store_star ) then if ( cla % passed . and . allocated ( cla % val )) then select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I1P ) type is ( logical ) read ( cla % val , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % val ) type is ( character ( * )) val = cla % val endselect elseif ( allocated ( cla % def )) then ! using default value select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I1P ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) type is ( character ( * )) val = cla % def endselect endif if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val , pref = prefd ) elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla subroutine get_cla_list ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val ( 1 :) !< CLA values. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsV ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsD ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect endif elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list function check_list_size_cla ( cla , Nv , val , pref ) result ( is_ok ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA multiple values list size consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), intent ( IN ) :: Nv !< Number of values. character ( * ), intent ( IN ) :: val !< First value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical :: is_ok !< Check result. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref is_ok = . true . if ( Nv == 1 ) then if ( trim ( adjustl ( val )) == '' ) then ! there is no real value, but only for nargs=+ this is a real error is_ok = . false . if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction check_list_size_cla subroutine get_cla_list_varying_R16P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R16P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return if ( Nv == 1 ) then if ( trim ( adjustl ( valsD ( 1 ))) == '' ) then if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif return endif endif allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P subroutine get_cla_list_varying_R8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P subroutine get_cla_list_varying_R4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P subroutine get_cla_list_varying_I8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P subroutine get_cla_list_varying_I4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P subroutine get_cla_list_varying_I2P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I2P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P subroutine get_cla_list_varying_I1P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I1P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P subroutine get_cla_list_varying_logical ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, logical. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. logical , allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical subroutine get_cla_list_varying_char ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, character. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsV ( v ))) enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsD ( v ))) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char function usage_cla ( cla , pref ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLA usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: usage !< Usage string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then prefd = '' ; if ( present ( pref )) prefd = pref if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then usage = '' select case ( cla % nargs ) case ( '+' ) usage = usage // ' value#1 [value#2...]' case ( '*' ) usage = usage // ' [value#1 value#2...]' case default do a = 1 , cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) usage = usage // ' value#' // trim ( str (. true ., a )) enddo endselect if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // usage // ', ' // trim ( adjustl ( cla % switch_ab )) // usage else usage = '   ' // trim ( adjustl ( cla % switch )) // usage endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ' value, ' // trim ( adjustl ( cla % switch_ab )) // ' value' else usage = '   ' // trim ( adjustl ( cla % switch )) // ' value' endif endif else usage = '  value' endif if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif elseif ( cla % act == action_store_star ) then usage = '  [value]' if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ', ' // trim ( adjustl ( cla % switch_ab )) else usage = '   ' // trim ( adjustl ( cla % switch )) endif endif usage = prefd // usage if ( cla % positional ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( str (. true ., cla % position )) // '-th argument' if ( allocated ( cla % envvar )) then if ( cla % envvar /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'environment variable name \"' // trim ( adjustl ( cla % envvar )) // '\"' endif endif if (. not . cla % required ) then if ( cla % def /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'default value ' // trim ( adjustl ( cla % def )) endif endif if ( cla % m_exclude /= '' ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'mutually exclude \"' // cla % m_exclude // '\"' usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( adjustl ( cla % help )) else usage = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_cla function signature_cla ( cla ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: nargs !< Number of arguments consumed by CLA. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then select case ( cla % nargs ) case ( '+' ) signd = ' value#1 [value#2 value#3...]' case ( '*' ) signd = ' [value#1 value#2 value#3...]' case default nargs = cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) signd = '' do a = 1 , nargs signd = signd // ' value#' // trim ( str (. true ., a )) enddo endselect else signd = ' value' endif if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) // signd else signd = ' [' // trim ( adjustl ( cla % switch )) // signd // ']' endif else if ( cla % required ) then signd = ' value' else signd = ' [value]' endif endif elseif ( cla % act == action_store_star ) then signd = ' [value]' else if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) else signd = ' [' // trim ( adjustl ( cla % switch )) // ']' endif endif else signd = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_cla elemental subroutine assign_cla ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign two CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Argument ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Argument members if ( allocated ( rhs % switch )) lhs % switch = rhs % switch if ( allocated ( rhs % switch_ab )) lhs % switch_ab = rhs % switch_ab if ( allocated ( rhs % act )) lhs % act = rhs % act if ( allocated ( rhs % def )) lhs % def = rhs % def if ( allocated ( rhs % nargs )) lhs % nargs = rhs % nargs if ( allocated ( rhs % choices )) lhs % choices = rhs % choices if ( allocated ( rhs % val )) lhs % val = rhs % val if ( allocated ( rhs % envvar )) lhs % envvar = rhs % envvar lhs % required = rhs % required lhs % positional = rhs % positional lhs % position = rhs % position lhs % passed = rhs % passed lhs % hidden = rhs % hidden return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_cla ! Type_Command_Line_Arguments_Group procedures elemental subroutine free_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call clasg % free_object ! Type_Command_Line_Arguments_Group members if ( allocated ( clasg % group )) deallocate ( clasg % group ) if ( allocated ( clasg % cla )) then call clasg % cla % free deallocate ( clasg % cla ) endif clasg % Na = 0_I4P clasg % Na_required = 0_I4P clasg % Na_optional = 0_I4P clasg % called = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_clasg elemental subroutine finalize_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call clasg % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_clasg subroutine check_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! verifing if CLAs switches are unique CLA_unique : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then do aa = 1 , clasg % Na if (( a /= aa ). and .(. not . clasg % cla ( aa )% positional )) then if (( clasg % cla ( a )% switch == clasg % cla ( aa )% switch ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch ). or .& ( clasg % cla ( a )% switch == clasg % cla ( aa )% switch_ab ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch_ab )) then call clasg % errored ( pref = prefd , error = error_clasg_consistency , a1 = a , a2 = aa ) exit CLA_unique endif endif enddo endif enddo CLA_unique ! updating mutually exclusive relations CLA_exclude : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % defined ( switch = clasg % cla ( a )% m_exclude , pos = aa )) then clasg % cla ( aa )% m_exclude = clasg % cla ( a )% switch endif endif endif enddo CLA_exclude return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_clasg subroutine check_required_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLAs are passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( clasg % called ) then do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) then if (. not . clasg % cla ( a )% passed ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_missing_required ) clasg % error = clasg % cla ( a )% error write ( stdout , '(A)' ) clasg % usage ( pref = prefd ) return endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_required_clasg subroutine check_m_exclusive_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs have been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref do a = 1 , clasg % Na if ( clasg % cla ( a )% passed ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % passed ( switch = clasg % cla ( a )% m_exclude )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_m_exclude ) clasg % error = clasg % cla ( a )% error return endif endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive_clasg subroutine add_cla_clasg ( clasg , pref , cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. type ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. type ( Type_Command_Line_Argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % Na > 0_I4P ) then if (. not . cla % positional ) then allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , clasg % Na cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( clasg % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , clasg % Na + 1 cla_list_new ( c ) = clasg % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = clasg % cla ) clasg % Na = clasg % Na + 1 if ( cla % required ) then clasg % Na_required = clasg % Na_required + 1 else clasg % Na_optional = clasg % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) prefd = '' ; if ( present ( pref )) prefd = pref call clasg % check ( pref = prefd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_cla_clasg pure function passed_clasg ( clasg , switch , position ) result ( passed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if ( clasg % Na > 0 ) then if ( present ( switch )) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then passed = clasg % cla ( a )% passed exit endif endif enddo elseif ( present ( position )) then passed = clasg % cla ( position )% passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed_clasg function defined_clasg ( clasg , switch , pos ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( OUT ) :: pos !< CLA position. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if ( present ( pos )) pos = 0 if ( clasg % Na > 0 ) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_clasg subroutine parse_clasg ( clasg , pref , args ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAs group arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), intent ( IN ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , clasg % Na ! loop ver CLAs group clas named options if (. not . clasg % cla ( a )% positional ) then if ( trim ( adjustl ( clasg % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( clasg % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( clasg % cla ( a )% act == action_store ) then found_val = . false . if ( allocated ( clasg % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = clasg % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then clasg % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) then clasg % cla ( a )% val = clasg % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( clasg % cla ( a )% nargs )) then clasg % cla ( a )% val = '' select case ( clasg % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( clasg % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) enddo arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_value_missing ) clasg % error = clasg % cla ( a )% error return endif arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( clasg % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . endif endif if (. not . found ) then ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) clasg % cla ( a )% val = clasg % cla ( a )% def endif elseif ( clasg % cla ( a )% act == action_print_help ) then clasg % error = status_clasg_print_h elseif ( clasg % cla ( a )% act == action_print_vers ) then clasg % error = status_clasg_print_v endif clasg % cla ( a )% passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . clasg % cla ( arg )% positional ) then ! current argument (arg-th) is not positional... there is a problem! call clasg % cla ( arg )% errored ( pref = prefd , error = error_cla_unknown , switch = trim ( adjustl ( args ( arg )))) clasg % error = clasg % cla ( arg )% error return else ! positional CLA always stores a value clasg % cla ( arg )% val = trim ( adjustl ( args ( arg ))) clasg % cla ( arg )% passed = . true . endif endif enddo call clasg % check_m_exclusive ( pref = prefd ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_clasg function usage_clasg ( clasg , pref , no_header ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAs group usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref usage = clasg % progname ; if ( clasg % group /= '' ) usage = clasg % progname // ' ' // clasg % group usage = prefd // clasg % help // ' ' // usage // clasg % signature () if ( clasg % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // clasg % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( clasg % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif if ( clasg % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , clasg % Na if (. not . clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_clasg function signature_clasg ( clasg ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs group signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = '' do a = 1 , clasg % Na signd = signd // clasg % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_clasg elemental subroutine assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign two CLASg. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Arguments_Group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % called = rhs % called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_clasg ! Type_Command_Line_Interface procedures elemental subroutine free ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cli % free_object ! Type_Command_Line_Interface members if ( allocated ( cli % clasg )) then do g = 0 , size ( cli % clasg , dim = 1 ) - 1 call cli % clasg ( g )% free enddo deallocate ( cli % clasg ) endif if ( allocated ( cli % examples )) deallocate ( cli % examples ) cli % disable_hv = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free elemental subroutine finalize ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize subroutine init ( cli , progname , version , help , description , license , authors , examples , epilog , disable_hv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: progname !< Program name. character ( * ), optional , intent ( IN ) :: version !< Program version. character ( * ), optional , intent ( IN ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( IN ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( IN ) :: license !< License description. character ( * ), optional , intent ( IN ) :: authors !< Authors list. character ( * ), optional , intent ( IN ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( IN ) :: epilog !< Epilog message. logical , optional , intent ( IN ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free if ( present ( progname )) then cli % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then cli % progname = prog_invocation else cli % progname = 'program' endif endif cli % version = 'unknown' ; if ( present ( version )) cli % version = version cli % help = 'usage: ' ; if ( present ( help )) cli % help = help cli % description = '' ; if ( present ( description )) cli % description = description cli % license = '' ; if ( present ( license )) cli % license = license cli % authors = '' ; if ( present ( authors )) cli % authors = authors cli % epilog = '' ; if ( present ( epilog )) cli % epilog = epilog if ( present ( disable_hv )) cli % disable_hv = disable_hv if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( cli % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: cli % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif cli % examples = examples endif ! initialize only the first default group allocate ( cli % clasg ( 0 : 0 )) call cli % clasg ( 0 )% assign_object ( cli ) cli % clasg ( 0 )% group = '' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine add_group ( cli , help , description , exclude , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLAs group to CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: help !< Help message. character ( * ), optional , intent ( IN ) :: description !< Detailed description. character ( * ), optional , intent ( IN ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( IN ) :: group !< Name of the grouped CLAs. type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. integer ( I4P ) :: gi !< Group index !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cli % defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( cli % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) !    clasg_list_new(0:Ng-1) = cli%clasg(0:Ng-1) ! Not working on Intel Fortran 15.0.2 do gi = 0 , Ng - 1 clasg_list_new ( gi ) = cli % clasg ( gi ) enddo call clasg_list_new ( Ng )% assign_object ( cli ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( cli % clasg ) allocate ( cli % clasg ( 0 : Ng )) cli % clasg = clasg_list_new deallocate ( clasg_list_new ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_group subroutine set_mutually_exclusive_groups ( cli , group1 , group2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set two CLAs group ad mutually exclusive. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( IN ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 !< Counter. integer ( I4P ) :: g2 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( cli % defined_group ( group = group1 , g = g1 ). and . cli % defined_group ( group = group2 , g = g2 )) then cli % clasg ( g1 )% m_exclude = group2 cli % clasg ( g2 )% m_exclude = group1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_mutually_exclusive_groups subroutine add ( cli , pref , group , group_index , switch , switch_ab , help , required , positional , position , hidden , act , def , nargs ,& choices , exclude , envvar , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( IN ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( IN ) :: help !< Help message describing the CLA. logical , optional , intent ( IN ) :: required !< Flag for set required argument. logical , optional , intent ( IN ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical , optional , intent ( IN ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( IN ) :: act !< CLA value action. character ( * ), optional , intent ( IN ) :: def !< Default value. character ( * ), optional , intent ( IN ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( IN ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( IN ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( IN ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. type ( Type_Command_Line_Argument ) :: cla !< CLA data. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initializing CLA call cla % assign_object ( cli ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % required = . false . ; if ( present ( required )) cla % required = required cla % positional = . false . ; if ( present ( positional )) cla % positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % hidden = . false . ; if ( present ( hidden )) cla % hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( def )) cla % val = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar prefd = '' ; if ( present ( pref )) prefd = pref call cla % check ( pref = prefd ) ; cli % error = cla % error if ( cli % error /= 0 ) then if ( present ( error )) error = cli % error return endif ! adding CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call cli % clasg ( 0 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( 0 )% error elseif ( present ( group )) then if ( cli % defined_group ( group = group , g = g )) then call cli % clasg ( g )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( g )% error else call cli % add_group ( group = group ) call cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( cli % clasg , dim = 1 ) - 1 ) then call cli % clasg ( group_index )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( group_index )% error endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add subroutine check ( cli , pref , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLAs data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter. integer ( I4P ) :: gg !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref do g = 0 , size ( cli % clasg , dim = 1 ) - 1 ! check group consistency call cli % clasg ( g )% check ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( present ( error )) error = cli % error if ( cli % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( cli % clasg ( g )% m_exclude /= '' ) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) cli % clasg ( gg )% m_exclude = cli % clasg ( g )% group endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check subroutine check_m_exclusive ( cli , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs group have been called. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter. integer ( I4P ) :: gg !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do g = 1 , size ( cli % clasg , dim = 1 ) - 1 if ( cli % clasg ( g )% called . and .( cli % clasg ( g )% m_exclude /= '' )) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) then if ( cli % clasg ( gg )% called ) then prefd = '' ; if ( present ( pref )) prefd = pref call cli % clasg ( g )% errored ( pref = prefd , error = error_clasg_m_exclude ) cli % error = cli % clasg ( g )% error exit endif endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive function passed ( cli , group , switch , position ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if (. not . present ( group )) then if ( present ( switch )) then passed = cli % clasg ( 0 )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( 0 )% passed ( position = position ) endif else if ( cli % defined_group ( group = group , g = g )) then if ( present ( switch )) then passed = cli % clasg ( g )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( g )% passed ( position = position ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed function defined_group ( cli , group , g ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. integer ( I4P ), optional , intent ( OUT ) :: g !< Index of group. logical :: defined !< Check if a CLAs group has been defined. integer ( I4P ) :: gg !< Counter. integer ( I4P ) :: ggg !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . do gg = 0 , size ( cli % clasg , dim = 1 ) - 1 ggg = gg if ( allocated ( cli % clasg ( gg )% group )) defined = ( cli % clasg ( gg )% group == group ) if ( defined ) exit enddo if ( present ( g )) g = ggg return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_group function called_group ( cli , group ) result ( called ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been runned. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: called !< Check if a CLAs group has been runned. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- called = . false . if ( cli % defined_group ( group = group , g = g )) called = cli % clasg ( g )% called return !--------------------------------------------------------------------------------------------------------------------------------- endfunction called_group function defined ( cli , switch , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if (. not . present ( group )) then defined = cli % clasg ( 0 )% defined ( switch = switch ) else if ( cli % defined_group ( group = group , g = g )) defined = cli % clasg ( g )% defined ( switch = switch ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined subroutine parse ( cli , pref , args , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse Command Line Interfaces by means of a previously initialized CLAs groups list. !< !< @note The leading and trailing white spaces are removed from CLA values. !< !< @note If the *args* argument is passed the command line arguments are taken from it and not from the actual program CLI !< invocations. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: args !< String containing command line arguments. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter for CLAs group. integer ( I4P ), allocatable :: ai (:,:) !< Counter for CLAs grouped. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! add help and version switches if not done by user if (. not . cli % disable_hv ) then do g = 0 , size ( cli % clasg , dim = 1 ) - 1 if (. not .( cli % defined ( group = cli % clasg ( g )% group , switch = '--help' ). and . cli % defined ( group = cli % clasg ( g )% group , switch = '-h' ))) & call cli % add ( pref = prefd , & group_index = g , & switch = '--help' , & switch_ab = '-h' , & help = 'Print this help message' , & required = . false ., & def = '' , & act = 'print_help' ) if (. not .( cli % defined ( group = cli % clasg ( g )% group , switch = '--version' ). and . cli % defined ( group = cli % clasg ( g )% group , switch = '-v' ))) & call cli % add ( pref = prefd , & group_index = g , & switch = '--version' , & switch_ab = '-v' , & help = 'Print version' , & required = . false ., & def = '' , & act = 'print_version' ) enddo endif ! add hidden CLA '--' for getting the rid of eventual trailing CLAs garbage do g = 0 , size ( cli % clasg , dim = 1 ) - 1 if (. not . cli % defined ( group = cli % clasg ( g )% group , switch = '--' )) & call cli % add ( pref = prefd , & group_index = g , & switch = '--' , & required = . false ., & hidden = . true ., & nargs = '*' , & def = '' , & act = 'store' ) enddo ! parsing passed CLAs grouping in indexes if ( present ( args )) then call cli % get_args ( args = args , ai = ai ) else call cli % get_args ( ai = ai ) endif ! checking CLI consistency call cli % check ( pref = prefd ) if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! parsing cli do g = 0 , size ( ai , dim = 1 ) - 1 if ( ai ( g , 1 ) > 0 ) call cli % clasg ( g )% parse ( pref = prefd , args = cli % args ( ai ( g , 1 ): ai ( g , 2 ))) cli % error = cli % clasg ( g )% error if ( cli % error /= 0 ) exit enddo if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! trapping the special cases of version/help printing if ( cli % error == status_clasg_print_v ) then call cli % print_version ( pref = prefd ) stop elseif ( cli % error == status_clasg_print_h ) then write ( stdout , '(A)' ) cli % usage ( pref = prefd , g = g ) stop endif ! checking if all required CLAs have been passed do g = 0 , size ( ai , dim = 1 ) - 1 call cli % clasg ( g )% check_required ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( cli % error > 0 ) exit enddo if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! check mutually exclusive interaction call cli % check_m_exclusive ( pref = prefd ) if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse subroutine get_clasg_indexes ( cli , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. integer ( I4P ) :: g !< Counter for CLAs group. logical :: found !< Flag for inquiring if a named group is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( ai ( 0 : size ( cli % clasg , dim = 1 ) - 1 , 1 : 2 )) ai = 0 if ( allocated ( cli % args )) then Na = size ( cli % args , dim = 1 ) a = 0 found = . false . search_named : do while ( a < Na ) a = a + 1 if ( cli % defined_group ( group = trim ( cli % args ( a )), g = g )) then found = . true . cli % clasg ( g )% called = . true . ai ( g , 1 ) = a + 1 aa = a do while ( aa < Na ) aa = aa + 1 if ( cli % defined_group ( group = trim ( cli % args ( aa )))) then a = aa - 1 ai ( g , 2 ) = a exit else ai ( g , 2 ) = aa endif enddo elseif (. not . found ) then ai ( 0 , 2 ) = a endif enddo search_named if ( ai ( 0 , 2 ) > 0 ) then ai ( 0 , 1 ) = 1 cli % clasg ( 0 )% called = . true . elseif ( all ( ai == 0 )) then cli % clasg ( 0 )% called = . true . endif else cli % clasg ( 0 )% called = . true . endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_clasg_indexes subroutine get_args_from_string ( cli , args , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from string. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: args !< String containing command line arguments. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. character ( len = len_trim ( args )) :: argsd !< Dummy string containing command line arguments. character ( len = len_trim ( args )), allocatable :: toks (:) !< CLAs tokenized. integer ( I4P ) :: Nt !< Number of tokens. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: t !< Counter for tokens. integer ( I4P ) :: c !< Counter for characters inside tokens. #ifndef __GFORTRAN__ integer ( I4P ) :: length !< Maxium lenght of arguments string. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! prepare cli arguments list if ( allocated ( cli % args )) deallocate ( cli % args ) ! sanitize arguments string argsd = trim ( args ) if ( index ( args , \"'\" ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = \"'\" ) elseif ( index ( args , '\"' ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = '\"' ) endif ! tokenize arguments string; the previously sanitized white spaces inside tokens are restored call tokenize ( strin = argsd , delimiter = ' ' , toks = toks , Nt = Nt ) Na = 0 find_number_of_valid_arguments : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then Na = Na + 1 do c = 1 , len ( toks ( t )) if ( toks ( t )( c : c ) == \"'\" ) toks ( t )( c : c ) = \" \" enddo endif enddo find_number_of_valid_arguments if ( Na > 0 ) then ! allocate cli arguments list #ifdef __GFORTRAN__ allocate ( cli % args ( 1 : Na )) #else length = 0 find_longest_arg : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) length = max ( length , len_trim ( adjustl ( toks ( t )))) enddo find_longest_arg allocate ( character ( length ) :: cli % args ( 1 : Na )) #endif ! construct arguments list a = 0 get_args : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then a = a + 1 cli % args ( a ) = trim ( adjustl ( toks ( t ))) endif enddo get_args endif call cli % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- contains function sanitize_args ( argsin , delimiter ) result ( sanitized ) !------------------------------------------------------------------------------------------------------------------------------- !< Sanitize arguments string. !< !< Substitute white spaces enclosed into string-arguments, i.e. 'string argument with spaces...' or !< \"string argument with spaces...\" with a safe equivalent for tokenization against white spaces, i.e. the finally tokenized !< string is string'argument'with'spaces... !< !< @note The white spaces are reintroduce later. !------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: argsin !< Arguments string. character ( * ), intent ( IN ) :: delimiter !< Delimiter enclosing string argument. character ( len = len_trim ( argsin )) :: sanitized !< Arguments string sanitized. character ( len = len_trim ( argsin )), allocatable :: tok (:) !< Arguments string tokens. integer ( I4P ) :: Nt !< Number of command line arguments passed. integer ( I4P ) :: t !< Counter. integer ( I4P ) :: tt !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- call tokenize ( strin = trim ( argsin ), delimiter = delimiter , toks = tok , Nt = Nt ) do t = 2 , Nt , 2 do tt = 1 , len_trim ( adjustl ( tok ( t ))) if ( tok ( t )( tt : tt ) == ' ' ) tok ( t )( tt : tt ) = \"'\" enddo enddo sanitized = '' do t = 1 , Nt sanitized = trim ( sanitized ) // \" \" // trim ( adjustl ( tok ( t ))) enddo sanitized = trim ( adjustl ( sanitized )) return !------------------------------------------------------------------------------------------------------------------------------- endfunction sanitize_args endsubroutine get_args_from_string subroutine get_args_from_invocation ( cli , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from CLI invocation. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. character ( max_val_len ) :: switch !< Switch name. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( cli % args )) deallocate ( cli % args ) Na = command_argument_count () if ( Na > 0 ) then #ifdef __GFORTRAN__ allocate ( cli % args ( 1 : Na )) #else aa = 0 find_longest_arg : do a = 1 , Na call get_command_argument ( a , switch ) aa = max ( aa , len_trim ( switch )) enddo find_longest_arg allocate ( character ( aa ) :: cli % args ( 1 : Na )) #endif get_args : do a = 1 , Na call get_command_argument ( a , switch ) cli % args ( a ) = trim ( adjustl ( switch )) enddo get_args endif call cli % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_args_from_invocation subroutine get_cla_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. class ( * ), intent ( INOUT ) :: val !< CLA value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( cli % error == 0. and . cli % clasg ( g )% called ) then if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( position )% error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_cli subroutine get_cla_list_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. class ( * ), intent ( INOUT ) :: val ( 1 :) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_cli subroutine get_cla_list_varying_R16P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R16P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P_cli subroutine get_cla_list_varying_R8P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P_cli subroutine get_cla_list_varying_R4P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P_cli subroutine get_cla_list_varying_I8P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P_cli subroutine get_cla_list_varying_I4P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P_cli subroutine get_cla_list_varying_I2P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I2P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P_cli subroutine get_cla_list_varying_I1P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I1P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P_cli subroutine get_cla_list_varying_logical_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, logical. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. logical , allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical_cli subroutine get_cla_list_varying_char_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, character. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char_cli function usage ( cli , g , pref , no_header , no_examples , no_epilog ) result ( usaged ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print correct usage of CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. integer ( I4P ), intent ( IN ) :: g !< Group index. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( IN ) :: no_examples !< Avoid insert examples to usage. logical , optional , intent ( IN ) :: no_epilog !< Avoid insert epilogue to usage. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len = :), allocatable :: usaged !< Usage string. logical :: no_headerd !< Avoid insert header to usage. logical :: no_examplesd !< Avoid insert examples to usage. logical :: no_epilogd !< Avoid insert epilogue to usage. integer ( I4P ) :: gi !< Counter. integer ( I4P ) :: e !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- no_headerd = . false . ; if ( present ( no_header )) no_headerd = no_header no_examplesd = . false . ; if ( present ( no_examples )) no_examplesd = no_examples no_epilogd = . false . ; if ( present ( no_epilog )) no_epilogd = no_epilog prefd = '' ; if ( present ( pref )) prefd = pref if ( g > 0 ) then ! usage of a specific command usaged = cli % clasg ( g )% usage ( pref = prefd , no_header = no_headerd ) else ! usage of whole CLI if ( no_headerd ) then usaged = '' else usaged = prefd // cli % help // cli % progname // ' ' // cli % signature () if ( cli % description /= '' ) usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // cli % description endif if ( cli % clasg ( 0 )% Na > 0 ) usaged = usaged // new_line ( 'a' ) // cli % clasg ( 0 )% usage ( pref = prefd , no_header = . true .) if ( size ( cli % clasg , dim = 1 ) > 1 ) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Commands:' do gi = 1 , size ( cli % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // cli % clasg ( gi )% group usaged = usaged // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // cli % clasg ( gi )% description enddo usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'For more detailed commands help try:' do gi = 1 , size ( cli % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // cli % progname // ' ' // cli % clasg ( gi )% group // ' -h,--help' enddo endif endif if ( allocated ( cli % examples ). and .(. not . no_examplesd )) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Examples:' do e = 1 , size ( cli % examples , dim = 1 ) usaged = usaged // new_line ( 'a' ) // prefd // '   ' // trim ( cli % examples ( e )) enddo endif if ( cli % epilog /= '' . and .(. not . no_epilogd )) usaged = usaged // new_line ( 'a' ) // prefd // cli % epilog return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage function signature ( cli ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLI signature. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = cli % clasg ( 0 )% signature () if ( size ( cli % clasg , dim = 1 ) > 1 ) then signd = signd // ' {' // cli % clasg ( 1 )% group do g = 2 , size ( cli % clasg , dim = 1 ) - 1 signd = signd // ',' // cli % clasg ( g )% group enddo signd = signd // '} ...' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature subroutine print_usage ( cli , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print correct usage of CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref write ( stdout , '(A)' ) cli % usage ( pref = prefd , g = 0 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_usage subroutine save_man_page ( cli , man_file , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save man page build on the CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: man_file !< Output file name for saving man page. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: man !< Man page. integer ( I4P ) :: idate ( 1 : 8 ) !< Integer array for handling the date. integer ( I4P ) :: e !< Counter. integer ( I4P ) :: u !< Unit file handler. character ( * ), parameter :: month ( 12 ) = [ \"Jan\" ,& \"Feb\" ,& \"Mar\" ,& \"Apr\" ,& \"May\" ,& \"Jun\" ,& \"Jul\" ,& \"Aug\" ,& \"Sep\" ,& \"Oct\" ,& \"Nov\" ,& \"Dec\" ] !< Months list. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call date_and_time ( values = idate ) man = '.TH ' // cli % progname // ' \"1\" \"' // month ( idate ( 2 )) // ' ' // trim ( adjustl ( strz ( 4 , idate ( 1 )))) // '\" \"version ' // cli % version // & '\" \"' // cli % progname // ' Manual\"' man = man // new_line ( 'a' ) // '.SH NAME' man = man // new_line ( 'a' ) // cli % progname // ' - manual page for ' // cli % progname // ' version ' // cli % version man = man // new_line ( 'a' ) // '.SH SYNOPSIS' man = man // new_line ( 'a' ) // '.B ' // cli % progname // new_line ( 'a' ) // trim ( adjustl ( cli % signature ())) if ( cli % description /= '' ) man = man // new_line ( 'a' ) // '.SH DESCRIPTION' // new_line ( 'a' ) // cli % description if ( cli % clasg ( 0 )% Na > 0 ) then man = man // new_line ( 'a' ) // '.SH OPTIONS' man = man // new_line ( 'a' ) // cli % usage ( no_header = . true ., no_examples = . true ., no_epilog = . true ., g = 0 ) endif if ( allocated ( cli % examples )) then man = man // new_line ( 'a' ) // '.SH EXAMPLES' man = man // new_line ( 'a' ) // '.PP' man = man // new_line ( 'a' ) // '.nf' man = man // new_line ( 'a' ) // '.RS' do e = 1 , size ( cli % examples , dim = 1 ) man = man // new_line ( 'a' ) // trim ( cli % examples ( e )) enddo man = man // new_line ( 'a' ) // '.RE' man = man // new_line ( 'a' ) // '.fi' man = man // new_line ( 'a' ) // '.PP' endif if ( cli % authors /= '' ) man = man // new_line ( 'a' ) // '.SH AUTHOR' // new_line ( 'a' ) // cli % authors if ( cli % license /= '' ) man = man // new_line ( 'a' ) // '.SH COPYRIGHT' // new_line ( 'a' ) // cli % license open ( newunit = u , file = trim ( adjustl ( man_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) man else write ( u , \"(A)\" ) man endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_man_page elemental subroutine assign_cli ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign two CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Interface ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Interface members if ( allocated ( rhs % clasg )) lhs % clasg = rhs % clasg if ( allocated ( rhs % examples )) lhs % examples = rhs % examples lhs % disable_hv = rhs % disable_hv return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_cli endmodule Data_Type_Command_Line_Interface","tags":"","loc":"sourcefile/data_type_command_line_interface.f90.html","title":"Data_Type_Command_Line_Interface.F90 – FOODIE"},{"text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program test_basic !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface ! Definition of Type_Command_Line_Interface. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: sval !< String value. real ( R8P ) :: rval !< Real value. real ( R8P ) :: prval !< Positional real value. integer ( I4P ) :: ival !< Integer value. integer ( I4P ) :: ieval !< Exclusive integer value. integer ( I4P ) :: envi !< Environment set integer value. logical :: bval !< Boolean value. logical :: vbval !< Valued-boolean value. integer ( I8P ) :: ilist ( 1 : 3 ) !< Integer list values. real ( R8P ), allocatable :: vlistR8P (:) !< Varying size real list values. real ( R4P ), allocatable :: vlistR4P (:) !< Varying size real list values. integer ( I8P ), allocatable :: vlistI8P (:) !< Varying size integer list values. integer ( I4P ), allocatable :: vlistI4P (:) !< Varying size integer list values. integer ( I2P ), allocatable :: vlistI2P (:) !< Varying size integer list values. integer ( I1P ), allocatable :: vlistI1P (:) !< Varying size integer list values. logical , allocatable :: vlistBool (:) !< Varying size boolean list values. character ( 10 ), allocatable :: vlistChar (:) !< Varying size character list values. character ( 99 ), allocatable :: garbage (:) !< Varying size character list for trailing garbage values. integer ( I4P ) :: error !< Error trapping flag. integer ( I4P ) :: l !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! initializing Command Line Interface call cli % init ( progname = 'test_basic' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & help = 'Usage: ' , & description = 'Toy program for testing FLAP' , & examples = [ \"test_basic -s 'Hello FLAP'                               \" , & \"test_basic -s 'Hello FLAP' -i -2 # printing error...     \" , & \"test_basic -s 'Hello FLAP' -i 3 -ie 1 # printing error...\" , & \"test_basic -s 'Hello FLAP' -i 3 -r 33.d0                 \" , & \"test_basic -s 'Hello FLAP' --integer_list 10 -3 87       \" , & \"test_basic -s 'Hello FLAP' --man_file FLAP.1             \" , & \"test_basic 33.0 -s 'Hello FLAP' -i 5                     \" , & \"test_basic --string 'Hello FLAP' --boolean               \" ],& epilog = new_line ( 'a' ) // \"And that's how to FLAP your life\" ) ! setting Command Line Argumenst call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer_ex' , switch_ab = '-ie' , help = 'Exclusive integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , exclude = '-ie' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) if ( error /= 0 ) stop call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--env' , switch_ab = '-e' , help = 'Environment input' , required = . false ., act = 'store' , def = '-1' , envvar = 'FLAP_NUM_INT' ,& error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--man_file' , help = 'Save manual into man_file' , required = . false ., act = 'store' , def = 'test_basic.1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listR8P' , switch_ab = '-vlR8P' , help = 'Varying size real R8P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listR4P' , switch_ab = '-vlR4P' , help = 'Varying size real R4P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1.0 2.0 3.0 4.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI8P' , switch_ab = '-vlI8P' , help = 'Varying size integer I8P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2 3 4 5 6 7 8' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI4P' , switch_ab = '-vlI4P' , help = 'Varying size integer I4P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2 3 4' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI2P' , switch_ab = '-vlI2P' , help = 'Varying size integer I2P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI1P' , switch_ab = '-vlI1P' , help = 'Varying size integer I1P list input' , required = . false ., act = 'store' ,& nargs = '+' , def = '1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listBool' , switch_ab = '-vlBool' , help = 'Varying size boolean list input' , required = . false ., act = 'store' ,& nargs = '*' , def = 'T F T T F' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listChar' , switch_ab = '-vlChar' , help = 'Varying size character list input' , required = . false ., act = 'store' ,& nargs = '*' , def = 'foo bar baz' , error = error ) if ( error /= 0 ) stop ! parsing Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) stop ! using Command Line Interface data to set test_basic behaviour call cli % get ( switch = '-s' , val = sval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = rval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = ival , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-ie' , val = ieval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-b' , val = bval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-bv' , val = vbval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-il' , val = ilist , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-e' , val = envi , error = error ) ; if ( error /= 0 ) stop call cli % get ( position = 1_I4P , val = prval , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlR8P' , val = vlistR8P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlR4P' , val = vlistR4P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI8P' , val = vlistI8P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI4P' , val = vlistI4P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI2P' , val = vlistI2P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI1P' , val = vlistI1P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlBool' , val = vlistBool , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlChar' , val = vlistChar , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '--' , val = garbage , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'test_basic has been called with the following arguments values:' print '(A)' , 'String              input = ' // trim ( adjustl ( sval )) print '(A)' , 'Real                input = ' // str ( n = rval ) print '(A)' , 'Integer             input = ' // str ( n = ival ) print '(A)' , 'Exclusive   integer input = ' // str ( n = ieval ) print '(A)' , 'Environment integer input = ' // str ( n = envi ) print '(A,L1)' , 'Boolean             input = ' , bval print '(A,L1)' , 'Valued boolean      input = ' , vbval print '(A)' , 'Positional real     input = ' // str ( n = prval ) print '(A)' , 'Integer list inputs:' do l = 1 , 3 print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = ilist ( l ))) enddo if ( allocated ( vlistR8P )) then print '(A)' , 'Varying size real R8P list inputs:' do l = 1 , size ( vlistR8P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistR8P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size real R8P list!' endif if ( allocated ( vlistR4P )) then print '(A)' , 'Varying size real R4P list inputs:' do l = 1 , size ( vlistR4P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistR4P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size real R4P list!' endif if ( allocated ( vlistI8P )) then print '(A)' , 'Varying size integer I8P list inputs:' do l = 1 , size ( vlistI8P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistI8P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I8P list!' endif if ( allocated ( vlistI4P )) then print '(A)' , 'Varying size integer I4P list inputs:' do l = 1 , size ( vlistI4P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistI4P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I4P list!' endif if ( allocated ( vlistI2P )) then print '(A)' , 'Varying size integer I2P list inputs:' do l = 1 , size ( vlistI2P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistI2P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I2P list!' endif if ( allocated ( vlistI1P )) then print '(A)' , 'Varying size integer I1P list inputs:' do l = 1 , size ( vlistI1P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistI1P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I1P list!' endif if ( allocated ( vlistBool )) then print '(A)' , 'Varying size boolean list inputs:' do l = 1 , size ( vlistBool ) print '(A,L1)' , '  Input(' // trim ( str (. true ., l )) // ') = ' , vlistBool ( l ) enddo else print '(A)' , 'Problems occuour with varying size boolean list!' endif if ( allocated ( vlistChar )) then print '(A)' , 'Varying size character list inputs:' do l = 1 , size ( vlistChar ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // vlistChar ( l ) enddo else print '(A)' , 'Problems occuour with varying size character list!' endif if ( allocated ( garbage )) then print '(A)' , 'You have used implicit \"--\" option for collecting list of \"trailing garbage\" values that are:' do l = 1 , size ( garbage ) print '(A)' , '  Garbage(' // trim ( str (. true ., l )) // ') = ' // garbage ( l ) enddo endif if ( cli % passed ( switch = '--man_file' )) then call cli % get ( switch = '--man_file' , val = sval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Saving man page' call cli % save_man_page ( error = error , man_file = trim ( adjustl ( sval ))) endif stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_basic","tags":"","loc":"sourcefile/test_basic.f90.html","title":"test_basic.f90 – FOODIE"},{"text":"Test FLAP for bad usage of choices option with logical Source Code !< Test FLAP for bad usage of choices option with logical program test_choices_logical !----------------------------------------------------------------------------------------------------------------------------------- !< Test FLAP for bad usage of choices option with logical !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision USE Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command Line Interface (CLI). logical :: vbval !< Valued-boolean value. integer ( I4P ) :: error !< Error trapping flag. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call cli % init ( progname = 'test_choices_logical' ) call cli % add ( switch = '--boolean-value' , switch_ab = '-bv' , help = 'A help message' , & required = . false ., def = '.false.' , choices = '.True.,.False.' , act = 'store' , error = error ) call cli % parse ( error = error ) call cli % get ( switch = '-bv' , val = vbval , error = error ) print \"(A)\" , \"Error code: \" // trim ( str (. true ., error )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_choices_logical","tags":"","loc":"sourcefile/test_choices_logical.f90.html","title":"test_choices_logical.f90 – FOODIE"},{"text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program test_nested !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface ! Definition of Type_Command_Line_Interface. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command Line Interface (CLI). logical :: authors_print !< Boolean value. character ( 500 ) :: message !< Message value. integer ( I4P ) :: error !< Error trapping flag. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- authors_print = . false . ! initializing Command Line Interface call cli % init ( progname = 'test_nested' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with nested commands' , & examples = [ 'test_nested                      ' , & 'test_nested -h                   ' , & 'test_nested init                 ' , & 'test_nested commit -m \"fix bug-1\"' , & 'test_nested tag -a \"v2.1.5\"      ' ]) ! set a Command Line Argument without a group to trigger authors names printing call cli % add ( switch = '--authors' , switch_ab = '-a' , help = 'Print authors names' , required = . false ., act = 'store_true' , def = '.false.' ) ! set Command Line Arguments Groups, i.e. commands call cli % add_group ( group = 'init' , description = 'fake init versioning' ) call cli % add_group ( group = 'commit' , description = 'fake commit changes to current branch' ) call cli % add_group ( group = 'tag' , description = 'fake tag current commit' ) call cli % set_mutually_exclusive_groups ( group1 = 'init' , group2 = 'commit' ) ! set Command Line Arguments of commit command call cli % add ( group = 'commit' , switch = '--message' , switch_ab = '-m' , help = 'Commit message' , required = . false ., act = 'store' , def = '' ) ! set Command Line Arguments of commit command call cli % add ( group = 'tag' , switch = '--annotate' , switch_ab = '-a' , help = 'Tag annotation' , required = . false ., act = 'store' , def = '' ) ! parsing Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) then print '(A)' , 'Error code: ' // trim ( str ( n = error )) stop endif ! using Command Line Interface data to trigger program behaviour call cli % get ( switch = '-a' , val = authors_print , error = error ) ; if ( error /= 0 ) stop if ( authors_print ) then print '(A)' , 'Authors: ' // cli % authors elseif ( cli % run_command ( 'init' )) then print '(A)' , 'init (fake) versioning' elseif ( cli % run_command ( 'commit' )) then call cli % get ( group = 'commit' , switch = '-m' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'commit changes to current branch with message \"' // trim ( message ) // '\"' elseif ( cli % run_command ( 'tag' )) then call cli % get ( group = 'tag' , switch = '-a' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'tag current branch with message \"' // trim ( message ) // '\"' else print '(A)' , 'cowardly you are doing nothing... try at least \"-h\" option!' endif stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_nested","tags":"","loc":"sourcefile/test_nested.f90.html","title":"test_nested.f90 – FOODIE"},{"text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program test_string !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface ! Definition of Type_Command_Line_Interface. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: sval !< String value. real ( R8P ) :: rval !< Real value. real ( R8P ) :: prval !< Positional real value. integer ( I4P ) :: ival !< Integer value. integer ( I4P ) :: ieval !< Exclusive integer value. logical :: bval !< Boolean value. logical :: vbval !< Valued-boolean value. integer ( I8P ) :: ilist ( 1 : 3 ) !< Integer list values. integer ( I4P ) :: error !< Error trapping flag. integer ( I4P ) :: l !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! initializing Command Line Interface call cli % init ( progname = 'test_sting' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with a fake string input' , & examples = [ \"test_sting -s 'Hello FLAP'                               \" , & \"test_sting -s 'Hello FLAP' -i -2 # printing error...     \" , & \"test_sting -s 'Hello FLAP' -i 3 -ie 1 # printing error...\" , & \"test_sting -s 'Hello FLAP' -i 3 -r 33.d0                 \" , & \"test_sting -s 'Hello FLAP' --integer_list 10 -3 87       \" , & \"test_sting 33.0 -s 'Hello FLAP' -i 5                     \" , & \"test_sting --string 'Hello FLAP' --boolean               \" ],& epilog = new_line ( 'a' ) // \"And that's how to FLAP your life\" ) ! setting Command Line Argumenst call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--integer_ex' , switch_ab = '-ie' , help = 'Exclusive integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , exclude = '-ie' , error = error ) call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) ! parsing Command Line Interface call cli % parse ( args = \"-s 'FAKE INVOCATION FROM STRING' --integer_list 10 -3 87\" , error = error ) if ( error /= 0 ) stop ! using Command Line Interface data to set test_string behaviour call cli % get ( switch = '-s' , val = sval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = rval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = ival , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-ie' , val = ieval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-b' , val = bval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-bv' , val = vbval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-il' , val = ilist , error = error ) ; if ( error /= 0 ) stop call cli % get ( position = 1_I4P , val = prval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'test_string has been called with the following arguments values:' print '(A)' , 'String            input = ' // trim ( adjustl ( sval )) print '(A)' , 'Real              input = ' // str ( n = rval ) print '(A)' , 'Integer           input = ' // str ( n = ival ) print '(A)' , 'Exclusive integer input = ' // str ( n = ieval ) print '(A,L1)' , 'Boolean           input = ' , bval print '(A,L1)' , 'Valued boolean    input = ' , vbval print '(A)' , 'Positional real   input = ' // str ( n = prval ) print '(A)' , 'Integer list inputs:' do l = 1 , 3 print '(A)' , 'Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = ilist ( l ))) enddo stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_string","tags":"","loc":"sourcefile/test_string.f90.html","title":"test_string.f90 – FOODIE"},{"text":"Testing program for IR_Precision, Pure Fortran (2003+) library for ensuring codes portability Source Code !< Testing program for IR_Precision, Pure Fortran (2003+) library for ensuring codes portability program Test_Driver !----------------------------------------------------------------------------------------------------------------------------------- !< Testing program for IR_Precision, Pure Fortran (2003+) library for ensuring codes portability !< !<### Usage !<```bash !< ./Test_Driver !<``` !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision USE , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! initialize IR_Precision call IR_Init ! print main IR_Precision values call IR_Print ( unit = stdout ) print \"(A)\" , '' print \"(A)\" , 'Testing IR_Precision tools' print \"(A)\" , 'Casting real-to-string: ' // str ( n = 1._R8P ) print \"(A)\" , 'Casting integer-to-string: ' // str ( n = 11_I8P ) print \"(A,\" // FR8P // \")\" , 'Casting string-to-real: ' , cton ( str = '2.2d0' , knd = 1._R8P ) print \"(A,\" // FI4P // \")\" , 'Casting integer-to-string: ' , cton ( str = '43' , knd = 1_I4P ) print \"(A)\" , 'Casting integer-to-string with zero padding: ' // trim ( strz ( nz_pad = 3 , n = 34_I8P )) ! print \"(A)\", 'Casting real-to-bit_string: '//bstr(n=1._R4P) print \"(A)\" , 'Casting integer-to-bit_string: ' // bstr ( n = 1_I4P ) ! print \"(A,\"//FR4P//\")\", 'Casting bit_string-to-real: ',bcton(bstr='00111111100000000000000000000000',knd=1._R4P) print \"(A,\" // FI4P // \")\" , 'Casting bit_string-to-integer: ' , bcton ( bstr = '00000000000000000000000000000001' , knd = 1_I4P ) print \"(A)\" , 'Number of digit of 1023: ' // str ( n = digit ( 1023_I4P )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram Test_Driver","tags":"","loc":"sourcefile/test_driver.f90~2.html","title":"Test_Driver.f90 – FOODIE"},{"text":"Source Code module type_weno_interpolator !----------------------------------------------------------------------------------------------------------------------------------- !< Abstract WENO interpolator object, !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : I_P , R_P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: weno_interpolator , weno_constructor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , abstract :: weno_constructor !< Abstract type used for create new concrete WENO interpolators. !< !< @note Every concrete WENO interpolator implementations must define their own constructor type. private endtype weno_constructor type , abstract :: weno_interpolator !< WENO interpolator object. !< !< @note Do not implement any real interpolator: provide the interface for the different interpolators implemented. private contains procedure ( abstract_destructor ), pass ( self ), deferred , public :: destroy procedure ( abstract_constructor ), pass ( self ), deferred , public :: create procedure ( abstract_description ), pass ( self ), deferred , public :: description procedure ( abstract_interpolate ), pass ( self ), deferred , public :: interpolate endtype weno_interpolator abstract interface elemental subroutine abstract_destructor ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy a WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- import :: weno_interpolator class ( weno_interpolator ), intent ( INOUT ) :: self !< WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine abstract_destructor subroutine abstract_constructor ( self , constructor ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create a WENO interpolator. !< !< @note Before call this method a concrete constructor must be instantiated. !--------------------------------------------------------------------------------------------------------------------------------- import :: weno_interpolator import :: weno_constructor class ( weno_interpolator ), intent ( INOUT ) :: self !< WENO interpolator. class ( weno_constructor ), intent ( IN ) :: constructor !< WENO constructor. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine abstract_constructor pure subroutine abstract_description ( self , string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string describing a WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- import :: weno_interpolator class ( weno_interpolator ), intent ( IN ) :: self !< WENO interpolator. character ( len = :), allocatable , intent ( OUT ) :: string !< String returned. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine abstract_description pure subroutine abstract_interpolate ( self , S , stencil , location , interpolation ) !--------------------------------------------------------------------------------------------------------------------------------- !< Interpolate the stecil input values computing the actual interpolation. !--------------------------------------------------------------------------------------------------------------------------------- import :: weno_interpolator , I_P , R_P class ( weno_interpolator ), intent ( IN ) :: self !< WENO interpolator. integer ( I_P ), intent ( IN ) :: S !< Number of stencils used. real ( R_P ), intent ( IN ) :: stencil ( 1 :, 1 - S :) !< Stencil used for the interpolation, [1:2, 1-S:-1+S]. character ( * ), intent ( IN ) :: location !< Location of interpolated value(s): central, left, right, both. real ( R_P ), intent ( OUT ) :: interpolation ( 1 :) !< Result of the interpolation, [1:2]. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine abstract_interpolate endinterface !----------------------------------------------------------------------------------------------------------------------------------- endmodule type_weno_interpolator","tags":"","loc":"sourcefile/type_weno_interpolator.f90.html","title":"type_weno_interpolator.f90 – FOODIE"},{"text":"Source Code module type_weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !< Module providing upwind biased WENO interpolator object and constructor, !< !< @note The provided WENO interpolator implements the *Efficient Implementation of Weighted ENO Schemes*, !< Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : I_P , R_P , str use type_weno_interpolator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: weno_interpolator_upwind , weno_constructor_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( weno_constructor ) :: weno_constructor_upwind !< Upwind biased WENO interpolator constructor, !< !< @note The constructed WENO interpolator implements the *Efficient Implementation of Weighted ENO Schemes*, !< Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130. integer ( I_P ) :: S = 0 !< Stencils dimension. real ( R_P ) :: eps = 1 0._R_P ** ( - 6 ) !< Parameter for avoiding divided by zero when computing smoothness indicators. endtype weno_constructor_upwind interface weno_constructor_upwind procedure weno_constructor_upwind_init endinterface type , extends ( weno_interpolator ) :: weno_interpolator_upwind !< Upwind biased WENO interpolator object, !< !< @note The WENO interpolator implemented is the *Efficient Implementation of Weighted ENO Schemes*, !< Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130. !< !< @note The supported accuracy formal order are: 3rd, 5th, 7th corresponding to use 2, 3, 4 stencils composed of 2, 3, 4 values, !< respectively. private integer ( I_P ) :: S = 0_I_P !< Stencil dimension. real ( R_P ) :: eps = 0._R_P !< Parameter for avoiding divided by zero when computing smoothness indicators. real ( R_P ), allocatable :: weights_opt (:,:) !< Optimal weights                    [1:2,0:S-1]. real ( R_P ), allocatable :: poly_coef (:,:,:) !< Polynomials coefficients           [1:2,0:S-1,0:S-1]. real ( R_P ), allocatable :: smooth_coef (:,:,:) !< Smoothness indicators coefficients [0:S-1,0:S-1,0:S-1]. contains ! public methods procedure , pass ( self ), public :: destroy procedure , pass ( self ), public :: create procedure , pass ( self ), public :: description procedure , pass ( self ), public :: interpolate generic , public :: assignment ( = ) => assign_interpolator !< Overloading = assignament. ! private methods procedure , pass ( lhs ), private :: assign_interpolator !< Assignament operator. final :: finalize endtype weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- contains ! weno_constructor_upwind elemental function weno_constructor_upwind_init ( S , eps ) result ( constructor ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create (initialize) the WENO interpolator. !< !< @note For this class of interpolators it is sufficient to provide the maximum number of stencils used (that is also the !< dimension, i.e. number of values, of each stencil). During the actual interpolation phase the client code can specify, for each !< intepolation a different number of stencil bounded by this maximum value. This is useful for coupling the interpolator with !< algorithm like the Recursive Order Reduction (ROR) strategy. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: S !< Maximum stencils dimension. real ( R_P ), intent ( IN ), optional :: eps !< Parameter for avoiding divided by zero when computing smoothness indicators. type ( weno_constructor_upwind ) :: constructor !<WENO constructor. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- constructor % S = S if ( present ( eps )) constructor % eps = eps return !--------------------------------------------------------------------------------------------------------------------------------- endfunction weno_constructor_upwind_init ! weno_interpolator_upwind ! public methods elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( INOUT ) :: self !< WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % S = 0_I_P self % eps = 0._R_P if ( allocated ( self % weights_opt )) deallocate ( self % weights_opt ) if ( allocated ( self % poly_coef )) deallocate ( self % poly_coef ) if ( allocated ( self % smooth_coef )) deallocate ( self % smooth_coef ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine create ( self , constructor ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( INOUT ) :: self !< WENO interpolator. class ( weno_constructor ), intent ( IN ) :: constructor !< WENO constructor. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( constructor ) type is ( weno_constructor_upwind ) call self % destroy self % S = constructor % S self % eps = constructor % eps allocate ( self % weights_opt ( 1 : 2 , 0 : self % S - 1 )) allocate ( self % poly_coef ( 1 : 2 , 0 : self % S - 1 , 0 : self % S - 1 )) allocate ( self % smooth_coef ( 0 : self % S - 1 , 0 : self % S - 1 , 0 : self % S - 1 )) call set_weights_optimal call set_polynomial_coefficients call set_smoothness_indicators_coefficients endselect return !--------------------------------------------------------------------------------------------------------------------------------- contains subroutine set_weights_optimal () !------------------------------------------------------------------------------------------------------------------------------- !< Set the values of optimial weights. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- select case ( self % S ) case ( 2 ) ! 3rd order ! 1 => left interface (i-1/2) self % weights_opt ( 1 , 0 ) = 2._R_P / 3._R_P ! stencil 0 self % weights_opt ( 1 , 1 ) = 1._R_P / 3._R_P ! stencil 1 ! 2 => right interface (i+1/2) self % weights_opt ( 2 , 0 ) = 1._R_P / 3._R_P ! stencil 0 self % weights_opt ( 2 , 1 ) = 2._R_P / 3._R_P ! stencil 1 case ( 3 ) ! 5th order ! 1 => left interface (i-1/2) self % weights_opt ( 1 , 0 ) = 0.3_R_P ! stencil 0 self % weights_opt ( 1 , 1 ) = 0.6_R_P ! stencil 1 self % weights_opt ( 1 , 2 ) = 0.1_R_P ! stencil 2 ! 2 => right interface (i+1/2) self % weights_opt ( 2 , 0 ) = 0.1_R_P ! stencil 0 self % weights_opt ( 2 , 1 ) = 0.6_R_P ! stencil 1 self % weights_opt ( 2 , 2 ) = 0.3_R_P ! stencil 2 case ( 4 ) ! 7th order ! 1 => left interface (i-1/2) self % weights_opt ( 1 , 0 ) = 4._R_P / 3 5._R_P ! stencil 0 self % weights_opt ( 1 , 1 ) = 1 8._R_P / 3 5._R_P ! stencil 1 self % weights_opt ( 1 , 2 ) = 1 2._R_P / 3 5._R_P ! stencil 2 self % weights_opt ( 1 , 3 ) = 1._R_P / 3 5._R_P ! stencil 3 ! 2 => right interface (i+1/2) self % weights_opt ( 2 , 0 ) = 1._R_P / 3 5._R_P ! stencil 0 self % weights_opt ( 2 , 1 ) = 1 2._R_P / 3 5._R_P ! stencil 1 self % weights_opt ( 2 , 2 ) = 1 8._R_P / 3 5._R_P ! stencil 2 self % weights_opt ( 2 , 3 ) = 4._R_P / 3 5._R_P ! stencil 3 endselect return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_weights_optimal subroutine set_polynomial_coefficients () !------------------------------------------------------------------------------------------------------------------------------- !< Set the values of polynomial_coefficient. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- associate ( coef => self % poly_coef ) select case ( self % S ) case ( 2 ) ! 3rd order ! 1 => left interface (i-1/2) !  cell  0               ;    cell  1 coef ( 1 , 0 , 0 ) = 0.5_R_P ; coef ( 1 , 1 , 0 ) = 0.5_R_P ! stencil 0 coef ( 1 , 0 , 1 ) = - 0.5_R_P ; coef ( 1 , 1 , 1 ) = 1.5_R_P ! stencil 1 ! 2 => right interface (i+1/2) !  cell  0               ;    cell  1 coef ( 2 , 0 , 0 ) = 1.5_R_P ; coef ( 2 , 1 , 0 ) = - 0.5_R_P ! stencil 0 coef ( 2 , 0 , 1 ) = 0.5_R_P ; coef ( 2 , 1 , 1 ) = 0.5_R_P ! stencil 1 case ( 3 ) ! 5th order ! 1 => left interface (i-1/2) !  cell  0                     ;    cell  1                     ;    cell  2 coef ( 1 , 0 , 0 ) = 1._R_P / 3._R_P ; coef ( 1 , 1 , 0 ) = 5._R_P / 6._R_P ; coef ( 1 , 2 , 0 ) = - 1._R_P / 6._R_P ! stencil 0 coef ( 1 , 0 , 1 ) = - 1._R_P / 6._R_P ; coef ( 1 , 1 , 1 ) = 5._R_P / 6._R_P ; coef ( 1 , 2 , 1 ) = 1._R_P / 3._R_P ! stencil 1 coef ( 1 , 0 , 2 ) = 1._R_P / 3._R_P ; coef ( 1 , 1 , 2 ) = - 7._R_P / 6._R_P ; coef ( 1 , 2 , 2 ) = 1 1._R_P / 6._R_P ! stencil 2 ! 2 => right interface (i+1/2) !  cell  0                     ;    cell  1                     ;    cell  2 coef ( 2 , 0 , 0 ) = 1 1._R_P / 6._R_P ; coef ( 2 , 1 , 0 ) = - 7._R_P / 6._R_P ; coef ( 2 , 2 , 0 ) = 1._R_P / 3._R_P ! stencil 0 coef ( 2 , 0 , 1 ) = 1._R_P / 3._R_P ; coef ( 2 , 1 , 1 ) = 5._R_P / 6._R_P ; coef ( 2 , 2 , 1 ) = - 1._R_P / 6._R_P ! stencil 1 coef ( 2 , 0 , 2 ) = - 1._R_P / 6._R_P ; coef ( 2 , 1 , 2 ) = 5._R_P / 6._R_P ; coef ( 2 , 2 , 2 ) = 1._R_P / 3._R_P ! stencil 2 case ( 4 ) ! 7th order ! 1 => left interface (i-1/2) !  cell  0                 ;   cell  1                 ;   cell  2                  ;   cell  3 coef ( 1 , 0 , 0 ) = 1._R_P / 4._R_P ; coef ( 1 , 1 , 0 ) = 1 3._R_P / 1 2._R_P ; coef ( 1 , 2 , 0 ) = - 5._R_P / 1 2._R_P ; coef ( 1 , 3 , 0 ) = 1._R_P / 1 2._R_P ! sten 0 coef ( 1 , 0 , 1 ) =- 1._R_P / 1 2._R_P ; coef ( 1 , 1 , 1 ) = 7._R_P / 1 2._R_P ; coef ( 1 , 2 , 1 ) = 7._R_P / 1 2._R_P ; coef ( 1 , 3 , 1 ) =- 1._R_P / 1 2._R_P ! sten 1 coef ( 1 , 0 , 2 ) = 1._R_P / 1 2._R_P ; coef ( 1 , 1 , 2 ) =- 5._R_P / 1 2._R_P ; coef ( 1 , 2 , 2 ) = 1 3._R_P / 1 2._R_P ; coef ( 1 , 3 , 2 ) = 1._R_P / 4._R_P ! sten 2 coef ( 1 , 0 , 3 ) =- 1._R_P / 4._R_P ; coef ( 1 , 1 , 3 ) = 1 3._R_P / 1 2._R_P ; coef ( 1 , 2 , 3 ) =- 2 3._R_P / 1 2._R_P ; coef ( 1 , 3 , 3 ) = 2 5._R_P / 1 2._R_P ! sten 3 ! 2 => right interface (i+1/2) !  cell  0                 ;   cell  1                  ;   cell  2                 ;   cell  3 coef ( 2 , 0 , 0 ) = 2 5._R_P / 1 2._R_P ; coef ( 2 , 1 , 0 ) =- 2 3._R_P / 1 2._R_P ; coef ( 2 , 2 , 0 ) = 1 3._R_P / 1 2._R_P ; coef ( 2 , 3 , 0 ) =- 1._R_P / 4._R_P ! sten 0 coef ( 2 , 0 , 1 ) = 1._R_P / 4._R_P ; coef ( 2 , 1 , 1 ) = 1 3._R_P / 1 2._R_P ; coef ( 2 , 2 , 1 ) =- 5._R_P / 1 2._R_P ; coef ( 2 , 3 , 1 ) = 1._R_P / 1 2._R_P ! sten 1 coef ( 2 , 0 , 2 ) =- 1._R_P / 1 2._R_P ; coef ( 2 , 1 , 2 ) = 7._R_P / 1 2._R_P ; coef ( 2 , 2 , 2 ) = 7._R_P / 1 2._R_P ; coef ( 2 , 3 , 2 ) =- 1._R_P / 1 2._R_P ! sten 2 coef ( 2 , 0 , 3 ) = 1._R_P / 1 2._R_P ; coef ( 2 , 1 , 3 ) = - 5._R_P / 1 2._R_P ; coef ( 2 , 2 , 3 ) = 1 3._R_P / 1 2._R_P ; coef ( 2 , 3 , 3 ) = 1._R_P / 4._R_P ! sten 3 endselect endassociate return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_polynomial_coefficients subroutine set_smoothness_indicators_coefficients () !------------------------------------------------------------------------------------------------------------------------------- !< Set the values of smoothness indicators coefficients. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- associate ( coef => self % smooth_coef ) select case ( self % S ) case ( 2 ) ! 3rd order ! stencil 0 !      i*i             ;       (i-1)*i coef ( 0 , 0 , 0 ) = 1._R_P ; coef ( 1 , 0 , 0 ) = - 2._R_P !      /               ;       (i-1)*(i-1) coef ( 0 , 1 , 0 ) = 0._R_P ; coef ( 1 , 1 , 0 ) = 1._R_P ! stencil 1 !     (i+1)*(i+1)      ;       (i+1)*i coef ( 0 , 0 , 1 ) = 1._R_P ; coef ( 1 , 0 , 1 ) = - 2._R_P !      /               ;        i*i coef ( 0 , 1 , 1 ) = 0._R_P ; coef ( 1 , 1 , 1 ) = 1._R_P case ( 3 ) ! 5th order ! stencil 0 !      i*i                      ;       (i-1)*i                   ;       (i-2)*i coef ( 0 , 0 , 0 ) = 1 0._R_P / 3._R_P ; coef ( 1 , 0 , 0 ) = - 3 1._R_P / 3._R_P ; coef ( 2 , 0 , 0 ) = 1 1._R_P / 3._R_P !      /                        ;       (i-1)*(i-1)               ;       (i-2)*(i-1) coef ( 0 , 1 , 0 ) = 0._R_P ; coef ( 1 , 1 , 0 ) = 2 5._R_P / 3._R_P ; coef ( 2 , 1 , 0 ) = - 1 9._R_P / 3._R_P !      /                        ;        /                        ;       (i-2)*(i-2) coef ( 0 , 2 , 0 ) = 0._R_P ; coef ( 1 , 2 , 0 ) = 0._R_P ; coef ( 2 , 2 , 0 ) = 4._R_P / 3._R_P ! stencil 1 !     (i+1)*(i+1)               ;        i*(i+1)                  ;       (i-1)*(i+1) coef ( 0 , 0 , 1 ) = 4._R_P / 3._R_P ; coef ( 1 , 0 , 1 ) = - 1 3._R_P / 3._R_P ; coef ( 2 , 0 , 1 ) = 5._R_P / 3._R_P !      /                        ;        i*i                      ;       (i-1)*i coef ( 0 , 1 , 1 ) = 0._R_P ; coef ( 1 , 1 , 1 ) = 1 3._R_P / 3._R_P ; coef ( 2 , 1 , 1 ) = - 1 3._R_P / 3._R_P !      /                        ;        /                        ;       (i-1)*(i-1) coef ( 0 , 2 , 1 ) = 0._R_P ; coef ( 1 , 2 , 1 ) = 0._R_P ; coef ( 2 , 2 , 1 ) = 4._R_P / 3._R_P ! stencil 2 !     (i+2)*(i+2)               ;       (i+1)*(i+2)               ;        i*(i+2) coef ( 0 , 0 , 2 ) = 4._R_P / 3._R_P ; coef ( 1 , 0 , 2 ) = - 1 9._R_P / 3._R_P ; coef ( 2 , 0 , 2 ) = 1 1._R_P / 3._R_P !      /                        ;       (i+1)*(i+1)               ;        i*(i+1) coef ( 0 , 1 , 2 ) = 0._R_P ; coef ( 1 , 1 , 2 ) = 2 5._R_P / 3._R_P ; coef ( 2 , 1 , 2 ) = - 3 1._R_P / 3._R_P !      /                        ;        /                        ;        i*i coef ( 0 , 2 , 2 ) = 0._R_P ; coef ( 1 , 2 , 2 ) = 0._R_P ; coef ( 2 , 2 , 2 ) = 1 0._R_P / 3._R_P case ( 4 ) ! 7th order ! stencil 0 !      i*i                ;       (i-1)*i             ;       (i-2)*i              ;       (i-3)*i coef ( 0 , 0 , 0 ) = 210 7._R_P ; coef ( 1 , 0 , 0 ) =- 940 2._R_P ; coef ( 2 , 0 , 0 ) = 704 2._R_P ; coef ( 3 , 0 , 0 ) = - 185 4._R_P !      /                  ;       (i-1)*(i-1)         ;       (i-2)*(i-1)          ;       (i-3)*(i-1) coef ( 0 , 1 , 0 ) = 0._R_P ; coef ( 1 , 1 , 0 ) = 1100 3._R_P ; coef ( 2 , 1 , 0 ) =- 1724 6._R_P ; coef ( 3 , 1 , 0 ) = 464 2._R_P !      /                  ;        /                  ;       (i-2)*(i-2)          ;       (i-3)*(i-2) coef ( 0 , 2 , 0 ) = 0._R_P ; coef ( 1 , 2 , 0 ) = 0._R_P ; coef ( 2 , 2 , 0 ) = 704 3._R_P ; coef ( 3 , 2 , 0 ) = - 388 2._R_P !      /                  ;        /                  ;        /                   ;       (i-3)*(i-3) coef ( 0 , 3 , 0 ) = 0._R_P ; coef ( 1 , 3 , 0 ) = 0._R_P ; coef ( 2 , 3 , 0 ) = 0._R_P ; coef ( 3 , 3 , 0 ) = 54 7._R_P ! stencil 1 !     (i+1)*(i+1)         ;        i*(i+1)            ;       (i-1)*(i+1)          ;       (i-2)*(i+1) coef ( 0 , 0 , 1 ) = 54 7._R_P ; coef ( 1 , 0 , 1 ) =- 252 2._R_P ; coef ( 2 , 0 , 1 ) = 192 2._R_P ; coef ( 3 , 0 , 1 ) = - 49 4._R_P !       /                 ;          i*i              ;       (i-1)*i              ;       (i-2)*i coef ( 0 , 1 , 1 ) = 0._R_P ; coef ( 1 , 1 , 1 ) = 344 3._R_P ; coef ( 2 , 1 , 1 ) = - 596 6._R_P ; coef ( 3 , 1 , 1 ) = 160 2._R_P !       /                 ;          /                ;       (i-1)*(i-1)          ;       (i-2)*(i-1) coef ( 0 , 2 , 1 ) = 0._R_P ; coef ( 1 , 2 , 1 ) = 0._R_P ; coef ( 2 , 2 , 1 ) = 284 3._R_P ; coef ( 3 , 2 , 1 ) = - 164 2._R_P !       /                 ;          /                ;        /                   ;       (i-2)*(i-2) coef ( 0 , 3 , 1 ) = 0._R_P ; coef ( 1 , 3 , 1 ) = 0._R_P ; coef ( 2 , 3 , 1 ) = 0._R_P ; coef ( 3 , 3 , 1 ) = 26 7._R_P ! stencil 2 !     (i+2)*(i+2)         ;       (i+1)*(i+2)         ;            i*(i+2)         ;       (i-1)*(i+2) coef ( 0 , 0 , 2 ) = 26 7._R_P ; coef ( 1 , 0 , 2 ) =- 164 2._R_P ; coef ( 2 , 0 , 2 ) = 160 2._R_P ; coef ( 3 , 0 , 2 ) = - 49 4._R_P !      /                  ;       (i+1)*(i+1)         ;        i*(i+1)             ;       (i-1)*(i+1) coef ( 0 , 1 , 2 ) = 0._R_P ; coef ( 1 , 1 , 2 ) = 284 3._R_P ; coef ( 2 , 1 , 2 ) = - 596 6._R_P ; coef ( 3 , 1 , 2 ) = 192 2._R_P !      /                  ;        /                  ;        i*i                 ;       (i-1)*i coef ( 0 , 2 , 2 ) = 0._R_P ; coef ( 1 , 2 , 2 ) = 0._R_P ; coef ( 2 , 2 , 2 ) = 344 3._R_P ; coef ( 3 , 2 , 2 ) = - 252 2._R_P !      /                  ;        /                  ;        /                   ;       (i-1)*(i-1) coef ( 0 , 3 , 2 ) = 0._R_P ; coef ( 1 , 3 , 2 ) = 0._R_P ; coef ( 2 , 3 , 2 ) = 0._R_P ; coef ( 3 , 3 , 2 ) = 54 7._R_P ! stencil 3 !     (i+3)*(i+3)         ;       (i+2)*(i+3)         ;           (i+1)*(i+3)      ;        i*(i+3) coef ( 0 , 0 , 3 ) = 54 7._R_P ; coef ( 1 , 0 , 3 ) =- 388 2._R_P ; coef ( 2 , 0 , 3 ) = 464 2._R_P ; coef ( 3 , 0 , 3 ) = - 185 4._R_P !      /                  ;       (i+2)*(i+2)         ;       (i+1)*(i+2)          ;        i*(i+2) coef ( 0 , 1 , 3 ) = 0._R_P ; coef ( 1 , 1 , 3 ) = 704 3._R_P ; coef ( 2 , 1 , 3 ) =- 1724 6._R_P ; coef ( 3 , 1 , 3 ) = 704 2._R_P !      /                  ;        /                  ;       (i+1)*(i+1)          ;        i*(i+1) coef ( 0 , 2 , 3 ) = 0._R_P ; coef ( 1 , 2 , 3 ) = 0._R_P ; coef ( 2 , 2 , 3 ) = 1100 3._R_P ; coef ( 3 , 2 , 3 ) = - 940 2._R_P !      /                  ;        /                  ;        /                   ;        i*i coef ( 0 , 3 , 3 ) = 0._R_P ; coef ( 1 , 3 , 3 ) = 0._R_P ; coef ( 2 , 3 , 3 ) = 0._R_P ; coef ( 3 , 3 , 3 ) = 210 7._R_P endselect endassociate return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_smoothness_indicators_coefficients endsubroutine create pure subroutine description ( self , string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string describing the WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( IN ) :: self !< WENO interpolator. character ( len = :), allocatable , intent ( OUT ) :: string !< String returned. character ( len = 1 ) :: dummy !< Dummy string. character ( len = 1 ), parameter :: nl = new_line ( 'a' ) !< New line character. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- string = 'WENO upwind-biased interpolator' // nl string = string // '  Based on the scheme proposed by Jiang and Shu \"Efficient Implementation of Weighted ENO Schemes\", see ' // & 'JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130' // nl string = string // '  Provide a formal order of accuracy equals to: ' // trim ( str (. true ., 2 * self % S - 1 )) // nl string = string // '  Use ' // trim ( str (. true ., self % S )) // ' stencils composed by ' // trim ( str (. true ., self % S )) // ' values' // nl string = string // '  The eps value used for avoiding division by zero is ' // trim ( str (. true ., self % eps )) // nl string = string // '  The \"interpolate\" method has the following public API' // nl string = string // '    interpolate(S, stencil, location, interpolation)' // nl string = string // '  where:' // nl string = string // '    S: integer(I_P), intent(IN), the number of stencils actually used' // nl string = string // '    stencil(1:, 1-S:-1+S): real(R_P), intent(IN), the stencils used' // nl string = string // '    location: character(*), intent(IN), the location of interpolation {left, right, both}' // nl string = string // '    interpolation(1:, 1-S:-1+S): realR_P, intent(OUT), the interpolated values' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine description pure subroutine interpolate ( self , S , stencil , location , interpolation ) !--------------------------------------------------------------------------------------------------------------------------------- !< Interpolate the stecil input values computing the actual interpolation. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( IN ) :: self !< WENO interpolator. integer , intent ( IN ) :: S !< Number of stencils actually used. real ( R_P ), intent ( IN ) :: stencil ( 1 :, 1 - S :) !< Stencil used for the interpolation, [1:2, 1-S:-1+S]. character ( * ), intent ( IN ) :: location !< Location of interpolated value(s): left, right, both. real ( R_P ), intent ( OUT ) :: interpolation ( 1 :) !< Result of the interpolation, [1:2]. real ( R_P ) :: polynomials ( 1 : 2 , 0 : S - 1 ) !< Polynomial reconstructions. real ( R_P ) :: weights ( 1 : 2 , 0 : S - 1 ) !< Weights of the stencils. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( location ) case ( 'both' , 'b' ) call compute_polynomials ( f1 = 1_I_P , f2 = 2_I_P , ff = 0_I_P , polynomials = polynomials ) call compute_weights ( f1 = 1_I_P , f2 = 2_I_P , ff = 0_I_P , weights = weights ) call compute_convolution ( f1 = 1_I_P , f2 = 2_I_P , ff = 0_I_P , interpolation = interpolation ) case ( 'left' , 'l' ) call compute_polynomials ( f1 = 1_I_P , f2 = 1_I_P , ff = 0_I_P , polynomials = polynomials ) call compute_weights ( f1 = 1_I_P , f2 = 1_I_P , ff = 0_I_P , weights = weights ) call compute_convolution ( f1 = 1_I_P , f2 = 1_I_P , ff = 0_I_P , interpolation = interpolation ) case ( 'right' , 'r' ) call compute_polynomials ( f1 = 2_I_P , f2 = 2_I_P , ff =- 1_I_P , polynomials = polynomials ) call compute_weights ( f1 = 2_I_P , f2 = 2_I_P , ff =- 1_I_P , weights = weights ) call compute_convolution ( f1 = 2_I_P , f2 = 2_I_P , ff =- 1_I_P , interpolation = interpolation ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- contains pure subroutine compute_polynomials ( f1 , f2 , ff , polynomials ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute the polynomials reconstructions. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: f1 , f2 , ff !< Faces to be computed. real ( R_P ), intent ( OUT ) :: polynomials ( 1 :, 0 :) !< Polynomial reconstructions. integer ( I_P ) :: s1 , s2 , f !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- polynomials = 0. do s1 = 0 , S - 1 ! stencils loop do s2 = 0 , S - 1 ! values loop do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) polynomials ( f , s1 ) = polynomials ( f , s1 ) + self % poly_coef ( f , s2 , s1 ) * stencil ( f + ff , - s2 + s1 ) enddo enddo enddo return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine compute_polynomials pure subroutine compute_weights ( f1 , f2 , ff , weights ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute the stencils weights. !------------------------------------------------------------------------------------------------------------------------------- integer , intent ( IN ) :: f1 , f2 , ff !< Faces to be computed. real ( R_P ), intent ( OUT ) :: weights ( 1 :, 0 :) !< Weights of the stencils, [1:2, 0:S - 1 ]. real ( R_P ) :: IS ( 1 : 2 , 0 : S - 1 ) !< Smoothness indicators of the stencils. real ( R_P ) :: a ( 1 : 2 , 0 : S - 1 ) !< Alpha coefficients for the weights. real ( R_P ) :: a_tot ( 1 : 2 ) !< Sum of the alpha coefficients. integer ( I_P ) :: s1 , s2 , s3 , f !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- ! computing smoothness indicators do s1 = 0 , S - 1 ! stencils loop do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) IS ( f , s1 ) = 0. do s2 = 0 , S - 1 do s3 = 0 , S - 1 IS ( f , s1 ) = IS ( f , s1 ) + self % smooth_coef ( s3 , s2 , s1 ) * stencil ( f + ff , s1 - s3 ) * stencil ( f + ff , s1 - s2 ) enddo enddo enddo enddo ! computing alfa coefficients a_tot = 0. do s1 = 0 , S - 1 ! stencil loops do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) a ( f , s1 ) = self % weights_opt ( f , s1 ) * ( 1. / ( self % eps + IS ( f , s1 )) ** S ) ; a_tot ( f ) = a_tot ( f ) + a ( f , s1 ) enddo enddo ! computing the weights do s1 = 0 , S - 1 ! stencils loop do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) weights ( f , s1 ) = a ( f , s1 ) / a_tot ( f ) enddo enddo return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine compute_weights pure subroutine compute_convolution ( f1 , f2 , ff , interpolation ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute the polynomials convolution. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: f1 , f2 , ff !< Faces to be computed. real ( R_P ), intent ( OUT ) :: interpolation ( 1 :) !< Left and right (1,2) interface value of reconstructed. integer ( I_P ) :: k , f !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- ! computing the convultion interpolation = 0. do k = 0 , S - 1 ! stencils loop do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) interpolation ( f + ff ) = interpolation ( f + ff ) + weights ( f , k ) * polynomials ( f , k ) enddo enddo return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine compute_convolution endsubroutine interpolate ! private methods pure subroutine assign_interpolator ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one interpolator to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( INOUT ) :: lhs !< Left hand side. class ( weno_interpolator ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( weno_interpolator_upwind ) lhs % S = rhs % S lhs % eps = rhs % eps if ( allocated ( rhs % weights_opt )) then if ( allocated ( lhs % weights_opt )) deallocate ( lhs % weights_opt ) ; allocate ( lhs % weights_opt ( 1 : 2 , 0 : lhs % S - 1 )) lhs % weights_opt = rhs % weights_opt endif if ( allocated ( rhs % poly_coef )) then if ( allocated ( lhs % poly_coef )) deallocate ( lhs % poly_coef ) ; allocate ( lhs % poly_coef ( 1 : 2 , 0 : lhs % S - 1 , 0 : lhs % S - 1 )) lhs % poly_coef = rhs % poly_coef endif if ( allocated ( rhs % smooth_coef )) then if ( allocated ( lhs % smooth_coef )) deallocate ( lhs % smooth_coef ) ; allocate ( lhs % smooth_coef ( 0 : lhs % S - 1 , 0 : lhs % S - 1 , 0 : lhs % S - 1 )) lhs % smooth_coef = rhs % smooth_coef endif endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_interpolator elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( weno_interpolator_upwind ), intent ( INOUT ) :: self !< WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule type_weno_interpolator_upwind","tags":"","loc":"sourcefile/type_weno_interpolator_upwind.f90.html","title":"type_weno_interpolator_upwind.f90 – FOODIE"},{"text":"Source Code module wenoof !----------------------------------------------------------------------------------------------------------------------------------- !< WenOOF, WENO interpolation Object Oriented Fortran library !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use type_weno_interpolator , only : weno_constructor , weno_interpolator use type_weno_interpolator_upwind , only : weno_constructor_upwind , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: weno_factory , weno_constructor , weno_interpolator public :: weno_constructor_upwind , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: weno_factory !< WENO factory aimed to create and return a concrete WENO interpolator to the client code without exposing the concrete !< interpolators classes. contains procedure , nopass :: create endtype !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine create ( constructor , interpolator ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create and return a concrete WENO interpolator object being an extension of the abstract *weno_interpolator* type. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_constructor ), intent ( IN ) :: constructor !< The concrete WENO constructor selected by client code. class ( weno_interpolator ), allocatable , intent ( OUT ) :: interpolator !< The concrete WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( constructor ) type is ( weno_constructor_upwind ) allocate ( weno_interpolator_upwind :: interpolator ) call interpolator % create ( constructor = constructor ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine create endmodule wenoof","tags":"","loc":"sourcefile/wenoof.f90.html","title":"wenoof.f90 – FOODIE"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 4/14/2015 !  license: BSD ! !  For making simple x-y plots from Fortran. !  It works by generating a Python script and executing it. ! !# See also !   * Inspired by: [EasyPlot](https://pypi.python.org/pypi/EasyPlot) module pyplot_module use , intrinsic :: iso_fortran_env , only : real64 implicit none private integer , parameter , private :: wp = real64 !! Default real kind [8 bytes]. character ( len =* ), parameter :: tmp_file = 'pyplot_module_temp_1234567890.py' !! Default name of the temporary file !! (this can also be user-specified). character ( len =* ), parameter :: python_exe = 'python' !! The python executable name. character ( len =* ), parameter :: int_fmt = '(I10)' !! integer format string integer , parameter :: max_int_len = 10 !! max string length for integers character ( len =* ), parameter :: real_fmt_default = '(E30.16)' !! default real number format string integer , parameter :: max_real_len = 30 !! max string length for reals type , public :: pyplot !!  The main pyplot class. private character ( len = :), allocatable :: str !! string buffer logical :: show_legend = . false . !! show legend into plot logical :: use_numpy = . true . !! use numpy python module logical :: mplot3d = . false . !! it is a 3d plot logical :: polar = . false . !! it is a polar plot logical :: axis_equal = . false . !! equal scale on each axis character ( len = :), allocatable :: real_fmt !! real number formatting contains ! public methods procedure , public :: initialize !! initialize pyplot instance procedure , public :: add_plot !! add a 2d plot to pyplot instance procedure , public :: add_3d_plot !! add a 3d plot to pyplot instance procedure , public :: add_contour !! add a contour plot to pyplot instance procedure , public :: add_bar !! add a barplot to pyplot instance procedure , public :: savefig !! save plots of pyplot instance procedure , public :: destroy !! destroy pyplot instance ! private methods procedure :: execute !! execute pyplot commands procedure :: add_str !! add string to pytplot instance buffer end type pyplot contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Destructor. subroutine destroy ( me ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler if ( allocated ( me % str )) deallocate ( me % str ) if ( allocated ( me % real_fmt )) deallocate ( me % real_fmt ) end subroutine destroy !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Add a string to the buffer. subroutine add_str ( me , str ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler character ( len =* ), intent ( in ) :: str !! str to be added to pyplot handler buffer me % str = me % str // str // new_line ( ' ' ) end subroutine add_str !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Initialize a plot subroutine initialize ( me , grid , xlabel , ylabel , zlabel , title , legend , use_numpy , figsize , & font_size , axes_labelsize , xtick_labelsize , ytick_labelsize , ztick_labelsize , & legend_fontsize , mplot3d , axis_equal , polar , real_fmt ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler logical , intent ( in ), optional :: grid !! activate grid drawing character ( len =* ), intent ( in ), optional :: xlabel !! label of x axis character ( len =* ), intent ( in ), optional :: ylabel !! label of y axis character ( len =* ), intent ( in ), optional :: zlabel !! label of z axis character ( len =* ), intent ( in ), optional :: title !! plot title logical , intent ( in ), optional :: legend !! plot legend logical , intent ( in ), optional :: use_numpy !! activate usage of numpy python module integer , dimension ( 2 ), intent ( in ), optional :: figsize !! dimension of the figure integer , intent ( in ), optional :: font_size !! font size integer , intent ( in ), optional :: axes_labelsize !! size of axis labels integer , intent ( in ), optional :: xtick_labelsize !! size of x axis tick lables integer , intent ( in ), optional :: ytick_labelsize !! size of y axis tick lables integer , intent ( in ), optional :: ztick_labelsize !! size of z axis tick lables integer , intent ( in ), optional :: legend_fontsize !! size of legend font logical , intent ( in ), optional :: mplot3d !! set true for 3d plots (cannot use with polar) logical , intent ( in ), optional :: axis_equal !! set true for axis = 'equal' logical , intent ( in ), optional :: polar !! set true for polar plots (cannot use with mplot3d) character ( len =* ), intent ( in ), optional :: real_fmt !! format string for real numbers (examples: '(E30.16)' [default], '*') character ( len = max_int_len ) :: width_str !! figure width dummy string character ( len = max_int_len ) :: height_str !! figure height dummy string character ( len = max_int_len ) :: font_size_str !! font size dummy string character ( len = max_int_len ) :: axes_labelsize_str !! size of axis labels dummy string character ( len = max_int_len ) :: xtick_labelsize_str !! size of x axis tick labels dummy string character ( len = max_int_len ) :: ytick_labelsize_str !! size of x axis tick labels dummy string character ( len = max_int_len ) :: ztick_labelsize_str !! size of z axis tick labels dummy string character ( len = max_int_len ) :: legend_fontsize_str !! size of legend font dummy string character ( len =* ), parameter :: default_font_size_str = '10' !! the default font size for plots call me % destroy () if ( present ( legend )) then me % show_legend = legend else me % show_legend = . false . end if if ( present ( use_numpy )) then me % use_numpy = use_numpy else me % use_numpy = . true . end if if ( present ( figsize )) then call integer_to_string ( figsize ( 1 ), width_str ) call integer_to_string ( figsize ( 2 ), height_str ) end if if ( present ( mplot3d )) then me % mplot3d = mplot3d else me % mplot3d = . false . end if if ( present ( polar )) then me % polar = polar else me % polar = . false . end if if ( present ( axis_equal )) then me % axis_equal = axis_equal else me % axis_equal = . false . end if if ( present ( real_fmt )) then me % real_fmt = trim ( adjustl ( real_fmt )) else me % real_fmt = real_fmt_default end if call optional_int_to_string ( font_size , font_size_str , default_font_size_str ) call optional_int_to_string ( axes_labelsize , axes_labelsize_str , default_font_size_str ) call optional_int_to_string ( xtick_labelsize , xtick_labelsize_str , default_font_size_str ) call optional_int_to_string ( ytick_labelsize , ytick_labelsize_str , default_font_size_str ) call optional_int_to_string ( ztick_labelsize , ztick_labelsize_str , default_font_size_str ) call optional_int_to_string ( legend_fontsize , legend_fontsize_str , default_font_size_str ) me % str = '' call me % add_str ( '#!/usr/bin/python' ) call me % add_str ( '' ) call me % add_str ( 'import matplotlib' ) call me % add_str ( 'import matplotlib.pyplot as plt' ) if ( me % mplot3d ) call me % add_str ( 'from mpl_toolkits.mplot3d import Axes3D' ) if ( me % use_numpy ) call me % add_str ( 'import numpy as np' ) call me % add_str ( '' ) call me % add_str ( 'matplotlib.rcParams[\"font.family\"] = \"Serif\"' ) call me % add_str ( 'matplotlib.rcParams[\"font.size\"] = ' // trim ( font_size_str )) call me % add_str ( 'matplotlib.rcParams[\"axes.labelsize\"] = ' // trim ( axes_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"xtick.labelsize\"] = ' // trim ( xtick_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"ytick.labelsize\"] = ' // trim ( ytick_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"legend.fontsize\"] = ' // trim ( legend_fontsize_str )) call me % add_str ( '' ) if ( present ( figsize )) then !if specifying the figure size call me % add_str ( 'fig = plt.figure(figsize=(' // trim ( width_str ) // ',' // trim ( height_str ) // '))' ) else call me % add_str ( 'fig = plt.figure()' ) end if if ( me % mplot3d ) then call me % add_str ( 'ax = fig.gca(projection=''3d'')' ) elseif ( me % polar ) then call me % add_str ( 'ax = fig.gca(projection=''polar'')' ) else call me % add_str ( 'ax = fig.gca()' ) end if if ( present ( grid )) then if ( grid ) call me % add_str ( 'ax.grid()' ) end if if ( present ( xlabel )) call me % add_str ( 'ax.set_xlabel(\"' // trim ( xlabel ) // '\")' ) if ( present ( ylabel )) call me % add_str ( 'ax.set_ylabel(\"' // trim ( ylabel ) // '\")' ) if ( present ( zlabel )) call me % add_str ( 'ax.set_zlabel(\"' // trim ( zlabel ) // '\")' ) if ( present ( title )) call me % add_str ( 'ax.set_title(\"' // trim ( title ) // '\")' ) call me % add_str ( '' ) end subroutine initialize !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Add an x,y plot. subroutine add_plot ( me , x , y , label , linestyle , markersize , linewidth , xlim , ylim , xscale , yscale ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler real ( wp ), dimension (:), intent ( in ) :: x !! x values real ( wp ), dimension (:), intent ( in ) :: y !! y values character ( len =* ), intent ( in ) :: label !! plot label character ( len =* ), intent ( in ) :: linestyle !! style of the plot line integer , intent ( in ), optional :: markersize !! size of the plot markers integer , intent ( in ), optional :: linewidth !! width of the plot line real ( wp ), dimension ( 2 ), intent ( in ), optional :: xlim !! x-axis range real ( wp ), dimension ( 2 ), intent ( in ), optional :: ylim !! y-axis range character ( len =* ), intent ( in ), optional :: xscale !! example: 'linear' (default), 'log' character ( len =* ), intent ( in ), optional :: yscale !! example: 'linear' (default), 'log' character ( len = :), allocatable :: xstr !! x values stringified character ( len = :), allocatable :: ystr !! y values stringified character ( len = :), allocatable :: xlimstr !! xlim values stringified character ( len = :), allocatable :: ylimstr !! ylim values stringified character ( len = max_int_len ) :: imark !! actual markers size character ( len = max_int_len ) :: iline !! actual line width character ( len =* ), parameter :: xname = 'x' !! x variable name for script character ( len =* ), parameter :: yname = 'y' !! y variable name for script if ( allocated ( me % str )) then !axis limits (optional): if ( present ( xlim )) call vec_to_string ( xlim , me % real_fmt , xlimstr , me % use_numpy ) if ( present ( ylim )) call vec_to_string ( ylim , me % real_fmt , ylimstr , me % use_numpy ) !convert the arrays to strings: call vec_to_string ( x , me % real_fmt , xstr , me % use_numpy ) call vec_to_string ( y , me % real_fmt , ystr , me % use_numpy ) !get optional inputs (if not present, set default value): call optional_int_to_string ( markersize , imark , '3' ) call optional_int_to_string ( linewidth , iline , '3' ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) call me % add_str ( '' ) !write the plot statement: call me % add_str ( 'ax.plot(' // & trim ( xname ) // ',' // & trim ( yname ) // ',' // & '\"' // trim ( linestyle ) // '\",' // & 'linewidth=' // trim ( adjustl ( iline )) // ',' // & 'markersize=' // trim ( adjustl ( imark )) // ',' // & 'label=\"' // trim ( label ) // '\")' ) !axis limits: if ( allocated ( xlimstr )) call me % add_str ( 'ax.set_xlim(' // xlimstr // ')' ) if ( allocated ( ylimstr )) call me % add_str ( 'ax.set_ylim(' // ylimstr // ')' ) !axis scales: if ( present ( xscale )) call me % add_str ( 'ax.set_xscale(\"' // xscale // '\")' ) if ( present ( yscale )) call me % add_str ( 'ax.set_yscale(\"' // yscale // '\")' ) call me % add_str ( '' ) else error stop 'Error in add_plot: pyplot class not properly initialized.' end if end subroutine add_plot !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Add a contour plot. ! !@note This requires `use_numpy` to be True. subroutine add_contour ( me , x , y , z , label , linestyle , linewidth , levels , color , filled , cmap ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler real ( wp ), dimension (:), intent ( in ) :: x !! x values real ( wp ), dimension (:), intent ( in ) :: y !! y values real ( wp ), dimension (:,:), intent ( in ) :: z !! z values (a matrix) character ( len =* ), intent ( in ) :: label !! plot label character ( len =* ), intent ( in ) :: linestyle !! style of the plot line integer , intent ( in ), optional :: linewidth !! width of the plot line real ( wp ), dimension (:), intent ( in ), optional :: levels !! contour levels to plot character ( len =* ), intent ( in ), optional :: color !! color of the contour line logical , intent ( in ), optional :: filled !! use filled control (default=False) character ( len =* ), intent ( in ), optional :: cmap !! colormap if filled=True (examples: 'jet', 'bone') character ( len = :), allocatable :: xstr !! x values strinfied character ( len = :), allocatable :: ystr !! y values strinfied character ( len = :), allocatable :: zstr !! z values strinfied character ( len = :), allocatable :: levelstr !! levels vector strinfied character ( len = max_int_len ) :: iline !! actual line width character ( len =* ), parameter :: xname = 'x' !! x variable name for script character ( len =* ), parameter :: yname = 'y' !! y variable name for script character ( len =* ), parameter :: zname = 'z' !! z variable name for script character ( len =* ), parameter :: xname_ = 'X' !! X variable name for contour character ( len =* ), parameter :: yname_ = 'Y' !! Y variable name for contour character ( len =* ), parameter :: zname_ = 'Z' !! Z variable name for contour character ( len = :), allocatable :: extras !! optional stuff character ( len = :), allocatable :: contourfunc !! 'contour' or 'contourf' if ( allocated ( me % str )) then !convert the arrays to strings: call vec_to_string ( x , me % real_fmt , xstr , me % use_numpy ) call vec_to_string ( y , me % real_fmt , ystr , me % use_numpy ) call matrix_to_string ( z , me % real_fmt , zstr , me % use_numpy ) if ( present ( levels )) call vec_to_string ( levels , me % real_fmt , levelstr , me % use_numpy ) !get optional inputs (if not present, set default value): call optional_int_to_string ( linewidth , iline , '3' ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) call me % add_str ( trim ( zname ) // ' = ' // zstr ) call me % add_str ( '' ) !convert inputs for contour plotting: call me % add_str ( yname_ // ', ' // xname_ // ' = np.meshgrid(' // trim ( xname ) // ', ' // trim ( yname ) // ')' ) call me % add_str ( zname_ // ' = ' // zname ) !optional arguments: extras = '' if ( present ( levels )) extras = extras // ',' // 'levels=' // levelstr if ( present ( color )) extras = extras // ',' // 'colors=\"' // color // '\"' if ( present ( linewidth )) extras = extras // ',' // 'linewidths=' // trim ( adjustl ( iline )) if ( present ( cmap )) extras = extras // ',' // 'cmap=\"' // cmap // '\"' !filled or regular: contourfunc = 'contour' !default if ( present ( filled )) then if ( filled ) contourfunc = 'contourf' !filled contour end if !write the plot statement: call me % add_str ( 'CS = ax.' // contourfunc // '(' // xname_ // ',' // yname_ // ',' // zname_ // ',' // & 'label=\"' // trim ( label ) // '\",' // & 'linestyles=\"' // trim ( adjustl ( linestyle )) // '\"' // & extras // ')' ) call me % add_str ( 'ax.clabel(CS, fontsize=9, inline=1)' ) call me % add_str ( '' ) else error stop 'Error in add_plot: pyplot class not properly initialized.' end if end subroutine add_contour !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Add a 3D x,y,z plot. ! !@note Must initialize the class with ```mplot3d=.true.``` subroutine add_3d_plot ( me , x , y , z , label , linestyle , markersize , linewidth ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler real ( wp ), dimension (:), intent ( in ) :: x !! x values real ( wp ), dimension (:), intent ( in ) :: y !! y values real ( wp ), dimension (:), intent ( in ) :: z !! z values character ( len =* ), intent ( in ) :: label !! plot label character ( len =* ), intent ( in ) :: linestyle !! style of the plot line integer , intent ( in ), optional :: markersize !! size of the plot markers integer , intent ( in ), optional :: linewidth !! width of the plot line character ( len = :), allocatable :: xstr !! x values strinfied character ( len = :), allocatable :: ystr !! y values strinfied character ( len = :), allocatable :: zstr !! z values strinfied character ( len = max_int_len ) :: imark !! actual markers size character ( len = max_int_len ) :: iline !! actual line width character ( len =* ), parameter :: xname = 'x' !! x variable name for script character ( len =* ), parameter :: yname = 'y' !! y variable name for script character ( len =* ), parameter :: zname = 'z' !! z variable name for script if ( allocated ( me % str )) then !convert the arrays to strings: call vec_to_string ( x , me % real_fmt , xstr , me % use_numpy ) call vec_to_string ( y , me % real_fmt , ystr , me % use_numpy ) call vec_to_string ( z , me % real_fmt , zstr , me % use_numpy ) !get optional inputs (if not present, set default value): call optional_int_to_string ( markersize , imark , '3' ) call optional_int_to_string ( linewidth , iline , '3' ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) call me % add_str ( trim ( zname ) // ' = ' // zstr ) call me % add_str ( '' ) !write the plot statement: call me % add_str ( 'ax.plot(' // & trim ( xname ) // ',' // & trim ( yname ) // ',' // & trim ( zname ) // ',' // & '\"' // trim ( linestyle ) // '\",' // & 'linewidth=' // trim ( adjustl ( iline )) // ',' // & 'markersize=' // trim ( adjustl ( imark )) // ',' // & 'label=\"' // trim ( label ) // '\")' ) call me % add_str ( '' ) else error stop 'Error in add_3d_plot: pyplot class not properly initialized.' end if end subroutine add_3d_plot !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Add a bar plot. subroutine add_bar ( me , left , height , label , width , bottom , color , yerr , align , xlim , ylim , xscale , yscale ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler real ( wp ), dimension (:), intent ( in ) :: left !! left bar values real ( wp ), dimension (:), intent ( in ) :: height !! height bar values character ( len =* ), intent ( in ) :: label !! plot label real ( wp ), dimension (:), intent ( in ), optional :: width !! width values real ( wp ), dimension (:), intent ( in ), optional :: bottom !! bottom values character ( len =* ), intent ( in ), optional :: color !! plot color real ( wp ), dimension (:), intent ( in ), optional :: yerr !! yerr values character ( len =* ), intent ( in ), optional :: align !! default: 'center' real ( wp ), dimension ( 2 ), intent ( in ), optional :: xlim !! x-axis range real ( wp ), dimension ( 2 ), intent ( in ), optional :: ylim !! y-axis range character ( len =* ), intent ( in ), optional :: xscale !! example: 'linear' (default), 'log' character ( len =* ), intent ( in ), optional :: yscale !! example: 'linear' (default), 'log' character ( len = :), allocatable :: xstr !! x axis values stringified character ( len = :), allocatable :: ystr !! y axis values stringified character ( len = :), allocatable :: xlimstr !! xlim values stringified character ( len = :), allocatable :: ylimstr !! ylim values stringified character ( len = :), allocatable :: wstr !! width values stringified character ( len = :), allocatable :: bstr !! bottom values stringified character ( len = :), allocatable :: plt_str !! plot string character ( len = :), allocatable :: yerr_str !!  yerr values stringified character ( len =* ), parameter :: xname = 'x' !! x axis name character ( len =* ), parameter :: yname = 'y' !! y axis name character ( len =* ), parameter :: wname = 'w' !! width name character ( len =* ), parameter :: bname = 'b' !! bottom name character ( len =* ), parameter :: yerrname = 'yerr' !! yerr name if ( allocated ( me % str )) then !axis limits (optional): if ( present ( xlim )) call vec_to_string ( xlim , me % real_fmt , xlimstr , me % use_numpy ) if ( present ( ylim )) call vec_to_string ( ylim , me % real_fmt , ylimstr , me % use_numpy ) !convert the arrays to strings: call vec_to_string ( left , me % real_fmt , xstr , me % use_numpy ) call vec_to_string ( height , me % real_fmt , ystr , me % use_numpy ) if ( present ( width )) call vec_to_string ( width , me % real_fmt , wstr , me % use_numpy ) if ( present ( bottom )) call vec_to_string ( bottom , me % real_fmt , bstr , me % use_numpy ) if ( present ( yerr )) call vec_to_string ( yerr , me % real_fmt , yerr_str , me % use_numpy ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) if ( present ( width )) call me % add_str ( trim ( wname ) // ' = ' // wstr ) if ( present ( bottom )) call me % add_str ( trim ( bname ) // ' = ' // bstr ) if ( present ( yerr )) call me % add_str ( trim ( yerrname ) // ' = ' // yerr_str ) call me % add_str ( '' ) !create the plot string: plt_str = 'ax.bar(' // & 'left=' // trim ( xname ) // ',' // & 'height=' // trim ( yname ) // ',' if ( present ( yerr )) plt_str = plt_str // 'yerr=' // trim ( yerrname ) // ',' if ( present ( width )) plt_str = plt_str // 'width=' // trim ( wname ) // ',' if ( present ( bottom )) plt_str = plt_str // 'bottom=' // trim ( bstr ) // ',' if ( present ( color )) plt_str = plt_str // 'color=\"' // trim ( color ) // '\",' if ( present ( align )) plt_str = plt_str // 'align=\"' // trim ( align ) // '\",' plt_str = plt_str // 'label=\"' // trim ( label ) // '\")' !write the plot statement: call me % add_str ( plt_str ) !axis limits: if ( allocated ( xlimstr )) call me % add_str ( 'ax.set_xlim(' // xlimstr // ')' ) if ( allocated ( ylimstr )) call me % add_str ( 'ax.set_ylim(' // ylimstr // ')' ) !axis scales: if ( present ( xscale )) call me % add_str ( 'ax.set_xscale(\"' // xscale // '\")' ) if ( present ( yscale )) call me % add_str ( 'ax.set_yscale(\"' // yscale // '\")' ) call me % add_str ( '' ) else error stop 'Error in add_bar: pyplot class not properly initialized.' end if end subroutine add_bar !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Integer to string, specifying the default value if ! the optional argument is not present. subroutine optional_int_to_string ( int_value , string_value , default_value ) integer , intent ( in ), optional :: int_value !! integer value character ( len =* ), intent ( out ) :: string_value !! integer value stringified character ( len =* ), intent ( in ) :: default_value !! default integer value if ( present ( int_value )) then call integer_to_string ( int_value , string_value ) else string_value = default_value end if end subroutine optional_int_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Integer to string conversion. subroutine integer_to_string ( i , s ) integer , intent ( in ), optional :: i !! integer value character ( len =* ), intent ( out ) :: s !! integer value stringified integer :: istat !! IO status write ( s , int_fmt , iostat = istat ) i if ( istat /= 0 ) then error stop 'Error converting integer to string' else s = adjustl ( s ) end if end subroutine integer_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Real vector to string. subroutine vec_to_string ( v , fmt , str , use_numpy ) real ( wp ), dimension (:), intent ( in ) :: v !! real values character ( len =* ), intent ( in ) :: fmt !! real format string character ( len = :), allocatable , intent ( out ) :: str !! real values stringified logical , intent ( in ) :: use_numpy !! activate numpy python module usage integer :: i !! counter integer :: istat !! IO status character ( len = max_real_len ) :: tmp !! dummy string str = '[' do i = 1 , size ( v ) if ( fmt == '*' ) then write ( tmp , * , iostat = istat ) v ( i ) else write ( tmp , fmt , iostat = istat ) v ( i ) end if if ( istat /= 0 ) error stop 'Error in vec_to_string' str = str // trim ( adjustl ( tmp )) if ( i < size ( v )) str = str // ',' end do str = str // ']' !convert to numpy array if necessary: if ( use_numpy ) str = 'np.array(' // str // ')' end subroutine vec_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Real matrix (rank 2) to string. subroutine matrix_to_string ( v , fmt , str , use_numpy ) real ( wp ), dimension (:,:), intent ( in ) :: v !! real values character ( len =* ), intent ( in ) :: fmt !! real format string character ( len = :), allocatable , intent ( out ) :: str !! real values stringified logical , intent ( in ) :: use_numpy !! activate numpy python module usage integer :: i !! counter character ( len = :), allocatable :: tmp !! dummy string str = '[' do i = 1 , size ( v , 1 ) !rows call vec_to_string ( v ( i ,:), fmt , tmp , use_numpy ) !one row at a time str = str // trim ( adjustl ( tmp )) if ( i < size ( v , 1 )) str = str // ',' end do str = str // ']' !convert to numpy array if necessary: if ( use_numpy ) str = 'np.array(' // str // ')' end subroutine matrix_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 8/16/2015 ! !  Write the buffer to a file, and then execute it with Python. ! !  If user specifies a Python file name, then the file is kept, otherwise !  a temporary filename is used, and the file is deleted after it is used. subroutine execute ( me , pyfile ) class ( pyplot ), intent ( inout ) :: me !! pytplot handler character ( len =* ), intent ( in ), optional :: pyfile !! name of the python script to generate integer :: istat !! IO status integer :: iunit !! IO unit character ( len = :), allocatable :: file !! file name logical :: scratch !! if a scratch file is to be used if ( allocated ( me % str )) then scratch = (. not . present ( pyfile )) !file name to use: if ( scratch ) then file = trim ( tmp_file ) !use the default else file = trim ( pyfile ) !use the user-specified name end if !open the file: open ( newunit = iunit , file = file , status = 'REPLACE' , iostat = istat ) if ( istat /= 0 ) error stop 'Error opening file.' !write to the file: write ( iunit , '(A)' ) me % str !to ensure that the file is there for the next command line call: flush ( iunit ) !run the file using python: call execute_command_line ( python_exe // ' ' // file ) !close the file: if ( scratch ) then close ( iunit , status = 'DELETE' , iostat = istat ) else close ( iunit , iostat = istat ) end if if ( istat /= 0 ) error stop 'Error closing file.' !cleanup: if ( allocated ( file )) deallocate ( file ) end if end subroutine execute !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Save the figure. subroutine savefig ( me , figfile , pyfile ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler character ( len =* ), intent ( in ) :: figfile !! file name for the figure character ( len =* ), intent ( in ), optional :: pyfile !! name of the Python script to generate if ( allocated ( me % str )) then !finish up the string: if ( me % show_legend ) then call me % add_str ( 'ax.legend(loc=\"best\")' ) call me % add_str ( '' ) end if if ( me % axis_equal ) then call me % add_str ( 'ax.axis(\"equal\")' ) call me % add_str ( '' ) end if call me % add_str ( 'plt.savefig(\"' // trim ( figfile ) // '\")' ) !run it: call me % execute ( pyfile ) else error stop 'error in savefig: pyplot class not properly initialized.' end if end subroutine savefig !***************************************************************************************** !***************************************************************************************** end module pyplot_module !*****************************************************************************************","tags":"","loc":"sourcefile/pyplot_module.f90.html","title":"pyplot_module.f90 – FOODIE"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 4/14/2015 !  license: BSD ! !  Unit test for [[pyplot_module]]. program test use , intrinsic :: iso_fortran_env , only : wp => real64 use pyplot_module , only : pyplot implicit none integer , parameter :: n = 100 real ( wp ), dimension ( n ) :: x !! x values real ( wp ), dimension ( n ) :: y !! y values real ( wp ), dimension ( n ) :: yerr !! error values for bar chart real ( wp ), dimension ( n ) :: sx !! sin(x) values real ( wp ), dimension ( n ) :: cx !! cos(x) values real ( wp ), dimension ( n ) :: tx !! sin(x)*cos(x) values real ( wp ), dimension ( n , n ) :: z !! z matrix for contour plot type ( pyplot ) :: plt !! pytplot handler integer :: i !! counter integer :: j !! counter real ( wp ) :: r2 !! temp variable !generate some data: x = [( real ( i , wp ), i = 0 , size ( x ) - 1 )] / 5.0_wp sx = sin ( x ) cx = cos ( x ) tx = sx * cx yerr = abs ( sx * . 25_wp ) !2d line plot: call plt % initialize ( grid = . true ., xlabel = 'angle (rad)' , figsize = [ 20 , 10 ],& title = 'plot test' , legend = . true ., axis_equal = . true .) call plt % add_plot ( x , sx , label = '$\\sin (x)$' , linestyle = 'b-o' , markersize = 5 , linewidth = 2 ) call plt % add_plot ( x , cx , label = '$\\cos (x)$' , linestyle = 'r-o' , markersize = 5 , linewidth = 2 ) call plt % add_plot ( x , tx , label = '$\\sin (x) \\cos (x)$' , linestyle = 'g-o' , markersize = 2 , linewidth = 1 ) call plt % savefig ( 'plottest.png' , pyfile = 'plottest.py' ) !bar chart: tx = 0.1_wp !for bar width call plt % initialize ( grid = . true ., xlabel = 'angle (rad)' ,& title = 'bar test' , legend = . true ., figsize = [ 20 , 10 ],& font_size = 20 ,& axes_labelsize = 20 ,& xtick_labelsize = 20 ,& ytick_labelsize = 20 ,& legend_fontsize = 20 ) call plt % add_bar ( left = x , height = sx , width = tx , label = '$\\sin (x)$' ,& color = 'r' , yerr = yerr , xlim = [ 0.0_wp , 2 0.0_wp ], align = 'center' ) call plt % savefig ( 'bartest.png' , pyfile = 'bartest.py' ) !contour plot: x = [( real ( i , wp ), i = 0 , n - 1 )] / 10 0.0_wp y = [( real ( i , wp ), i = 0 , n - 1 )] / 10 0.0_wp do i = 1 , n do j = 1 , n r2 = x ( i ) ** 2 + y ( j ) ** 2 z ( i , j ) = sin ( x ( i )) * cos ( y ( j )) * sin ( r2 ) / ( 1.0_wp + log ( r2 + 1.0_wp )) end do end do call plt % initialize ( grid = . true ., xlabel = 'x angle (rad)' , ylabel = 'y angle (rad)' , figsize = [ 10 , 10 ],& title = 'Contour plot test' , real_fmt = '*' ) call plt % add_contour ( x , y , z , label = 'contour' , linestyle = '-' , linewidth = 2 , filled = . true ., cmap = 'bone' ) call plt % savefig ( 'contour.png' , pyfile = 'contour.py' ) end program test !*****************************************************************************************","tags":"","loc":"sourcefile/test.f90.html","title":"test.f90 – FOODIE"},{"text":"type, public, abstract :: integrand Abstract type for building FOODIE ODE integrators. Components Type Visibility Attributes Name Initial class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. Type-Bound Procedures procedure( time_derivative ), public, pass(self), deferred :: t Time derivative, residuals. function time_derivative (self, t) result(dState_dt) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function. procedure( local_error_operator ), public, pass(lhs), deferred :: local_error ||integrand - integrand||. function local_error_operator (lhs, rhs) result(error) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 solution approximations. procedure( symmetric_operator ), public, pass(lhs), deferred :: integrand_multiply_integrand Integrand * integrand operator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. procedure( integrand_op_real ), public, pass(lhs), deferred :: integrand_multiply_real Integrand * real operator. function integrand_op_real (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real. procedure( real_op_integrand ), public, pass(rhs), deferred :: real_multiply_integrand Real * integrand operator. function real_op_integrand (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand. procedure( symmetric_operator ), public, pass(lhs), deferred :: add Integrand + integrand operator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. procedure( symmetric_operator ), public, pass(lhs), deferred :: sub Integrand - integrand operator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. procedure( assignment_integrand ), public, pass(lhs), deferred :: assign_integrand Integrand = integrand. pure subroutine assignment_integrand (lhs, rhs) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. function local_error_operator (lhs, rhs) result(error) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 solution approximations. generic, public :: operator(+) => add Overloading + operator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. generic, public :: operator(-) => sub Overloading - operator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. generic, public :: operator(*) => integrand_multiply_integrand , real_multiply_integrand , integrand_multiply_real Overloading * operator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. function real_op_integrand (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand. function integrand_op_real (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real. generic, public :: assignment(=) => assign_integrand Overloading = assignament. pure subroutine assignment_integrand (lhs, rhs) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand. Source Code type , abstract :: integrand !< Abstract type for building FOODIE ODE integrators. #ifdef CAF class ( * ), allocatable :: dummy_to_allow_extensions [:] !< Dummy member to allow concrete extensions with coarray members. #endif contains ! public deferred procedures that concrete integrand-field must implement procedure ( time_derivative ), pass ( self ), deferred , public :: t !< Time derivative, residuals. ! operators procedure ( local_error_operator ), pass ( lhs ), deferred , public :: local_error !< ||integrand - integrand||. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_multiply_integrand !< Integrand * integrand operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_multiply_real !< Integrand * real operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_multiply_integrand !< Real * integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: add !< Integrand + integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: sub !< Integrand - integrand operator. procedure ( assignment_integrand ), pass ( lhs ), deferred , public :: assign_integrand !< Integrand = integrand. ! operators overloading generic , public :: operator (. lterror .) => local_error !< Estimate local truncation error. generic , public :: operator ( + ) => add !< Overloading + operator. generic , public :: operator ( - ) => sub !< Overloading - operator. generic , public :: operator ( * ) => integrand_multiply_integrand , & real_multiply_integrand , & integrand_multiply_real !< Overloading * operator. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. endtype integrand","tags":"","loc":"type/integrand.html","title":"integrand – FOODIE "},{"text":"type, public :: adams_bashforth_integrator FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. Note The integrator must be created or initialized (initialize the b coefficients) before used. ### List of errors status\n+ error=0 => no error;\n+ error=1 => bad (unsupported) number of required time steps;\n Finalize object. Inherited By type~~adams_bashforth_integrator~~InheritedByGraph type~adams_bashforth_integrator adams_bashforth_integrator type~adams_bashforth_moulton_integrator adams_bashforth_moulton_integrator type~adams_bashforth_integrator->type~adams_bashforth_moulton_integrator predictor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps. real(kind=R_P), private, allocatable :: b (:) b coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. Finalization Procedures final :: finalize private elemental subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: init Initialize (create) the integrator. private elemental subroutine init (self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth integrator: initialize the b coefficients. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Destroy the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, autoupdate) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Description Integrate field with Adams-Bashforth class scheme. procedure, public, pass(self) :: update_previous Cyclic update previous time steps. private subroutine update_previous (self, U, previous) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Description Cyclic update previous time steps. procedure, public, nopass :: min_steps Return the minimum number of steps supported. private elemental function min_steps () Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Description Return the minimum number of steps supported. procedure, public, nopass :: max_steps Return the maximum number of steps supported. private elemental function max_steps () Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. Description Return the maximum number of steps supported. procedure, public, nopass :: is_supported Check if the queried number of steps is supported or not. private elemental function is_supported (steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . Description Check if the queried number of steps is supported or not. Source Code type :: adams_bashforth_integrator !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required time steps; private integer ( I_P ) :: steps = 0 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< *b* coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. final :: finalize !< Finalize object. endtype adams_bashforth_integrator","tags":"","loc":"type/adams_bashforth_integrator.html","title":"adams_bashforth_integrator – FOODIE "},{"text":"type, public :: adams_bashforth_moulton_integrator type~~adams_bashforth_moulton_integrator~~InheritsGraph type~adams_bashforth_moulton_integrator adams_bashforth_moulton_integrator type~adams_bashforth_integrator adams_bashforth_integrator type~adams_bashforth_integrator->type~adams_bashforth_moulton_integrator predictor type~adams_moulton_integrator adams_moulton_integrator type~adams_moulton_integrator->type~adams_bashforth_moulton_integrator corrector Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. Note The integrator must be created or initialized (predictor and corrector schemes selection) before used. ### List of errors status\n+ error=0 => no error;\n+ error=1 => bad (unsupported) number of required time steps;\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = -1 Number of time steps. type( adams_bashforth_integrator ), private :: predictor Predictor solver. type( adams_moulton_integrator ), private :: corrector Corrector solver. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. Finalization Procedures final :: finalize private elemental subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: init Initialize (create) the integrator. private elemental subroutine init (self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth-Moulton integrator: initialize the b coefficients. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. Description Destroy the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, iterations) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(in) :: self Actual ABM integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations of AM scheme. Description Integrate field with Adams-Bashforth-Moulton class scheme. procedure, public, nopass :: min_steps Return the minimum number of steps supported. private elemental function min_steps () Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Description Return the minimum number of steps supported. procedure, public, nopass :: max_steps Return the maximum number of steps supported. private elemental function max_steps () Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. Description Return the maximum number of steps supported. procedure, public, nopass :: is_supported Check if the queried number of steps is supported or not. private elemental function is_supported (steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . Description Check if the queried number of steps is supported or not. Source Code type :: adams_bashforth_moulton_integrator !< FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. !< !< @note The integrator must be created or initialized (predictor and corrector schemes selection) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required time steps; private integer ( I_P ) :: steps =- 1 !< Number of time steps. type ( adams_bashforth_integrator ) :: predictor !< Predictor solver. type ( adams_moulton_integrator ) :: corrector !< Corrector solver. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. final :: finalize !< Finalize object. endtype adams_bashforth_moulton_integrator","tags":"","loc":"type/adams_bashforth_moulton_integrator.html","title":"adams_bashforth_moulton_integrator – FOODIE "},{"text":"type, public :: adams_moulton_integrator FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 16th order accurate. Note The integrator must be created or initialized (initialize the b coefficients) before used. ### List of errors status\n+ error=0 => no error;\n+ error=1 => bad (unsupported) number of required time steps;\n Finalize object. Inherited By type~~adams_moulton_integrator~~InheritedByGraph type~adams_moulton_integrator adams_moulton_integrator type~adams_bashforth_moulton_integrator adams_bashforth_moulton_integrator type~adams_moulton_integrator->type~adams_bashforth_moulton_integrator corrector Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = -1 Number of time steps. real(kind=R_P), private, allocatable :: b (:) b coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. Finalization Procedures final :: finalize private elemental subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( adams_moulton_integrator ), intent(inout) :: self AB integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: init Initialize (create) the integrator. private elemental subroutine init (self, steps) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Moulton integrator: initialize the b coefficients. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. Description Destroy the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, iterations, autoupdate) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Description Integrate field with Adams-Moulton class scheme. procedure, public, pass(self) :: update_previous Cyclic update previous time steps. private subroutine update_previous (self, U, previous) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Description Cyclic update previous time steps. procedure, public, nopass :: min_steps Return the minimum number of steps supported. private elemental function min_steps () Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Description Return the minimum number of steps supported. procedure, public, nopass :: max_steps Return the maximum number of steps supported. private elemental function max_steps () Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. Description Return the maximum number of steps supported. procedure, public, nopass :: is_supported Check if the queried number of steps is supported or not. private elemental function is_supported (steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . Description Check if the queried number of steps is supported or not. Source Code type :: adams_moulton_integrator !< FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 16th order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required time steps; private integer ( I_P ) :: steps =- 1 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< b coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. final :: finalize !< Finalize object. endtype adams_moulton_integrator","tags":"","loc":"type/adams_moulton_integrator.html","title":"adams_moulton_integrator – FOODIE "},{"text":"type, public :: back_df_integrator FOODIE integrator: provide an implicit class of Backward-Differentiation-Formula multi-step schemes, from 1st to 6th order\n accurate. Note The integrator must be created or initialized (initialize the alpha and beta coefficients) before used. ### List of errors status\n+ error=0 => no error;\n+ error=1 => bad (unsupported) number of required time steps;\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps. real(kind=R_P), private, allocatable :: a (:) \\alpha coefficients. real(kind=R_P), private :: b = 0.0_R_P \\beta coefficient. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. Finalization Procedures final :: finalize private elemental subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( back_df_integrator ), intent(inout) :: self BDF integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(inout) :: self BDF integrator. Description Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elemental subroutine init (self, steps) Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(inout) :: self BDF integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual BDF integrator: initialize the alpha and beta coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, iterations, autoupdate) Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(in) :: self Actual BDF integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Description Integrate field with BDF class scheme. procedure, public, pass(self) :: update_previous Cyclic update previous time steps. private subroutine update_previous (self, U, previous) Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(in) :: self Actual BDF integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Description Cyclic update previous time steps. procedure, public, nopass :: min_steps Return the minimum number of steps supported. private elemental function min_steps () Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Description Return the minimum number of steps supported. procedure, public, nopass :: max_steps Return the maximum number of steps supported. private elemental function max_steps () Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. Description Return the maximum number of steps supported. procedure, public, nopass :: is_supported Check if the queried number of steps is supported or not. private elemental function is_supported (steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . Description Check if the queried number of steps is supported or not. Source Code type :: back_df_integrator !< FOODIE integrator: provide an implicit class of Backward-Differentiation-Formula multi-step schemes, from 1st to 6th order !< accurate. !< !< @note The integrator must be created or initialized (initialize the *alpha* and *beta* coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required time steps; private integer ( I_P ) :: steps = 0 !< Number of time steps. real ( R_P ), allocatable :: a (:) !< \\alpha coefficients. real ( R_P ) :: b = 0.0_R_P !< \\beta coefficient. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. final :: finalize !< Finalize object. endtype back_df_integrator","tags":"","loc":"type/back_df_integrator.html","title":"back_df_integrator – FOODIE "},{"text":"type, public :: emd_runge_kutta_integrator FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. Note The integrator must be created or initialized (initialize the RK coefficients) before used. ### List of errors status\n+ error=0 => no error;\n+ error=1 => bad (unsupported) number of required stages;\n Finalize object. Components Type Visibility Attributes Name Initial real(kind=R_P), private :: tolerance = 0._R_P Tolerance on the local truncation error. real(kind=R_P), private :: pp1_inv = 0._R_P 1/(p+1) where p is the accuracy order of the lower accurate scheme of the pair. integer(kind=I_P), private :: stages = 0 Number of stages. real(kind=R_P), private, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), private, allocatable :: beta (:,:) \\beta Butcher's coefficients. real(kind=R_P), private, allocatable :: gamm (:) \\gamma Butcher's coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. Finalization Procedures final :: finalize private elemental subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( emd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: init Initialize (create) the integrator. private elemental subroutine init (self, stages, tolerance) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. real(kind=R_P), intent(in), optional :: tolerance Tolerance on the local truncation error (default 0.01). Description Create the actual RK integrator: initialize the Butcher' table coefficients. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(inout) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit embedded Runge-Kutta scheme. procedure, public, nopass :: min_stages Return the minimum number of stages supported. private elemental function min_stages () Arguments None Return Value integer(kind=I_P) Minimum number of stages supported. Description Return the minimum number of stages supported. procedure, public, nopass :: max_stages Return the maximum number of stages supported. private elemental function max_stages () Arguments None Return Value integer(kind=I_P) Maximum number of stages supported. Description Return the maximum number of stages supported. procedure, public, nopass :: is_supported Check if the queried number of stages is supported or not. private elemental function is_supported (stages) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value logical Is true is the stages number is in supported_stages . Description Check if the queried number of stages is supported or not. procedure, private, pass(self) :: new_Dt Compute new estimation of the time step Dt. private elemental subroutine new_Dt (self, error, Dt) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Integrator. real(kind=R_P), intent(in) :: error Local truncation error estimation. real(kind=R_P), intent(inout) :: Dt Time step. Description Compute new estimation of the time step Dt. Source Code type :: emd_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required stages; private real ( R_P ) :: tolerance = 0._R_P !< Tolerance on the local truncation error. real ( R_P ) :: pp1_inv = 0._R_P !< 1/(p+1) where p is the accuracy order of the lower accurate scheme of the pair. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:,:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_stages !< Return the minimum number of stages supported. procedure , nopass , public :: max_stages !< Return the maximum number of stages supported. procedure , nopass , public :: is_supported !< Check if the queried number of stages is supported or not. procedure , pass ( self ), private :: new_Dt !< Compute new estimation of the time step Dt. final :: finalize !< Finalize object. endtype emd_runge_kutta_integrator","tags":"","loc":"type/emd_runge_kutta_integrator.html","title":"emd_runge_kutta_integrator – FOODIE "},{"text":"type, public :: euler_explicit_integrator FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. Note The integrator can be used directly without any initialization. Type-Bound Procedures procedure, public, nopass :: integrate Integrate integrand field. private subroutine integrate (U, Dt, t) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. Description Integrate field with explicit Euler scheme, 1st order. procedure, public, nopass :: min_stages_steps Return the minimum number of stages/steps supported. private elemental function min_stages_steps () Arguments None Return Value integer(kind=I_P) Minimum number of stages/steps supported. Description Return the minimum number of stages/steps supported. procedure, public, nopass :: max_stages_steps Return the maximum number of stages/steps supported. private elemental function max_stages_steps () Arguments None Return Value integer(kind=I_P) Maximum number of stages/steps supported. Description Return the maximum number of stages/steps supported. procedure, public, nopass :: is_supported Check if the queried number of stages/steps is supported or not. private elemental function is_supported (stages_steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages_steps Number of stages/steps used. Return Value logical Is true is the stages number is in supported_stages_steps . Description Check if the queried number of stages/steps is supported or not. Source Code type :: euler_explicit_integrator !< FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< @note The integrator can be used directly without any initialization. private contains private procedure , nopass , public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_stages_steps !< Return the minimum number of stages/steps supported. procedure , nopass , public :: max_stages_steps !< Return the maximum number of stages/steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of stages/steps is supported or not. endtype euler_explicit_integrator","tags":"","loc":"type/euler_explicit_integrator.html","title":"euler_explicit_integrator – FOODIE "},{"text":"type, public :: leapfrog_integrator FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Note The integrator could be used without initialialization (initialize the time filter coefficients) if the defulat values\n are suitable for the problem. Components Type Visibility Attributes Name Initial real(kind=R_P), private :: nu = 0.01_R_P Robert-Asselin filter coefficient. real(kind=R_P), private :: alpha = 0.53_R_P Robert-Asselin-Williams filter coefficient. Type-Bound Procedures procedure, public, pass(self) :: init Initialize (create) the integrator. private elemental subroutine init (self, nu, alpha) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(inout) :: self LF integrator. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. Description Create the actual leapfrog integrator: initialize the filter coefficient. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, filter) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(in) :: self LF integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:2) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. class( integrand ), intent(inout), optional :: filter Filter field displacement. Description Integrate field with leapfrog class scheme. procedure, public, nopass :: min_steps Return the minimum number of steps supported. private elemental function min_steps () Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Description Return the minimum number of steps supported. procedure, public, nopass :: max_steps Return the maximum number of steps supported. private elemental function max_steps () Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. Description Return the maximum number of steps supported. procedure, public, nopass :: is_supported Check if the queried number of steps is supported or not. private elemental function is_supported (steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . Description Check if the queried number of steps is supported or not. Source Code type :: leapfrog_integrator !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. !< !< @note The integrator could be used without initialialization (initialize the time filter coefficients) if the defulat values !< are suitable for the problem. private real ( R_P ) :: nu = 0.01_R_P !< Robert-Asselin filter coefficient. real ( R_P ) :: alpha = 0.53_R_P !< Robert-Asselin-Williams filter coefficient. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. endtype leapfrog_integrator","tags":"","loc":"type/leapfrog_integrator.html","title":"leapfrog_integrator – FOODIE "},{"text":"type, public :: ls_runge_kutta_integrator FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. Note The integrator must be created or initialized (initialize the RK coefficients) before used. ### List of errors status\n+ error=0 => no error;\n+ error=1 => bad (unsupported) number of required stages;\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: stages = 0 Number of stages. real(kind=R_P), private, allocatable :: A (:) Low storage A coefficients. real(kind=R_P), private, allocatable :: B (:) Low storage B coefficients. real(kind=R_P), private, allocatable :: C (:) Low storage C coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. Finalization Procedures final :: finalize private elemental subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: init Initialize (create) the integrator. private elemental subroutine init (self, stages) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' low storage table coefficients. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:registers) Runge-Kutta registers. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit low storage Runge-Kutta scheme. procedure, public, nopass :: used_registers Return the number of registers used. private elemental function used_registers () Arguments None Return Value integer(kind=I_P) Number of registers used. Description Return the number of registers used. procedure, public, nopass :: min_stages Return the minimum number of stages supported. private elemental function min_stages () Arguments None Return Value integer(kind=I_P) Minimum number of stages supported. Description Return the minimum number of stages supported. procedure, public, nopass :: max_stages Return the maximum number of stages supported. private elemental function max_stages () Arguments None Return Value integer(kind=I_P) Maximum number of stages supported. Description Return the maximum number of stages supported. procedure, public, nopass :: is_supported Check if the queried number of stages is supported or not. private elemental function is_supported (stages) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value logical Is true is the stages number is in supported_stages . Description Check if the queried number of stages is supported or not. Source Code type :: ls_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required stages; private integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: A (:) !< Low storage *A* coefficients. real ( R_P ), allocatable :: B (:) !< Low storage *B* coefficients. real ( R_P ), allocatable :: C (:) !< Low storage *C* coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: used_registers !< Return the number of registers used. procedure , nopass , public :: min_stages !< Return the minimum number of stages supported. procedure , nopass , public :: max_stages !< Return the maximum number of stages supported. procedure , nopass , public :: is_supported !< Check if the queried number of stages is supported or not. final :: finalize !< Finalize object. endtype ls_runge_kutta_integrator","tags":"","loc":"type/ls_runge_kutta_integrator.html","title":"ls_runge_kutta_integrator – FOODIE "},{"text":"type, public :: tvd_runge_kutta_integrator FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. Note The integrator must be created or initialized (initialize the RK coefficients) before used. ### List of errors status\n+ error=0 => no error;\n+ error=1 => bad (unsupported) number of required stages;\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: stages = 0 Number of stages. real(kind=R_P), private, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), private, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), private, allocatable :: gamm (:) \\gamma Butcher's coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. Finalization Procedures final :: finalize private elemental subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: init Initialize (create) the integrator. private elemental subroutine init (self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. procedure, public, nopass :: min_stages Return the minimum number of stages supported. private elemental function min_stages () Arguments None Return Value integer(kind=I_P) Minimum number of stages supported. Description Return the minimum number of stages supported. procedure, public, nopass :: max_stages Return the maximum number of stages supported. private elemental function max_stages () Arguments None Return Value integer(kind=I_P) Maximum number of stages supported. Description Return the maximum number of stages supported. procedure, public, nopass :: is_supported Check if the queried number of stages is supported or not. private elemental function is_supported (stages) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value logical Is true is the stages number is in supported_stages . Description Check if the queried number of stages is supported or not. Source Code type :: tvd_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required stages; private integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_stages !< Return the minimum number of stages supported. procedure , nopass , public :: max_stages !< Return the maximum number of stages supported. procedure , nopass , public :: is_supported !< Check if the queried number of stages is supported or not. final :: finalize !< Finalize object. endtype tvd_runge_kutta_integrator","tags":"","loc":"type/tvd_runge_kutta_integrator~3.html","title":"tvd_runge_kutta_integrator – FOODIE "},{"text":"type, public :: oscillation_test type~~oscillation_test~~InheritsGraph type~oscillation_test oscillation_test Type_Command_Line_Interface Type_Command_Line_Interface Type_Command_Line_Interface->type~oscillation_test cli Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Class to handle oscillation test(s). Test is driven by the Command Line Interface (CLI) options. Test has only 1 public method execute : it executes test(s) accordingly to cli options. Components Type Visibility Attributes Name Initial type(Type_Command_Line_Interface), private :: cli Command line interface handler. integer(kind=I_P), private :: error = 0 Error handler. logical, private :: errors_analysis = .false. Flag for activating errors analysis. real(kind=R_P), private :: frequency = 0.0_R_P Oscillation frequency. real(kind=R_P), private :: final_time = 0.0_R_P Final integration time. integer(kind=I_P), private :: implicit_iterations = 0 Number of iterations (implicit solvers). character(len=99), private :: output_cli = 'unset' Output files basename. logical, private :: plots = .false. Flag for activating plots saving. logical, private :: results = .false. Flag for activating results saving. character(len=99), private :: solver = 'adams-bashforth' Solver used. integer(kind=I_P), private, allocatable :: stages_steps (:) Number of stages/steps used. real(kind=R_P), private, allocatable :: Dt (:) Time step(s) exercised. real(kind=R_P), private, allocatable :: tolerance (:) Tolerance(s) exercised on local truncation error. Type-Bound Procedures procedure, public, pass(self) :: execute Execute selected test(s). private subroutine execute (self) Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(inout) :: self Test. Description Execute test(s). procedure, private, pass(self) :: init Initialize test: set Command Line Interface, parse it and check its validity. private subroutine init (self) Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(inout) :: self Test. Description Initialize test: set Command Line Interface, parse it and check its validity. procedure, private, pass(self) :: test Perform the test. private subroutine test (self, solver) Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(in) :: self Test. character(len=*), intent(in) :: solver Selected solver. Description Perform the test. Source Code type :: oscillation_test !< Class to handle oscillation test(s). !< !< Test is driven by the Command Line Interface (CLI) options. !< !< Test has only 1 public method `execute`: it executes test(s) accordingly to cli options. private type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. integer ( I_P ) :: error = 0 !< Error handler. logical :: errors_analysis = . false . !< Flag for activating errors analysis. real ( R_P ) :: frequency = 0.0_R_P !< Oscillation frequency. real ( R_P ) :: final_time = 0.0_R_P !< Final integration time. integer ( I_P ) :: implicit_iterations = 0 !< Number of iterations (implicit solvers). character ( 99 ) :: output_cli = 'unset' !< Output files basename. logical :: plots = . false . !< Flag for activating plots saving. logical :: results = . false . !< Flag for activating results saving. character ( 99 ) :: solver = 'adams-bashforth' !< Solver used. integer ( I_P ), allocatable :: stages_steps (:) !< Number of stages/steps used. real ( R_P ), allocatable :: Dt (:) !< Time step(s) exercised. real ( R_P ), allocatable :: tolerance (:) !< Tolerance(s) exercised on local truncation error. contains private ! Public methods procedure , pass ( self ), public :: execute !< Execute selected test(s). ! Private methods procedure , pass ( self ), private :: init !< Initialize test: set Command Line Interface, parse it and check its validity. procedure , pass ( self ), private :: test !< Perform the test. endtype oscillation_test","tags":"","loc":"type/oscillation_test.html","title":"oscillation_test – FOODIE "},{"text":"type, public, extends(integrand) :: oscillation type~~oscillation~~InheritsGraph type~oscillation oscillation integrand integrand integrand->type~oscillation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Oscillation equations field. It is a FOODIE integrand class concrete extension. Oscillation ODEs system The (inertial) Oscillation equations system is a non linear system of pure ODEs and it can be written as: \\begin{matrix}\n U_t = R(U)  \\\\\n U = \\begin{bmatrix}\n v_1 \\\\\n v_2\n \\end{bmatrix}\\;\\;\\;\n R(U) = \\begin{bmatrix}\n -f v_2 \\\\\n f v_1\n \\end{bmatrix}\n\\end{matrix} The frequency f is constant and it is here selected as f=10&#94;-4 . In the space v1-v2 the path of the oscillation must be a circle, but for the frequency selected some ODE solvers are not\nstable leading to a wrong path, see [1]. Bibliography [1] Numerical Methods for Fluid Dynamics With Applications to Geophysics , Dale R. Durran, Springer, 2010. State variables organization State variables are organized as an array (rank 1) of reals of dims elements, in this case 2 elements. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. real(kind=R_P), private :: f = 0._R_P Oscillation frequency (Hz). real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, [1:dims]. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private pure subroutine init (self, initial_state, frequency) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of the Oscillation field vector. real(kind=R_P), intent(in) :: frequency Frequency of oscillation. Description Construct an initialized Oscillation field. procedure, public, pass(self) :: output Extract Oscillation field. private pure function output (self) result(state) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. Return Value real(kind=R_P),\n  dimension(:),allocatable Oscillation state vector. Description Output the Oscillation field state. procedure, public, pass(self) :: t => dOscillation_dt Time derivative, residuals. private pure function dOscillation_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Oscillation field time derivative. Description Time derivative of Oscillation field. procedure, public, pass(lhs) :: local_error => oscillation_local_error ||Oscillation-oscillation||. private pure function oscillation_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 oscillation approximations. procedure, public, pass(lhs) :: integrand_multiply_integrand => oscillation_multiply_oscillation Oscillation * oscillation. private pure function oscillation_multiply_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a oscillation field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => oscillation_multiply_real Oscillation * real. private pure function oscillation_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Oscillation field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_oscillation Real * Oscillation. private pure function real_multiply_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( oscillation ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Oscillation field. procedure, public, pass(lhs) :: add => add_oscillation Oscillation + Oscillation. private pure function add_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Oscillation fields. procedure, public, pass(lhs) :: sub => sub_oscillation Oscillation - Oscillation. private pure function sub_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Oscillation fields. procedure, public, pass(lhs) :: assign_integrand => oscillation_assign_oscillation Oscillation = Oscillation. private pure subroutine oscillation_assign_oscillation (lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Oscillation field to another. Source Code type , extends ( integrand ) :: oscillation !< Oscillation equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Oscillation ODEs system !<The (inertial) Oscillation equations system is a non linear system of pure ODEs and it can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< v_1 \\\\ !< v_2 !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< -f v_2 \\\\ !< f v_1 !< \\end{bmatrix} !<\\end{matrix} !< !<The frequency *f* is constant and it is here selected as *f=10&#94;-4*. !< !<In the space *v1-v2* the path of the oscillation must be a circle, but for the frequency selected some ODE solvers are not !<stable leading to a wrong path, see [1]. !< !<#### Bibliography !< !<[1] *Numerical Methods for Fluid Dynamics With Applications to Geophysics*, Dale R. Durran, Springer, 2010. !< !<#### State variables organization !< State variables are organized as an array (rank 1) of reals of *dims* elements, in this case 2 elements. private integer ( I_P ) :: dims = 0 !< Space dimensions. real ( R_P ) :: f = 0._R_P !< Oscillation frequency (Hz). real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, [1:dims]. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Oscillation field. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dOscillation_dt !< Time derivative, residuals. procedure , pass ( lhs ), public :: local_error => oscillation_local_error !<||Oscillation-oscillation||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => oscillation_multiply_oscillation !< Oscillation * oscillation. procedure , pass ( lhs ), public :: integrand_multiply_real => oscillation_multiply_real !< Oscillation * real. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_oscillation !< Real * Oscillation. procedure , pass ( lhs ), public :: add => add_oscillation !< Oscillation + Oscillation. procedure , pass ( lhs ), public :: sub => sub_oscillation !< Oscillation - Oscillation. procedure , pass ( lhs ), public :: assign_integrand => oscillation_assign_oscillation !< Oscillation = Oscillation. endtype oscillation","tags":"","loc":"type/oscillation.html","title":"oscillation – FOODIE "},{"text":"type, public :: euler_1D_caf_nf type~~euler_1d_caf_nf~~InheritsGraph type~euler_1d_caf_nf euler_1D_caf_nf type~weno_interpolator_upwind weno_interpolator_upwind type~weno_interpolator_upwind->type~euler_1d_caf_nf weno weno_interpolator weno_interpolator weno_interpolator->type~weno_interpolator_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Euler 1D (CAF enabled) PDEs system field. Note This object does not use FOODIE. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E)\n Finalize field. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type( weno_interpolator_upwind ), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. integer(kind=I_P), private :: me = 0 ID of this_image(). integer(kind=I_P), private :: we = 0 Number of CAF images used. Finalization Procedures final :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( euler_1D_caf_nf ), intent(inout) :: self Euler field. Description Destroy field. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, me, we, ord) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension (local image). integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in) :: me ID of this_image(). integer(kind=I_P), intent(in) :: we Number of CAF images used. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. procedure, public, pass(self) :: destroy Destroy field. private subroutine destroy (self) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: self Euler field. Description Destroy field. procedure, public, pass(self) :: output Extract Euler field. private pure function output (self, conservative) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. logical, intent(in), optional :: conservative Output conservative variables instead of primitive. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private pure function compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. generic, public :: assignment(=) => assign_integrand Overloading = assignament. private subroutine euler_assign_euler (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_caf_nf ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. procedure, private, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. Return Value type( euler_1D_caf_nf ) Euler field time derivative. Description Time derivative of Euler field, the residuals function. procedure, private, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_caf_nf ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private pure function primitive2conservative (self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private pure function conservative2primitive (self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. procedure, private, pass(self) :: synchronize Synchronize CAF images. private subroutine synchronize (self) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. Description Synchronize CAF images. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private subroutine impose_boundary_conditions (self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private pure subroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Source Code type :: euler_1D_caf_nf !< Euler 1D (CAF enabled) PDEs system field. !< !< @note This object does not use FOODIE. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. integer ( I_P ) :: me = 0 !< ID of this_image(). integer ( I_P ) :: we = 0 !< Number of CAF images used. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. ! private methods procedure , pass ( self ), private :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), private :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: synchronize !< Synchronize CAF images. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_caf_nf","tags":"","loc":"type/euler_1d_caf_nf.html","title":"euler_1D_caf_nf – FOODIE "},{"text":"type, public :: tvd_runge_kutta_integrator TVD RK integrator. Note The integrator must be created or initialized (initialize the RK coeficients) before used.\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. Finalization Procedures final :: finalize_rk private elemental subroutine finalize_rk (self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy => destroy_rk Destroy the integrator. private elemental subroutine destroy_rk (self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destoy the integrator. procedure, public, pass(self) :: init => init_rk Initialize (create) the integrator. private elemental subroutine init_rk (self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. procedure, public, pass(self) :: integrate => integrate_rk Integrate integrand field. private subroutine integrate_rk (self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( euler_1D_caf_nf ), intent(inout) :: U Field to be integrated. class( euler_1D_caf_nf ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Source Code type :: tvd_runge_kutta_integrator !< TVD RK integrator. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy => destroy_rk !< Destroy the integrator. procedure , pass ( self ), public :: init => init_rk !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate => integrate_rk !< Integrate integrand field. final :: finalize_rk !< Finalize object. endtype tvd_runge_kutta_integrator","tags":"","loc":"type/tvd_runge_kutta_integrator.html","title":"tvd_runge_kutta_integrator – FOODIE "},{"text":"type, public, extends(integrand) :: euler_1D_caf type~~euler_1d_caf~~InheritsGraph type~euler_1d_caf euler_1D_caf type~weno_interpolator_upwind weno_interpolator_upwind type~weno_interpolator_upwind->type~euler_1d_caf weno weno_interpolator weno_interpolator weno_interpolator->type~weno_interpolator_upwind integrand integrand integrand->type~euler_1d_caf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Euler 1D PDEs system field. It is a FOODIE integrand class concrete extension. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E)\n Finalize field. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type( weno_interpolator_upwind ), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. integer(kind=I_P), private :: me = 0 ID of this_image(). integer(kind=I_P), private :: we = 0 Number of CAF images used. Finalization Procedures final :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( euler_1D_caf ), intent(inout) :: self Euler field. Description Destroy field. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, me, we, ord) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension (local image). integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in) :: me ID of this_image(). integer(kind=I_P), intent(in) :: we Number of CAF images used. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. procedure, public, pass(self) :: destroy Destroy field. private subroutine destroy (self) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: self Euler field. Description Destroy field. procedure, public, pass(self) :: output Extract Euler field. private pure function output (self, conservative) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. logical, intent(in), optional :: conservative Output conservative variables instead of primitive. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private pure function compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. procedure, public, pass(lhs) :: local_error => euler_local_error ||euler-euler||. private function euler_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 euler approximations. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Euler * Euler operator. private function euler_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Euler * real operator. private function euler_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Real * Euler operator. private function real_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D_caf ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. procedure, public, pass(lhs) :: add => add_euler Euler + Euler operator. private function add_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. procedure, public, pass(lhs) :: sub => sub_euler Euler - Euler. private function sub_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. procedure, public, pass(lhs) :: assign_real => euler_assign_real Euler = real. private subroutine euler_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private pure function primitive2conservative (self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private pure function conservative2primitive (self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. procedure, private, pass(self) :: synchronize Synchronize CAF images. private subroutine synchronize (self) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. Description Synchronize CAF images. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private subroutine impose_boundary_conditions (self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private pure subroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Source Code type , extends ( integrand ) :: euler_1D_caf !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. integer ( I_P ) :: me = 0 !< ID of this_image(). integer ( I_P ) :: we = 0 !< Number of CAF images used. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !<||euler-euler||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: synchronize !< Synchronize CAF images. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_caf","tags":"","loc":"type/euler_1d_caf.html","title":"euler_1D_caf – FOODIE "},{"text":"type, public :: euler_1D_omp_nf type~~euler_1d_omp_nf~~InheritsGraph type~euler_1d_omp_nf euler_1D_omp_nf type~weno_interpolator_upwind weno_interpolator_upwind type~weno_interpolator_upwind->type~euler_1d_omp_nf weno weno_interpolator weno_interpolator weno_interpolator->type~weno_interpolator_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Euler 1D (OpenMP enabled) PDEs system field. Note This object does not use FOODIE. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E)\n Finalize field. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type( weno_interpolator_upwind ), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalization Procedures final :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( euler_1D_omp_nf ), intent(inout) :: self Euler field. Description Destroy field. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, ord) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. procedure, public, pass(self) :: destroy Destroy field. private pure subroutine destroy (self) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: self Euler field. Description Destroy field. procedure, public, pass(self) :: output Extract Euler field. private pure function output (self) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private pure function compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. generic, public :: assignment(=) => assign_integrand Overloading = assignament. private subroutine euler_assign_euler (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_omp_nf ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. procedure, private, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. Return Value type( euler_1D_omp_nf ) Euler field time derivative. Description Time derivative of Euler field, the residuals function. procedure, private, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_omp_nf ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private pure function primitive2conservative (self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private pure function conservative2primitive (self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private pure subroutine impose_boundary_conditions (self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private pure subroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Source Code type :: euler_1D_omp_nf !< Euler 1D (OpenMP enabled) PDEs system field. !< !< @note This object does not use FOODIE. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. ! private methods procedure , pass ( self ), private :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), private :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_omp_nf","tags":"","loc":"type/euler_1d_omp_nf.html","title":"euler_1D_omp_nf – FOODIE "},{"text":"type, public :: tvd_runge_kutta_integrator TVD RK integrator. Note The integrator must be created or initialized (initialize the RK coeficients) before used.\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. Finalization Procedures final :: finalize_rk private elemental subroutine finalize_rk (self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy => destroy_rk Destroy the integrator. private elemental subroutine destroy_rk (self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destoy the integrator. procedure, public, pass(self) :: init => init_rk Initialize (create) the integrator. private elemental subroutine init_rk (self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. procedure, public, pass(self) :: integrate => integrate_rk Integrate integrand field. private subroutine integrate_rk (self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( euler_1D_omp_nf ), intent(inout) :: U Field to be integrated. class( euler_1D_omp_nf ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Source Code type :: tvd_runge_kutta_integrator !< TVD RK integrator. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy => destroy_rk !< Destroy the integrator. procedure , pass ( self ), public :: init => init_rk !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate => integrate_rk !< Integrate integrand field. final :: finalize_rk !< Finalize object. endtype tvd_runge_kutta_integrator","tags":"","loc":"type/tvd_runge_kutta_integrator~2.html","title":"tvd_runge_kutta_integrator – FOODIE "},{"text":"type, public, extends(integrand) :: euler_1D_openmp type~~euler_1d_openmp~~InheritsGraph type~euler_1d_openmp euler_1D_openmp type~weno_interpolator_upwind weno_interpolator_upwind type~weno_interpolator_upwind->type~euler_1d_openmp weno weno_interpolator weno_interpolator weno_interpolator->type~weno_interpolator_upwind integrand integrand integrand->type~euler_1d_openmp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Euler 1D (OpenMP enabled) PDEs system field. It is a FOODIE integrand class concrete extension. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E)\n Finalize field. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type( weno_interpolator_upwind ), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalization Procedures final :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( euler_1D_openmp ), intent(inout) :: self Euler field. Description Destroy field. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, ord) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. procedure, public, pass(self) :: destroy Destroy field. private pure subroutine destroy (self) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: self Euler field. Description Destroy field. procedure, public, pass(self) :: output Extract Euler field. private pure function output (self) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private pure function compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. procedure, public, pass(lhs) :: local_error => euler_local_error ||euler-euler||. private function euler_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 euler approximations. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Euler * Euler operator. private function euler_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Euler * real operator. private function euler_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Real * Euler operator. private function real_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D_openmp ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. procedure, public, pass(lhs) :: add => add_euler Euler + Euler operator. private function add_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. procedure, public, pass(lhs) :: sub => sub_euler Euler - Euler. private function sub_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. procedure, public, pass(lhs) :: assign_real => euler_assign_real Euler = real. private subroutine euler_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private pure function primitive2conservative (self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private pure function conservative2primitive (self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private pure subroutine impose_boundary_conditions (self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private pure subroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Source Code type , extends ( integrand ) :: euler_1D_openmp !< Euler 1D (OpenMP enabled) PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !<||euler-euler||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_openmp","tags":"","loc":"type/euler_1d_openmp.html","title":"euler_1D_openmp – FOODIE "},{"text":"type, public, extends(integrand) :: burgers type~~burgers~~InheritsGraph type~burgers burgers integrand integrand integrand->type~burgers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Burgers equations field. It is a FOODIE integrand class concrete extension. Burgers PDE equation The Burgers PDE equation is a non linear PDE widely used as numerical benchmark that can be applied to describe\na wide range of different problems, from fluid dynamics to traffic flows, see [1]. \n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = [u]\\;\\;\\;\nF(U) = [-\\frac{1}{2}u&#94;2+\\nu u_x]\n\\end{matrix}\n This is the viscous Burgers' equation, \\nu being the viscosity. This equation is of paramount relevance because it retains\ncomplex aspects such as the hyperbolic nature of the convection term (allowing discontinuous solutions) and the diffusive nature\nof the viscous term. Bibliography [1] The partial differential equation ut + uux = nuxx , Hopf, Eberhard, Communications on Pure and Applied Mathematics,\n vol 3, issue 3, doi 10.1002/cpa.3160030302, pp. 201–230, 1950. State variables organization State variable is organized as an array (rank 1) for whole physical domain. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. integer(kind=I_P), private :: Ni = 0 Number of grid nodes. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private :: h = 0._R_P Space step discretization. real(kind=R_P), private :: nu = 0._R_P Viscosity. real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, whole physical domain, [1:Ni]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:Ni,1:steps]. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, initial_state, Ni, h, nu, steps) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. real(kind=R_P), intent(in), dimension(1:Ni) :: initial_state Initial state of Burgers field domain. integer(kind=I_P), intent(in) :: Ni Number of grid nodes. real(kind=R_P), intent(in) :: h Space step discretization. real(kind=R_P), intent(in) :: nu Viscosity. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Burgers field. procedure, public, pass(self) :: output Extract Burgers field. private pure function output (self) result(state) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value real(kind=R_P),\n  dimension(:),allocatable Burgers state variable. Description Output the Burgers field state. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private pure function compute_dt (self, CFL) result(dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in) :: CFL Courant-Friedricks-Lewi stability coefficient. Return Value real(kind=R_P) Current time step. Description Compute the current time step, by means of CFL condition. procedure, public, pass(self) :: t => dBurgers_dt Time derivative, residuals func. private function dBurgers_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Burgers field time derivative. Description Time derivative of Burgers field, residuals function. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Burgers field. Description Extract previous time solution of Burgers field. procedure, public, pass(lhs) :: local_error => burgers_local_error Local error. private function burgers_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 burgers approximations. procedure, public, pass(lhs) :: integrand_multiply_integrand => burgers_multiply_burgers Burgers * burgers operator. private function burgers_multiply_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => burgers_multiply_real Burgers * real operator. private function burgers_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_burgers Real * Burgers operator. private function real_multiply_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( burgers ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Burgers field. procedure, public, pass(lhs) :: add => add_burgers Burgers + Burgers operator. private function add_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Burgers fields. procedure, public, pass(lhs) :: sub => sub_burgers Burgers - Burgers operator. private function sub_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Burgers fields. procedure, public, pass(lhs) :: assign_integrand => burgers_assign_burgers Burgers = Burgers. private subroutine burgers_assign_burgers (lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Burgers field to another. procedure, public, pass(lhs) :: assign_real => burgers_assign_real Burgers = real. private subroutine burgers_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Burgers field. procedure, private, pass(self) :: x => dBurgers_dx 1st derivative. private function dBurgers_dx (self) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative. Description Compute the first order spatial derivative of Burgers field. procedure, private, pass(self) :: xx => d2Burgers_dx2 2nd derivative. private function d2Burgers_dx2 (self) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative. Description Compute the second order spatial derivative of Burgers field. Source Code type , extends ( integrand ) :: burgers !< Burgers equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Burgers PDE equation !<The Burgers PDE equation is a non linear PDE widely used as numerical benchmark that can be applied to describe !<a wide range of different problems, from fluid dynamics to traffic flows, see [1]. !< !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = [u]\\;\\;\\; !<F(U) = [-\\frac{1}{2}u&#94;2+\\nu u_x] !<\\end{matrix} !< !< !<This is the viscous Burgers' equation, \\nu being the viscosity. This equation is of paramount relevance because it retains !<complex aspects such as the hyperbolic nature of the convection term (allowing discontinuous solutions) and the diffusive nature !<of the viscous term. !< !<#### Bibliography !< !<[1] *The partial differential equation ut + uux = nuxx*, Hopf, Eberhard, Communications on Pure and Applied Mathematics, !< vol 3, issue 3, doi 10.1002/cpa.3160030302, pp. 201--230, 1950. !< !<#### State variables organization !< State variable is organized as an array (rank 1) for whole physical domain. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: Ni = 0 !< Number of grid nodes. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ) :: h = 0._R_P !< Space step discretization. real ( R_P ) :: nu = 0._R_P !< Viscosity. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, whole physical domain, [1:Ni]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:Ni,1:steps]. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Burgers field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dBurgers_dt !< Time derivative, residuals func. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: local_error => burgers_local_error !< Local error. procedure , pass ( lhs ), public :: integrand_multiply_integrand => burgers_multiply_burgers !< Burgers * burgers operator. procedure , pass ( lhs ), public :: integrand_multiply_real => burgers_multiply_real !< Burgers * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_burgers !< Real * Burgers operator. procedure , pass ( lhs ), public :: add => add_burgers !< Burgers + Burgers operator. procedure , pass ( lhs ), public :: sub => sub_burgers !< Burgers - Burgers operator. procedure , pass ( lhs ), public :: assign_integrand => burgers_assign_burgers !< Burgers = Burgers. procedure , pass ( lhs ), public :: assign_real => burgers_assign_real !< Burgers = real. ! private methods procedure , pass ( self ), private :: x => dBurgers_dx !< 1st derivative. procedure , pass ( self ), private :: xx => d2Burgers_dx2 !< 2nd derivative. endtype burgers","tags":"","loc":"type/burgers.html","title":"burgers – FOODIE "},{"text":"type, public, extends(integrand) :: euler_1D type~~euler_1d~~InheritsGraph type~euler_1d euler_1D type~weno_interpolator_upwind weno_interpolator_upwind type~weno_interpolator_upwind->type~euler_1d weno weno_interpolator weno_interpolator weno_interpolator->type~weno_interpolator_upwind integrand integrand integrand->type~euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Euler 1D PDEs system field. It is a FOODIE integrand class concrete extension. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E)\n Finalize field. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps stored. integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type( weno_interpolator_upwind ), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real(kind=R_P), private, allocatable :: previous (:,:,:) Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalization Procedures final :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( euler_1D ), intent(inout) :: self Euler field. Description Destroy field. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, steps, ord) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: steps Time steps stored. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. procedure, public, pass(self) :: destroy Destroy field. private pure subroutine destroy (self) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. Description Destroy field. procedure, public, pass(self) :: output Extract Euler field. private pure function output (self) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private pure function compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. procedure, public, pass(lhs) :: local_error => euler_local_error Local error. private function euler_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 euler approximations. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Euler field. Description Extract previous time solution of Euler field. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Euler * Euler operator. private function euler_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Euler * real operator. private function euler_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Real * Euler operator. private function real_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. procedure, public, pass(lhs) :: add => add_euler Euler + Euler operator. private function add_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. procedure, public, pass(lhs) :: sub => sub_euler Euler - Euler. private function sub_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. procedure, public, pass(lhs) :: assign_real => euler_assign_real Euler = real. private subroutine euler_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private pure function primitive2conservative (self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private pure function conservative2primitive (self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private pure subroutine impose_boundary_conditions (self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private pure subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private pure subroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Source Code type , extends ( integrand ) :: euler_1D !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: steps = 0 !< Number of time steps stored. integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real ( R_P ), allocatable :: previous (:,:,:) !< Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !< Local error. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D","tags":"","loc":"type/euler_1d.html","title":"euler_1D – FOODIE "},{"text":"type, public, extends(integrand) :: lorenz type~~lorenz~~InheritsGraph type~lorenz lorenz integrand integrand integrand->type~lorenz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Lorenz equations field. It is a FOODIE integrand class concrete extension. Lorenz ODEs system The Lorenz' equations system [1] is a non linear system of pure ODEs that retains a reasonable-complex behaviour: such a\nsystem, for a certain parameters-region exhibits a chaotic dynamics useful for testing FOODIE solvers. The Lorenz' ODEs system can be written as: \\begin{matrix}\n U_t = R(U)  \\\\\n U = \\begin{bmatrix}\n v_1 \\\\\n v_2 \\\\\n v_3\n \\end{bmatrix}\\;\\;\\;\n R(U) = \\begin{bmatrix}\n \\sigma (v_2-v_1) \\\\\n v_1(\\rho - v_3) -v_2 \\\\\n v_1 v_2 - \\beta v_3\n \\end{bmatrix}\n\\end{matrix} The parameters set is constant and it is here selected as: \\begin{matrix}\n \\sigma = 10 \\\\\n \\rho = 28 \\\\\n \\beta = \\frac{8}{3}\n\\end{matrix} These values are chaos-inducing thus they magnify the eventual numerical inaccuracies of FOODIE solvers, see [2]. Bibliography [1] Deterministic Nonperiodic Flow , Lorenz E.N., Journal of the Atmospheric Sciences, 1963, vol. 20, pp. 130–141,\ndoi: http://dx.doi.org/10.1175/1520-0469(1963)020<0130:DNF>2.0.CO;2 [2] Scientific software design: the object-oriented way , Rouson, Damian, Jim Xia, and Xiaofeng Xu,\nCambridge University Press, 2011 State variables organization State variables are organized as an array (rank 1) of reals of dims elements, in this case 3 elements. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, [1:dims]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:dims,1:steps]. real(kind=R_P), private :: sigma = 0._R_P Lorenz \\sigma. real(kind=R_P), private :: rho = 0._R_P Lorenz \\rho. real(kind=R_P), private :: beta = 0._R_P Lorenz \\beta. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, initial_state, sigma, rho, beta, steps) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Lorenz field. procedure, public, pass(self) :: output Extract Lorenz field. private pure function output (self) result(state) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value real(kind=R_P),\n  dimension(:),allocatable Lorenz state vector. Description Output the Lorenz field state. procedure, public, pass(self) :: t => dLorenz_dt Time derivative, residuals function. private function dLorenz_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Lorenz field time derivative. Description Time derivative of Lorenz field. procedure, public, pass(lhs) :: local_error => lorenz_local_error Local error. private function lorenz_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 lorenz approximations. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Lorenz field. Description Extract previous time solution of Lorenz field. procedure, public, pass(lhs) :: integrand_multiply_integrand => lorenz_multiply_lorenz Lorenz * Lorenz operator. private function lorenz_multiply_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a lorenz field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => lorenz_multiply_real Lorenz * real operator. private function lorenz_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Lorenz field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_lorenz Real * Lorenz operator. private function real_multiply_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( lorenz ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Lorenz field. procedure, public, pass(lhs) :: add => add_lorenz Lorenz + Lorenz operator. private function add_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Lorenz fields. procedure, public, pass(lhs) :: sub => sub_lorenz Lorenz - Lorenz. private function sub_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Lorenz fields. procedure, public, pass(lhs) :: assign_integrand => lorenz_assign_lorenz Lorenz = Lorenz. private subroutine lorenz_assign_lorenz (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Lorenz field to another. procedure, public, pass(lhs) :: assign_real => lorenz_assign_real Lorenz = real. private subroutine lorenz_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Lorenz field. Source Code type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Lorenz ODEs system !<The Lorenz' equations system [1] is a non linear system of pure ODEs that retains a reasonable-complex behaviour: such a !<system, for a certain parameters-region exhibits a chaotic dynamics useful for testing FOODIE solvers. !< !<The Lorenz' ODEs system can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< v_1 \\\\ !< v_2 \\\\ !< v_3 !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< \\sigma (v_2-v_1) \\\\ !< v_1(\\rho - v_3) -v_2 \\\\ !< v_1 v_2 - \\beta v_3 !< \\end{bmatrix} !<\\end{matrix} !< !<The parameters set is constant and it is here selected as: !< !<\\begin{matrix} !< \\sigma = 10 \\\\ !< \\rho = 28 \\\\ !< \\beta = \\frac{8}{3} !<\\end{matrix} !< !<These values are chaos-inducing thus they magnify the eventual numerical inaccuracies of FOODIE solvers, see [2]. !< !<#### Bibliography !< !<[1] *Deterministic Nonperiodic Flow*, Lorenz E.N., Journal of the Atmospheric Sciences, 1963, vol. 20, pp. 130--141, !<doi: http://dx.doi.org/10.1175/1520-0469(1963)020<0130:DNF>2.0.CO;2 !< !<[2] *Scientific software design: the object-oriented way*, Rouson, Damian, Jim Xia, and Xiaofeng Xu, !<Cambridge University Press, 2011 !< !<#### State variables organization !< State variables are organized as an array (rank 1) of reals of *dims* elements, in this case 3 elements. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, [1:dims]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:dims,1:steps]. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Lorenz field. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => lorenz_local_error !< Local error. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => lorenz_multiply_lorenz !< Lorenz * Lorenz operator. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< Lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz operator. procedure , pass ( lhs ), public :: sub => sub_lorenz !< Lorenz - Lorenz. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. endtype lorenz","tags":"","loc":"type/lorenz.html","title":"lorenz – FOODIE "},{"text":"type, private, abstract :: Type_Object Abstract object defining data and methods that are common to CLA, CLAG and CLI. Inherited By type~~type_object~~InheritedByGraph type~type_object Type_Object type~type_command_line_argument Type_Command_Line_Argument type~type_object->type~type_command_line_argument type~type_command_line_interface Type_Command_Line_Interface type~type_object->type~type_command_line_interface type~type_command_line_arguments_group Type_Command_Line_Arguments_Group type~type_object->type~type_command_line_arguments_group type~type_command_line_argument->type~type_command_line_arguments_group cla type~type_command_line_arguments_group->type~type_command_line_interface clasg var pantypetype_objectInheritedByGraph = svgPanZoom('#typetype_objectInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), private, allocatable :: help Help message. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilog message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). integer(kind=I4P), public :: error = 0_I4P Error traping flag. Type-Bound Procedures procedure, public :: free_object Free dynamic memory. private elemental subroutine free_object (obj) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: obj Object data. Description Free dynamic memory. procedure, public :: errored Trig error occurence and print meaningful message. private subroutine errored (obj, error, pref, group, switch, val_str, log_value, a1, a2) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: obj Object data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Group name. character(len=*), intent(in), optional :: switch CLA switch name. character(len=*), intent(in), optional :: val_str Value string. character(len=*), intent(in), optional :: log_value Logical value to be casted. integer(kind=I4P), intent(in), optional :: a1 First index CLAs group inconsistent. integer(kind=I4P), intent(in), optional :: a2 Second index CLAs group inconsistent. Description Trig error occurence and print meaningful message. procedure, public :: print_version Print version. private subroutine print_version (obj, pref) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(in) :: obj Object data. character(len=*), intent(in), optional :: pref Prefixing string. Description Print version. procedure, public :: assign_object Assignment overloading. private elemental subroutine assign_object (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: lhs Left hand side. class( Type_Object ), intent(in) :: rhs Rigth hand side. Description Assign two abstract objects. Source Code type , abstract :: Type_Object !< Abstract object defining data and methods that are common to CLA, CLAG and CLI. private character ( len = :), public , allocatable :: progname !< Program name. character ( len = :), public , allocatable :: version !< Program version. character ( len = :), allocatable :: help !< Help message. character ( len = :), public , allocatable :: description !< Detailed description. character ( len = :), public , allocatable :: license !< License description. character ( len = :), public , allocatable :: authors !< Authors list. character ( len = :), public , allocatable :: epilog !< Epilog message. character ( len = :), public , allocatable :: m_exclude !< Mutually exclude other CLA(s group). integer ( I4P ), public :: error = 0_I4P !< Error traping flag. contains procedure :: free_object !< Free dynamic memory. procedure :: errored !< Trig error occurence and print meaningful message. procedure :: print_version !< Print version. procedure :: assign_object !< Assignment overloading. endtype Type_Object","tags":"","loc":"type/type_object.html","title":"Type_Object – FOODIE "},{"text":"type, private, extends( Type_Object ) :: Type_Command_Line_Argument type~~type_command_line_argument~~InheritsGraph type~type_command_line_argument Type_Command_Line_Argument type~type_object Type_Object type~type_object->type~type_command_line_argument Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Command line arguments (CLA). Note If not otherwise declared the action on CLA value is set to \"store\" a value.\n Free dynamic memory when finalizing. Inherited By type~~type_command_line_argument~~InheritedByGraph type~type_command_line_argument Type_Command_Line_Argument type~type_command_line_arguments_group Type_Command_Line_Arguments_Group type~type_command_line_argument->type~type_command_line_arguments_group cla type~type_command_line_interface Type_Command_Line_Interface type~type_command_line_arguments_group->type~type_command_line_interface clasg var pantypetype_command_line_argumentInheritedByGraph = svgPanZoom('#typetype_command_line_argumentInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: switch Switch name. character(len=:), private, allocatable :: switch_ab Abbreviated switch name. logical, private :: required = .false. Flag for set required argument. logical, private :: positional = .false. Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), private :: position = 0_I4P Position of positional CLA. logical, private :: passed = .false. Flag for checking if CLA has been passed to CLI. logical, private :: hidden = .false. Flag for hiding CLA, thus it does not compare into help. character(len=:), private, allocatable :: act CLA value action. character(len=:), private, allocatable :: def Default value. character(len=:), private, allocatable :: nargs Number of arguments consumed by CLA. character(len=:), private, allocatable :: choices List (comma separated) of allowable values for the argument. character(len=:), private, allocatable :: val CLA value. character(len=:), private, allocatable :: envvar Environment variable from which take value. Finalization Procedures final :: finalize_cla private elemental subroutine finalize_cla (cla) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. Description Free dynamic memory when finalizing. Type-Bound Procedures procedure, public :: free => free_cla Free dynamic memory. private elemental subroutine free_cla (cla) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. Description Free dynamic memory. procedure, public :: check => check_cla Check CLA data consistency. private subroutine check_cla (cla, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check CLA data consistency. procedure, public :: check_choices => check_choices_cla Check if CLA value is in allowed choices. private subroutine check_choices_cla (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. class(*), intent(in) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if CLA value is in allowed choices. procedure, public :: check_list_size => check_list_size_cla Check CLA multiple values list size consistency. private function check_list_size_cla (cla, Nv, val, pref) result(is_ok) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I4P), intent(in) :: Nv Number of values. character(len=*), intent(in) :: val First value. character(len=*), intent(in), optional :: pref Prefixing string. Return Value logical Check result. Description Check CLA multiple values list size consistency. generic, public :: get => get_cla , get_cla_list Get CLA value(s). private subroutine get_cla (cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val CLA value. Description Get CLA (single) value. private subroutine get_cla_list (cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. Description Get CLA (multiple) value. generic, public :: get_varying => get_cla_list_varying_R8P , get_cla_list_varying_R4P , get_cla_list_varying_I8P , get_cla_list_varying_I4P , get_cla_list_varying_I2P , get_cla_list_varying_I1P , get_cla_list_varying_logical , get_cla_list_varying_char Get CLA value(s) from CLAs list parsedi, varying size list. private subroutine get_cla_list_varying_R8P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R8P). private subroutine get_cla_list_varying_R4P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R4P). private subroutine get_cla_list_varying_I8P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I8P). private subroutine get_cla_list_varying_I4P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I4P). private subroutine get_cla_list_varying_I2P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I2P). private subroutine get_cla_list_varying_I1P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I1P). private subroutine get_cla_list_varying_logical (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, logical. private subroutine get_cla_list_varying_char (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, character. procedure, public :: usage => usage_cla Get correct CLA usage. private function usage_cla (cla, pref) result(usage) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(in) :: cla CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Return Value character(len=:),\n  allocatable Usage string. Description Get correct CLA usage. procedure, public :: signature => signature_cla Get CLA signature for adding to CLI one. private function signature_cla (cla) result(signd) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(in) :: cla CLA data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLA signature for adding to the CLI one. procedure, private :: get_cla Get CLA (single) value from CLAs list parsed. private subroutine get_cla (cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val CLA value. Description Get CLA (single) value. procedure, private :: get_cla_list Get CLA multiple values from CLAs list parsed. private subroutine get_cla_list (cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. Description Get CLA (multiple) value. procedure, private :: get_cla_list_varying_R8P Get CLA multiple values from CLAs list parsed, varying size, R8P. private subroutine get_cla_list_varying_R8P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R8P). procedure, private :: get_cla_list_varying_R4P Get CLA multiple values from CLAs list parsed, varying size, R4P. private subroutine get_cla_list_varying_R4P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R4P). procedure, private :: get_cla_list_varying_I8P Get CLA multiple values from CLAs list parsed, varying size, I8P. private subroutine get_cla_list_varying_I8P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I8P). procedure, private :: get_cla_list_varying_I4P Get CLA multiple values from CLAs list parsed, varying size, I4P. private subroutine get_cla_list_varying_I4P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I4P). procedure, private :: get_cla_list_varying_I2P Get CLA multiple values from CLAs list parsed, varying size, I2P. private subroutine get_cla_list_varying_I2P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I2P). procedure, private :: get_cla_list_varying_I1P Get CLA multiple values from CLAs list parsed, varying size, I1P. private subroutine get_cla_list_varying_I1P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I1P). procedure, private :: get_cla_list_varying_logical Get CLA multiple values from CLAs list parsed, varying size, bool. private subroutine get_cla_list_varying_logical (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, logical. procedure, private :: get_cla_list_varying_char Get CLA multiple values from CLAs list parsed, varying size, char. private subroutine get_cla_list_varying_char (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, character. procedure, private :: assign_cla CLA assignment overloading. private elemental subroutine assign_cla (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Argument ), intent(in) :: rhs Rigth hand side. Description Assign two CLA. generic, private :: assignment(=) => assign_cla CLA assignment overloading. private elemental subroutine assign_cla (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Argument ), intent(in) :: rhs Rigth hand side. Description Assign two CLA. Source Code type , extends ( Type_Object ) :: Type_Command_Line_Argument !< Command line arguments (CLA). !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value. private character ( len = :), allocatable :: switch !< Switch name. character ( len = :), allocatable :: switch_ab !< Abbreviated switch name. logical :: required = . false . !< Flag for set required argument. logical :: positional = . false . !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ) :: position = 0_I4P !< Position of positional CLA. logical :: passed = . false . !< Flag for checking if CLA has been passed to CLI. logical :: hidden = . false . !< Flag for hiding CLA, thus it does not compare into help. character ( len = :), allocatable :: act !< CLA value action. character ( len = :), allocatable :: def !< Default value. character ( len = :), allocatable :: nargs !< Number of arguments consumed by CLA. character ( len = :), allocatable :: choices !< List (comma separated) of allowable values for the argument. character ( len = :), allocatable :: val !< CLA value. character ( len = :), allocatable :: envvar !< Environment variable from which take value. contains ! public methods procedure , public :: free => free_cla !< Free dynamic memory. procedure , public :: check => check_cla !< Check CLA data consistency. procedure , public :: check_choices => check_choices_cla !< Check if CLA value is in allowed choices. procedure , public :: check_list_size => check_list_size_cla !< Check CLA multiple values list size consistency. generic , public :: get => get_cla , get_cla_list !< Get CLA value(s). generic , public :: get_varying => & !< Get CLA value(s) from CLAs list parsedi, varying size list. #ifdef r16p get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char procedure , public :: usage => usage_cla !< Get correct CLA usage. procedure , public :: signature => signature_cla !< Get CLA signature for adding to CLI one. ! private methods procedure , private :: get_cla !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: assign_cla !< CLA assignment overloading. generic , private :: assignment ( = ) => assign_cla !< CLA assignment overloading. final :: finalize_cla !< Free dynamic memory when finalizing. endtype Type_Command_Line_Argument","tags":"","loc":"type/type_command_line_argument.html","title":"Type_Command_Line_Argument – FOODIE "},{"text":"type, private, extends( Type_Object ) :: Type_Command_Line_Arguments_Group type~~type_command_line_arguments_group~~InheritsGraph type~type_command_line_arguments_group Type_Command_Line_Arguments_Group type~type_command_line_argument Type_Command_Line_Argument type~type_command_line_argument->type~type_command_line_arguments_group cla type~type_object Type_Object type~type_object->type~type_command_line_arguments_group type~type_object->type~type_command_line_argument Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Group of CLAs for building nested commands.\n Free dynamic memory when finalizing. Inherited By type~~type_command_line_arguments_group~~InheritedByGraph type~type_command_line_arguments_group Type_Command_Line_Arguments_Group type~type_command_line_interface Type_Command_Line_Interface type~type_command_line_arguments_group->type~type_command_line_interface clasg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: group Group name (command). integer(kind=I4P), private :: Na = 0_I4P Number of CLA. integer(kind=I4P), private :: Na_required = 0_I4P Number of command line arguments that CLI requires. integer(kind=I4P), private :: Na_optional = 0_I4P Number of command line arguments that are optional for CLI. type( Type_Command_Line_Argument ), private, allocatable :: cla (:) CLA list [1:Na]. logical, private :: called = .false. Flag for checking if CLAs group has been passed to CLI. Finalization Procedures final :: finalize_clasg private elemental subroutine finalize_clasg (clasg) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. Description Free dynamic memory when finalizing. Type-Bound Procedures procedure, public :: free => free_clasg Free dynamic memory. private elemental subroutine free_clasg (clasg) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. Description Free dynamic memory. procedure, public :: check => check_clasg Check CLAs data consistency. private subroutine check_clasg (clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check CLA data consistency. procedure, public :: check_required => check_required_clasg Check if required CLAs are passed. private subroutine check_required_clasg (clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if required CLAs are passed. procedure, public :: check_m_exclusive => check_m_exclusive_clasg Check if two mutually exclusive CLAs have been passed. private subroutine check_m_exclusive_clasg (clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if two mutually exclusive CLAs have been passed. procedure, public :: add => add_cla_clasg Add CLA to CLAs group. private subroutine add_cla_clasg (clasg, pref, cla) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. type( Type_Command_Line_Argument ), intent(in) :: cla CLA data. Description Add CLA to CLAs list. procedure, public :: passed => passed_clasg Check if a CLA has been passed. private pure function passed_clasg (clasg, switch, position) result(passed) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Description Check if a CLA has been passed. procedure, public :: defined => defined_clasg Check if a CLA has been defined. private function defined_clasg (clasg, switch, pos) result(defined) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in) :: switch Switch name. integer(kind=I4P), intent(out), optional :: pos CLA position. Return Value logical Check if a CLA has been defined. Description Check if a CLA has been defined. procedure, public :: parse => parse_clasg Parse CLAs group arguments. private subroutine parse_clasg (clasg, pref, args) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in) :: args (:) Command line arguments. Description Parse CLAs group arguments. procedure, public :: usage => usage_clasg Get correct CLAs group usage. private function usage_clasg (clasg, pref, no_header) result(usage) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. Return Value character(len=:),\n  allocatable Usage string. Description Get correct CLAs group usage. procedure, public :: signature => signature_clasg Get CLAs group signature for adding to the CLI one. private function signature_clasg (clasg) result(signd) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLAs group signature for adding to the CLI one. procedure, private :: assign_clasg CLAs group assignment overloading. private elemental subroutine assign_clasg (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Arguments_Group ), intent(in) :: rhs Right hand side. Description Assign two CLASg. generic, private :: assignment(=) => assign_clasg CLAs group assignment overloading. private elemental subroutine assign_clasg (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Arguments_Group ), intent(in) :: rhs Right hand side. Description Assign two CLASg. Source Code type , extends ( Type_Object ) :: Type_Command_Line_Arguments_Group !< Group of CLAs for building nested commands. private character ( len = :), allocatable :: group !< Group name (command). integer ( I4P ) :: Na = 0_I4P !< Number of CLA. integer ( I4P ) :: Na_required = 0_I4P !< Number of command line arguments that CLI requires. integer ( I4P ) :: Na_optional = 0_I4P !< Number of command line arguments that are optional for CLI. type ( Type_Command_Line_Argument ), allocatable :: cla (:) !< CLA list [1:Na]. logical :: called = . false . !< Flag for checking if CLAs group has been passed to CLI. contains ! public methods procedure , public :: free => free_clasg !< Free dynamic memory. procedure , public :: check => check_clasg !< Check CLAs data consistency. procedure , public :: check_required => check_required_clasg !< Check if required CLAs are passed. procedure , public :: check_m_exclusive => check_m_exclusive_clasg !< Check if two mutually exclusive CLAs have been passed. procedure , public :: add => add_cla_clasg !< Add CLA to CLAs group. procedure , public :: passed => passed_clasg !< Check if a CLA has been passed. procedure , public :: defined => defined_clasg !< Check if a CLA has been defined. procedure , public :: parse => parse_clasg !< Parse CLAs group arguments. procedure , public :: usage => usage_clasg !< Get correct CLAs group usage. procedure , public :: signature => signature_clasg !< Get CLAs group signature for adding to the CLI one. ! private methods procedure , private :: assign_clasg !< CLAs group assignment overloading. generic , private :: assignment ( = ) => assign_clasg !< CLAs group assignment overloading. final :: finalize_clasg !< Free dynamic memory when finalizing. endtype Type_Command_Line_Arguments_Group","tags":"","loc":"type/type_command_line_arguments_group.html","title":"Type_Command_Line_Arguments_Group – FOODIE "},{"text":"type, public, extends( Type_Object ) :: Type_Command_Line_Interface type~~type_command_line_interface~~InheritsGraph type~type_command_line_interface Type_Command_Line_Interface type~type_command_line_arguments_group Type_Command_Line_Arguments_Group type~type_command_line_arguments_group->type~type_command_line_interface clasg type~type_command_line_argument Type_Command_Line_Argument type~type_command_line_argument->type~type_command_line_arguments_group cla type~type_object Type_Object type~type_object->type~type_command_line_interface type~type_object->type~type_command_line_arguments_group type~type_object->type~type_command_line_argument var pantypetype_command_line_interfaceInheritsGraph = svgPanZoom('#typetype_command_line_interfaceInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Command Line Interface (CLI).\n Free dynamic memory when finalizing. Components Type Visibility Attributes Name Initial type( Type_Command_Line_Arguments_Group ), private, allocatable :: clasg (:) CLA list [1:Na]. character(len=512), private, allocatable :: args (:) Actually passed command line arguments. character(len=512), private, allocatable :: examples (:) Examples of correct usage. logical, private :: disable_hv = .false. Disable automatic 'help' and 'version' CLAs. Finalization Procedures final :: finalize private elemental subroutine finalize (cli) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. Description Free dynamic memory when finalizing. Type-Bound Procedures procedure, public :: free Free dynamic memory. private elemental subroutine free (cli) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. Description Free dynamic memory. procedure, public :: init Initialize CLI. private subroutine init (cli, progname, version, help, description, license, authors, examples, epilog, disable_hv) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: progname Program name. character(len=*), intent(in), optional :: version Program version. character(len=*), intent(in), optional :: help Help message introducing the CLI usage. character(len=*), intent(in), optional :: description Detailed description message introducing the program. character(len=*), intent(in), optional :: license License description. character(len=*), intent(in), optional :: authors Authors list. character(len=*), intent(in), optional :: examples (1:) Examples of correct usage. character(len=*), intent(in), optional :: epilog Epilog message. logical, intent(in), optional :: disable_hv Disable automatic insert of 'help' and 'version' CLAs. Description Initialize CLI. procedure, public :: add_group Add CLAs group CLI. private subroutine add_group (cli, help, description, exclude, group) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: help Help message. character(len=*), intent(in), optional :: description Detailed description. character(len=*), intent(in), optional :: exclude Group name of the mutually exclusive group. character(len=*), intent(in) :: group Name of the grouped CLAs. Description Add CLAs group to CLI. procedure, public :: add Add CLA to CLI. private subroutine add (cli, pref, group, group_index, switch, switch_ab, help, required, positional, position, hidden, act, def, nargs, choices, exclude, envvar, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of the grouped CLAs. integer(kind=I4P), intent(in), optional :: group_index Index of the grouped CLAs. character(len=*), intent(in), optional :: switch Switch name. character(len=*), intent(in), optional :: switch_ab Abbreviated switch name. character(len=*), intent(in), optional :: help Help message describing the CLA. logical, intent(in), optional :: required Flag for set required argument. logical, intent(in), optional :: positional Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. logical, intent(in), optional :: hidden Flag for hiding CLA, thus it does not compare into help. character(len=*), intent(in), optional :: act CLA value action. character(len=*), intent(in), optional :: def Default value. character(len=*), intent(in), optional :: nargs Number of arguments consumed by CLA. character(len=*), intent(in), optional :: choices List of allowable values for the argument. character(len=*), intent(in), optional :: exclude Switch name of the mutually exclusive CLA. character(len=*), intent(in), optional :: envvar Environment variable from which take value. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Add CLA to CLI. procedure, public :: passed Check if a CLA has been passed. private function passed (cli, group, switch, position) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Description Check if a CLA has been passed. procedure, public :: defined Check if a CLA has been defined. private function defined (cli, switch, group) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: switch Switch name. character(len=*), intent(in), optional :: group Name of group (command) of CLAs. Return Value logical Check if a CLA has been defined. Description Check if a CLA has been defined. procedure, public :: defined_group Check if a CLAs group has been defined. private function defined_group (cli, group, g) result(defined) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. integer(kind=I4P), intent(out), optional :: g Index of group. Return Value logical Check if a CLAs group has been defined. Description Check if a CLAs group has been defined. procedure, public :: set_mutually_exclusive_groups Set two CLAs group as mutually exclusive. private subroutine set_mutually_exclusive_groups (cli, group1, group2) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in) :: group1 Name of the first grouped CLAs. character(len=*), intent(in) :: group2 Name of the second grouped CLAs. Description Set two CLAs group ad mutually exclusive. procedure, public :: run_command => called_group Check if a CLAs group has been runned. private function called_group (cli, group) result(called) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. Return Value logical Check if a CLAs group has been runned. Description Check if a CLAs group has been runned. procedure, public :: parse Parse Command Line Interfaces. private subroutine parse (cli, pref, args, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Parse Command Line Interfaces by means of a previously initialized CLAs groups list. generic, public :: get => get_cla_cli , get_cla_list_cli Get CLA value(s) from CLAs list parsed. private subroutine get_cla_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA (single) value from CLAs list parsed. private subroutine get_cla_list_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val (1:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed. generic, public :: get_varying => get_cla_list_varying_R8P_cli , get_cla_list_varying_R4P_cli , get_cla_list_varying_I8P_cli , get_cla_list_varying_I4P_cli , get_cla_list_varying_I2P_cli , get_cla_list_varying_I1P_cli , get_cla_list_varying_logical_cli , get_cla_list_varying_char_cli Get CLA value(s) from CLAs list parsedi, varying size list. private subroutine get_cla_list_varying_R8P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). private subroutine get_cla_list_varying_R4P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). private subroutine get_cla_list_varying_I8P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). private subroutine get_cla_list_varying_I4P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). private subroutine get_cla_list_varying_I2P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). private subroutine get_cla_list_varying_I1P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). private subroutine get_cla_list_varying_logical_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, logical. private subroutine get_cla_list_varying_char_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, character. procedure, public :: usage Get CLI usage. private function usage (cli, g, pref, no_header, no_examples, no_epilog) result(usaged) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. integer(kind=I4P), intent(in) :: g Group index. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: no_examples Avoid insert examples to usage. logical, intent(in), optional :: no_epilog Avoid insert epilogue to usage. Return Value character(len=:),\n  allocatable Usage string. Description Print correct usage of CLI. procedure, public :: signature Get CLI signature. private function signature (cli) result(signd) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLI signature. procedure, public :: print_usage Print correct usage of CLI. private subroutine print_usage (cli, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Description Print correct usage of CLI. procedure, public :: save_man_page Save man page build on CLI. private subroutine save_man_page (cli, man_file, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: man_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Save man page build on the CLI. procedure, private :: check Check CLAs data consistenc. private subroutine check (cli, pref, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Check CLAs data consistency. procedure, private :: check_m_exclusive Check if two mutually exclusive CLAs group have been called. private subroutine check_m_exclusive (cli, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if two mutually exclusive CLAs group have been called. procedure, private :: get_clasg_indexes Get CLAs groups indexes. private subroutine get_clasg_indexes (cli, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. generic, private :: get_args => get_args_from_string , get_args_from_invocation Get CLAs from string.\n Get CLAs from CLI invocation. private subroutine get_args_from_string (cli, args, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from string. private subroutine get_args_from_invocation (cli, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from CLI invocation. procedure, private :: get_args_from_string Get CLAs from string. private subroutine get_args_from_string (cli, args, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from string. procedure, private :: get_args_from_invocation Get CLAs from CLI invocation. private subroutine get_args_from_invocation (cli, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from CLI invocation. procedure, private :: get_cla_cli Get CLA (single) value from CLAs list parsed. private subroutine get_cla_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA (single) value from CLAs list parsed. procedure, private :: get_cla_list_cli Get CLA multiple values from CLAs list parsed. private subroutine get_cla_list_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val (1:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed. procedure, private :: get_cla_list_varying_R16P_cli Get CLA multiple values from CLAs list parsed, varying size, R16P. private subroutine get_cla_list_varying_R16P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). procedure, private :: get_cla_list_varying_R8P_cli Get CLA multiple values from CLAs list parsed, varying size, R8P. private subroutine get_cla_list_varying_R8P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). procedure, private :: get_cla_list_varying_R4P_cli Get CLA multiple values from CLAs list parsed, varying size, R4P. private subroutine get_cla_list_varying_R4P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). procedure, private :: get_cla_list_varying_I8P_cli Get CLA multiple values from CLAs list parsed, varying size, I8P. private subroutine get_cla_list_varying_I8P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). procedure, private :: get_cla_list_varying_I4P_cli Get CLA multiple values from CLAs list parsed, varying size, I4P. private subroutine get_cla_list_varying_I4P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). procedure, private :: get_cla_list_varying_I2P_cli Get CLA multiple values from CLAs list parsed, varying size, I2P. private subroutine get_cla_list_varying_I2P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). procedure, private :: get_cla_list_varying_I1P_cli Get CLA multiple values from CLAs list parsed, varying size, I1P. private subroutine get_cla_list_varying_I1P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). procedure, private :: get_cla_list_varying_logical_cli Get CLA multiple values from CLAs list parsed, varying size, bool. private subroutine get_cla_list_varying_logical_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, logical. procedure, private :: get_cla_list_varying_char_cli Get CLA multiple values from CLAs list parsed, varying size, char. private subroutine get_cla_list_varying_char_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, character. procedure, private :: assign_cli CLI assignment overloading. private elemental subroutine assign_cli (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Interface ), intent(in) :: rhs Right hand side. Description Assign two CLI. generic, private :: assignment(=) => assign_cli CLI assignment overloading. private elemental subroutine assign_cli (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Interface ), intent(in) :: rhs Right hand side. Description Assign two CLI. Source Code type , extends ( Type_Object ), public :: Type_Command_Line_Interface !< Command Line Interface (CLI). private type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg (:) !< CLA list [1:Na]. #ifdef __GFORTRAN__ character ( 512 ), allocatable :: args (:) !< Actually passed command line arguments. character ( 512 ), allocatable :: examples (:) !< Examples of correct usage. #else character ( len = :), allocatable :: args (:) !< Actually passed command line arguments. character ( len = :), allocatable :: examples (:) !< Examples of correct usage (not work with gfortran). #endif logical :: disable_hv = . false . !< Disable automatic 'help' and 'version' CLAs. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: init !< Initialize CLI. procedure , public :: add_group !< Add CLAs group CLI. procedure , public :: add !< Add CLA to CLI. procedure , public :: passed !< Check if a CLA has been passed. procedure , public :: defined !< Check if a CLA has been defined. procedure , public :: defined_group !< Check if a CLAs group has been defined. procedure , public :: set_mutually_exclusive_groups !< Set two CLAs group as mutually exclusive. procedure , public :: run_command => called_group !< Check if a CLAs group has been runned. procedure , public :: parse !< Parse Command Line Interfaces. generic , public :: get => get_cla_cli , get_cla_list_cli !< Get CLA value(s) from CLAs list parsed. generic , public :: get_varying => & !< Get CLA value(s) from CLAs list parsedi, varying size list. #ifdef r16p get_cla_list_varying_R16P_cli , & #endif get_cla_list_varying_R8P_cli , & get_cla_list_varying_R4P_cli , & get_cla_list_varying_I8P_cli , & get_cla_list_varying_I4P_cli , & get_cla_list_varying_I2P_cli , & get_cla_list_varying_I1P_cli , & get_cla_list_varying_logical_cli , & get_cla_list_varying_char_cli procedure , public :: usage !< Get CLI usage. procedure , public :: signature !< Get CLI signature. procedure , public :: print_usage !< Print correct usage of CLI. procedure , public :: save_man_page !< Save man page build on CLI. ! private methods procedure , private :: check !< Check CLAs data consistenc. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs group have been called. procedure , private :: get_clasg_indexes !< Get CLAs groups indexes. generic , private :: get_args => get_args_from_string ,& !< Get CLAs from string. get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_args_from_string !< Get CLAs from string. procedure , private :: get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_cla_cli !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list_cli !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R16P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R16P. procedure , private :: get_cla_list_varying_R8P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical_cli !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char_cli !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: assign_cli !< CLI assignment overloading. generic , private :: assignment ( = ) => assign_cli !< CLI assignment overloading. final :: finalize !< Free dynamic memory when finalizing. endtype Type_Command_Line_Interface","tags":"","loc":"type/type_command_line_interface.html","title":"Type_Command_Line_Interface – FOODIE "},{"text":"type, public, abstract :: weno_constructor Abstract type used for create new concrete WENO interpolators. Note Every concrete WENO interpolator implementations must define their own constructor type. Source Code type , abstract :: weno_constructor !< Abstract type used for create new concrete WENO interpolators. !< !< @note Every concrete WENO interpolator implementations must define their own constructor type. private endtype weno_constructor","tags":"","loc":"type/weno_constructor.html","title":"weno_constructor – FOODIE "},{"text":"type, public, abstract :: weno_interpolator WENO interpolator object. Note Do not implement any real interpolator: provide the interface for the different interpolators implemented. Type-Bound Procedures procedure( abstract_destructor ), public, pass(self), deferred :: destroy elemental subroutine abstract_destructor (self) Prototype Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(inout) :: self WENO interpolator. Description Destoy a WENO interpolator. procedure( abstract_constructor ), public, pass(self), deferred :: create subroutine abstract_constructor (self, constructor) Prototype Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(inout) :: self WENO interpolator. class( weno_constructor ), intent(in) :: constructor WENO constructor. Description Create a WENO interpolator. procedure( abstract_description ), public, pass(self), deferred :: description pure subroutine abstract_description (self, string) Prototype Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(in) :: self WENO interpolator. character(len=:), intent(out), allocatable :: string String returned. Description Return a string describing a WENO interpolator. procedure( abstract_interpolate ), public, pass(self), deferred :: interpolate pure subroutine abstract_interpolate (self, S, stencil, location, interpolation) Prototype Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(in) :: self WENO interpolator. integer(kind=I_P), intent(in) :: S Number of stencils used. real(kind=R_P), intent(in) :: stencil (1:,1-S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. character(len=*), intent(in) :: location Location of interpolated value(s): central, left, right, both. real(kind=R_P), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Description Interpolate the stecil input values computing the actual interpolation. Source Code type , abstract :: weno_interpolator !< WENO interpolator object. !< !< @note Do not implement any real interpolator: provide the interface for the different interpolators implemented. private contains procedure ( abstract_destructor ), pass ( self ), deferred , public :: destroy procedure ( abstract_constructor ), pass ( self ), deferred , public :: create procedure ( abstract_description ), pass ( self ), deferred , public :: description procedure ( abstract_interpolate ), pass ( self ), deferred , public :: interpolate endtype weno_interpolator","tags":"","loc":"type/weno_interpolator.html","title":"weno_interpolator – FOODIE "},{"text":"type, public, extends(weno_constructor) :: weno_constructor_upwind type~~weno_constructor_upwind~~InheritsGraph type~weno_constructor_upwind weno_constructor_upwind weno_constructor weno_constructor weno_constructor->type~weno_constructor_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Upwind biased WENO interpolator constructor, Note The constructed WENO interpolator implements the Efficient Implementation of Weighted ENO Schemes ,\n Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202–228, doi:10.1006/jcph.1996.0130. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0 Stencils dimension. real(kind=R_P), public :: eps = 10._R_P**(-6) Parameter for avoiding divided by zero when computing smoothness indicators. Constructor public interface weno_constructor_upwind private elemental function weno_constructor_upwind_init (S, eps) result(constructor) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: S Maximum stencils dimension. real(kind=R_P), intent(in), optional :: eps Parameter for avoiding divided by zero when computing smoothness indicators. Return Value type( weno_constructor_upwind ) WENO constructor. Description Create (initialize) the WENO interpolator. Source Code type , extends ( weno_constructor ) :: weno_constructor_upwind !< Upwind biased WENO interpolator constructor, !< !< @note The constructed WENO interpolator implements the *Efficient Implementation of Weighted ENO Schemes*, !< Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130. integer ( I_P ) :: S = 0 !< Stencils dimension. real ( R_P ) :: eps = 1 0._R_P ** ( - 6 ) !< Parameter for avoiding divided by zero when computing smoothness indicators. endtype weno_constructor_upwind","tags":"","loc":"type/weno_constructor_upwind.html","title":"weno_constructor_upwind – FOODIE "},{"text":"type, public, extends(weno_interpolator) :: weno_interpolator_upwind type~~weno_interpolator_upwind~~InheritsGraph type~weno_interpolator_upwind weno_interpolator_upwind weno_interpolator weno_interpolator weno_interpolator->type~weno_interpolator_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Upwind biased WENO interpolator object, Note The WENO interpolator implemented is the Efficient Implementation of Weighted ENO Schemes ,\n Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202–228, doi:10.1006/jcph.1996.0130. Note The supported accuracy formal order are: 3rd, 5th, 7th corresponding to use 2, 3, 4 stencils composed of 2, 3, 4 values,\n respectively. Inherited By type~~weno_interpolator_upwind~~InheritedByGraph type~weno_interpolator_upwind weno_interpolator_upwind type~euler_1d_caf_nf euler_1D_caf_nf type~weno_interpolator_upwind->type~euler_1d_caf_nf weno type~euler_1d_openmp euler_1D_openmp type~weno_interpolator_upwind->type~euler_1d_openmp weno type~euler_1d euler_1D type~weno_interpolator_upwind->type~euler_1d weno type~euler_1d_caf euler_1D_caf type~weno_interpolator_upwind->type~euler_1d_caf weno type~euler_1d_omp_nf euler_1D_omp_nf type~weno_interpolator_upwind->type~euler_1d_omp_nf weno Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: S = 0_I_P Stencil dimension. real(kind=R_P), private :: eps = 0._R_P Parameter for avoiding divided by zero when computing smoothness indicators. real(kind=R_P), private, allocatable :: weights_opt (:,:) Optimal weights                    [1:2,0:S-1]. real(kind=R_P), private, allocatable :: poly_coef (:,:,:) Polynomials coefficients           [1:2,0:S-1,0:S-1]. real(kind=R_P), private, allocatable :: smooth_coef (:,:,:) Smoothness indicators coefficients [0:S-1,0:S-1,0:S-1]. Finalization Procedures final :: finalize private elemental subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( weno_interpolator_upwind ), intent(inout) :: self WENO interpolator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy private elemental subroutine destroy (self) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(inout) :: self WENO interpolator. Description Destoy the WENO interpolator. procedure, public, pass(self) :: create private subroutine create (self, constructor) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(inout) :: self WENO interpolator. class( weno_constructor ), intent(in) :: constructor WENO constructor. Description Create the WENO interpolator. procedure, public, pass(self) :: description private pure subroutine description (self, string) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(in) :: self WENO interpolator. character(len=:), intent(out), allocatable :: string String returned. Description Return a string describing the WENO interpolator. procedure, public, pass(self) :: interpolate private pure subroutine interpolate (self, S, stencil, location, interpolation) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(in) :: self WENO interpolator. integer, intent(in) :: S Number of stencils actually used. real(kind=R_P), intent(in) :: stencil (1:,1-S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. character(len=*), intent(in) :: location Location of interpolated value(s): left, right, both. real(kind=R_P), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Description Interpolate the stecil input values computing the actual interpolation. generic, public :: assignment(=) => assign_interpolator Overloading = assignament. private pure subroutine assign_interpolator (lhs, rhs) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(inout) :: lhs Left hand side. class( weno_interpolator ), intent(in) :: rhs Right hand side. Description Assign one interpolator to another. procedure, private, pass(lhs) :: assign_interpolator Assignament operator. private pure subroutine assign_interpolator (lhs, rhs) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(inout) :: lhs Left hand side. class( weno_interpolator ), intent(in) :: rhs Right hand side. Description Assign one interpolator to another. Source Code type , extends ( weno_interpolator ) :: weno_interpolator_upwind !< Upwind biased WENO interpolator object, !< !< @note The WENO interpolator implemented is the *Efficient Implementation of Weighted ENO Schemes*, !< Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130. !< !< @note The supported accuracy formal order are: 3rd, 5th, 7th corresponding to use 2, 3, 4 stencils composed of 2, 3, 4 values, !< respectively. private integer ( I_P ) :: S = 0_I_P !< Stencil dimension. real ( R_P ) :: eps = 0._R_P !< Parameter for avoiding divided by zero when computing smoothness indicators. real ( R_P ), allocatable :: weights_opt (:,:) !< Optimal weights                    [1:2,0:S-1]. real ( R_P ), allocatable :: poly_coef (:,:,:) !< Polynomials coefficients           [1:2,0:S-1,0:S-1]. real ( R_P ), allocatable :: smooth_coef (:,:,:) !< Smoothness indicators coefficients [0:S-1,0:S-1,0:S-1]. contains ! public methods procedure , pass ( self ), public :: destroy procedure , pass ( self ), public :: create procedure , pass ( self ), public :: description procedure , pass ( self ), public :: interpolate generic , public :: assignment ( = ) => assign_interpolator !< Overloading = assignament. ! private methods procedure , pass ( lhs ), private :: assign_interpolator !< Assignament operator. final :: finalize endtype weno_interpolator_upwind","tags":"","loc":"type/weno_interpolator_upwind.html","title":"weno_interpolator_upwind – FOODIE "},{"text":"type, public :: weno_factory WENO factory aimed to create and return a concrete WENO interpolator to the client code without exposing the concrete\n interpolators classes. Type-Bound Procedures procedure, public, nopass :: create private subroutine create (constructor, interpolator) Arguments Type Intent Optional Attributes Name class( weno_constructor ), intent(in) :: constructor The concrete WENO constructor selected by client code. class( weno_interpolator ), intent(out), allocatable :: interpolator The concrete WENO interpolator. Description Create and return a concrete WENO interpolator object being an extension of the abstract weno_interpolator type.","tags":"","loc":"type/weno_factory.html","title":"weno_factory – FOODIE "},{"text":"type, public :: pyplot Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: str logical, private :: show_legend = .false. logical, private :: use_numpy = .true. logical, private :: mplot3d = .false. logical, private :: polar = .false. logical, private :: axis_equal = .false. character(len=:), private, allocatable :: real_fmt Type-Bound Procedures procedure, public :: initialize private subroutine initialize (me, grid, xlabel, ylabel, zlabel, title, legend, use_numpy, figsize, font_size, axes_labelsize, xtick_labelsize, ytick_labelsize, ztick_labelsize, legend_fontsize, mplot3d, axis_equal, polar, real_fmt) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me logical, intent(in), optional :: grid character(len=*), intent(in), optional :: xlabel character(len=*), intent(in), optional :: ylabel character(len=*), intent(in), optional :: zlabel character(len=*), intent(in), optional :: title logical, intent(in), optional :: legend logical, intent(in), optional :: use_numpy integer, intent(in), optional dimension(2) :: figsize integer, intent(in), optional :: font_size integer, intent(in), optional :: axes_labelsize integer, intent(in), optional :: xtick_labelsize integer, intent(in), optional :: ytick_labelsize integer, intent(in), optional :: ztick_labelsize integer, intent(in), optional :: legend_fontsize logical, intent(in), optional :: mplot3d logical, intent(in), optional :: axis_equal logical, intent(in), optional :: polar character(len=*), intent(in), optional :: real_fmt Description Author Jacob Williams procedure, public :: add_plot private subroutine add_plot (me, x, y, label, linestyle, markersize, linewidth, xlim, ylim, xscale, yscale) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y character(len=*), intent(in) :: label character(len=*), intent(in) :: linestyle integer, intent(in), optional :: markersize integer, intent(in), optional :: linewidth real(kind=wp), intent(in), optional dimension(2) :: xlim real(kind=wp), intent(in), optional dimension(2) :: ylim character(len=*), intent(in), optional :: xscale character(len=*), intent(in), optional :: yscale Description Author Jacob Williams procedure, public :: add_3d_plot private subroutine add_3d_plot (me, x, y, z, label, linestyle, markersize, linewidth) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z character(len=*), intent(in) :: label character(len=*), intent(in) :: linestyle integer, intent(in), optional :: markersize integer, intent(in), optional :: linewidth Description Author Jacob Williams procedure, public :: add_contour private subroutine add_contour (me, x, y, z, label, linestyle, linewidth, levels, color, filled, cmap) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:,:) :: z character(len=*), intent(in) :: label character(len=*), intent(in) :: linestyle integer, intent(in), optional :: linewidth real(kind=wp), intent(in), optional dimension(:) :: levels character(len=*), intent(in), optional :: color logical, intent(in), optional :: filled character(len=*), intent(in), optional :: cmap Description Author Jacob Williams procedure, public :: add_bar private subroutine add_bar (me, left, height, label, width, bottom, color, yerr, align, xlim, ylim, xscale, yscale) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: left real(kind=wp), intent(in), dimension(:) :: height character(len=*), intent(in) :: label real(kind=wp), intent(in), optional dimension(:) :: width real(kind=wp), intent(in), optional dimension(:) :: bottom character(len=*), intent(in), optional :: color real(kind=wp), intent(in), optional dimension(:) :: yerr character(len=*), intent(in), optional :: align real(kind=wp), intent(in), optional dimension(2) :: xlim real(kind=wp), intent(in), optional dimension(2) :: ylim character(len=*), intent(in), optional :: xscale character(len=*), intent(in), optional :: yscale Description Author Jacob Williams procedure, public :: savefig private subroutine savefig (me, figfile, pyfile) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in) :: figfile character(len=*), intent(in), optional :: pyfile Description Author Jacob Williams procedure, public :: destroy private subroutine destroy (me) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me Description Author Jacob Williams procedure, public :: execute private subroutine execute (me, pyfile) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in), optional :: pyfile Description Author Jacob Williams procedure, public :: add_str private subroutine add_str (me, str) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in) :: str Description Author Jacob Williams Source Code type , public :: pyplot !!  The main pyplot class. private character ( len = :), allocatable :: str !! string buffer logical :: show_legend = . false . !! show legend into plot logical :: use_numpy = . true . !! use numpy python module logical :: mplot3d = . false . !! it is a 3d plot logical :: polar = . false . !! it is a polar plot logical :: axis_equal = . false . !! equal scale on each axis character ( len = :), allocatable :: real_fmt !! real number formatting contains ! public methods procedure , public :: initialize !! initialize pyplot instance procedure , public :: add_plot !! add a 2d plot to pyplot instance procedure , public :: add_3d_plot !! add a 3d plot to pyplot instance procedure , public :: add_contour !! add a contour plot to pyplot instance procedure , public :: add_bar !! add a barplot to pyplot instance procedure , public :: savefig !! save plots of pyplot instance procedure , public :: destroy !! destroy pyplot instance ! private methods procedure :: execute !! execute pyplot commands procedure :: add_str !! add string to pytplot instance buffer end type pyplot","tags":"","loc":"type/pyplot.html","title":"pyplot – FOODIE "},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private pure subroutine assignment_integrand(lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand.","tags":"","loc":"interface/assignment_integrand.html","title":"assignment_integrand – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function time_derivative(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function.","tags":"","loc":"interface/time_derivative.html","title":"time_derivative – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function local_error_operator(lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 solution approximations.","tags":"","loc":"interface/local_error_operator.html","title":"local_error_operator – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function integrand_op_real(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real.","tags":"","loc":"interface/integrand_op_real.html","title":"integrand_op_real – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function real_op_integrand(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand.","tags":"","loc":"interface/real_op_integrand.html","title":"real_op_integrand – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function symmetric_operator(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand.","tags":"","loc":"interface/symmetric_operator.html","title":"symmetric_operator – FOODIE"},{"text":"abstract interface private elemental subroutine abstract_destructor(self) Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(inout) :: self WENO interpolator. Description Destoy a WENO interpolator.","tags":"","loc":"interface/abstract_destructor.html","title":"abstract_destructor – FOODIE"},{"text":"abstract interface private subroutine abstract_constructor(self, constructor) Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(inout) :: self WENO interpolator. class( weno_constructor ), intent(in) :: constructor WENO constructor. Description Create a WENO interpolator. Note Before call this method a concrete constructor must be instantiated.","tags":"","loc":"interface/abstract_constructor.html","title":"abstract_constructor – FOODIE"},{"text":"abstract interface private pure subroutine abstract_description(self, string) Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(in) :: self WENO interpolator. character(len=:), intent(out), allocatable :: string String returned. Description Return a string describing a WENO interpolator.","tags":"","loc":"interface/abstract_description.html","title":"abstract_description – FOODIE"},{"text":"abstract interface private pure subroutine abstract_interpolate(self, S, stencil, location, interpolation) Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(in) :: self WENO interpolator. integer(kind=I_P), intent(in) :: S Number of stencils used. real(kind=R_P), intent(in) :: stencil (1:,1-S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. character(len=*), intent(in) :: location Location of interpolated value(s): central, left, right, both. real(kind=R_P), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Description Interpolate the stecil input values computing the actual interpolation.","tags":"","loc":"interface/abstract_interpolate.html","title":"abstract_interpolate – FOODIE"},{"text":"private elemental function min_steps() Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Description Return the minimum number of steps supported. Source Code elemental function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps","tags":"","loc":"proc/min_steps.html","title":"min_steps – FOODIE"},{"text":"private elemental function max_steps() Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. Description Return the maximum number of steps supported. Source Code elemental function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps","tags":"","loc":"proc/max_steps.html","title":"max_steps – FOODIE"},{"text":"private elemental function is_supported(steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . Description Check if the queried number of steps is supported or not. Calls proc~~is_supported~~CallsGraph proc~is_supported is_supported proc~is_admissible is_admissible proc~is_supported->proc~is_admissible proc~tokenize tokenize proc~is_admissible->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported.html","title":"is_supported – FOODIE"},{"text":"private elemental subroutine init(self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth integrator: initialize the b coefficients. Note If the integrator is initialized with a bad (unsupported) number of required time steps the initialization fails and\n the integrator error status is updated consistently for external-provided errors handling. Source Code elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth integrator: initialize the *b* coefficients. !< !< @note If the integrator is initialized with a bad (unsupported) number of required time steps the initialization fails and !< the integrator error status is updated consistently for external-provided errors handling. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( steps )) then self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 1 : steps )) ; self % b = 0.0_R_P select case ( steps ) case ( 1 ) ! AB(1) Forward-Euler self % b ( 1 ) = 1.0_R_P case ( 2 ) self % b ( 1 ) = - 1.0_R_P / 2.0_R_P self % b ( 2 ) = 3.0_R_P / 2.0_R_P case ( 3 ) self % b ( 1 ) = 5.0_R_P / 1 2.0_R_P self % b ( 2 ) = - 1 6.0_R_P / 1 2.0_R_P self % b ( 3 ) = 2 3.0_R_P / 1 2.0_R_P case ( 4 ) self % b ( 1 ) = - 9.0_R_P / 2 4.0_R_P self % b ( 2 ) = 3 7.0_R_P / 2 4.0_R_P self % b ( 3 ) = - 5 9.0_R_P / 2 4.0_R_P self % b ( 4 ) = 5 5.0_R_P / 2 4.0_R_P case ( 5 ) self % b ( 1 ) = 25 1.0_R_P / 72 0.0_R_P self % b ( 2 ) = - 127 4.0_R_P / 72 0.0_R_P self % b ( 3 ) = 261 6.0_R_P / 72 0.0_R_P self % b ( 4 ) = - 277 4.0_R_P / 72 0.0_R_P self % b ( 5 ) = 190 1.0_R_P / 72 0.0_R_P case ( 6 ) self % b ( 1 ) = - 47 5.0_R_P / 144 0.0_R_P self % b ( 2 ) = 287 7.0_R_P / 144 0.0_R_P self % b ( 3 ) = - 729 8.0_R_P / 144 0.0_R_P self % b ( 4 ) = 998 2.0_R_P / 144 0.0_R_P self % b ( 5 ) = - 792 3.0_R_P / 144 0.0_R_P self % b ( 6 ) = 427 7.0_R_P / 144 0.0_R_P case ( 7 ) self % b ( 1 ) = 1908 7.0_R_P / 6048 0.0_R_P self % b ( 2 ) = - 13447 2.0_R_P / 6048 0.0_R_P self % b ( 3 ) = 40713 9.0_R_P / 6048 0.0_R_P self % b ( 4 ) = - 68825 6.0_R_P / 6048 0.0_R_P self % b ( 5 ) = 70554 9.0_R_P / 6048 0.0_R_P self % b ( 6 ) = - 44728 8.0_R_P / 6048 0.0_R_P self % b ( 7 ) = 19872 1.0_R_P / 6048 0.0_R_P case ( 8 ) self % b ( 1 ) = - 3679 9.0_R_P / 12096 0.0_R_P self % b ( 2 ) = 29576 7.0_R_P / 12096 0.0_R_P self % b ( 3 ) = - 104172 3.0_R_P / 12096 0.0_R_P self % b ( 4 ) = 210224 3.0_R_P / 12096 0.0_R_P self % b ( 5 ) = - 266447 7.0_R_P / 12096 0.0_R_P self % b ( 6 ) = 218387 7.0_R_P / 12096 0.0_R_P self % b ( 7 ) = - 115216 9.0_R_P / 12096 0.0_R_P self % b ( 8 ) = 43424 1.0_R_P / 12096 0.0_R_P case ( 9 ) self % b ( 1 ) = 107001 7.0_R_P / 362880 0.0_R_P self % b ( 2 ) = - 966410 6.0_R_P / 362880 0.0_R_P self % b ( 3 ) = 3883348 6.0_R_P / 362880 0.0_R_P self % b ( 4 ) = - 9117264 2.0_R_P / 362880 0.0_R_P self % b ( 5 ) = 13796848 0.0_R_P / 362880 0.0_R_P self % b ( 6 ) = - 13985526 2.0_R_P / 362880 0.0_R_P self % b ( 7 ) = 9547678 6.0_R_P / 362880 0.0_R_P self % b ( 8 ) = - 4312520 6.0_R_P / 362880 0.0_R_P self % b ( 9 ) = 1409724 7.0_R_P / 362880 0.0_R_P case ( 10 ) self % b ( 1 ) = - 208275 3.0_R_P / 725760 0.0_R_P self % b ( 2 ) = 2088481 1.0_R_P / 725760 0.0_R_P self % b ( 3 ) = - 9430732 0.0_R_P / 725760 0.0_R_P self % b ( 4 ) = 25261822 4.0_R_P / 725760 0.0_R_P self % b ( 5 ) = - 44477216 2.0_R_P / 725760 0.0_R_P self % b ( 6 ) = 53836383 8.0_R_P / 725760 0.0_R_P self % b ( 7 ) = - 45466177 6.0_R_P / 725760 0.0_R_P self % b ( 8 ) = 26593268 0.0_R_P / 725760 0.0_R_P self % b ( 9 ) = - 10499518 9.0_R_P / 725760 0.0_R_P self % b ( 10 ) = 3027724 7.0_R_P / 725760 0.0_R_P case ( 11 ) self % b ( 1 ) = 13421126 5.0_R_P / 47900160 0.0_R_P self % b ( 2 ) = - 147957434 8.0_R_P / 47900160 0.0_R_P self % b ( 3 ) = 741790445 1.0_R_P / 47900160 0.0_R_P self % b ( 4 ) = - 2232963492 0.0_R_P / 47900160 0.0_R_P self % b ( 5 ) = 4485716843 4.0_R_P / 47900160 0.0_R_P self % b ( 6 ) = - 6317620147 2.0_R_P / 47900160 0.0_R_P self % b ( 7 ) = 6371637895 8.0_R_P / 47900160 0.0_R_P self % b ( 8 ) = - 4611302901 6.0_R_P / 47900160 0.0_R_P self % b ( 9 ) = 2359106380 5.0_R_P / 47900160 0.0_R_P self % b ( 10 ) = - 827179512 4.0_R_P / 47900160 0.0_R_P self % b ( 11 ) = 213250956 7.0_R_P / 47900160 0.0_R_P case ( 12 ) self % b ( 1 ) = - 26274726 5.0_R_P / 95800320 0.0_R_P self % b ( 2 ) = 315864244 5.0_R_P / 95800320 0.0_R_P self % b ( 3 ) = - 1741024827 1.0_R_P / 95800320 0.0_R_P self % b ( 4 ) = 5818910762 7.0_R_P / 95800320 0.0_R_P self % b ( 5 ) = - 13136586729 0.0_R_P / 95800320 0.0_R_P self % b ( 6 ) = 21110357329 8.0_R_P / 95800320 0.0_R_P self % b ( 7 ) = - 24774163937 4.0_R_P / 95800320 0.0_R_P self % b ( 8 ) = 21413935536 6.0_R_P / 95800320 0.0_R_P self % b ( 9 ) = - 13557935675 7.0_R_P / 95800320 0.0_R_P self % b ( 10 ) = 6163322718 5.0_R_P / 95800320 0.0_R_P self % b ( 11 ) = - 1943381016 3.0_R_P / 95800320 0.0_R_P self % b ( 12 ) = 452776639 9.0_R_P / 95800320 0.0_R_P case ( 13 ) self % b ( 1 ) = 70360425435 7.0_R_P / 261534873600 0.0_R_P self % b ( 2 ) = - 916055108573 4.0_R_P / 261534873600 0.0_R_P self % b ( 3 ) = 5506097466241 2.0_R_P / 261534873600 0.0_R_P self % b ( 4 ) = - 20232291373837 0.0_R_P / 261534873600 0.0_R_P self % b ( 5 ) = 50714036972842 5.0_R_P / 261534873600 0.0_R_P self % b ( 6 ) = - 91588338715244 4.0_R_P / 261534873600 0.0_R_P self % b ( 7 ) = 122644308612940 8.0_R_P / 261534873600 0.0_R_P self % b ( 8 ) = - 123358924494176 4.0_R_P / 261534873600 0.0_R_P self % b ( 9 ) = 93288454605589 5.0_R_P / 261534873600 0.0_R_P self % b ( 10 ) = - 52492457990515 0.0_R_P / 261534873600 0.0_R_P self % b ( 11 ) = 21469659100261 2.0_R_P / 261534873600 0.0_R_P self % b ( 12 ) = - 6149755279727 4.0_R_P / 261534873600 0.0_R_P self % b ( 13 ) = 1306440652362 7.0_R_P / 261534873600 0.0_R_P case ( 14 ) self % b ( 1 ) = - 138274192962 1.0_R_P / 523069747200 0.0_R_P self % b ( 2 ) = 1938285359378 7.0_R_P / 523069747200 0.0_R_P self % b ( 3 ) = - 12617497268190 6.0_R_P / 523069747200 0.0_R_P self % b ( 4 ) = 50558614119643 0.0_R_P / 523069747200 0.0_R_P self % b ( 5 ) = - 139330630715575 5.0_R_P / 523069747200 0.0_R_P self % b ( 6 ) = 279386960287907 7.0_R_P / 523069747200 0.0_R_P self % b ( 7 ) = - 420455192553452 4.0_R_P / 523069747200 0.0_R_P self % b ( 8 ) = 482567132348845 2.0_R_P / 523069747200 0.0_R_P self % b ( 9 ) = - 424676735330575 5.0_R_P / 523069747200 0.0_R_P self % b ( 10 ) = 285442957179080 5.0_R_P / 523069747200 0.0_R_P self % b ( 11 ) = - 144531335168190 6.0_R_P / 523069747200 0.0_R_P self % b ( 12 ) = 53724705251566 2.0_R_P / 523069747200 0.0_R_P self % b ( 13 ) = - 14097075067962 1.0_R_P / 523069747200 0.0_R_P self % b ( 14 ) = 2751155497687 5.0_R_P / 523069747200 0.0_R_P case ( 15 ) self % b ( 1 ) = 816416873759 9.0_R_P / 3138418483200 0.0_R_P self % b ( 2 ) = - 12259481390411 2.0_R_P / 3138418483200 0.0_R_P self % b ( 3 ) = 85923647668423 1.0_R_P / 3138418483200 0.0_R_P self % b ( 4 ) = - 372880725657747 2.0_R_P / 3138418483200 0.0_R_P self % b ( 5 ) = 1120584975351517 9.0_R_P / 3138418483200 0.0_R_P self % b ( 6 ) = - 2470450365560772 8.0_R_P / 3138418483200 0.0_R_P self % b ( 7 ) = 4128021633628425 9.0_R_P / 3138418483200 0.0_R_P self % b ( 8 ) = - 5324673866064691 2.0_R_P / 3138418483200 0.0_R_P self % b ( 9 ) = 5347102665994050 9.0_R_P / 3138418483200 0.0_R_P self % b ( 10 ) = - 4182526993250772 8.0_R_P / 3138418483200 0.0_R_P self % b ( 11 ) = 2529891033708142 9.0_R_P / 3138418483200 0.0_R_P self % b ( 12 ) = - 1164363753057747 2.0_R_P / 3138418483200 0.0_R_P self % b ( 13 ) = 396642167021548 1.0_R_P / 3138418483200 0.0_R_P self % b ( 14 ) = - 96012286640411 2.0_R_P / 3138418483200 0.0_R_P self % b ( 15 ) = 17323349859884 9.0_R_P / 3138418483200 0.0_R_P case ( 16 ) self % b ( 1 ) = - 1608812922937 5.0_R_P / 6276836966400 0.0_R_P self % b ( 2 ) = 25765027591582 3.0_R_P / 6276836966400 0.0_R_P self % b ( 3 ) = - 193444319689259 9.0_R_P / 6276836966400 0.0_R_P self % b ( 4 ) = 903857175273408 7.0_R_P / 6276836966400 0.0_R_P self % b ( 5 ) = - 2941791091125181 9.0_R_P / 6276836966400 0.0_R_P self % b ( 6 ) = 7072435158284348 3.0_R_P / 6276836966400 0.0_R_P self % b ( 7 ) = - 12993009410423733 1.0_R_P / 6276836966400 0.0_R_P self % b ( 8 ) = 18608754426359664 3.0_R_P / 6276836966400 0.0_R_P self % b ( 9 ) = - 21002058891232194 9.0_R_P / 6276836966400 0.0_R_P self % b ( 10 ) = 18746314011290289 3.0_R_P / 6276836966400 0.0_R_P self % b ( 11 ) = - 13196319194082858 1.0_R_P / 6276836966400 0.0_R_P self % b ( 12 ) = 7255811707225973 3.0_R_P / 6276836966400 0.0_R_P self % b ( 13 ) = - 3060737386052056 9.0_R_P / 6276836966400 0.0_R_P self % b ( 14 ) = 962209690951533 7.0_R_P / 6276836966400 0.0_R_P self % b ( 15 ) = - 216156767124884 9.0_R_P / 6276836966400 0.0_R_P self % b ( 16 ) = 36255512642707 3.0_R_P / 6276836966400 0.0_R_P endselect self % error = 0 else ! bad (unsupported) number of required time steps self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init.html","title":"init – FOODIE"},{"text":"private elemental subroutine destroy(self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 if ( allocated ( self % b )) deallocate ( self % b ) self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy.html","title":"destroy – FOODIE"},{"text":"private subroutine integrate(self, U, previous, Dt, t, autoupdate) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Description Integrate field with Adams-Bashforth class scheme. Variables Type Visibility Attributes Name Initial logical, public :: autoupdate_ Perform cyclic autoupdate of previous time steps, dummy var. integer(kind=I_P), public :: s Steps counter. Source Code subroutine integrate ( self , U , previous , Dt , t , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate do s = 1 , self % steps U = U + previous ( s )% t ( t = t ( s )) * ( Dt * self % b ( s )) enddo if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate.html","title":"integrate – FOODIE"},{"text":"private subroutine update_previous(self, U, previous) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Description Cyclic update previous time steps. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Steps counter. Source Code subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do s = 1 , self % steps - 1 previous ( s ) = previous ( s + 1 ) enddo previous ( self % steps ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous","tags":"","loc":"proc/update_previous.html","title":"update_previous – FOODIE"},{"text":"private elemental subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize.html","title":"finalize – FOODIE"},{"text":"private elemental function min_steps() Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Description Return the minimum number of steps supported. Source Code elemental function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps","tags":"","loc":"proc/min_steps~2.html","title":"min_steps – FOODIE"},{"text":"private elemental function max_steps() Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. Description Return the maximum number of steps supported. Source Code elemental function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps","tags":"","loc":"proc/max_steps~2.html","title":"max_steps – FOODIE"},{"text":"private elemental function is_supported(steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . Description Check if the queried number of steps is supported or not. Calls proc~~is_supported~2~~CallsGraph proc~is_supported~2 is_supported proc~is_admissible is_admissible proc~is_supported~2->proc~is_admissible proc~tokenize tokenize proc~is_admissible->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported~2.html","title":"is_supported – FOODIE"},{"text":"private elemental subroutine init(self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth-Moulton integrator: initialize the b coefficients. Source Code elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth-Moulton integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( steps )) then self % steps = steps call self % predictor % init ( steps = steps ) call self % corrector % init ( steps = steps - 1 ) self % error = 0 else ! bad (unsupported) number of required time steps self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~2.html","title":"init – FOODIE"},{"text":"private elemental subroutine destroy(self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = - 1 call self % predictor % destroy call self % corrector % destroy self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~2.html","title":"destroy – FOODIE"},{"text":"private subroutine integrate(self, U, previous, Dt, t, iterations) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(in) :: self Actual ABM integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations of AM scheme. Description Integrate field with Adams-Bashforth-Moulton class scheme. Source Code subroutine integrate ( self , U , previous , Dt , t , iterations ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth-Moulton class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( IN ) :: self !< Actual ABM integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations of AM scheme. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % predictor % integrate ( U = U , previous = previous , Dt = Dt , t = t , autoupdate = . false .) call self % corrector % integrate ( U = U , previous = previous ( 2 :), Dt = Dt , t = t , iterations = iterations , autoupdate = . false .) call self % predictor % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~2.html","title":"integrate – FOODIE"},{"text":"private elemental subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~2.html","title":"finalize – FOODIE"},{"text":"private elemental function min_steps() Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Description Return the minimum number of steps supported. Source Code elemental function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps","tags":"","loc":"proc/min_steps~3.html","title":"min_steps – FOODIE"},{"text":"private elemental function max_steps() Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. Description Return the maximum number of steps supported. Source Code elemental function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps","tags":"","loc":"proc/max_steps~3.html","title":"max_steps – FOODIE"},{"text":"private elemental function is_supported(steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . Description Check if the queried number of steps is supported or not. Calls proc~~is_supported~3~~CallsGraph proc~is_supported~3 is_supported proc~is_admissible is_admissible proc~is_supported~3->proc~is_admissible proc~tokenize tokenize proc~is_admissible->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported~3.html","title":"is_supported – FOODIE"},{"text":"private elemental subroutine init(self, steps) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Moulton integrator: initialize the b coefficients. Source Code elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Moulton integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( steps )) then self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 0 : steps )) ; self % b = 0.0_R_P select case ( steps ) case ( 0 ) ! AM(0) Bacward-Euler self % b ( 0 ) = 1.0_R_P case ( 1 ) self % b ( 0 ) = 1.0_R_P / 2.0_R_P self % b ( 1 ) = 1.0_R_P / 2.0_R_P case ( 2 ) self % b ( 0 ) = - 1.0_R_P / 1 2.0_R_P self % b ( 1 ) = 8.0_R_P / 1 2.0_R_P self % b ( 2 ) = 5.0_R_P / 1 2.0_R_P case ( 3 ) self % b ( 0 ) = 1.0_R_P / 2 4.0_R_P self % b ( 1 ) = - 5.0_R_P / 2 4.0_R_P self % b ( 2 ) = 1 9.0_R_P / 2 4.0_R_P self % b ( 3 ) = 9.0_R_P / 2 4.0_R_P case ( 4 ) self % b ( 0 ) = - 1 9.0_R_P / 72 0.0_R_P self % b ( 1 ) = 10 6.0_R_P / 72 0.0_R_P self % b ( 2 ) = - 26 4.0_R_P / 72 0.0_R_P self % b ( 3 ) = 64 6.0_R_P / 72 0.0_R_P self % b ( 4 ) = 25 1.0_R_P / 72 0.0_R_P case ( 5 ) self % b ( 0 ) = 2 7.0_R_P / 144 0.0_R_P self % b ( 1 ) = - 17 3.0_R_P / 144 0.0_R_P self % b ( 2 ) = 48 2.0_R_P / 144 0.0_R_P self % b ( 3 ) = - 79 8.0_R_P / 144 0.0_R_P self % b ( 4 ) = 142 7.0_R_P / 144 0.0_R_P self % b ( 5 ) = 47 5.0_R_P / 144 0.0_R_P case ( 6 ) self % b ( 0 ) = - 86 3.0_R_P / 6048 0.0_R_P self % b ( 1 ) = 631 2.0_R_P / 6048 0.0_R_P self % b ( 2 ) = - 2021 1.0_R_P / 6048 0.0_R_P self % b ( 3 ) = 3750 4.0_R_P / 6048 0.0_R_P self % b ( 4 ) = - 4646 1.0_R_P / 6048 0.0_R_P self % b ( 5 ) = 6511 2.0_R_P / 6048 0.0_R_P self % b ( 6 ) = 1908 7.0_R_P / 6048 0.0_R_P case ( 7 ) self % b ( 0 ) = 137 5.0_R_P / 12096 0.0_R_P self % b ( 1 ) = - 1135 1.0_R_P / 12096 0.0_R_P self % b ( 2 ) = 4149 9.0_R_P / 12096 0.0_R_P self % b ( 3 ) = - 8854 7.0_R_P / 12096 0.0_R_P self % b ( 4 ) = 12313 3.0_R_P / 12096 0.0_R_P self % b ( 5 ) = - 12179 7.0_R_P / 12096 0.0_R_P self % b ( 6 ) = 13984 9.0_R_P / 12096 0.0_R_P self % b ( 7 ) = 3679 9.0_R_P / 12096 0.0_R_P case ( 8 ) self % b ( 0 ) = - 3395 3.0_R_P / 362880 0.0_R_P self % b ( 1 ) = 31287 4.0_R_P / 362880 0.0_R_P self % b ( 2 ) = - 129121 4.0_R_P / 362880 0.0_R_P self % b ( 3 ) = 314633 8.0_R_P / 362880 0.0_R_P self % b ( 4 ) = - 503312 0.0_R_P / 362880 0.0_R_P self % b ( 5 ) = 559535 8.0_R_P / 362880 0.0_R_P self % b ( 6 ) = - 460459 4.0_R_P / 362880 0.0_R_P self % b ( 7 ) = 446709 4.0_R_P / 362880 0.0_R_P self % b ( 8 ) = 107001 7.0_R_P / 362880 0.0_R_P case ( 9 ) self % b ( 0 ) = 5728 1.0_R_P / 725760 0.0_R_P self % b ( 1 ) = - 58343 5.0_R_P / 725760 0.0_R_P self % b ( 2 ) = 268786 4.0_R_P / 725760 0.0_R_P self % b ( 3 ) = - 739403 2.0_R_P / 725760 0.0_R_P self % b ( 4 ) = 1351008 2.0_R_P / 725760 0.0_R_P self % b ( 5 ) = - 1728364 6.0_R_P / 725760 0.0_R_P self % b ( 6 ) = 1600232 0.0_R_P / 725760 0.0_R_P self % b ( 7 ) = - 1127130 4.0_R_P / 725760 0.0_R_P self % b ( 8 ) = 944971 7.0_R_P / 725760 0.0_R_P self % b ( 9 ) = 208275 3.0_R_P / 725760 0.0_R_P case ( 10 ) self % b ( 0 ) = - 325043 3.0_R_P / 47900160 0.0_R_P self % b ( 1 ) = 3628487 6.0_R_P / 47900160 0.0_R_P self % b ( 2 ) = - 18477619 5.0_R_P / 47900160 0.0_R_P self % b ( 3 ) = 56745098 4.0_R_P / 47900160 0.0_R_P self % b ( 4 ) = - 117059704 2.0_R_P / 47900160 0.0_R_P self % b ( 5 ) = 171077452 8.0_R_P / 47900160 0.0_R_P self % b ( 6 ) = - 182331156 6.0_R_P / 47900160 0.0_R_P self % b ( 7 ) = 144620508 0.0_R_P / 47900160 0.0_R_P self % b ( 8 ) = - 89017554 9.0_R_P / 47900160 0.0_R_P self % b ( 9 ) = 65618565 2.0_R_P / 47900160 0.0_R_P self % b ( 10 ) = 13421126 5.0_R_P / 47900160 0.0_R_P case ( 11 ) self % b ( 0 ) = 567526 5.0_R_P / 95800320 0.0_R_P self % b ( 1 ) = - 6892878 1.0_R_P / 95800320 0.0_R_P self % b ( 2 ) = 38470932 7.0_R_P / 95800320 0.0_R_P self % b ( 3 ) = - 130597111 5.0_R_P / 95800320 0.0_R_P self % b ( 4 ) = 300773941 8.0_R_P / 95800320 0.0_R_P self % b ( 5 ) = - 496316651 4.0_R_P / 95800320 0.0_R_P self % b ( 6 ) = 604352148 6.0_R_P / 95800320 0.0_R_P self % b ( 7 ) = - 551946058 2.0_R_P / 95800320 0.0_R_P self % b ( 8 ) = 382882888 5.0_R_P / 95800320 0.0_R_P self % b ( 9 ) = - 209249067 3.0_R_P / 95800320 0.0_R_P self % b ( 10 ) = 137479921 9.0_R_P / 95800320 0.0_R_P self % b ( 11 ) = 26274726 5.0_R_P / 95800320 0.0_R_P case ( 12 ) self % b ( 0 ) = - 1369577909 3.0_R_P / 261534873600 0.0_R_P self % b ( 1 ) = 17984282256 6.0_R_P / 261534873600 0.0_R_P self % b ( 2 ) = - 109209699226 8.0_R_P / 261534873600 0.0_R_P self % b ( 3 ) = 406332786317 0.0_R_P / 261534873600 0.0_R_P self % b ( 4 ) = - 1034471179498 5.0_R_P / 261534873600 0.0_R_P self % b ( 5 ) = 1905818565279 6.0_R_P / 261534873600 0.0_R_P self % b ( 6 ) = - 2620434446515 2.0_R_P / 261534873600 0.0_R_P self % b ( 7 ) = 2734587069843 6.0_R_P / 261534873600 0.0_R_P self % b ( 8 ) = - 2184753803989 5.0_R_P / 261534873600 0.0_R_P self % b ( 9 ) = 1346577425651 0.0_R_P / 261534873600 0.0_R_P self % b ( 10 ) = - 661642095742 8.0_R_P / 261534873600 0.0_R_P self % b ( 11 ) = 391755121698 6.0_R_P / 261534873600 0.0_R_P self % b ( 12 ) = 70360425435 7.0_R_P / 261534873600 0.0_R_P case ( 13 ) self % b ( 0 ) = 2446657909 3.0_R_P / 523069747200 0.0_R_P self % b ( 1 ) = - 34545708639 5.0_R_P / 523069747200 0.0_R_P self % b ( 2 ) = 226807881438 6.0_R_P / 523069747200 0.0_R_P self % b ( 3 ) = - 918163560513 4.0_R_P / 523069747200 0.0_R_P self % b ( 4 ) = 2562025977783 5.0_R_P / 523069747200 0.0_R_P self % b ( 5 ) = - 5217791088266 1.0_R_P / 523069747200 0.0_R_P self % b ( 6 ) = 8010102102918 0.0_R_P / 523069747200 0.0_R_P self % b ( 7 ) = - 9439333865389 2.0_R_P / 523069747200 0.0_R_P self % b ( 8 ) = 8618022868956 3.0_R_P / 523069747200 0.0_R_P self % b ( 9 ) = - 6118868013128 5.0_R_P / 523069747200 0.0_R_P self % b ( 10 ) = 3392899013361 8.0_R_P / 523069747200 0.0_R_P self % b ( 11 ) = - 1514123508411 0.0_R_P / 523069747200 0.0_R_P self % b ( 12 ) = 815316796218 1.0_R_P / 523069747200 0.0_R_P self % b ( 13 ) = 138274192962 1.0_R_P / 523069747200 0.0_R_P case ( 14 ) self % b ( 0 ) = - 13228284012 7.0_R_P / 3138418483200 0.0_R_P self % b ( 1 ) = 199875923633 6.0_R_P / 3138418483200 0.0_R_P self % b ( 2 ) = - 1411048096992 7.0_R_P / 3138418483200 0.0_R_P self % b ( 3 ) = 6175942669254 4.0_R_P / 3138418483200 0.0_R_P self % b ( 4 ) = - 18750493659793 1.0_R_P / 3138418483200 0.0_R_P self % b ( 5 ) = 41855180460126 4.0_R_P / 3138418483200 0.0_R_P self % b ( 6 ) = - 71031283419734 7.0_R_P / 3138418483200 0.0_R_P self % b ( 7 ) = 93460083349094 4.0_R_P / 3138418483200 0.0_R_P self % b ( 8 ) = - 96360540082473 3.0_R_P / 3138418483200 0.0_R_P self % b ( 9 ) = 78191161807163 2.0_R_P / 3138418483200 0.0_R_P self % b ( 10 ) = - 49954720375483 7.0_R_P / 3138418483200 0.0_R_P self % b ( 11 ) = 25172489460793 6.0_R_P / 3138418483200 0.0_R_P self % b ( 12 ) = - 10288514895621 7.0_R_P / 3138418483200 0.0_R_P self % b ( 13 ) = 5077096753486 4.0_R_P / 3138418483200 0.0_R_P self % b ( 14 ) = 816416873759 9.0_R_P / 3138418483200 0.0_R_P case ( 15 ) self % b ( 0 ) = 24020824582 3.0_R_P / 6276836966400 0.0_R_P self % b ( 1 ) = - 386768936759 9.0_R_P / 6276836966400 0.0_R_P self % b ( 2 ) = 2921938428408 7.0_R_P / 6276836966400 0.0_R_P self % b ( 3 ) = - 13751571378931 9.0_R_P / 6276836966400 0.0_R_P self % b ( 4 ) = 45140310893348 3.0_R_P / 6276836966400 0.0_R_P self % b ( 5 ) = - 109635523540233 1.0_R_P / 6276836966400 0.0_R_P self % b ( 6 ) = 203934587954664 3.0_R_P / 6276836966400 0.0_R_P self % b ( 7 ) = - 296636573026569 9.0_R_P / 6276836966400 0.0_R_P self % b ( 8 ) = 341494172885289 3.0_R_P / 6276836966400 0.0_R_P self % b ( 9 ) = - 312945307199358 1.0_R_P / 6276836966400 0.0_R_P self % b ( 10 ) = 228516859834973 3.0_R_P / 6276836966400 0.0_R_P self % b ( 11 ) = - 132697866305806 9.0_R_P / 6276836966400 0.0_R_P self % b ( 12 ) = 61274454106533 7.0_R_P / 6276836966400 0.0_R_P self % b ( 13 ) = - 23099216372384 9.0_R_P / 6276836966400 0.0_R_P self % b ( 14 ) = 10514505875707 3.0_R_P / 6276836966400 0.0_R_P self % b ( 15 ) = 1608812922937 5.0_R_P / 6276836966400 0.0_R_P endselect self % error = 0 else ! bad (unsupported) number of required time steps self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~3.html","title":"init – FOODIE"},{"text":"private elemental subroutine destroy(self) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = - 1 if ( allocated ( self % b )) deallocate ( self % b ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~3.html","title":"destroy – FOODIE"},{"text":"private subroutine integrate(self, U, previous, Dt, t, iterations, autoupdate) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Description Integrate field with Adams-Moulton class scheme. Variables Type Visibility Attributes Name Initial logical, public :: autoupdate_ Perform cyclic autoupdate of previous time steps, dummy var. class( integrand ), public, allocatable :: delta Delta RHS for fixed point iterations. integer(kind=I_P), public :: s Steps counter. Source Code subroutine integrate ( self , U , previous , Dt , t , iterations , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Moulton class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. class ( integrand ), allocatable :: delta !< Delta RHS for fixed point iterations. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate if ( self % steps > 0 ) then if ( present ( iterations )) then ! perform fixed point iterations allocate ( delta , source = previous ( self % steps )) do s = 0 , self % steps - 1 delta = delta + previous ( s + 1 )% t ( t = t ( s + 1 )) * ( Dt * self % b ( s )) enddo do s = 1 , iterations U = delta + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps )) enddo else U = previous ( self % steps ) + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps )) do s = 0 , self % steps - 1 U = U + previous ( s + 1 )% t ( t = t ( s + 1 )) * ( Dt * self % b ( s )) enddo endif if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) else U = U + U % t ( t = t ( 1 )) * ( Dt * self % b ( 0 )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~3.html","title":"integrate – FOODIE"},{"text":"private subroutine update_previous(self, U, previous) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Description Cyclic update previous time steps. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Steps counter. Source Code subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 0 , self % steps - 2 previous ( s + 1 ) = previous ( s + 2 ) enddo previous ( self % steps ) = U endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous","tags":"","loc":"proc/update_previous~2.html","title":"update_previous – FOODIE"},{"text":"private elemental subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( adams_moulton_integrator ), intent(inout) :: self AB integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~3.html","title":"finalize – FOODIE"},{"text":"private elemental function min_steps() Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Description Return the minimum number of steps supported. Source Code elemental function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps","tags":"","loc":"proc/min_steps~4.html","title":"min_steps – FOODIE"},{"text":"private elemental function max_steps() Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. Description Return the maximum number of steps supported. Source Code elemental function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps","tags":"","loc":"proc/max_steps~4.html","title":"max_steps – FOODIE"},{"text":"private elemental function is_supported(steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . Description Check if the queried number of steps is supported or not. Calls proc~~is_supported~4~~CallsGraph proc~is_supported~4 is_supported proc~is_admissible is_admissible proc~is_supported~4->proc~is_admissible proc~tokenize tokenize proc~is_admissible->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported~4.html","title":"is_supported – FOODIE"},{"text":"private elemental subroutine init(self, steps) Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(inout) :: self BDF integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual BDF integrator: initialize the alpha and beta coefficients. Source Code elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual BDF integrator: initialize the *alpha* and *beta* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( back_df_integrator ), intent ( INOUT ) :: self !< BDF integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps if ( allocated ( self % a )) deallocate ( self % a ) ; allocate ( self % a ( 1 : steps )) ; self % a = 0.0_R_P select case ( steps ) case ( 1 ) self % a ( 1 ) = - 1.0_R_P self % b = 1.0_R_P case ( 2 ) self % a ( 1 ) = 1.0_R_P / 3.0_R_P self % a ( 2 ) = - 4.0_R_P / 3.0_R_P self % b = 2.0_R_P / 3.0_R_P case ( 3 ) self % a ( 1 ) = - 2.0_R_P / 1 1.0_R_P self % a ( 2 ) = 9.0_R_P / 1 1.0_R_P self % a ( 3 ) = - 1 8.0_R_P / 1 1.0_R_P self % b = 6.0_R_P / 1 1.0_R_P case ( 4 ) self % a ( 1 ) = 3.0_R_P / 2 5.0_R_P self % a ( 2 ) = - 1 6.0_R_P / 2 5.0_R_P self % a ( 3 ) = 3 6.0_R_P / 2 5.0_R_P self % a ( 4 ) = - 4 8.0_R_P / 2 5.0_R_P self % b = 1 2.0_R_P / 2 5.0_R_P case ( 5 ) self % a ( 1 ) = - 1 2.0_R_P / 13 7.0_R_P self % a ( 2 ) = 7 5.0_R_P / 13 7.0_R_P self % a ( 3 ) = - 20 0.0_R_P / 13 7.0_R_P self % a ( 4 ) = 30 0.0_R_P / 13 7.0_R_P self % a ( 5 ) = - 30 0.0_R_P / 13 7.0_R_P self % b = 6 0.0_R_P / 13 7.0_R_P case ( 6 ) self % a ( 1 ) = 1 0.0_R_P / 14 7.0_R_P self % a ( 2 ) = - 7 2.0_R_P / 14 7.0_R_P self % a ( 3 ) = 22 5.0_R_P / 14 7.0_R_P self % a ( 4 ) = - 40 0.0_R_P / 14 7.0_R_P self % a ( 5 ) = 45 0.0_R_P / 14 7.0_R_P self % a ( 6 ) = - 36 0.0_R_P / 14 7.0_R_P self % b = 6 0.0_R_P / 14 7.0_R_P case default ! bad (unsupported) number of required time steps self % error = 1 endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~4.html","title":"init – FOODIE"},{"text":"private elemental subroutine destroy(self) Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(inout) :: self BDF integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( back_df_integrator ), intent ( INOUT ) :: self !< BDF integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 1 if ( allocated ( self % a )) deallocate ( self % a ) self % b = 0.0_R_P self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~4.html","title":"destroy – FOODIE"},{"text":"private subroutine integrate(self, U, previous, Dt, t, iterations, autoupdate) Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(in) :: self Actual BDF integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Description Integrate field with BDF class scheme. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: iterations_ Fixed point iterations. logical, public :: autoupdate_ Perform cyclic autoupdate of previous time steps, dummy var. class( integrand ), public, allocatable :: delta Delta RHS for fixed point iterations. integer(kind=I_P), public :: s Steps counter. Source Code subroutine integrate ( self , U , previous , Dt , t , iterations , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with BDF class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( back_df_integrator ), intent ( IN ) :: self !< Actual BDF integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. integer ( I_P ) :: iterations_ !< Fixed point iterations. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. class ( integrand ), allocatable :: delta !< Delta RHS for fixed point iterations. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate iterations_ = 1 ; if ( present ( iterations )) iterations_ = iterations allocate ( delta , source = previous ( self % steps ) * ( - self % a ( self % steps ))) do s = 1 , self % steps - 1 delta = delta + previous ( s ) * ( - self % a ( s )) enddo do s = 1 , iterations U = delta + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ) enddo if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~4.html","title":"integrate – FOODIE"},{"text":"private subroutine update_previous(self, U, previous) Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(in) :: self Actual BDF integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Description Cyclic update previous time steps. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Steps counter. Source Code subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( back_df_integrator ), intent ( IN ) :: self !< Actual BDF integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do s = 1 , self % steps - 1 previous ( s ) = previous ( s + 1 ) enddo previous ( self % steps ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous","tags":"","loc":"proc/update_previous~3.html","title":"update_previous – FOODIE"},{"text":"private elemental subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( back_df_integrator ), intent(inout) :: self BDF integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( back_df_integrator ), intent ( INOUT ) :: self !< BDF integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~4.html","title":"finalize – FOODIE"},{"text":"private elemental function min_stages() Arguments None Return Value integer(kind=I_P) Minimum number of stages supported. Description Return the minimum number of stages supported. Source Code elemental function min_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_stages !< Minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_stages = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_stages","tags":"","loc":"proc/min_stages.html","title":"min_stages – FOODIE"},{"text":"private elemental function max_stages() Arguments None Return Value integer(kind=I_P) Maximum number of stages supported. Description Return the maximum number of stages supported. Source Code elemental function max_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_stages !< Maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_stages = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_stages","tags":"","loc":"proc/max_stages.html","title":"max_stages – FOODIE"},{"text":"private elemental function is_supported(stages) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value logical Is true is the stages number is in supported_stages . Description Check if the queried number of stages is supported or not. Calls proc~~is_supported~5~~CallsGraph proc~is_supported~5 is_supported proc~is_admissible is_admissible proc~is_supported~5->proc~is_admissible proc~tokenize tokenize proc~is_admissible->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function is_supported ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of stages is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. logical :: is_supported !< Is true is the stages number is in *supported_stages*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = stages , adm_range = trim ( supported_stages )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported~5.html","title":"is_supported – FOODIE"},{"text":"private elemental subroutine init(self, stages, tolerance) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. real(kind=R_P), intent(in), optional :: tolerance Tolerance on the local truncation error (default 0.01). Description Create the actual RK integrator: initialize the Butcher' table coefficients. Source Code elemental subroutine init ( self , stages , tolerance ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. real ( R_P ), optional , intent ( IN ) :: tolerance !< Tolerance on the local truncation error (default 0.01). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( stages )) then if ( present ( tolerance )) then self % tolerance = tolerance else self % tolerance = 0.01_R_P endif self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages , 1 : 2 )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 2 ) ! do not use, seems to not work! ! HERK(2,2) self % pp1_inv = 1._R_P / ( 2._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.5_R_P ; self % beta ( 1 , 2 ) = 5._R_P self % beta ( 2 , 1 ) = 1._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 6 ) ! CKRK(6,5) self % pp1_inv = 1._R_P / ( 5._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 7._R_P / 37 8._R_P ; self % beta ( 1 , 2 ) = 282 5._R_P / 2764 8._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 25 0._R_P / 62 1._R_P ; self % beta ( 3 , 2 ) = 1857 5._R_P / 4838 4._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 59 4._R_P ; self % beta ( 4 , 2 ) = 1352 5._R_P / 5529 6._R_P self % beta ( 5 , 1 ) = 0._R_P ; self % beta ( 5 , 2 ) = 27 7._R_P / 1433 6._R_P self % beta ( 6 , 1 ) = 51 2._R_P / 177 1._R_P ; self % beta ( 6 , 2 ) = 1._R_P / 4._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 1 0._R_P ; self % alph ( 4 , 2 ) = - 9._R_P / 1 0._R_P ; self % alph ( 4 , 3 ) = 6._R_P / 5._R_P self % alph ( 5 , 1 ) =- 1 1._R_P / 5 4._R_P ; self % alph ( 5 , 2 ) = 5._R_P / 2._R_P ; self % alph ( 5 , 3 ) =- 7 0._R_P / 2 7._R_P self % alph ( 6 , 1 ) = 163 1._R_P / 5529 6._R_P ; self % alph ( 6 , 2 ) = 17 5._R_P / 51 2._R_P ; self % alph ( 6 , 3 ) = 57 5._R_P / 1382 4._R_P self % alph ( 5 , 4 ) = 3 5._R_P / 2 7._R_P self % alph ( 6 , 4 ) = 4427 5._R_P / 11059 2._R_P ; self % alph ( 6 , 5 ) = 25 3._R_P / 409 6._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 3._R_P / 5._R_P self % gamm ( 5 ) = 1._R_P self % gamm ( 6 ) = 7._R_P / 8._R_P case ( 7 ) ! DPRK(7,4) self % pp1_inv = 1._R_P / ( 4._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 5._R_P / 38 4._R_P ; self % beta ( 1 , 2 ) = 517 9._R_P / 5760 0._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 50 0._R_P / 111 3._R_P ; self % beta ( 3 , 2 ) = 757 1._R_P / 1669 5._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 19 2._R_P ; self % beta ( 4 , 2 ) = 39 3._R_P / 64 0._R_P self % beta ( 5 , 1 ) = - 218 7._R_P / 678 4._R_P ; self % beta ( 5 , 2 ) = - 9209 7._R_P / 33920 0._R_P self % beta ( 6 , 1 ) = 1 1._R_P / 8 4._R_P ; self % beta ( 6 , 2 ) = 18 7._R_P / 210 0._R_P self % beta ( 7 , 1 ) = 0._R_P ; self % beta ( 7 , 2 ) = 1._R_P / 4 0._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 4 4._R_P / 4 5._R_P ; self % alph ( 4 , 2 ) =- 5 6._R_P / 1 5._R_P ; self % alph ( 4 , 3 ) = 3 2._R_P / 9._R_P self % alph ( 5 , 1 ) = 1937 2._R_P / 656 1._R_P ; self % alph ( 5 , 2 ) =- 2536 0._R_P / 218 7._R_P ; self % alph ( 5 , 3 ) = 6444 8._R_P / 656 1._R_P self % alph ( 6 , 1 ) = 901 7._R_P / 316 8._R_P ; self % alph ( 6 , 2 ) =- 35 5._R_P / 3 3._R_P ; self % alph ( 6 , 3 ) = 4673 2._R_P / 524 7._R_P self % alph ( 7 , 1 ) = 3 5._R_P / 38 4._R_P ; self % alph ( 7 , 2 ) = 0._R_P ; self % alph ( 7 , 3 ) = 50 0._R_P / 111 3._R_P self % alph ( 5 , 4 ) =- 21 2._R_P / 72 9._R_P self % alph ( 6 , 4 ) = 4 9._R_P / 17 6._R_P ; self % alph ( 6 , 5 ) =- 510 3._R_P / 1865 6._R_P self % alph ( 7 , 4 ) = 12 5._R_P / 19 2._R_P ; self % alph ( 7 , 5 ) =- 218 7._R_P / 678 4._R_P ; self % alph ( 7 , 6 ) = 1 1._R_P / 8 4._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 4._R_P / 5._R_P self % gamm ( 5 ) = 8._R_P / 9._R_P self % gamm ( 6 ) = 1._R_P self % gamm ( 7 ) = 1._R_P case ( 9 ) ! CMRK(9,6) self % pp1_inv = 1._R_P / ( 6._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % beta ( 1 , 2 ) = 1523166 5._R_P / 51083033 4._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 5751301 1._R_P / 20186425 0._R_P ; self % beta ( 3 , 2 ) = 5945299 1._R_P / 11605044 8._R_P self % beta ( 4 , 1 ) = 1558730 6._R_P / 35450157 1._R_P ; self % beta ( 4 , 2 ) = - 2839851 7._R_P / 12243773 8._R_P self % beta ( 5 , 1 ) = 7178302 1._R_P / 23498286 5._R_P ; self % beta ( 5 , 2 ) = 5667382 4._R_P / 13701055 9._R_P self % beta ( 6 , 1 ) = 2967200 0._R_P / 18048016 7._R_P ; self % beta ( 6 , 2 ) = 6800384 9._R_P / 42667358 3._R_P self % beta ( 7 , 1 ) = 6556762 1._R_P / 12706095 2._R_P ; self % beta ( 7 , 2 ) = 709763 1._R_P / 3756402 1._R_P self % beta ( 8 , 1 ) = - 7907457 0._R_P / 21055759 7._R_P ; self % beta ( 8 , 2 ) = - 7122642 9._R_P / 58309374 2._R_P self % beta ( 9 , 1 ) = 0._R_P ; self % beta ( 9 , 2 ) = 1._R_P / 2 0._R_P self % alph ( 2 , 1 ) = 2._R_P / 1 5._R_P self % alph ( 3 , 1 ) = 1._R_P / 2 0._R_P ; self % alph ( 3 , 2 ) = 3._R_P / 2 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 8672701 5._R_P / 19685155 3._R_P ; self % alph ( 5 , 2 ) =- 6012907 3._R_P / 5262471 2._R_P self % alph ( 6 , 1 ) =- 8686084 9._R_P / 4562896 7._R_P ; self % alph ( 6 , 2 ) = 11102288 5._R_P / 2571648 7._R_P self % alph ( 7 , 1 ) = 7775959 1._R_P / 1609646 7._R_P ; self % alph ( 7 , 2 ) =- 4925280 9._R_P / 645255 5._R_P self % alph ( 8 , 1 ) = 23756426 3._R_P / 3928029 5._R_P ; self % alph ( 8 , 2 ) =- 10052323 9._R_P / 1067794 0._R_P self % alph ( 9 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 4 , 3 ) = 9._R_P / 4 0._R_P self % alph ( 5 , 3 ) = 95743643 4._R_P / 137835237 7._R_P ; self % alph ( 5 , 4 ) = 8388683 2._R_P / 14784244 1._R_P self % alph ( 6 , 3 ) = 10804668 2._R_P / 10116766 9._R_P ; self % alph ( 6 , 4 ) =- 14175674 6._R_P / 3600546 1._R_P self % alph ( 7 , 3 ) =- 38168011 1._R_P / 5157298 4._R_P ; self % alph ( 7 , 4 ) = 87926957 9._R_P / 6678883 1._R_P self % alph ( 8 , 3 ) =- 26557484 6._R_P / 2733024 7._R_P ; self % alph ( 8 , 4 ) = 31797841 1._R_P / 1898871 3._R_P self % alph ( 9 , 3 ) = 5751301 1._R_P / 20186425 0._R_P ; self % alph ( 9 , 4 ) = 1558730 6._R_P / 35450157 1._R_P self % alph ( 6 , 5 ) = 7313986 2._R_P / 6017063 3._R_P self % alph ( 7 , 5 ) =- 9045312 1._R_P / 3372216 2._R_P ; self % alph ( 7 , 6 ) = 11117955 2._R_P / 15715582 7._R_P self % alph ( 8 , 5 ) =- 12449438 5._R_P / 3545362 7._R_P ; self % alph ( 8 , 6 ) = 8682244 4._R_P / 10013863 5._R_P self % alph ( 9 , 5 ) = 7178302 1._R_P / 23498286 5._R_P ; self % alph ( 9 , 6 ) = 2967200 0._R_P / 18048016 7._R_P self % alph ( 8 , 7 ) =- 1287352 3._R_P / 72423262 5._R_P self % alph ( 9 , 7 ) = 6556762 1._R_P / 12706095 2._R_P ; self % alph ( 9 , 8 ) =- 7907457 0._R_P / 21055759 7._R_P self % gamm ( 2 ) = 2._R_P / 1 5._R_P self % gamm ( 3 ) = 1._R_P / 5._R_P self % gamm ( 4 ) = 3._R_P / 1 0._R_P self % gamm ( 5 ) = 1 4._R_P / 2 5._R_P self % gamm ( 6 ) = 1 9._R_P / 2 5._R_P self % gamm ( 7 ) = 3522660 7._R_P / 3568827 9._R_P self % gamm ( 8 ) = 1._R_P self % gamm ( 9 ) = 1._R_P case ( 17 ) ! FRK(17,10) self % pp1_inv = 1._R_P / ( 1 0._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 1 , 2 ) = 0.033333333333333333333_R_P self % beta ( 2 , 1 ) = 0.025_R_P ; self % beta ( 2 , 2 ) = 1._R_P / 3 6._R_P self % beta ( 3 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 3 , 2 ) = 0.033333333333333333333_R_P self % beta ( 4 , 1 ) = 0._R_P ; self % beta ( 4 , 2 ) = 0._R_P self % beta ( 5 , 1 ) = 0.05_R_P ; self % beta ( 5 , 2 ) = 0.05_R_P self % beta ( 6 , 1 ) = 0._R_P ; self % beta ( 6 , 2 ) = 0._R_P self % beta ( 7 , 1 ) = 0.04_R_P ; self % beta ( 7 , 2 ) = 0.04_R_P self % beta ( 8 , 1 ) = 0._R_P ; self % beta ( 8 , 2 ) = 0._R_P self % beta ( 9 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 9 , 2 ) = 0.189237478148923490158_R_P self % beta ( 10 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 10 , 2 ) = 0.277429188517743176508_R_P self % beta ( 11 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 11 , 2 ) = 0.277429188517743176508_R_P self % beta ( 12 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 12 , 2 ) = 0.189237478148923490158_R_P self % beta ( 13 , 1 ) =- 0.04_R_P ; self % beta ( 13 , 2 ) =- 0.04_R_P self % beta ( 14 , 1 ) =- 0.05_R_P ; self % beta ( 14 , 2 ) =- 0.05_R_P self % beta ( 15 , 1 ) =- 0.033333333333333333333_R_P ; self % beta ( 15 , 2 ) =- 0.033333333333333333333_R_P self % beta ( 16 , 1 ) =- 0.025_R_P ; self % beta ( 16 , 2 ) =- 1._R_P / 3 6._R_P self % beta ( 17 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 17 , 2 ) = 0.033333333333333333333_R_P self % alph ( 2 , 1 ) = 0.1_R_P self % alph ( 3 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 3 , 2 ) = 1.454534402178273228052_R_P self % alph ( 4 , 1 ) = 0.202259190301118170324_R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 0.184024714708643575149_R_P ; self % alph ( 5 , 2 ) = 0._R_P self % alph ( 6 , 1 ) = 0.087900734020668133731_R_P ; self % alph ( 6 , 2 ) = 0._R_P self % alph ( 7 , 1 ) = 0.085970050490246030218_R_P ; self % alph ( 7 , 2 ) = 0._R_P self % alph ( 8 , 1 ) = 0.120930449125333720660_R_P ; self % alph ( 8 , 2 ) = 0._R_P self % alph ( 9 , 1 ) = 0.110854379580391483508_R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 10 , 1 ) = 0.112054414752879004829_R_P ; self % alph ( 10 , 2 ) = 0._R_P self % alph ( 11 , 1 ) = 0.113976783964185986138_R_P ; self % alph ( 11 , 2 ) = 0._R_P self % alph ( 12 , 1 ) = 0.079831452828019604635_R_P ; self % alph ( 12 , 2 ) = 0._R_P self % alph ( 13 , 1 ) = 0.985115610164857280120_R_P ; self % alph ( 13 , 2 ) = 0._R_P self % alph ( 14 , 1 ) = 0.895080295771632891049_R_P ; self % alph ( 14 , 2 ) = 0._R_P self % alph ( 15 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 15 , 2 ) = 1.454534402178273228052_R_P self % alph ( 16 , 1 ) = 0.1_R_P ; self % alph ( 16 , 2 ) = 0._R_P self % alph ( 17 , 1 ) = 0.181781300700095283888_R_P ; self % alph ( 17 , 2 ) = 0.675_R_P self % alph ( 4 , 3 ) = 0.606777570903354510974_R_P self % alph ( 5 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 5 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 6 , 3 ) = 0._R_P ; self % alph ( 6 , 4 ) = 0.410459702520260645318_R_P self % alph ( 7 , 3 ) = 0._R_P ; self % alph ( 7 , 4 ) = 0.330885963040722183948_R_P self % alph ( 8 , 3 ) = 0._R_P ; self % alph ( 8 , 4 ) = 0._R_P self % alph ( 9 , 3 ) = 0._R_P ; self % alph ( 9 , 4 ) = 0._R_P self % alph ( 10 , 3 ) = 0._R_P ; self % alph ( 10 , 4 ) = 0._R_P self % alph ( 11 , 3 ) = 0._R_P ; self % alph ( 11 , 4 ) = 0._R_P self % alph ( 12 , 3 ) = 0._R_P ; self % alph ( 12 , 4 ) = 0._R_P self % alph ( 13 , 3 ) = 0._R_P ; self % alph ( 13 , 4 ) = 0.330885963040722183948_R_P self % alph ( 14 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 14 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 15 , 3 ) = 0._R_P ; self % alph ( 15 , 4 ) = 0._R_P self % alph ( 16 , 3 ) =- 0.157178665799771163367_R_P ; self % alph ( 16 , 4 ) = 0._R_P self % alph ( 17 , 3 ) = 0.342758159847189839942_R_P ; self % alph ( 17 , 4 ) = 0._R_P self % alph ( 6 , 5 ) = 0.482713753678866489204_R_P self % alph ( 7 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 7 , 6 ) =- 0.073185637507085073678_R_P self % alph ( 8 , 5 ) = 0.260124675758295622809_R_P ; self % alph ( 8 , 6 ) = 0.032540262154909133015_R_P self % alph ( 9 , 5 ) = 0._R_P ; self % alph ( 9 , 6 ) =- 0.060576148825500558762_R_P self % alph ( 10 , 5 ) = 0._R_P ; self % alph ( 10 , 6 ) =- 0.144942775902865915672_R_P self % alph ( 11 , 5 ) = 0._R_P ; self % alph ( 11 , 6 ) =- 0.076881336420335693858_R_P self % alph ( 12 , 5 ) = 0._R_P ; self % alph ( 12 , 6 ) =- 0.052032968680060307651_R_P self % alph ( 13 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 13 , 6 ) =- 1.378964865748435675821_R_P self % alph ( 14 , 5 ) = 0._R_P ; self % alph ( 14 , 6 ) =- 0.851236239662007619739_R_P self % alph ( 15 , 5 ) =- 0.777333643644968233538_R_P ; self % alph ( 15 , 6 ) = 0._R_P self % alph ( 16 , 5 ) = 0._R_P ; self % alph ( 16 , 6 ) = 0._R_P self % alph ( 17 , 5 ) = 0.259111214548322744512_R_P ; self % alph ( 17 , 6 ) =- 0.358278966717952089048_R_P self % alph ( 8 , 7 ) =- 0.059578021181736100156_R_P self % alph ( 9 , 7 ) = 0.321763705601778390100_R_P ; self % alph ( 9 , 8 ) = 0.510485725608063031577_R_P self % alph ( 10 , 7 ) =- 0.333269719096256706589_R_P ; self % alph ( 10 , 8 ) = 0.499269229556880061353_R_P self % alph ( 11 , 7 ) = 0.239527360324390649107_R_P ; self % alph ( 11 , 8 ) = 0.397774662368094639047_R_P self % alph ( 12 , 7 ) =- 0.057695414616854888173_R_P ; self % alph ( 12 , 8 ) = 0.194781915712104164976_R_P self % alph ( 13 , 7 ) =- 0.861164195027635666673_R_P ; self % alph ( 13 , 8 ) = 5.784288136375372200229_R_P self % alph ( 14 , 7 ) = 0.398320112318533301719_R_P ; self % alph ( 14 , 8 ) = 3.639372631810356060294_R_P self % alph ( 15 , 7 ) =- 0.091089566215517606959_R_P ; self % alph ( 15 , 8 ) = 0._R_P self % alph ( 16 , 7 ) = 0._R_P ; self % alph ( 16 , 8 ) = 0._R_P self % alph ( 17 , 7 ) =- 1.045948959408833060950_R_P ; self % alph ( 17 , 8 ) = 0.930327845415626983292_R_P self % alph ( 10 , 9 ) = 0.509504608929686104236_R_P self % alph ( 11 , 9 ) = 0.010755895687360745555_R_P ; self % alph ( 11 , 10 ) =- 0.327769124164018874147_R_P self % alph ( 12 , 9 ) = 0.145384923188325069727_R_P ; self % alph ( 12 , 10 ) =- 0.078294271035167077755_R_P self % alph ( 13 , 9 ) = 3.288077619851035668904_R_P ; self % alph ( 13 , 10 ) =- 2.386339050931363840134_R_P self % alph ( 14 , 9 ) = 1.548228770398303223653_R_P ; self % alph ( 14 , 10 ) =- 2.122217147040537160260_R_P self % alph ( 15 , 9 ) = 0._R_P ; self % alph ( 15 , 10 ) = 0._R_P self % alph ( 16 , 9 ) = 0._R_P ; self % alph ( 16 , 10 ) = 0._R_P self % alph ( 17 , 9 ) = 1.779509594317081024461_R_P ; self % alph ( 17 , 10 ) = 0.1_R_P self % alph ( 12 , 11 ) =- 0.114503299361098912184_R_P self % alph ( 13 , 11 ) =- 3.254793424836439186545_R_P ; self % alph ( 13 , 12 ) =- 2.163435416864229823539_R_P self % alph ( 14 , 11 ) =- 1.583503985453261727133_R_P ; self % alph ( 14 , 12 ) =- 1.715616082859362649220_R_P self % alph ( 15 , 11 ) = 0._R_P ; self % alph ( 15 , 12 ) = 0._R_P self % alph ( 16 , 11 ) = 0._R_P ; self % alph ( 16 , 12 ) = 0._R_P self % alph ( 17 , 11 ) =- 0.282547569539044081612_R_P ; self % alph ( 17 , 12 ) =- 0.159327350119972549169_R_P self % alph ( 14 , 13 ) =- 0.024403640575012745213_R_P self % alph ( 15 , 13 ) = 0.091089566215517606959_R_P ; self % alph ( 15 , 14 ) = 0.777333643644968233538_R_P self % alph ( 16 , 13 ) = 0._R_P ; self % alph ( 16 , 14 ) = 0._R_P self % alph ( 17 , 13 ) =- 0.145515894647001510860_R_P ; self % alph ( 17 , 14 ) =- 0.259111214548322744512_R_P self % alph ( 16 , 15 ) = 0.157178665799771163367_R_P self % alph ( 17 , 15 ) =- 0.342758159847189839942_R_P ; self % alph ( 17 , 16 ) =- 0.675_R_P self % gamm ( 2 ) = 0.1_R_P self % gamm ( 3 ) = 0.539357840802981787532_R_P self % gamm ( 4 ) = 0.809036761204472681298_R_P self % gamm ( 5 ) = 0.309036761204472681298_R_P self % gamm ( 6 ) = 0.981074190219795268254_R_P self % gamm ( 7 ) = 0.833333333333333333333_R_P self % gamm ( 8 ) = 0.354017365856802376329_R_P self % gamm ( 9 ) = 0.882527661964732346425_R_P self % gamm ( 10 ) = 0.642615758240322548157_R_P self % gamm ( 11 ) = 0.357384241759677451842_R_P self % gamm ( 12 ) = 0.117472338035267653574_R_P self % gamm ( 13 ) = 0.833333333333333333333_R_P self % gamm ( 14 ) = 0.309036761204472681298_R_P self % gamm ( 15 ) = 0.539357840802981787532_R_P self % gamm ( 16 ) = 0.1_R_P self % gamm ( 17 ) = 1._R_P endselect self % error = 0 else ! bad (unsupported) number of required stages self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~5.html","title":"init – FOODIE"},{"text":"private elemental subroutine destroy(self) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % tolerance = 0._R_P self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~5.html","title":"destroy – FOODIE"},{"text":"private subroutine integrate(self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(inout) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit embedded Runge-Kutta scheme. The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. Note This method can be used after the integrator is created (i.e. the RK coefficients are initialized). Variables Type Visibility Attributes Name Initial class( integrand ), public, allocatable :: U1 First U evaluation. class( integrand ), public, allocatable :: U2 Second U evaluation. real(kind=R_P), public :: error Local truncation error estimation. integer(kind=I_P), public :: s First stages counter. integer(kind=I_P), public :: ss Second stages counter. Source Code subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit embedded Runge-Kutta scheme. !< !< The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( INOUT ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: U1 !< First U evaluation. class ( integrand ), allocatable :: U2 !< Second U evaluation. real ( R_P ) :: error !< Local truncation error estimation. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( U1 , source = U ) allocate ( U2 , source = U ) error = 1 e6 do while ( error > self % tolerance ) ! compute stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! compute new time step U1 = U U2 = U do s = 1 , self % stages U1 = U1 + stage ( s ) * ( Dt * self % beta ( s , 1 )) U2 = U2 + stage ( s ) * ( Dt * self % beta ( s , 2 )) enddo error = U2 . lterror . U1 call self % new_Dt ( error = error , Dt = Dt ) enddo U = U1 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~5.html","title":"integrate – FOODIE"},{"text":"private elemental subroutine new_Dt(self, error, Dt) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Integrator. real(kind=R_P), intent(in) :: error Local truncation error estimation. real(kind=R_P), intent(inout) :: Dt Time step. Description Compute new estimation of the time step Dt. The formula employed is:  Dt_{new} = 0.9 Dt_{old} \\left( \\frac{tolerance}{error} \\right)&#94;{\\frac{1}{p+1}}  Note 0.9 is a safety factor. Source Code elemental subroutine new_Dt ( self , error , Dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute new estimation of the time step Dt. !< !< The formula employed is: !< !<  Dt_{new} = 0.9 Dt_{old} \\left( \\frac{tolerance}{error} \\right)&#94;{\\frac{1}{p+1}}  !< !< @note 0.9 is a safety factor. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( IN ) :: self !< Integrator. real ( R_P ), intent ( IN ) :: error !< Local truncation error estimation. real ( R_P ), intent ( INOUT ) :: Dt !< Time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( error > self % tolerance ) Dt = 0.9_R_P * Dt * ( self % tolerance / error ) ** self % pp1_inv return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine new_Dt","tags":"","loc":"proc/new_dt.html","title":"new_Dt – FOODIE"},{"text":"private elemental subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( emd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~5.html","title":"finalize – FOODIE"},{"text":"private elemental function min_stages_steps() Arguments None Return Value integer(kind=I_P) Minimum number of stages/steps supported. Description Return the minimum number of stages/steps supported. Source Code elemental function min_stages_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of stages/steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_stages_steps !< Minimum number of stages/steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_stages_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_stages_steps","tags":"","loc":"proc/min_stages_steps.html","title":"min_stages_steps – FOODIE"},{"text":"private elemental function max_stages_steps() Arguments None Return Value integer(kind=I_P) Maximum number of stages/steps supported. Description Return the maximum number of stages/steps supported. Source Code elemental function max_stages_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of stages/steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_stages_steps !< Maximum number of stages/steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_stages_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_stages_steps","tags":"","loc":"proc/max_stages_steps.html","title":"max_stages_steps – FOODIE"},{"text":"private elemental function is_supported(stages_steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages_steps Number of stages/steps used. Return Value logical Is true is the stages number is in supported_stages_steps . Description Check if the queried number of stages/steps is supported or not. Calls proc~~is_supported~6~~CallsGraph proc~is_supported~6 is_supported proc~is_admissible is_admissible proc~is_supported~6->proc~is_admissible proc~tokenize tokenize proc~is_admissible->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function is_supported ( stages_steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of stages/steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages_steps !< Number of stages/steps used. logical :: is_supported !< Is true is the stages number is in *supported_stages_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = stages_steps , adm_range = trim ( supported_stages_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported~6.html","title":"is_supported – FOODIE"},{"text":"private subroutine integrate(U, Dt, t) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. Description Integrate field with explicit Euler scheme, 1st order. Source Code subroutine integrate ( U , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit Euler scheme, 1st order. !--------------------------------------------------------------------------------------------------------------------------------- class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), optional , intent ( IN ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- U = U + U % t ( t = t ) * Dt return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~6.html","title":"integrate – FOODIE"},{"text":"private elemental function min_steps() Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Description Return the minimum number of steps supported. Source Code elemental function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps","tags":"","loc":"proc/min_steps~5.html","title":"min_steps – FOODIE"},{"text":"private elemental function max_steps() Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. Description Return the maximum number of steps supported. Source Code elemental function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps","tags":"","loc":"proc/max_steps~5.html","title":"max_steps – FOODIE"},{"text":"private elemental function is_supported(steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . Description Check if the queried number of steps is supported or not. Calls proc~~is_supported~7~~CallsGraph proc~is_supported~7 is_supported proc~is_admissible is_admissible proc~is_supported~7->proc~is_admissible proc~tokenize tokenize proc~is_admissible->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported~7.html","title":"is_supported – FOODIE"},{"text":"private elemental subroutine init(self, nu, alpha) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(inout) :: self LF integrator. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. Description Create the actual leapfrog integrator: initialize the filter coefficient. Source Code elemental subroutine init ( self , nu , alpha ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual leapfrog integrator: initialize the filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( INOUT ) :: self !< LF integrator. real ( R_P ), optional , intent ( IN ) :: nu !< Williams-Robert-Asselin filter coefficient. real ( R_P ), optional , intent ( IN ) :: alpha !< Robert-Asselin filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % nu = 0.01_R_P self % alpha = 0.53_R_P if ( present ( nu )) self % nu = nu if ( present ( alpha )) self % alpha = alpha return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~6.html","title":"init – FOODIE"},{"text":"private subroutine integrate(self, U, previous, Dt, t, filter) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(in) :: self LF integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:2) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. class( integrand ), intent(inout), optional :: filter Filter field displacement. Description Integrate field with leapfrog class scheme. Source Code subroutine integrate ( self , U , previous , Dt , t , filter ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with leapfrog class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( IN ) :: self !< LF integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 : 2 ) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. class ( integrand ), optional , intent ( INOUT ) :: filter !< Filter field displacement. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- U = previous ( 1 ) + previous ( 2 )% t ( t = t ) * ( Dt * 2._R_P ) if ( present ( filter )) then filter = ( previous ( 1 ) - previous ( 2 ) * 2._R_P + U ) * self % nu * 0.5_R_P previous ( 2 ) = previous ( 2 ) + filter * self % alpha U = U + filter * ( self % alpha - 1._R_P ) endif previous ( 1 ) = previous ( 2 ) previous ( 2 ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~7.html","title":"integrate – FOODIE"},{"text":"private elemental function used_registers() Arguments None Return Value integer(kind=I_P) Number of registers used. Description Return the number of registers used. Source Code elemental function used_registers () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the number of registers used. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: used_registers !< Number of registers used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- used_registers = registers return !--------------------------------------------------------------------------------------------------------------------------------- endfunction used_registers","tags":"","loc":"proc/used_registers.html","title":"used_registers – FOODIE"},{"text":"private elemental function min_stages() Arguments None Return Value integer(kind=I_P) Minimum number of stages supported. Description Return the minimum number of stages supported. Source Code elemental function min_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_stages !< Minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_stages = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_stages","tags":"","loc":"proc/min_stages~2.html","title":"min_stages – FOODIE"},{"text":"private elemental function max_stages() Arguments None Return Value integer(kind=I_P) Maximum number of stages supported. Description Return the maximum number of stages supported. Source Code elemental function max_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_stages !< Maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_stages = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_stages","tags":"","loc":"proc/max_stages~2.html","title":"max_stages – FOODIE"},{"text":"private elemental function is_supported(stages) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value logical Is true is the stages number is in supported_stages . Description Check if the queried number of stages is supported or not. Calls proc~~is_supported~8~~CallsGraph proc~is_supported~8 is_supported proc~is_admissible is_admissible proc~is_supported~8->proc~is_admissible proc~tokenize tokenize proc~is_admissible->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function is_supported ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of stages is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. logical :: is_supported !< Is true is the stages number is in *supported_stages*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = stages , adm_range = trim ( supported_stages )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported~8.html","title":"is_supported – FOODIE"},{"text":"private elemental subroutine init(self, stages) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' low storage table coefficients. Source Code elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' low storage table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( stages )) then self % stages = stages if ( allocated ( self % A )) deallocate ( self % A ) ; allocate ( self % A ( 1 : stages )) ; self % A = 0._R_P if ( allocated ( self % B )) deallocate ( self % B ) ; allocate ( self % B ( 1 : stages )) ; self % B = 0._R_P if ( allocated ( self % C )) deallocate ( self % C ) ; allocate ( self % C ( 1 : stages )) ; self % C = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % B ( 1 ) = 1._R_P case ( 5 ) ! LSRK(5,4) self % A ( 1 ) = 0._R_P self % A ( 2 ) = - real ( 567301805773_I8P , kind = R_P ) / real ( 1357537059087_I8P , kind = R_P ) self % A ( 3 ) = - real ( 2404267990393_I8P , kind = R_P ) / real ( 2016746695238_I8P , kind = R_P ) self % A ( 4 ) = - real ( 3550918686646_I8P , kind = R_P ) / real ( 2091501179385_I8P , kind = R_P ) self % A ( 5 ) = - real ( 1275806237668_I8P , kind = R_P ) / real ( 842570457699_I8P , kind = R_P ) self % B ( 1 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % B ( 2 ) = real ( 5161836677717_I8P , kind = R_P ) / real ( 13612068292357_I8P , kind = R_P ) self % B ( 3 ) = real ( 1720146321549_I8P , kind = R_P ) / real ( 2090206949498_I8P , kind = R_P ) self % B ( 4 ) = real ( 3134564353537_I8P , kind = R_P ) / real ( 4481467310338_I8P , kind = R_P ) self % B ( 5 ) = real ( 2277821191437_I8P , kind = R_P ) / real ( 14882151754819_I8P , kind = R_P ) self % C ( 1 ) = 0._R_P self % C ( 2 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % C ( 3 ) = real ( 2526269341429_I8P , kind = R_P ) / real ( 6820363962896_I8P , kind = R_P ) self % C ( 4 ) = real ( 2006345519317_I8P , kind = R_P ) / real ( 3224310063776_I8P , kind = R_P ) self % C ( 5 ) = real ( 2802321613138_I8P , kind = R_P ) / real ( 2924317926251_I8P , kind = R_P ) case ( 6 ) ! LSRK(6,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.122000000000_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.691750960670_R_P ; self % B ( 2 ) = 0.477263056358_R_P ; self % C ( 2 ) = 0.122000000000_R_P self % A ( 3 ) = - 1.727127405211_R_P ; self % B ( 3 ) = 0.381941220320_R_P ; self % C ( 3 ) = 0.269115878630_R_P self % A ( 4 ) = - 0.694890150986_R_P ; self % B ( 4 ) = 0.447757195744_R_P ; self % C ( 4 ) = 0.447717183551_R_P self % A ( 5 ) = - 1.039942756197_R_P ; self % B ( 5 ) = 0.498614246822_R_P ; self % C ( 5 ) = 0.749979795490_R_P self % A ( 6 ) = - 1.531977447611_R_P ; self % B ( 6 ) = 0.186648570846_R_P ; self % C ( 6 ) = 0.898555413085_R_P case ( 7 ) ! LSRK(7,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.117322146869_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.647900745934_R_P ; self % B ( 2 ) = 0.503270262127_R_P ; self % C ( 2 ) = 0.117322146869_R_P self % A ( 3 ) = - 2.704760863204_R_P ; self % B ( 3 ) = 0.233663281658_R_P ; self % C ( 3 ) = 0.294523230758_R_P self % A ( 4 ) = - 0.460080550118_R_P ; self % B ( 4 ) = 0.283419634625_R_P ; self % C ( 4 ) = 0.305658622131_R_P self % A ( 5 ) = - 0.500581787785_R_P ; self % B ( 5 ) = 0.540367414023_R_P ; self % C ( 5 ) = 0.582864148403_R_P self % A ( 6 ) = - 1.906532255913_R_P ; self % B ( 6 ) = 0.371499414620_R_P ; self % C ( 6 ) = 0.858664273599_R_P self % A ( 7 ) = - 1.450000000000_R_P ; self % B ( 7 ) = 0.136670099385_R_P ; self % C ( 7 ) = 0.868664273599_R_P case ( 12 ) ! LSRK(12,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0650008435125904_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.0923311242368072_R_P ; self % B ( 2 ) = 0.0161459902249842_R_P ; self % C ( 2 ) = 0.0650008435125904_R_P self % A ( 3 ) = - 0.9441056581158819_R_P ; self % B ( 3 ) = 0.5758627178358159_R_P ; self % C ( 3 ) = 0.0796560563081853_R_P self % A ( 4 ) = - 4.3271273247576394_R_P ; self % B ( 4 ) = 0.1649758848361671_R_P ; self % C ( 4 ) = 0.1620416710085376_R_P self % A ( 5 ) = - 2.1557771329026072_R_P ; self % B ( 5 ) = 0.3934619494248182_R_P ; self % C ( 5 ) = 0.2248877362907778_R_P self % A ( 6 ) = - 0.9770727190189062_R_P ; self % B ( 6 ) = 0.0443509641602719_R_P ; self % C ( 6 ) = 0.2952293985641261_R_P self % A ( 7 ) = - 0.7581835342571139_R_P ; self % B ( 7 ) = 0.2074504268408778_R_P ; self % C ( 7 ) = 0.3318332506149405_R_P self % A ( 8 ) = - 1.7977525470825499_R_P ; self % B ( 8 ) = 0.6914247433015102_R_P ; self % C ( 8 ) = 0.4094724050198658_R_P self % A ( 9 ) = - 2.6915667972700770_R_P ; self % B ( 9 ) = 0.3766646883450449_R_P ; self % C ( 9 ) = 0.6356954475753369_R_P self % A ( 10 ) = - 4.6466798960268143_R_P ; self % B ( 10 ) = 0.0757190350155483_R_P ; self % C ( 10 ) = 0.6806551557645497_R_P self % A ( 11 ) = - 0.1539613783825189_R_P ; self % B ( 11 ) = 0.2027862031054088_R_P ; self % C ( 11 ) = 0.7143773712418350_R_P self % A ( 12 ) = - 0.5943293901830616_R_P ; self % B ( 12 ) = 0.2167029365631842_R_P ; self % C ( 12 ) = 0.9032588871651854_R_P case ( 13 ) ! LSRK(13,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0271990297818803_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.6160178650170565_R_P ; self % B ( 2 ) = 0.1772488819905108_R_P ; self % C ( 2 ) = 0.0271990297818803_R_P self % A ( 3 ) = - 0.4449487060774118_R_P ; self % B ( 3 ) = 0.0378528418949694_R_P ; self % C ( 3 ) = 0.0952594339119365_R_P self % A ( 4 ) = - 1.0952033345276178_R_P ; self % B ( 4 ) = 0.6086431830142991_R_P ; self % C ( 4 ) = 0.1266450286591127_R_P self % A ( 5 ) = - 1.2256030785959187_R_P ; self % B ( 5 ) = 0.2154313974316100_R_P ; self % C ( 5 ) = 0.1825883045699772_R_P self % A ( 6 ) = - 0.2740182222332805_R_P ; self % B ( 6 ) = 0.2066152563885843_R_P ; self % C ( 6 ) = 0.3737511439063931_R_P self % A ( 7 ) = - 0.0411952089052647_R_P ; self % B ( 7 ) = 0.0415864076069797_R_P ; self % C ( 7 ) = 0.5301279418422206_R_P self % A ( 8 ) = - 0.1797084899153560_R_P ; self % B ( 8 ) = 0.0219891884310925_R_P ; self % C ( 8 ) = 0.5704177433952291_R_P self % A ( 9 ) = - 1.1771530652064288_R_P ; self % B ( 9 ) = 0.9893081222650993_R_P ; self % C ( 9 ) = 0.5885784947099155_R_P self % A ( 10 ) = - 0.4078831463120878_R_P ; self % B ( 10 ) = 0.0063199019859826_R_P ; self % C ( 10 ) = 0.6160769826246714_R_P self % A ( 11 ) = - 0.8295636426191777_R_P ; self % B ( 11 ) = 0.3749640721105318_R_P ; self % C ( 11 ) = 0.6223252334314046_R_P self % A ( 12 ) = - 4.7895970584252288_R_P ; self % B ( 12 ) = 1.6080235151003195_R_P ; self % C ( 12 ) = 0.6897593128753419_R_P self % A ( 13 ) = - 0.6606671432964504_R_P ; self % B ( 13 ) = 0.0961209123818189_R_P ; self % C ( 13 ) = 0.9126827615920843_R_P case ( 14 ) ! LSRK(14,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0367762454319673_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.7188012108672410_R_P ; self % B ( 2 ) = 0.3136296607553959_R_P ; self % C ( 2 ) = 0.0367762454319673_R_P self % A ( 3 ) = - 0.7785331173421570_R_P ; self % B ( 3 ) = 0.1531848691869027_R_P ; self % C ( 3 ) = 0.1249685262725025_R_P self % A ( 4 ) = - 0.0053282796654044_R_P ; self % B ( 4 ) = 0.0030097086818182_R_P ; self % C ( 4 ) = 0.2446177702277698_R_P self % A ( 5 ) = - 0.8552979934029281_R_P ; self % B ( 5 ) = 0.3326293790646110_R_P ; self % C ( 5 ) = 0.2476149531070420_R_P self % A ( 6 ) = - 3.9564138245774565_R_P ; self % B ( 6 ) = 0.2440251405350864_R_P ; self % C ( 6 ) = 0.2969311120382472_R_P self % A ( 7 ) = - 1.5780575380587385_R_P ; self % B ( 7 ) = 0.3718879239592277_R_P ; self % C ( 7 ) = 0.3978149645802642_R_P self % A ( 8 ) = - 2.0837094552574054_R_P ; self % B ( 8 ) = 0.6204126221582444_R_P ; self % C ( 8 ) = 0.5270854589440328_R_P self % A ( 9 ) = - 0.7483334182761610_R_P ; self % B ( 9 ) = 0.1524043173028741_R_P ; self % C ( 9 ) = 0.6981269994175695_R_P self % A ( 10 ) = - 0.7032861106563359_R_P ; self % B ( 10 ) = 0.0760894927419266_R_P ; self % C ( 10 ) = 0.8190890835352128_R_P self % A ( 11 ) = 0.0013917096117681_R_P ; self % B ( 11 ) = 0.0077604214040978_R_P ; self % C ( 11 ) = 0.8527059887098624_R_P self % A ( 12 ) = - 0.0932075369637460_R_P ; self % B ( 12 ) = 0.0024647284755382_R_P ; self % C ( 12 ) = 0.8604711817462826_R_P self % A ( 13 ) = - 0.9514200470875948_R_P ; self % B ( 13 ) = 0.0780348340049386_R_P ; self % C ( 13 ) = 0.8627060376969976_R_P self % A ( 14 ) = - 7.1151571693922548_R_P ; self % B ( 14 ) = 5.5059777270269628_R_P ; self % C ( 14 ) = 0.8734213127600976_R_P endselect self % error = 0 else ! bad (unsupported) number of required stages self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~7.html","title":"init – FOODIE"},{"text":"private elemental subroutine destroy(self) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % A )) deallocate ( self % A ) if ( allocated ( self % B )) deallocate ( self % B ) if ( allocated ( self % C )) deallocate ( self % C ) self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~6.html","title":"destroy – FOODIE"},{"text":"private subroutine integrate(self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:registers) Runge-Kutta registers. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit low storage Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coefficients are initialized). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s First stages counter. Source Code subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit low storage Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 : registers ) !< Runge-Kutta registers. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages stage ( 1 ) = U stage ( 2 ) = U * 0._R_P do s = 1 , self % stages stage ( 2 ) = stage ( 2 ) * self % A ( s ) + stage ( 1 )% t ( t = t + self % C ( s ) * Dt ) * Dt stage ( 1 ) = stage ( 1 ) + stage ( 2 ) * self % B ( s ) enddo U = stage ( 1 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~8.html","title":"integrate – FOODIE"},{"text":"private elemental subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~6.html","title":"finalize – FOODIE"},{"text":"private elemental function min_stages() Arguments None Return Value integer(kind=I_P) Minimum number of stages supported. Description Return the minimum number of stages supported. Source Code elemental function min_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_stages !< Minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_stages = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_stages","tags":"","loc":"proc/min_stages~3.html","title":"min_stages – FOODIE"},{"text":"private elemental function max_stages() Arguments None Return Value integer(kind=I_P) Maximum number of stages supported. Description Return the maximum number of stages supported. Source Code elemental function max_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_stages !< Maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_stages = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_stages","tags":"","loc":"proc/max_stages~3.html","title":"max_stages – FOODIE"},{"text":"private elemental function is_supported(stages) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value logical Is true is the stages number is in supported_stages . Description Check if the queried number of stages is supported or not. Calls proc~~is_supported~9~~CallsGraph proc~is_supported~9 is_supported proc~is_admissible is_admissible proc~is_supported~9->proc~is_admissible proc~tokenize tokenize proc~is_admissible->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function is_supported ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of stages is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. logical :: is_supported !< Is true is the stages number is in *supported_stages*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = stages , adm_range = trim ( supported_stages )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported~9.html","title":"is_supported – FOODIE"},{"text":"private elemental subroutine init(self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. Source Code elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( stages )) then self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect self % error = 0 else ! bad (unsupported) number of required stages self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~8.html","title":"init – FOODIE"},{"text":"private elemental subroutine destroy(self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~7.html","title":"destroy – FOODIE"},{"text":"private subroutine integrate(self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coefficients are initialized). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s First stages counter. integer(kind=I_P), public :: ss Second stages counter. Source Code subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! computing new time step do s = 1 , self % stages U = U + stage ( s ) * ( Dt * self % beta ( s )) enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~9.html","title":"integrate – FOODIE"},{"text":"private elemental subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~7.html","title":"finalize – FOODIE"},{"text":"public elemental function is_admissible(n, adm_range) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: n Number queried. character(len=*), intent(in) :: adm_range Admissible range string. Return Value logical Is true is the number is in adm_range . Description Check if the queried number n is admitted by the admissible range list adm_range . The admissible range list must be formatted as string containing admissible numbers; valid list are:\n+ adm_range = '1-5' => 1, 2, 3, 4, 5 are admissible numbers;\n+ adm_range = '1,3,5,10-12' => 1, 3, 5, 10, 11, 12 are admissible numbers;\n+ adm_range = '1-4,8,21-22' => 1, 2, 3, 4, 8, 21, 22 are admissible numbers; You can mix any number of range ( min-max format) and/or single number ( , comma separated) entries. Calls proc~~is_admissible~~CallsGraph proc~is_admissible is_admissible proc~tokenize tokenize proc~is_admissible->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~is_admissible~~CalledByGraph proc~is_admissible is_admissible proc~is_supported~8 is_supported proc~is_supported~8->proc~is_admissible proc~is_supported~4 is_supported proc~is_supported~4->proc~is_admissible proc~is_supported~7 is_supported proc~is_supported~7->proc~is_admissible proc~is_supported~9 is_supported proc~is_supported~9->proc~is_admissible proc~is_supported~5 is_supported proc~is_supported~5->proc~is_admissible proc~is_supported~2 is_supported proc~is_supported~2->proc~is_admissible proc~is_supported~6 is_supported proc~is_supported~6->proc~is_admissible proc~is_supported is_supported proc~is_supported->proc~is_admissible proc~is_supported~3 is_supported proc~is_supported~3->proc~is_admissible Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=len(adm_range)), public, allocatable :: tokens (:) Tokens for parsing adm_range string. character(len=len(adm_range)), public, allocatable :: subtokens (:) Tokens for parsing adm_range string. integer(kind=I_P), public :: t Counter. integer(kind=I_P), public :: n_parsed (1:2) Values parsed from adm_range .. Source Code elemental function is_admissible ( n , adm_range ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number *n* is admitted by the *admissible* range list *adm_range*. !< !< The admissible range list must be formatted as string containing admissible numbers; valid list are: !<+ `adm_range = '1-5'` => 1, 2, 3, 4, 5 are admissible numbers; !<+ `adm_range = '1,3,5,10-12'` => 1, 3, 5, 10, 11, 12 are admissible numbers; !<+ `adm_range = '1-4,8,21-22'` => 1, 2, 3, 4, 8, 21, 22 are admissible numbers; !< !< You can mix any number of range (`min-max` format) and/or single number (`,` comma separated) entries. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: n !< Number queried. character ( * ), intent ( IN ) :: adm_range !< Admissible range string. logical :: is_admissible !< Is true is the number is in *adm_range*. character ( len ( adm_range )), allocatable :: tokens (:) !< Tokens for parsing *adm_range* string. character ( len ( adm_range )), allocatable :: subtokens (:) !< Tokens for parsing *adm_range* string. integer ( I_P ) :: t !< Counter. integer ( I_P ) :: n_parsed ( 1 : 2 ) !< Values parsed from *adm_range*.. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_admissible = . false . call tokenize ( string = adm_range , delimiter = ',' , toks = tokens ) search_me : do t = 1 , size ( tokens ) if ( index ( tokens ( t ), '-' ) > 0 ) then call tokenize ( string = tokens ( t ), delimiter = '-' , toks = subtokens ) read ( subtokens ( 1 ), * ) n_parsed ( 1 ) read ( subtokens ( 2 ), * ) n_parsed ( 2 ) is_admissible = ( n_parsed ( 1 ) <= n . and . n <= n_parsed ( 2 )) else read ( tokens ( t ), * ) n_parsed ( 1 ) is_admissible = ( n_parsed ( 1 ) == n ) endif if ( is_admissible ) exit search_me enddo search_me return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_admissible","tags":"","loc":"proc/is_admissible.html","title":"is_admissible – FOODIE"},{"text":"private pure subroutine tokenize(string, delimiter, toks, Nt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be tokenized. character(len=*), intent(in) :: delimiter Delimiter of tokens. character(len=len(string)), intent(out), allocatable :: toks (:) Tokens. integer(kind=I_P), intent(out), optional :: Nt Number of tokens. Description Tokenize a string in order to parse it. Note The dummy array containing tokens must be allocatable and its character elements must have the same length of the input\n string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with\n only one element set to char(0). Called By proc~~tokenize~~CalledByGraph proc~tokenize tokenize proc~is_admissible is_admissible proc~is_admissible->proc~tokenize proc~is_supported~8 is_supported proc~is_supported~8->proc~is_admissible proc~is_supported~4 is_supported proc~is_supported~4->proc~is_admissible proc~is_supported~7 is_supported proc~is_supported~7->proc~is_admissible proc~is_supported~9 is_supported proc~is_supported~9->proc~is_admissible proc~is_supported~5 is_supported proc~is_supported~5->proc~is_admissible proc~is_supported~2 is_supported proc~is_supported~2->proc~is_admissible proc~is_supported~6 is_supported proc~is_supported~6->proc~is_admissible proc~is_supported is_supported proc~is_supported->proc~is_admissible proc~is_supported~3 is_supported proc~is_supported~3->proc~is_admissible Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=len(string)), public :: strsub Temporary string. integer(kind=I_P), public :: dlen Delimiter length. integer(kind=I_P), public :: c Counter. integer(kind=I_P), public :: n Counter. integer(kind=I_P), public :: t Counter. Source Code pure subroutine tokenize ( string , delimiter , toks , Nt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must be allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to char(0). !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( IN ) :: string !< String to be tokenized. character ( len =* ), intent ( IN ) :: delimiter !< Delimiter of tokens. character ( len = len ( string )), allocatable , intent ( OUT ) :: toks (:) !< Tokens. integer ( I_P ), optional , intent ( OUT ) :: Nt !< Number of tokens. character ( len = len ( string )) :: strsub !< Temporary string. integer ( I_P ) :: dlen !< Delimiter length. integer ( I_P ) :: c !< Counter. integer ( I_P ) :: n !< Counter. integer ( I_P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialize if ( allocated ( toks )) deallocate ( toks ) strsub = string dlen = len ( delimiter ) if ( dlen > len ( string )) then allocate ( toks ( 1 : 1 )) toks ( 1 ) = char ( 0 ) if ( present ( Nt )) Nt = 1 return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenize do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tokenize","tags":"","loc":"proc/tokenize.html","title":"tokenize – FOODIE"},{"text":"private pure function exact_solution_xy(frequency, t) result(ex_sol) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: frequency Oscillation frequency. real(kind=R_P), intent(in) :: t Time. Return Value real(kind=R_P)\n  (1:2) Exact solution. Description Compute the exact solution on X-Y domain. Called By proc~~exact_solution_xy~~CalledByGraph proc~exact_solution_xy exact_solution_xy proc~error_l2 error_L2 proc~error_l2->proc~exact_solution_xy proc~save_results save_results proc~save_results->proc~exact_solution_xy proc~solve solve proc~solve->proc~error_l2 proc~test test proc~test->proc~save_results proc~test->proc~solve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function exact_solution_xy ( frequency , t ) result ( ex_sol ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the exact solution on X-Y domain. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( in ) :: frequency !< Oscillation frequency. real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ) :: ex_sol ( 1 : 2 ) !< Exact solution. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ex_sol ( 1 ) = initial_state ( 1 ) * cos ( frequency * t ) - initial_state ( 2 ) * sin ( frequency * t ) ex_sol ( 2 ) = initial_state ( 1 ) * sin ( frequency * t ) + initial_state ( 2 ) * cos ( frequency * t ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction exact_solution_xy","tags":"","loc":"proc/exact_solution_xy.html","title":"exact_solution_xy – FOODIE"},{"text":"private pure function error_L2(frequency, solution) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: frequency Oscillation frequency. real(kind=R_P), intent(in) :: solution (0:,0:) Solution at each time step. Return Value real(kind=R_P)\n  (1:space_dimension) L2 norm of the numerical error. Description Compute the L2 norm of numerical error with respect the exact solution. Calls proc~~error_l2~~CallsGraph proc~error_l2 error_L2 proc~exact_solution_xy exact_solution_xy proc~error_l2->proc~exact_solution_xy Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~error_l2~~CalledByGraph proc~error_l2 error_L2 proc~solve solve proc~solve->proc~error_l2 proc~test test proc~test->proc~solve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: ex_sol (1:space_dimension) Exact solution. integer(kind=I_P), public :: s Steps/stages counter. integer(kind=I_P), public :: v Variables counter. Source Code pure function error_L2 ( frequency , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the L2 norm of numerical error with respect the exact solution. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( in ) :: frequency !< Oscillation frequency. real ( R_P ), intent ( IN ) :: solution ( 0 :, 0 :) !< Solution at each time step. real ( R_P ) :: error_L2 ( 1 : space_dimension ) !< L2 norm of the numerical error. real ( R_P ) :: ex_sol ( 1 : space_dimension ) !< Exact solution. integer ( I_P ) :: s !< Steps/stages counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- error_L2 = 0._R_P do s = 0 , ubound ( solution , dim = 2 ) ex_sol = exact_solution_xy ( frequency = frequency , t = solution ( 0 , s )) do v = 1 , space_dimension error_L2 ( v ) = error_L2 ( v ) + ( solution ( v , s ) - ex_sol ( v )) * ( solution ( v , s ) - ex_sol ( v )) enddo enddo error_L2 = sqrt ( error_L2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction error_L2","tags":"","loc":"proc/error_l2.html","title":"error_L2 – FOODIE"},{"text":"private pure function observed_order(error, Dt) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: error (1:space_dimension,1:2) Computed errors. real(kind=R_P), intent(in) :: Dt (1:2) Time steps used. Return Value real(kind=R_P)\n  (1:space_dimension) Estimation of the order of accuracy. Description Estimate the order of accuracy using 2 subsequent refined numerical solutions. Called By proc~~observed_order~~CalledByGraph proc~observed_order observed_order proc~test test proc~test->proc~observed_order Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: v Variables counter. Source Code pure function observed_order ( error , Dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate the order of accuracy using 2 subsequent refined numerical solutions. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: error ( 1 : space_dimension , 1 : 2 ) !< Computed errors. real ( R_P ), intent ( IN ) :: Dt ( 1 : 2 ) !< Time steps used. real ( R_P ) :: observed_order ( 1 : space_dimension ) !< Estimation of the order of accuracy. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do v = 1 , space_dimension observed_order ( v ) = log ( error ( v , 1 ) / error ( v , 2 )) / log ( Dt ( 1 ) / Dt ( 2 )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction observed_order","tags":"","loc":"proc/observed_order.html","title":"observed_order – FOODIE"},{"text":"private subroutine execute(self) Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(inout) :: self Test. Description Execute test(s). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Counter. Source Code subroutine execute ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Execute test(s). !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation_test ), intent ( inout ) :: self !< Test. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % init if ( trim ( adjustl ( self % solver )) /= 'all' ) then call self % test ( solver = self % solver ) else do s = 1 , ubound ( solvers , dim = 1 ) self % solver = solvers ( s ) call self % test ( solver = self % solver ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine execute","tags":"","loc":"proc/execute.html","title":"execute – FOODIE"},{"text":"private subroutine init(self) Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(inout) :: self Test. Description Initialize test: set Command Line Interface, parse it and check its validity. Calls proc~~init~9~~CallsGraph proc~init~9 init none~set_cli set_cli proc~init~9->none~set_cli none~parse_cli parse_cli proc~init~9->none~parse_cli none~is_dt_valid is_dt_valid none~parse_cli->none~is_dt_valid str str none~parse_cli->str none~is_solver_valid is_solver_valid none~parse_cli->none~is_solver_valid none~list_solvers list_solvers none~parse_cli->none~list_solvers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions function is_solver_valid() Arguments None Return Value logical Return true is the selected solver is available. Description Verify if the selected solver is valid. function is_dt_valid() Arguments None Return Value logical Return true is the selected time step Dt is valid. Description Verify if the selected time step Dt is valid. function list_solvers() result(list) Arguments None Return Value character(len=:),\n  allocatable Pretty printed list of available solvers. Description List available solvers. Subroutines subroutine set_cli() Arguments None Description set Command Line Interface. subroutine parse_cli() Arguments None Description Parse Command Line Interface and check its validity. Source Code subroutine init ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize test: set Command Line Interface, parse it and check its validity. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation_test ), intent ( inout ) :: self !< Test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call set_cli call parse_cli return !--------------------------------------------------------------------------------------------------------------------------------- contains subroutine set_cli () !------------------------------------------------------------------------------------------------------------------------------- !< set Command Line Interface. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- associate ( cli => self % cli ) call cli % init ( progname = 'oscillation' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Oscillation equations integration' , & examples = [ \"oscillation --solver euler --results  \" , & \"oscillation --solver ls-runge-kutta -r\" , & \"oscillation --solver adams-bashforth  \" , & \"oscillation --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . false ., def = 'all' , act = 'store' ) call cli % add ( switch = '--iterations' , help = 'Number of iterations for implicit solvers' , required = . false ., act = 'store' , def = '5' ) call cli % add ( switch = '--frequency' , switch_ab = '-f' , help = 'Oscillation frequency' , required = . false ., def = '1e-4' , act = 'store' ) call cli % add ( switch = '--ss' , nargs = '+' , help = 'Stages/steps used' , required = . false ., def = '-1' , act = 'store' ) call cli % add ( switch = '--time_step' , switch_ab = '-Dt' , nargs = '+' , help = 'Time step' , required = . false ., def = '100.d0' , act = 'store' ) call cli % add ( switch = '--tolerance' , switch_ab = '-tol' , nargs = '+' , help = 'Error Tolerance' , required = . false ., def = '0.001d0' , & act = 'store' ) call cli % add ( switch = '--t_final' , switch_ab = '-tf' , help = 'Final integration time' , required = . false ., def = '1e6' , act = 'store' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--output' , help = 'Output files basename' , required = . false ., act = 'store' , def = 'unset' ) call cli % add ( switch = '--errors_analysis' , help = 'Peform errors analysis' , required = . false ., act = 'store_true' , def = '.false.' ) endassociate return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_cli subroutine parse_cli () !------------------------------------------------------------------------------------------------------------------------------- !< Parse Command Line Interface and check its validity. !------------------------------------------------------------------------------------------------------------------------------- character ( len = :), allocatable :: valid_solvers_list !< Pretty printed list of available solvers. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- associate ( cli => self % cli , error => self % error ) call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = self % solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--iterations' , val = self % implicit_iterations , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-f' , val = self % frequency , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '--ss' , val = self % stages_steps , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-Dt' , val = self % Dt , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-tol' , val = self % tolerance , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-tf' , val = self % final_time , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = self % results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = self % plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--output' , val = self % output_cli , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--errors_analysis' , val = self % errors_analysis , error = error ) ; if ( error /= 0 ) stop endassociate if (. not . is_solver_valid ()) then print \"(A)\" , 'Error: the solver \"' // trim ( adjustl ( self % solver )) // '\" is unknown!' valid_solvers_list = list_solvers () print \"(A)\" , valid_solvers_list stop endif if (. not . is_dt_valid ()) then print \"(A)\" , 'Error: the final integration time must be an exact multiple of the time step used!' print \"(A)\" , 'Final integration time: ' // str (. true ., self % final_time ) print \"(A)\" , 'Time step: ' // str (. true ., self % Dt ) stop endif if ( size ( self % stages_steps ) == 2 ) then if (. not .( self % stages_steps ( 2 ) > self % stages_steps ( 1 ). and . self % stages_steps ( 1 ) >= 0 )) then print \"(A)\" , 'Error: when passing a range of stages/steps the valid format must be lower-upper (both positive)!' print \"(A)\" , 'Range passed: ' // trim ( str (. true ., self % stages_steps ( 1 ))) // '-' // trim ( str (. true ., self % stages_steps ( 2 ))) stop endif endif return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_cli function is_solver_valid () !------------------------------------------------------------------------------------------------------------------------------- !< Verify if the selected solver is valid. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_solver_valid !< Return true is the selected solver is available. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- is_solver_valid = . false . do s = 1 , ubound ( solvers , dim = 1 ) is_solver_valid = ( trim ( adjustl ( self % solver )) == trim ( adjustl ( solvers ( s )))) if ( is_solver_valid ) exit enddo return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_solver_valid function is_dt_valid () !------------------------------------------------------------------------------------------------------------------------------- !< Verify if the selected time step Dt is valid. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_dt_valid !< Return true is the selected time step Dt is valid. integer ( I_P ) :: t !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- is_dt_valid = . true . do t = 1 , size ( self % Dt ) is_dt_valid = (( self % final_time - int ( self % final_time / self % Dt ( t ), I_P ) * self % Dt ( t )) == 0 ) if (. not . is_dt_valid ) exit enddo return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_dt_valid function list_solvers () result ( list ) !------------------------------------------------------------------------------------------------------------------------------- !< List available solvers. !------------------------------------------------------------------------------------------------------------------------------- character ( len = :), allocatable :: list !< Pretty printed list of available solvers. integer ( I_P ) :: s !< Solvers counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- list = 'Valid solver names are:' // new_line ( 'a' ) do s = 1 , ubound ( solvers , dim = 1 ) list = list // '  + ' // trim ( adjustl ( solvers ( s ))) // new_line ( 'a' ) enddo list = list // '  + all' return !------------------------------------------------------------------------------------------------------------------------------- endfunction list_solvers endsubroutine init","tags":"","loc":"proc/init~9.html","title":"init – FOODIE"},{"text":"private subroutine test(self, solver) Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(in) :: self Test. character(len=*), intent(in) :: solver Selected solver. Description Perform the test. Calls proc~~test~~CallsGraph proc~test test proc~save_results save_results proc~test->proc~save_results proc~solve solve proc~test->proc~solve str str proc~test->str proc~observed_order observed_order proc~test->proc~observed_order proc~exact_solution_xy exact_solution_xy proc~save_results->proc~exact_solution_xy strz strz proc~save_results->strz none~amplitude_phase amplitude_phase proc~save_results->none~amplitude_phase proc~solve->str proc~error_l2 error_L2 proc~solve->proc~error_l2 proc~error_l2->proc~exact_solution_xy Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( adams_bashforth_integrator ), public :: ab_integrator Adams-Bashforth integrator. type( adams_bashforth_moulton_integrator ), public :: abm_integrator Adams-Bashforth-Moulton integrator. type( adams_moulton_integrator ), public :: am_integrator Adams-Moulton integrator. type( back_df_integrator ), public :: bdf_integrator BDF integrator. type( emd_runge_kutta_integrator ), public :: emd_rk_integrator Runge-Kutta integrator. type( euler_explicit_integrator ), public :: euler_integrator Euler integrator. type( leapfrog_integrator ), public :: lf_integrator Leapfrog integrator. type( ls_runge_kutta_integrator ), public :: ls_rk_integrator Low Storage Runge-Kutta integrator. type( tvd_runge_kutta_integrator ), public :: tvd_rk_integrator TVD Runge-Kutta integrator. real(kind=R_P), public, allocatable :: solution (:,:) Solution at each time step. real(kind=R_P), public, allocatable :: error (:,:) Error (norm L2) with respect the exact solution. real(kind=R_P), public, allocatable :: order (:,:) Observed order based on subsequent refined solutions. real(kind=R_P), public, allocatable :: Dt_mean (:) Mean time steps used for adaptive solver solutions. logical, public :: analyze_errors Flag for activating errors analysis for the current tests set. integer(kind=I_P), public :: stages_steps_range (1:2) Stages/Steps used. integer(kind=I_P), public :: last_step Last time step computed. integer(kind=I_P), public :: s Counter. integer(kind=I_P), public :: t Counter. Source Code subroutine test ( self , solver ) !--------------------------------------------------------------------------------------------------------------------------------- !< Perform the test. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation_test ), intent ( in ) :: self !< Test. character ( * ), intent ( in ) :: solver !< Selected solver. ! FOODIE integrators type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. type ( adams_bashforth_moulton_integrator ) :: abm_integrator !< Adams-Bashforth-Moulton integrator. type ( adams_moulton_integrator ) :: am_integrator !< Adams-Moulton integrator. type ( back_df_integrator ) :: bdf_integrator !< BDF integrator. type ( emd_runge_kutta_integrator ) :: emd_rk_integrator !< Runge-Kutta integrator. type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( ls_runge_kutta_integrator ) :: ls_rk_integrator !< Low Storage Runge-Kutta integrator. type ( tvd_runge_kutta_integrator ) :: tvd_rk_integrator !< TVD Runge-Kutta integrator. ! Auxiliary variables real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. real ( R_P ), allocatable :: error (:,:) !< Error (norm L2) with respect the exact solution. real ( R_P ), allocatable :: order (:,:) !< Observed order based on subsequent refined solutions. real ( R_P ), allocatable :: Dt_mean (:) !< Mean time steps used for adaptive solver solutions. logical :: analyze_errors !< Flag for activating errors analysis for the current tests set. integer ( I_P ) :: stages_steps_range ( 1 : 2 ) !< Stages/Steps used. integer ( I_P ) :: last_step !< Last time step computed. integer ( I_P ) :: s !< Counter. integer ( I_P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialize stages/steps range if ( size ( self % stages_steps ) == 2 ) then if ( self % stages_steps ( 2 ) > self % stages_steps ( 1 ). and . self % stages_steps ( 1 ) >= 0 ) then stages_steps_range = [ self % stages_steps ( 1 ), self % stages_steps ( 2 )] endif elseif ( self % stages_steps ( 1 ) >= 0 ) then stages_steps_range = self % stages_steps ( 1 ) else select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) stages_steps_range = [ ab_integrator % min_steps (), ab_integrator % max_steps ()] case ( 'adams-bashforth-moulton' ) stages_steps_range = [ abm_integrator % min_steps (), abm_integrator % max_steps ()] case ( 'adams-moulton' ) stages_steps_range = [ am_integrator % min_steps (), am_integrator % max_steps ()] case ( 'backward-diff-formula' ) stages_steps_range = [ bdf_integrator % min_steps (), bdf_integrator % max_steps ()] case ( 'emd-runge-kutta' ) stages_steps_range = [ emd_rk_integrator % min_stages (), emd_rk_integrator % max_stages ()] case ( 'euler' ) stages_steps_range = [ euler_integrator % min_stages_steps (), euler_integrator % max_stages_steps ()] case ( 'leapfrog' ) stages_steps_range = [ lf_integrator % min_steps (), lf_integrator % max_steps ()] case ( 'leapfrog-raw' ) stages_steps_range = [ lf_integrator % min_steps (), lf_integrator % max_steps ()] case ( 'ls-runge-kutta' ) stages_steps_range = [ ls_rk_integrator % min_stages (), ls_rk_integrator % max_stages ()] case ( 'tvd-runge-kutta' ) stages_steps_range = [ tvd_rk_integrator % min_stages (), tvd_rk_integrator % max_stages ()] endselect endif if ( trim ( adjustl ( solver )) == 'emd-runge-kutta' ) then if ( allocated ( error )) deallocate ( error ) ; allocate ( error ( 1 : space_dimension , 1 : size ( self % tolerance ))) if ( allocated ( Dt_mean )) deallocate ( Dt_mean ) ; allocate ( Dt_mean ( 1 : size ( error , dim = 2 ))) else if ( allocated ( error )) deallocate ( error ) ; allocate ( error ( 1 : space_dimension , 1 : size ( self % Dt ))) endif error = 0.0_R_P analyze_errors = . false . if ( trim ( adjustl ( solver )) == 'emd-runge-kutta' ) then if ( size ( self % tolerance ) > 1. and . self % errors_analysis ) then if ( allocated ( order )) deallocate ( order ) ; allocate ( order ( 1 : space_dimension , 1 : size ( self % tolerance ) - 1 )) analyze_errors = . true . endif else if ( size ( self % Dt ) > 1. and . self % errors_analysis ) then if ( allocated ( order )) deallocate ( order ) ; allocate ( order ( 1 : space_dimension , 1 : size ( self % Dt ) - 1 )) analyze_errors = . true . endif endif ! test(s) print \"(A)\" , trim ( adjustl ( solver )) do s = stages_steps_range ( 1 ), stages_steps_range ( 2 ) print \"(A)\" , '  stages/steps ' // trim ( str (. true ., s )) if ( trim ( adjustl ( solver )) == 'emd-runge-kutta' ) then do t = 1 , size ( self % tolerance ) call solve ( solver = solver , & frequency = self % frequency , & final_time = self % final_time , & stages_steps = s , & iterations = self % implicit_iterations , & solution = solution , & error = error (:, t ), & last_step = last_step , & tolerance = self % tolerance ( t )) Dt_mean ( t ) = self % final_time / real ( last_step , kind = R_P ) if ( allocated ( solution )) then print \"(A,I10,A,F10.3,A,F10.3,A,E10.3,A,E10.3)\" , \"    steps: \" , last_step , & \"    Dt: \" , Dt_mean ( t ), & \", f*Dt: \" , self % frequency * Dt_mean ( t ), & \", E(x): \" , error ( 1 , t ), \", E(y): \" , error ( 2 , t ) if ( analyze_errors . and . t > 1 ) then order (:, t - 1 ) = observed_order ( error = error (:, t - 1 : t ), Dt = Dt_mean ( t - 1 : t )) print \"(A,F10.2,A,F10.2)\" , \"      Observed order, O(x): \" , order ( 1 , t - 1 ), \", O(y): \" , order ( 2 , t - 1 ) endif call save_results ( results = self % results , & plots = self % plots , & output_cli = self % output_cli , & solver = trim ( adjustl ( solver )) // '-' // trim ( str (. true ., s )), & frequency = self % frequency , & solution = solution (:, 0 : last_step )) endif enddo else do t = 1 , size ( self % Dt ) call solve ( solver = solver , & frequency = self % frequency , & final_time = self % final_time , & stages_steps = s , & iterations = self % implicit_iterations , & solution = solution , & error = error (:, t ), & last_step = last_step , & Dt = self % Dt ( t )) if ( allocated ( solution )) then print \"(A,I10,A,F10.3,A,F10.3,A,E10.3,A,E10.3)\" , \"    steps: \" , last_step , & \"    Dt: \" , self % Dt ( t ), & \", f*Dt: \" , self % frequency * self % Dt ( t ), & \", E(x): \" , error ( 1 , t ), \", E(y): \" , error ( 2 , t ) if ( analyze_errors . and . t > 1 ) then order (:, t - 1 ) = observed_order ( error = error (:, t - 1 : t ), Dt = self % Dt ( t - 1 : t )) print \"(A,F10.2,A,F10.2)\" , \"      Observed order, O(x): \" , order ( 1 , t - 1 ), \", O(y): \" , order ( 2 , t - 1 ) endif call save_results ( results = self % results , & plots = self % plots , & output_cli = self % output_cli , & solver = trim ( adjustl ( solver )) // '-' // trim ( str (. true ., s )), & frequency = self % frequency , & solution = solution (:, 0 : last_step )) endif enddo endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test","tags":"","loc":"proc/test.html","title":"test – FOODIE"},{"text":"private subroutine solve(solver, frequency, final_time, stages_steps, iterations, solution, error, last_step, Dt, tolerance) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: solver Selected solver: must be defined into solvers . real(kind=R_P), intent(in) :: frequency Oscillation frequency. real(kind=R_P), intent(in) :: final_time Final integration time. integer(kind=I_P), intent(in) :: stages_steps Number of stages/steps used. integer(kind=I_P), intent(in) :: iterations Number of fixed point iterations. real(kind=R_P), intent(out), allocatable :: solution (:,:) Solution at each time step, X-Y. real(kind=R_P), intent(out) :: error (1:) Error (norm L2) with respect the exact solution. integer(kind=I_P), intent(out) :: last_step Last time step computed. real(kind=R_P), intent(in), optional :: Dt Time step. real(kind=R_P), intent(in), optional :: tolerance Local error tolerance. Description Rune the solver selected. The actual solver is selected by means of the solver input string that must be a valid string as defined into solvers parameter list. Calls proc~~solve~~CallsGraph proc~solve solve proc~error_l2 error_L2 proc~solve->proc~error_l2 str str proc~solve->str proc~exact_solution_xy exact_solution_xy proc~error_l2->proc~exact_solution_xy Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~solve~~CalledByGraph proc~solve solve proc~test test proc~test->proc~solve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( adams_bashforth_integrator ), public :: ab_integrator Adams-Bashforth integrator. type( adams_bashforth_moulton_integrator ), public :: abm_integrator Adams-Bashforth-Moulton integrator. type( adams_moulton_integrator ), public :: am_integrator Adams-Moulton integrator. type( back_df_integrator ), public :: bdf_integrator BDF integrator. type( emd_runge_kutta_integrator ), public :: emd_rk_integrator Runge-Kutta integrator. type( euler_explicit_integrator ), public :: euler_integrator Euler integrator. type( leapfrog_integrator ), public :: lf_integrator Leapfrog integrator. type( ls_runge_kutta_integrator ), public :: ls_rk_integrator Low Storage Runge-Kutta integrator. type( tvd_runge_kutta_integrator ), public :: tvd_rk_integrator TVD Runge-Kutta integrator. integer(kind=I_P), public, parameter :: max_rk_stages = 5 Max RK stages used to init high order multi-step solver. type( oscillation ), public :: oscillator Oscillation field. logical, public :: supported Flag for checking if the selected solver is supported. logical, public :: multistep Flag for tagging multi-step class of solvers. integer, public :: step_offset Time steps counter offset for slicing previous data array. logical, public :: adaptive Flag for tagging time step adaptive class of solvers. real(kind=R_P), public :: Dt_a Adaptive time step. type( oscillation ), public, allocatable :: rk_stage (:) Runge-Kutta stages. type( oscillation ), public, allocatable :: previous (:) Previous time steps solutions. type( oscillation ), public :: filter Filter displacement. integer, public :: step Time steps counter. Source Code subroutine solve ( solver , frequency , final_time , stages_steps , iterations , solution , error , last_step , Dt , tolerance ) !--------------------------------------------------------------------------------------------------------------------------------- !< Rune the solver selected. !< !< The actual solver is selected by means of the *solver* input string that must be a valid string as defined into *solvers* !< parameter list. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: solver !< Selected solver: must be defined into *solvers*. real ( R_P ), intent ( in ) :: frequency !< Oscillation frequency. real ( R_P ), intent ( in ) :: final_time !< Final integration time. integer ( I_P ), intent ( in ) :: stages_steps !< Number of stages/steps used. integer ( I_P ), intent ( in ) :: iterations !< Number of fixed point iterations. real ( R_P ), allocatable , intent ( out ) :: solution (:,:) !< Solution at each time step, X-Y. real ( R_P ), intent ( out ) :: error ( 1 :) !< Error (norm L2) with respect the exact solution. integer ( I_P ), intent ( out ) :: last_step !< Last time step computed. real ( R_P ), optional , intent ( in ) :: Dt !< Time step. real ( R_P ), optional , intent ( in ) :: tolerance !< Local error tolerance. ! FOODIE integrators type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. type ( adams_bashforth_moulton_integrator ) :: abm_integrator !< Adams-Bashforth-Moulton integrator. type ( adams_moulton_integrator ) :: am_integrator !< Adams-Moulton integrator. type ( back_df_integrator ) :: bdf_integrator !< BDF integrator. type ( emd_runge_kutta_integrator ) :: emd_rk_integrator !< Runge-Kutta integrator. type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( ls_runge_kutta_integrator ) :: ls_rk_integrator !< Low Storage Runge-Kutta integrator. type ( tvd_runge_kutta_integrator ) :: tvd_rk_integrator !< TVD Runge-Kutta integrator. ! Auxiliary variables integer ( I_P ), parameter :: max_rk_stages = 5 !< Max RK stages used to init high order multi-step solver. type ( oscillation ) :: oscillator !< Oscillation field. logical :: supported !< Flag for checking if the selected solver is supported. logical :: multistep !< Flag for tagging multi-step class of solvers. integer :: step_offset !< Time steps counter offset for slicing previous data array. logical :: adaptive !< Flag for tagging time step adaptive class of solvers. real ( R_P ) :: Dt_a !< Adaptive time step. type ( oscillation ), allocatable :: rk_stage (:) !< Runge-Kutta stages. type ( oscillation ), allocatable :: previous (:) !< Previous time steps solutions. type ( oscillation ) :: filter !< Filter displacement. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initizialize call oscillator % init ( initial_state = initial_state , frequency = frequency ) supported = . true . ! assume that selected solver is supported multistep = . false . ! assume multi-stage solver by default if ( stages_steps == 0 ) then step_offset = 1 ! for 0 step-(a convention)-solver offset is 1 else step_offset = stages_steps ! for >0 step-solver offset is steps endif adaptive = . false . ! assume fixed time step by default Dt_a = 1000 0._R_P ! initial step very large to trigger adaptation if ( present ( Dt )) then if ( allocated ( solution )) deallocate ( solution ) ; allocate ( solution ( 0 : space_dimension , 0 : int ( final_time / Dt ))) else if ( allocated ( solution )) deallocate ( solution ) ; allocate ( solution ( 0 : space_dimension , 0 : int ( final_time / 10 ))) ! hope is enough endif solution = 0.0_R_P solution ( 1 :, 0 ) = oscillator % output () select case ( trim ( adjustl ( solver ))) case ( \"adams-bashforth\" ) supported = ab_integrator % is_supported ( stages_steps ) multistep = . true . call ab_integrator % init ( steps = stages_steps ) if ( allocated ( previous )) deallocate ( previous ) ; allocate ( previous ( 1 : stages_steps )) case ( \"adams-bashforth-moulton\" ) supported = abm_integrator % is_supported ( stages_steps ) multistep = . true . call abm_integrator % init ( steps = stages_steps ) if ( allocated ( previous )) deallocate ( previous ) ; allocate ( previous ( 1 : stages_steps )) case ( \"adams-moulton\" ) supported = am_integrator % is_supported ( stages_steps ) multistep = . true . call am_integrator % init ( steps = stages_steps ) if ( allocated ( previous )) deallocate ( previous ) ; allocate ( previous ( 1 : stages_steps + 1 )) case ( \"backward-diff-formula\" ) supported = bdf_integrator % is_supported ( stages_steps ) multistep = . true . call bdf_integrator % init ( steps = stages_steps ) if ( allocated ( previous )) deallocate ( previous ) ; allocate ( previous ( 1 : stages_steps + 1 )) case ( \"emd-runge-kutta\" ) supported = emd_rk_integrator % is_supported ( stages_steps ) adaptive = . true . call emd_rk_integrator % init ( stages = stages_steps , tolerance = tolerance ) if ( allocated ( rk_stage )) deallocate ( rk_stage ) ; allocate ( rk_stage ( 1 : stages_steps )) case ( \"euler\" ) supported = euler_integrator % is_supported ( stages_steps ) case ( \"leapfrog\" ) supported = lf_integrator % is_supported ( stages_steps ) multistep = . true . call lf_integrator % init () if ( allocated ( previous )) deallocate ( previous ) ; allocate ( previous ( 1 : stages_steps )) case ( \"leapfrog-raw\" ) supported = lf_integrator % is_supported ( stages_steps ) multistep = . true . call lf_integrator % init () if ( allocated ( previous )) deallocate ( previous ) ; allocate ( previous ( 1 : stages_steps )) case ( \"ls-runge-kutta\" ) supported = ls_rk_integrator % is_supported ( stages_steps ) call ls_rk_integrator % init ( stages = stages_steps ) if ( allocated ( rk_stage )) deallocate ( rk_stage ) ; allocate ( rk_stage ( 1 : ls_rk_integrator % used_registers ())) case ( \"tvd-runge-kutta\" ) supported = tvd_rk_integrator % is_supported ( stages_steps ) call tvd_rk_integrator % init ( stages = stages_steps ) if ( allocated ( rk_stage )) deallocate ( rk_stage ) ; allocate ( rk_stage ( 1 : stages_steps )) endselect if ( multistep ) then call tvd_rk_integrator % init ( stages = max_rk_stages ) if ( allocated ( rk_stage )) deallocate ( rk_stage ) ; allocate ( rk_stage ( 1 : max_rk_stages )) endif if (. not . supported ) then print \"(A)\" , 'The solver ' // trim ( adjustl ( solver )) // ' does not support ' // trim ( str (. true ., stages_steps )) // ' stages/steps' if ( allocated ( solution )) deallocate ( solution ) return endif ! integrate step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 ! advance oscillator if ( multistep ) then if ( stages_steps >= step ) then call tvd_rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) previous ( step ) = oscillator else select case ( trim ( adjustl ( solver ))) case ( \"adams-bashforth\" ) call ab_integrator % integrate ( U = oscillator , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 )) case ( \"adams-bashforth-moulton\" ) call abm_integrator % integrate ( U = oscillator , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 )) case ( \"adams-moulton\" ) if ( iterations > 1 ) then call am_integrator % integrate ( U = oscillator , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 ), & iterations = iterations ) else call am_integrator % integrate ( U = oscillator , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 )) endif case ( \"backward-diff-formula\" ) if ( iterations > 1 ) then call bdf_integrator % integrate ( U = oscillator , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 ), & iterations = iterations ) else call bdf_integrator % integrate ( U = oscillator , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 )) endif case ( \"leapfrog\" ) call lf_integrator % integrate ( U = oscillator , & previous = previous , & Dt = Dt , & t = solution ( 0 , step )) case ( \"leapfrog-raw\" ) call lf_integrator % integrate ( U = oscillator , & previous = previous , & Dt = Dt , & t = solution ( 0 , step ), & filter = filter ) endselect endif else select case ( trim ( adjustl ( solver ))) case ( \"emd-runge-kutta\" ) call emd_rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt_a , t = solution ( 0 , step )) case ( \"euler\" ) call euler_integrator % integrate ( U = oscillator , Dt = Dt , t = solution ( 0 , step )) case ( \"ls-runge-kutta\" ) call ls_rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) case ( \"tvd-runge-kutta\" ) call tvd_rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) endselect endif ! update time if ( adaptive ) then solution ( 0 , step ) = solution ( 0 , step - 1 ) + Dt_a else solution ( 0 , step ) = step * Dt endif ! store step solution solution ( 1 :, step ) = oscillator % output () enddo last_step = step error = error_L2 ( frequency = frequency , solution = solution (:, 0 : last_step )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine solve","tags":"","loc":"proc/solve.html","title":"solve – FOODIE"},{"text":"private subroutine save_results(results, plots, output_cli, solver, frequency, solution) Arguments Type Intent Optional Attributes Name logical, intent(in) :: results Flag for activating results saving. logical, intent(in) :: plots Flag for activating plots saving. character(len=*), intent(in) :: output_cli Output files basename coming from CLI. character(len=*), intent(in) :: solver Selected solver: must be defined into solvers . real(kind=R_P), intent(in) :: frequency Oscillation frequency. real(kind=R_P), intent(in) :: solution (0:,0:) Solution at each time step. Description Save results (and plots). Calls proc~~save_results~~CallsGraph proc~save_results save_results proc~exact_solution_xy exact_solution_xy proc~save_results->proc~exact_solution_xy strz strz proc~save_results->strz none~amplitude_phase amplitude_phase proc~save_results->none~amplitude_phase Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_results~~CalledByGraph proc~save_results save_results proc~test test proc~test->proc~save_results Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: title Output files title. character(len=:), public, allocatable :: basename Output files basename. integer(kind=I_P), public :: rawfile Raw file unit for saving results. real(kind=R_P), public :: ex_sol (1:space_dimension) Exact solution. type( pyplot ), public :: plt Plot file handler. integer(kind=I_P), public :: s Counter. Functions function amplitude_phase(sol) result(ap) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: sol (1:) Solution in X-Y domain. Return Value real(kind=R_P)\n  (1:2) Amplitude and phase solution. Description Compute amplitude and phase of the solution provided in X-Y domain. Source Code subroutine save_results ( results , plots , output_cli , solver , frequency , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results (and plots). !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: results !< Flag for activating results saving. logical , intent ( in ) :: plots !< Flag for activating plots saving. character ( * ), intent ( in ) :: output_cli !< Output files basename coming from CLI. character ( * ), intent ( in ) :: solver !< Selected solver: must be defined into *solvers*. real ( R_P ), intent ( in ) :: frequency !< Oscillation frequency. real ( R_P ), intent ( IN ) :: solution ( 0 :, 0 :) !< Solution at each time step. character ( len = :), allocatable :: title !< Output files title. character ( len = :), allocatable :: basename !< Output files basename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. real ( R_P ) :: ex_sol ( 1 : space_dimension ) !< Exact solution. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- title = 'Oscillation equations integration, solver=' // trim ( adjustl ( solver )) if ( trim ( adjustl ( output_cli )) /= 'unset' ) then basename = trim ( adjustl ( output_cli )) // '-' // trim ( strz ( 10 , ubound ( solution , dim = 2 ))) // '-time_steps-' // trim ( adjustl ( solver )) else basename = 'oscillation_test-' // trim ( strz ( 10 , ubound ( solution , dim = 2 ))) // '-time_steps-' // trim ( adjustl ( solver )) endif if ( results ) then open ( newunit = rawfile , file = basename // '.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) 'VARIABLES=\"t\" \"x\" \"y\" \"amplitude\" \"phase\"' write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE time serie\"' do s = 0 , ubound ( solution , dim = 2 ) write ( rawfile , '(5(' // FR_P // ',1X))' ) solution (:, s ), amplitude_phase ( solution ( 1 : 2 , s )) enddo write ( rawfile , '(A)' ) 'ZONE T=\"Exact solution\"' do s = 0 , ubound ( solution , dim = 2 ) ex_sol = exact_solution_xy ( frequency = frequency , t = solution ( 0 , s )) write ( rawfile , '(5(' // FR_P // ',1X))' ) solution ( 0 , s ), ex_sol , amplitude_phase ( ex_sol ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'v' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( basename // '.png' ) call plt % initialize ( grid = . true ., xlabel = 'v1' , ylabel = 'v2' , title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'path' , linestyle = 'r-' , linewidth = 1 ) call plt % savefig ( 'path-' // basename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- contains function amplitude_phase ( sol ) result ( ap ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute amplitude and phase of the solution provided in X-Y domain. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: sol ( 1 :) !< Solution in X-Y domain. real ( R_P ) :: ap ( 1 : 2 ) !< Amplitude and phase solution. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- ap ( 1 ) = sqrt ( sol ( 1 ) ** 2 + sol ( 2 ) ** 2 ) ap ( 2 ) = atan ( - sol ( 1 ) / sol ( 2 )) return !------------------------------------------------------------------------------------------------------------------------------- endfunction amplitude_phase endsubroutine save_results","tags":"","loc":"proc/save_results.html","title":"save_results – FOODIE"},{"text":"private pure function output(self) result(state) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. Return Value real(kind=R_P),\n  dimension(:),allocatable Oscillation state vector. Description Output the Oscillation field state. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Oscillation field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. real ( R_P ), dimension (:), allocatable :: state !< Oscillation state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output.html","title":"output – FOODIE"},{"text":"private pure function dOscillation_dt(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Oscillation field time derivative. Description Time derivative of Oscillation field. Source Code pure function dOscillation_dt ( self , t ) result ( dState_dt ) #else function dOscillation_dt ( self , t ) result ( dState_dt ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Oscillation field time derivative. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: dState_dt ) select type ( dState_dt ) class is ( oscillation ) dState_dt = self dState_dt % U ( 1 ) = - self % f * self % U ( 2 ) dState_dt % U ( 2 ) = self % f * self % U ( 1 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dOscillation_dt","tags":"","loc":"proc/doscillation_dt.html","title":"dOscillation_dt – FOODIE"},{"text":"private pure function oscillation_local_error(lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 oscillation approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code pure function oscillation_local_error ( lhs , rhs ) result ( error ) #else function oscillation_local_error ( lhs , rhs ) result ( error ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 oscillation approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( oscillation ) error = 0._R_P do i = 1 , lhs % dims error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_local_error","tags":"","loc":"proc/oscillation_local_error.html","title":"oscillation_local_error – FOODIE"},{"text":"private pure function oscillation_multiply_oscillation(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a oscillation field by another one. Source Code pure function oscillation_multiply_oscillation ( lhs , rhs ) result ( opr ) #else function oscillation_multiply_oscillation ( lhs , rhs ) result ( opr ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a oscillation field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_multiply_oscillation","tags":"","loc":"proc/oscillation_multiply_oscillation.html","title":"oscillation_multiply_oscillation – FOODIE"},{"text":"private pure function oscillation_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Oscillation field by a real scalar. Source Code pure function oscillation_multiply_real ( lhs , rhs ) result ( opr ) #else function oscillation_multiply_real ( lhs , rhs ) result ( opr ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Oscillation field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_multiply_real","tags":"","loc":"proc/oscillation_multiply_real.html","title":"oscillation_multiply_real – FOODIE"},{"text":"private pure function real_multiply_oscillation(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( oscillation ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Oscillation field. Source Code pure function real_multiply_oscillation ( lhs , rhs ) result ( opr ) #else function real_multiply_oscillation ( lhs , rhs ) result ( opr ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( oscillation ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_oscillation","tags":"","loc":"proc/real_multiply_oscillation.html","title":"real_multiply_oscillation – FOODIE"},{"text":"private pure function add_oscillation(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Oscillation fields. Source Code pure function add_oscillation ( lhs , rhs ) result ( opr ) #else function add_oscillation ( lhs , rhs ) result ( opr ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Oscillation fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Oscillation","tags":"","loc":"proc/add_oscillation.html","title":"add_oscillation – FOODIE"},{"text":"private pure function sub_oscillation(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Oscillation fields. Source Code pure function sub_oscillation ( lhs , rhs ) result ( opr ) #else function sub_oscillation ( lhs , rhs ) result ( opr ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Oscillation fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_Oscillation","tags":"","loc":"proc/sub_oscillation.html","title":"sub_oscillation – FOODIE"},{"text":"private pure subroutine init(self, initial_state, frequency) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of the Oscillation field vector. real(kind=R_P), intent(in) :: frequency Frequency of oscillation. Description Construct an initialized Oscillation field. Source Code pure subroutine init ( self , initial_state , frequency ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: self !< Oscillation field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Initial state of the Oscillation field vector. real ( R_P ), intent ( IN ) :: frequency !< Frequency of oscillation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % f = frequency if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % dims )) ; self % U = initial_state return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~10.html","title":"init – FOODIE"},{"text":"private pure subroutine oscillation_assign_oscillation(lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Oscillation field to another. Source Code pure subroutine oscillation_assign_oscillation ( lhs , rhs ) #else subroutine oscillation_assign_oscillation ( lhs , rhs ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Oscillation field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( oscillation ) lhs % dims = rhs % dims lhs % f = rhs % f if ( allocated ( rhs % U )) lhs % U = rhs % U endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine oscillation_assign_oscillation","tags":"","loc":"proc/oscillation_assign_oscillation.html","title":"oscillation_assign_oscillation – FOODIE"},{"text":"subroutine init() Arguments None Description Initialize the simulation. Calls proc~~init~11~~CallsGraph proc~init~11 init strz strz proc~init~11->strz str str proc~init~11->str proc~save_time_serie save_time_serie proc~init~11->proc~save_time_serie proc~save_time_serie->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~init~11~~CalledByGraph proc~init~11 init program~integrate_euler_1d_caf integrate_euler_1D_caf program~integrate_euler_1d_caf->proc~init~11 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. real(kind=R_P), public :: x_L Left abscissa of local image. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~11.html","title":"init – FOODIE"},{"text":"subroutine synchronize() Arguments None Description Synchronize CAF images. Called By proc~~synchronize~~CalledByGraph proc~synchronize synchronize program~integrate_euler_1d_caf integrate_euler_1D_caf program~integrate_euler_1d_caf->proc~synchronize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Images counter. Source Code subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize","tags":"","loc":"proc/synchronize.html","title":"synchronize – FOODIE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. Calls proc~~save_results~2~~CallsGraph proc~save_results~2 save_results str str proc~save_results~2->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_results~2~~CalledByGraph proc~save_results~2 save_results program~integrate_euler_1d_caf integrate_euler_1D_caf program~integrate_euler_1d_caf->proc~save_results~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type( pyplot ), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~2.html","title":"save_results – FOODIE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Calls proc~~save_time_serie~~CallsGraph proc~save_time_serie save_time_serie str str proc~save_time_serie->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~~CalledByGraph proc~save_time_serie save_time_serie proc~init~11 init proc~init~11->proc~save_time_serie program~integrate_euler_1d_caf integrate_euler_1D_caf program~integrate_euler_1d_caf->proc~save_time_serie program~integrate_euler_1d_caf->proc~init~11 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public, save :: tsfile File unit for saving time serie results. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie.html","title":"save_time_serie – FOODIE"},{"text":"private pure function output(self, conservative) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. logical, intent(in), optional :: conservative Output conservative variables instead of primitive. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code pure function output ( self , conservative ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. logical , optional , intent ( IN ) :: conservative !< Output conservative variables instead of primitive. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( conservative )) then state = self % U else allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~2.html","title":"output – FOODIE"},{"text":"private pure function compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. Calls proc~~compute_dt~~CallsGraph proc~compute_dt compute_dt proc~a a proc~compute_dt->proc~a Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: P (:) Primitive variables. real(kind=R_P), public :: vmax Maximum propagation speed of signals. integer(kind=I_P), public :: i Counter. Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt.html","title":"compute_dt – FOODIE"},{"text":"private function dEuler_dt(self) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. Return Value type( euler_1D_caf_nf ) Euler field time derivative. Description Time derivative of Euler field, the residuals function. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: F (:,:) Fluxes of conservative variables. real(kind=R_P), public, allocatable :: P (:,:) Primitive variables. real(kind=R_P), public, allocatable :: PR (:,:,:) Left (1) and right (2) (reconstructed) interface values of primitive variables. integer(kind=I_P), public :: i Counter. Source Code function dEuler_dt ( self ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. type ( euler_1D_caf_nf ) :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals dState_dt = self do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt.html","title":"dEuler_dt – FOODIE"},{"text":"private pure function primitive2conservative(self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative.html","title":"primitive2conservative – FOODIE"},{"text":"private pure function conservative2primitive(self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: c (:) Species concentration. Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive.html","title":"conservative2primitive – FOODIE"},{"text":"private elemental function p(r, a, g) result(pressure) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Description Compute the pressure for an ideal calorically perfect gas. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p.html","title":"p – FOODIE"},{"text":"private elemental function r(p, a, g) result(density) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Description Compute the density for an ideal calorically perfect gas. Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r.html","title":"r – FOODIE"},{"text":"private elemental function a(p, r, g) result(ss) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Description Compute the speed of sound for an ideal calorically perfect gas. Called By proc~~a~~CalledByGraph proc~a a proc~compute_dt compute_dt proc~compute_dt->proc~a none~eigen_vect_r eigen_vect_R none~eigen_vect_r->proc~a none~eigen_vect_l eigen_vect_L none~eigen_vect_l->proc~a proc~reconstruct_interfaces_states reconstruct_interfaces_states proc~reconstruct_interfaces_states->none~eigen_vect_r proc~reconstruct_interfaces_states->none~eigen_vect_l Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a.html","title":"a – FOODIE"},{"text":"private elemental function E(p, r, u, g) result(energy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Description Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~e~~CalledByGraph proc~e E proc~riemann_solver riemann_solver proc~riemann_solver->proc~e Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e.html","title":"E – FOODIE"},{"text":"private elemental function H(p, r, u, g) result(entalpy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Description Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~h~~CalledByGraph proc~h H none~fluxes fluxes none~fluxes->proc~h proc~riemann_solver riemann_solver proc~riemann_solver->none~fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h.html","title":"H – FOODIE"},{"text":"private elemental subroutine init_rk(self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. Source Code elemental subroutine init_rk ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init_rk","tags":"","loc":"proc/init_rk.html","title":"init_rk – FOODIE"},{"text":"private elemental subroutine destroy_rk(self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destoy the integrator. Source Code elemental subroutine destroy_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy_rk","tags":"","loc":"proc/destroy_rk.html","title":"destroy_rk – FOODIE"},{"text":"private subroutine integrate_rk(self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( euler_1D_caf_nf ), intent(inout) :: U Field to be integrated. class( euler_1D_caf_nf ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coeficients are initialized). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s First stages counter. integer(kind=I_P), public :: ss Second stages counter. Source Code subroutine integrate_rk ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( euler_1D_caf_nf ), intent ( INOUT ) :: U !< Field to be integrated. class ( euler_1D_caf_nf ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s )% U = stage ( s )% U + stage ( ss )% U * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t () enddo ! computing new time step do s = 1 , self % stages U % U = U % U + stage ( s )% U * ( Dt * self % beta ( s )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate_rk","tags":"","loc":"proc/integrate_rk.html","title":"integrate_rk – FOODIE"},{"text":"private elemental subroutine finalize_rk(self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Source Code elemental subroutine finalize_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_rk","tags":"","loc":"proc/finalize_rk.html","title":"finalize_rk – FOODIE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, me, we, ord) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension (local image). integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in) :: me ID of this_image(). integer(kind=I_P), intent(in) :: we Number of CAF images used. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. Calls proc~~init~12~~CallsGraph proc~init~12 init interface~weno_constructor_upwind weno_constructor_upwind proc~init~12->interface~weno_constructor_upwind proc~weno_constructor_upwind_init weno_constructor_upwind_init interface~weno_constructor_upwind->proc~weno_constructor_upwind_init Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( weno_factory ), public :: factory WENO factory. class( weno_interpolator ), public, allocatable :: weno WENO interpolator. integer(kind=I_P), public :: i Space counter. Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , me , we , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension (local image). integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), intent ( IN ) :: me !< ID of this_image(). integer ( I_P ), intent ( IN ) :: we !< Number of CAF images used. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo self % me = me self % we = we #ifdef CAF if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )[ * ]) #else if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )) #endif if ( allocated ( U_L )) deallocate ( U_L ) ; allocate ( U_L ( 1 : self % Nc , 1 : self % Ni )) if ( allocated ( U_R )) deallocate ( U_R ) ; allocate ( U_R ( 1 : self % Nc , 1 : self % Ni )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~12.html","title":"init – FOODIE"},{"text":"private subroutine destroy(self) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) self % me = 0 self % we = 0 if ( allocated ( remote_U )) deallocate ( remote_U ) if ( allocated ( U_L )) deallocate ( U_L ) if ( allocated ( U_R )) deallocate ( U_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~8.html","title":"destroy – FOODIE"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_caf_nf ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: lhs !< Left hand side. class ( euler_1D_caf_nf ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf_nf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R lhs % me = rhs % me lhs % we = rhs % we endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler.html","title":"euler_assign_euler – FOODIE"},{"text":"private subroutine synchronize(self) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. Description Synchronize CAF images. Calls proc~~synchronize~2~~CallsGraph proc~synchronize~2 synchronize images images proc~synchronize~2->images Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Images counter. Source Code subroutine synchronize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( self % we > 1 ) then remote_U = self % U if ( self % me == 1 ) then sync images ( self % me + 1 ) U_R (:,:) = remote_U (:,:)[ self % me + 1 ] else if ( self % me == self % we ) then sync images ( self % me - 1 ) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] else sync images ([ self % me - 1 , self % me + 1 ]) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] U_R (:,:) = remote_U (:,:)[ self % me + 1 ] endif endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize","tags":"","loc":"proc/synchronize~2.html","title":"synchronize – FOODIE"},{"text":"private subroutine impose_boundary_conditions(self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. character(len=:), public, allocatable :: bc_type String containing BC type. Source Code subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. character ( len = :), allocatable :: bc_type !< String containing BC type. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- call self % synchronize bc_type = trim ( adjustl ( self % BC_L )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = 1 - self % Ng , 0 primitive (:, i ) = self % conservative2primitive ( U_L (:, self % Ni + i )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect endif bc_type = trim ( adjustl ( self % BC_R )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = self % conservative2primitive ( U_R (:, i - self % Ni )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect endif return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions.html","title":"impose_boundary_conditions – FOODIE"},{"text":"private subroutine reconstruct_interfaces_states(self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Calls proc~~reconstruct_interfaces_states~~CallsGraph proc~reconstruct_interfaces_states reconstruct_interfaces_states none~eigen_vect_l eigen_vect_L proc~reconstruct_interfaces_states->none~eigen_vect_l none~eigen_vect_r eigen_vect_R proc~reconstruct_interfaces_states->none~eigen_vect_r proc~a a none~eigen_vect_l->proc~a none~eigen_vect_r->proc~a Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: C (1:2,1-self%Ng:-1+self%Ng,1:self%Ns+2) Pseudo characteristic variables. real(kind=R_P), public :: CR (1:self%Ns+2,1:2) Pseudo characteristic reconst. vars. real(kind=R_P), public :: Pm (1:self%Np,1:2) Mean of primitive variables. real(kind=R_P), public :: LPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean left eigenvectors matrix. real(kind=R_P), public :: RPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean right eigenvectors matrix. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: j Counter. integer(kind=I_P), public :: f Counter. integer(kind=I_P), public :: v Counter. Functions pure function eigen_vect_L(Ns, Np, primitive) result(L) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Left eigenvectors matrix. Description Compute left eigenvectors from primitive variables. pure function eigen_vect_R(Ns, Np, primitive) result(R) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Right eigenvectors matrix. Description Compute right eigenvectors from primitive variables. Source Code subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states.html","title":"reconstruct_interfaces_states – FOODIE"},{"text":"private pure subroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Calls proc~~riemann_solver~~CallsGraph proc~riemann_solver riemann_solver proc~compute_inter_states compute_inter_states proc~riemann_solver->proc~compute_inter_states proc~e E proc~riemann_solver->proc~e none~fluxes fluxes proc~riemann_solver->none~fluxes proc~h H none~fluxes->proc~h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: F1 (1:3) State 1 fluxes. real(kind=R_P), public :: F4 (1:3) State 4 fluxes. real(kind=R_P), public :: u Velocity of the intermediate states. real(kind=R_P), public :: p Pressure of the intermediate states. real(kind=R_P), public :: S1 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: S4 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: lmax Maximum wave speed estimation. Functions pure function fluxes(p, r, u, g) result(Fc) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Velocity. real(kind=R_P), intent(in) :: g Specific heats ratio. Return Value real(kind=R_P)\n  (1:3) State fluxes. Description 1D Euler fluxes from primitive variables. Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver.html","title":"riemann_solver – FOODIE"},{"text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( euler_1D_caf_nf ), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~8.html","title":"finalize – FOODIE"},{"text":"private pure subroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Description Compute inter states (23*-states) from state1 and state4. Called By proc~~compute_inter_states~~CalledByGraph proc~compute_inter_states compute_inter_states proc~riemann_solver riemann_solver proc~riemann_solver->proc~compute_inter_states Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: a1 Speed of sound of state 1. real(kind=R_P), public :: a4 Speed of sound of state 4. real(kind=R_P), public :: ram Mean value of rho*a. real(kind=R_P), public, parameter :: toll = 1e-10_R_P Tollerance. Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states.html","title":"compute_inter_states – FOODIE"},{"text":"subroutine init() Arguments None Description Initialize the simulation. Calls proc~~init~13~~CallsGraph proc~init~13 init strz strz proc~init~13->strz str str proc~init~13->str proc~save_time_serie~2 save_time_serie proc~init~13->proc~save_time_serie~2 proc~save_time_serie~2->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~init~13~~CalledByGraph proc~init~13 init program~integrate_euler_1d_caf~2 integrate_euler_1D_caf program~integrate_euler_1d_caf~2->proc~init~13 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. real(kind=R_P), public :: x_L Left abscissa of local image. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~13.html","title":"init – FOODIE"},{"text":"subroutine synchronize() Arguments None Description Synchronize CAF images. Called By proc~~synchronize~3~~CalledByGraph proc~synchronize~3 synchronize program~integrate_euler_1d_caf~2 integrate_euler_1D_caf program~integrate_euler_1d_caf~2->proc~synchronize~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Images counter. Source Code subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize","tags":"","loc":"proc/synchronize~3.html","title":"synchronize – FOODIE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. Calls proc~~save_results~3~~CallsGraph proc~save_results~3 save_results str str proc~save_results~3->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_results~3~~CalledByGraph proc~save_results~3 save_results program~integrate_euler_1d_caf~2 integrate_euler_1D_caf program~integrate_euler_1d_caf~2->proc~save_results~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type( pyplot ), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~3.html","title":"save_results – FOODIE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Calls proc~~save_time_serie~2~~CallsGraph proc~save_time_serie~2 save_time_serie str str proc~save_time_serie~2->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~2~~CalledByGraph proc~save_time_serie~2 save_time_serie proc~init~13 init proc~init~13->proc~save_time_serie~2 program~integrate_euler_1d_caf~2 integrate_euler_1D_caf program~integrate_euler_1d_caf~2->proc~save_time_serie~2 program~integrate_euler_1d_caf~2->proc~init~13 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public, save :: tsfile File unit for saving time serie results. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie~2.html","title":"save_time_serie – FOODIE"},{"text":"private pure function output(self, conservative) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. logical, intent(in), optional :: conservative Output conservative variables instead of primitive. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code pure function output ( self , conservative ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. logical , optional , intent ( IN ) :: conservative !< Output conservative variables instead of primitive. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( conservative )) then state = self % U else allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~3.html","title":"output – FOODIE"},{"text":"private pure function compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. Calls proc~~compute_dt~2~~CallsGraph proc~compute_dt~2 compute_dt proc~a~2 a proc~compute_dt~2->proc~a~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: P (:) Primitive variables. real(kind=R_P), public :: vmax Maximum propagation speed of signals. integer(kind=I_P), public :: i Counter. Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~2.html","title":"compute_dt – FOODIE"},{"text":"private function dEuler_dt(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: F (:,:) Fluxes of conservative variables. real(kind=R_P), public, allocatable :: P (:,:) Primitive variables. real(kind=R_P), public, allocatable :: PR (:,:,:) Left (1) and right (2) (reconstructed) interface values of primitive variables. integer(kind=I_P), public :: i Counter. Source Code function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D_caf :: dState_dt ) select type ( dState_dt ) class is ( euler_1D_caf ) dState_dt = self endselect select type ( dState_dt ) class is ( euler_1D_caf ) do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt~2.html","title":"dEuler_dt – FOODIE"},{"text":"private function euler_local_error(lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 euler approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. integer(kind=I_P), public :: v Variables counter. Source Code function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf ) error = 0._R_P do i = 1 , lhs % Ni do v = 1 , lhs % Nc error = error + ( lhs % U ( v , i ) - rhs % U ( v , i )) ** 2 / lhs % U ( v , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error","tags":"","loc":"proc/euler_local_error.html","title":"euler_local_error – FOODIE"},{"text":"private function euler_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. Source Code function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler","tags":"","loc":"proc/euler_multiply_euler.html","title":"euler_multiply_euler – FOODIE"},{"text":"private function euler_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. Source Code function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real","tags":"","loc":"proc/euler_multiply_real.html","title":"euler_multiply_real – FOODIE"},{"text":"private function real_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D_caf ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. Source Code function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D_caf ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = rhs endselect select type ( opr ) class is ( euler_1D_caf ) opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler","tags":"","loc":"proc/real_multiply_euler.html","title":"real_multiply_euler – FOODIE"},{"text":"private function add_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. Source Code function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler","tags":"","loc":"proc/add_euler.html","title":"add_euler – FOODIE"},{"text":"private function sub_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. Source Code function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler","tags":"","loc":"proc/sub_euler.html","title":"sub_euler – FOODIE"},{"text":"private pure function primitive2conservative(self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative~2.html","title":"primitive2conservative – FOODIE"},{"text":"private pure function conservative2primitive(self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: c (:) Species concentration. Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive~2.html","title":"conservative2primitive – FOODIE"},{"text":"private elemental function p(r, a, g) result(pressure) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Description Compute the pressure for an ideal calorically perfect gas. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p~2.html","title":"p – FOODIE"},{"text":"private elemental function r(p, a, g) result(density) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Description Compute the density for an ideal calorically perfect gas. Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r~2.html","title":"r – FOODIE"},{"text":"private elemental function a(p, r, g) result(ss) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Description Compute the speed of sound for an ideal calorically perfect gas. Called By proc~~a~2~~CalledByGraph proc~a~2 a proc~compute_dt~2 compute_dt proc~compute_dt~2->proc~a~2 none~eigen_vect_r~2 eigen_vect_R none~eigen_vect_r~2->proc~a~2 none~eigen_vect_l~2 eigen_vect_L none~eigen_vect_l~2->proc~a~2 proc~reconstruct_interfaces_states~2 reconstruct_interfaces_states proc~reconstruct_interfaces_states~2->none~eigen_vect_r~2 proc~reconstruct_interfaces_states~2->none~eigen_vect_l~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a~2.html","title":"a – FOODIE"},{"text":"private elemental function E(p, r, u, g) result(energy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Description Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~e~2~~CalledByGraph proc~e~2 E proc~riemann_solver~2 riemann_solver proc~riemann_solver~2->proc~e~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e~2.html","title":"E – FOODIE"},{"text":"private elemental function H(p, r, u, g) result(entalpy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Description Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~h~2~~CalledByGraph proc~h~2 H none~fluxes~2 fluxes none~fluxes~2->proc~h~2 proc~riemann_solver~2 riemann_solver proc~riemann_solver~2->none~fluxes~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h~2.html","title":"H – FOODIE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, me, we, ord) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension (local image). integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in) :: me ID of this_image(). integer(kind=I_P), intent(in) :: we Number of CAF images used. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. Calls proc~~init~14~~CallsGraph proc~init~14 init interface~weno_constructor_upwind weno_constructor_upwind proc~init~14->interface~weno_constructor_upwind proc~weno_constructor_upwind_init weno_constructor_upwind_init interface~weno_constructor_upwind->proc~weno_constructor_upwind_init Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( weno_factory ), public :: factory WENO factory. class( weno_interpolator ), public, allocatable :: weno WENO interpolator. integer(kind=I_P), public :: i Space counter. Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , me , we , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension (local image). integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), intent ( IN ) :: me !< ID of this_image(). integer ( I_P ), intent ( IN ) :: we !< Number of CAF images used. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo self % me = me self % we = we #ifdef CAF if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )[ * ]) #else if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )) #endif if ( allocated ( U_L )) deallocate ( U_L ) ; allocate ( U_L ( 1 : self % Nc , 1 : self % Ni )) if ( allocated ( U_R )) deallocate ( U_R ) ; allocate ( U_R ( 1 : self % Nc , 1 : self % Ni )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~14.html","title":"init – FOODIE"},{"text":"private subroutine destroy(self) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) self % me = 0 self % we = 0 if ( allocated ( remote_U )) deallocate ( remote_U ) if ( allocated ( U_L )) deallocate ( U_L ) if ( allocated ( U_R )) deallocate ( U_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~9.html","title":"destroy – FOODIE"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R lhs % me = rhs % me lhs % we = rhs % we endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler~2.html","title":"euler_assign_euler – FOODIE"},{"text":"private subroutine euler_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. Source Code subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real","tags":"","loc":"proc/euler_assign_real.html","title":"euler_assign_real – FOODIE"},{"text":"private subroutine synchronize(self) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. Description Synchronize CAF images. Calls proc~~synchronize~4~~CallsGraph proc~synchronize~4 synchronize images images proc~synchronize~4->images Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Images counter. Source Code subroutine synchronize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( self % we > 1 ) then remote_U = self % U if ( self % me == 1 ) then sync images ( self % me + 1 ) U_R (:,:) = remote_U (:,:)[ self % me + 1 ] else if ( self % me == self % we ) then sync images ( self % me - 1 ) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] else sync images ([ self % me - 1 , self % me + 1 ]) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] U_R (:,:) = remote_U (:,:)[ self % me + 1 ] endif endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize","tags":"","loc":"proc/synchronize~4.html","title":"synchronize – FOODIE"},{"text":"private subroutine impose_boundary_conditions(self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. character(len=:), public, allocatable :: bc_type String containing BC type. Source Code subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. character ( len = :), allocatable :: bc_type !< String containing BC type. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- call self % synchronize bc_type = trim ( adjustl ( self % BC_L )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = 1 - self % Ng , 0 primitive (:, i ) = self % conservative2primitive ( U_L (:, self % Ni + i )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect endif bc_type = trim ( adjustl ( self % BC_R )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = self % conservative2primitive ( U_R (:, i - self % Ni )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect endif return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions~2.html","title":"impose_boundary_conditions – FOODIE"},{"text":"private subroutine reconstruct_interfaces_states(self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Calls proc~~reconstruct_interfaces_states~2~~CallsGraph proc~reconstruct_interfaces_states~2 reconstruct_interfaces_states none~eigen_vect_l~2 eigen_vect_L proc~reconstruct_interfaces_states~2->none~eigen_vect_l~2 none~eigen_vect_r~2 eigen_vect_R proc~reconstruct_interfaces_states~2->none~eigen_vect_r~2 proc~a~2 a none~eigen_vect_l~2->proc~a~2 none~eigen_vect_r~2->proc~a~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: C (1:2,1-self%Ng:-1+self%Ng,1:self%Ns+2) Pseudo characteristic variables. real(kind=R_P), public :: CR (1:self%Ns+2,1:2) Pseudo characteristic reconst. vars. real(kind=R_P), public :: Pm (1:self%Np,1:2) Mean of primitive variables. real(kind=R_P), public :: LPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean left eigenvectors matrix. real(kind=R_P), public :: RPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean right eigenvectors matrix. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: j Counter. integer(kind=I_P), public :: f Counter. integer(kind=I_P), public :: v Counter. Functions pure function eigen_vect_L(Ns, Np, primitive) result(L) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Left eigenvectors matrix. Description Compute left eigenvectors from primitive variables. pure function eigen_vect_R(Ns, Np, primitive) result(R) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Right eigenvectors matrix. Description Compute right eigenvectors from primitive variables. Source Code subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states~2.html","title":"reconstruct_interfaces_states – FOODIE"},{"text":"private pure subroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Calls proc~~riemann_solver~2~~CallsGraph proc~riemann_solver~2 riemann_solver proc~compute_inter_states~2 compute_inter_states proc~riemann_solver~2->proc~compute_inter_states~2 none~fluxes~2 fluxes proc~riemann_solver~2->none~fluxes~2 proc~e~2 E proc~riemann_solver~2->proc~e~2 proc~h~2 H none~fluxes~2->proc~h~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: F1 (1:3) State 1 fluxes. real(kind=R_P), public :: F4 (1:3) State 4 fluxes. real(kind=R_P), public :: u Velocity of the intermediate states. real(kind=R_P), public :: p Pressure of the intermediate states. real(kind=R_P), public :: S1 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: S4 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: lmax Maximum wave speed estimation. Functions pure function fluxes(p, r, u, g) result(Fc) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Velocity. real(kind=R_P), intent(in) :: g Specific heats ratio. Return Value real(kind=R_P)\n  (1:3) State fluxes. Description 1D Euler fluxes from primitive variables. Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver~2.html","title":"riemann_solver – FOODIE"},{"text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( euler_1D_caf ), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~9.html","title":"finalize – FOODIE"},{"text":"private pure subroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Description Compute inter states (23*-states) from state1 and state4. Called By proc~~compute_inter_states~2~~CalledByGraph proc~compute_inter_states~2 compute_inter_states proc~riemann_solver~2 riemann_solver proc~riemann_solver~2->proc~compute_inter_states~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: a1 Speed of sound of state 1. real(kind=R_P), public :: a4 Speed of sound of state 4. real(kind=R_P), public :: ram Mean value of rho*a. real(kind=R_P), public, parameter :: toll = 1e-10_R_P Tollerance. Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states~2.html","title":"compute_inter_states – FOODIE"},{"text":"subroutine init() Arguments None Description Initialize the field. Called By proc~~init~15~~CalledByGraph proc~init~15 init program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie program~integrate_euler_1d_openmp_no_foodie->proc~init~15 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~15.html","title":"init – FOODIE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. Calls proc~~save_results~4~~CallsGraph proc~save_results~4 save_results str str proc~save_results~4->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_results~4~~CalledByGraph proc~save_results~4 save_results program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie program~integrate_euler_1d_openmp_no_foodie->proc~save_results~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type( pyplot ), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~4.html","title":"save_results – FOODIE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Calls proc~~save_time_serie~3~~CallsGraph proc~save_time_serie~3 save_time_serie str str proc~save_time_serie~3->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~3~~CalledByGraph proc~save_time_serie~3 save_time_serie program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie program~integrate_euler_1d_openmp_no_foodie->proc~save_time_serie~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public, save :: tsfile File unit for saving time serie results. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie~3.html","title":"save_time_serie – FOODIE"},{"text":"private pure function output(self) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~4.html","title":"output – FOODIE"},{"text":"private pure function compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. Calls proc~~compute_dt~3~~CallsGraph proc~compute_dt~3 compute_dt proc~a~3 a proc~compute_dt~3->proc~a~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: P (:) Primitive variables. real(kind=R_P), public :: vmax Maximum propagation speed of signals. integer(kind=I_P), public :: i Counter. Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~3.html","title":"compute_dt – FOODIE"},{"text":"private function dEuler_dt(self) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. Return Value type( euler_1D_omp_nf ) Euler field time derivative. Description Time derivative of Euler field, the residuals function. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: F (:,:) Fluxes of conservative variables. real(kind=R_P), public, allocatable :: P (:,:) Primitive variables. real(kind=R_P), public, allocatable :: PR (:,:,:) Left (1) and right (2) (reconstructed) interface values of primitive variables. integer(kind=I_P), public :: i Counter. Source Code function dEuler_dt ( self ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. type ( euler_1D_omp_nf ) :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F, PR) do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals dState_dt = self !$OMP PARALLEL PRIVATE(i) SHARED(self, dState_dt, F) !$OMP DO do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt~3.html","title":"dEuler_dt – FOODIE"},{"text":"private pure function primitive2conservative(self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative~3.html","title":"primitive2conservative – FOODIE"},{"text":"private pure function conservative2primitive(self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: c (:) Species concentration. Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive~3.html","title":"conservative2primitive – FOODIE"},{"text":"private elemental function p(r, a, g) result(pressure) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Description Compute the pressure for an ideal calorically perfect gas. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p~3.html","title":"p – FOODIE"},{"text":"private elemental function r(p, a, g) result(density) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Description Compute the density for an ideal calorically perfect gas. Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r~3.html","title":"r – FOODIE"},{"text":"private elemental function a(p, r, g) result(ss) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Description Compute the speed of sound for an ideal calorically perfect gas. Called By proc~~a~3~~CalledByGraph proc~a~3 a proc~compute_dt~3 compute_dt proc~compute_dt~3->proc~a~3 none~eigen_vect_l~3 eigen_vect_L none~eigen_vect_l~3->proc~a~3 none~eigen_vect_r~3 eigen_vect_R none~eigen_vect_r~3->proc~a~3 proc~reconstruct_interfaces_states~3 reconstruct_interfaces_states proc~reconstruct_interfaces_states~3->none~eigen_vect_l~3 proc~reconstruct_interfaces_states~3->none~eigen_vect_r~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a~3.html","title":"a – FOODIE"},{"text":"private elemental function E(p, r, u, g) result(energy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Description Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~e~3~~CalledByGraph proc~e~3 E proc~riemann_solver~3 riemann_solver proc~riemann_solver~3->proc~e~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e~3.html","title":"E – FOODIE"},{"text":"private elemental function H(p, r, u, g) result(entalpy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Description Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~h~3~~CalledByGraph proc~h~3 H none~fluxes~3 fluxes none~fluxes~3->proc~h~3 proc~riemann_solver~3 riemann_solver proc~riemann_solver~3->none~fluxes~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h~3.html","title":"H – FOODIE"},{"text":"private elemental subroutine init_rk(self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. Source Code elemental subroutine init_rk ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init_rk","tags":"","loc":"proc/init_rk~2.html","title":"init_rk – FOODIE"},{"text":"private elemental subroutine destroy_rk(self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destoy the integrator. Source Code elemental subroutine destroy_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy_rk","tags":"","loc":"proc/destroy_rk~2.html","title":"destroy_rk – FOODIE"},{"text":"private subroutine integrate_rk(self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( euler_1D_omp_nf ), intent(inout) :: U Field to be integrated. class( euler_1D_omp_nf ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coeficients are initialized). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s First stages counter. integer(kind=I_P), public :: ss Second stages counter. Source Code subroutine integrate_rk ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( euler_1D_omp_nf ), intent ( INOUT ) :: U !< Field to be integrated. class ( euler_1D_omp_nf ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s )% U = stage ( s )% U + stage ( ss )% U * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t () enddo ! computing new time step do s = 1 , self % stages U % U = U % U + stage ( s )% U * ( Dt * self % beta ( s )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate_rk","tags":"","loc":"proc/integrate_rk~2.html","title":"integrate_rk – FOODIE"},{"text":"private elemental subroutine finalize_rk(self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Source Code elemental subroutine finalize_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_rk","tags":"","loc":"proc/finalize_rk~2.html","title":"finalize_rk – FOODIE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, ord) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. Calls proc~~init~16~~CallsGraph proc~init~16 init interface~weno_constructor_upwind weno_constructor_upwind proc~init~16->interface~weno_constructor_upwind proc~weno_constructor_upwind_init weno_constructor_upwind_init interface~weno_constructor_upwind->proc~weno_constructor_upwind_init Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( weno_factory ), public :: factory WENO factory. class( weno_interpolator ), public, allocatable :: weno WENO interpolator. integer(kind=I_P), public :: i Space counter. Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~16.html","title":"init – FOODIE"},{"text":"private pure subroutine destroy(self) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: self Euler field. Description Destroy field. Source Code pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~10.html","title":"destroy – FOODIE"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_omp_nf ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: lhs !< Left hand side. class ( euler_1D_omp_nf ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_omp_nf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Nc , 1 : lhs % Ni )) endif if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) if ( allocated ( rhs % U )) then !$OMP DO do i = 1 , lhs % Ni lhs % U (:, i ) = rhs % U (:, i ) enddo endif !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler~3.html","title":"euler_assign_euler – FOODIE"},{"text":"private pure subroutine impose_boundary_conditions(self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions~3.html","title":"impose_boundary_conditions – FOODIE"},{"text":"private subroutine reconstruct_interfaces_states(self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Calls proc~~reconstruct_interfaces_states~3~~CallsGraph proc~reconstruct_interfaces_states~3 reconstruct_interfaces_states none~eigen_vect_r~3 eigen_vect_R proc~reconstruct_interfaces_states~3->none~eigen_vect_r~3 none~eigen_vect_l~3 eigen_vect_L proc~reconstruct_interfaces_states~3->none~eigen_vect_l~3 proc~a~3 a none~eigen_vect_r~3->proc~a~3 none~eigen_vect_l~3->proc~a~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: C (1:2,1-self%Ng:-1+self%Ng,1:self%Ns+2) Pseudo characteristic variables. real(kind=R_P), public :: CR (1:self%Ns+2,1:2) Pseudo characteristic reconst. vars. real(kind=R_P), public :: Pm (1:self%Np,1:2) Mean of primitive variables. real(kind=R_P), public :: LPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean left eigenvectors matrix. real(kind=R_P), public :: RPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean right eigenvectors matrix. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: j Counter. integer(kind=I_P), public :: f Counter. integer(kind=I_P), public :: v Counter. Functions pure function eigen_vect_L(Ns, Np, primitive) result(L) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Left eigenvectors matrix. Description Compute left eigenvectors from primitive variables. pure function eigen_vect_R(Ns, Np, primitive) result(R) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Right eigenvectors matrix. Description Compute right eigenvectors from primitive variables. Source Code subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- !$OMP PARALLEL PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) SHARED(self, primitive, r_primitive) select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction !$OMP DO do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction !$OMP DO do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect !$OMP END PARALLEL return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states~3.html","title":"reconstruct_interfaces_states – FOODIE"},{"text":"private pure subroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Calls proc~~riemann_solver~3~~CallsGraph proc~riemann_solver~3 riemann_solver none~fluxes~3 fluxes proc~riemann_solver~3->none~fluxes~3 proc~compute_inter_states~3 compute_inter_states proc~riemann_solver~3->proc~compute_inter_states~3 proc~e~3 E proc~riemann_solver~3->proc~e~3 proc~h~3 H none~fluxes~3->proc~h~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: F1 (1:3) State 1 fluxes. real(kind=R_P), public :: F4 (1:3) State 4 fluxes. real(kind=R_P), public :: u Velocity of the intermediate states. real(kind=R_P), public :: p Pressure of the intermediate states. real(kind=R_P), public :: S1 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: S4 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: lmax Maximum wave speed estimation. Functions pure function fluxes(p, r, u, g) result(Fc) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Velocity. real(kind=R_P), intent(in) :: g Specific heats ratio. Return Value real(kind=R_P)\n  (1:3) State fluxes. Description 1D Euler fluxes from primitive variables. Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver~3.html","title":"riemann_solver – FOODIE"},{"text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( euler_1D_omp_nf ), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~10.html","title":"finalize – FOODIE"},{"text":"private pure subroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Description Compute inter states (23*-states) from state1 and state4. Called By proc~~compute_inter_states~3~~CalledByGraph proc~compute_inter_states~3 compute_inter_states proc~riemann_solver~3 riemann_solver proc~riemann_solver~3->proc~compute_inter_states~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: a1 Speed of sound of state 1. real(kind=R_P), public :: a4 Speed of sound of state 4. real(kind=R_P), public :: ram Mean value of rho*a. real(kind=R_P), public, parameter :: toll = 1e-10_R_P Tollerance. Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states~3.html","title":"compute_inter_states – FOODIE"},{"text":"subroutine init() Arguments None Description Initialize the field. Called By proc~~init~17~~CalledByGraph proc~init~17 init program~integrate_euler_1d_openmp integrate_euler_1D_openmp program~integrate_euler_1d_openmp->proc~init~17 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~17.html","title":"init – FOODIE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. Calls proc~~save_results~5~~CallsGraph proc~save_results~5 save_results str str proc~save_results~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_results~5~~CalledByGraph proc~save_results~5 save_results program~integrate_euler_1d_openmp integrate_euler_1D_openmp program~integrate_euler_1d_openmp->proc~save_results~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type( pyplot ), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~5.html","title":"save_results – FOODIE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Calls proc~~save_time_serie~4~~CallsGraph proc~save_time_serie~4 save_time_serie str str proc~save_time_serie~4->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~4~~CalledByGraph proc~save_time_serie~4 save_time_serie program~integrate_euler_1d_openmp integrate_euler_1D_openmp program~integrate_euler_1d_openmp->proc~save_time_serie~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public, save :: tsfile File unit for saving time serie results. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie~4.html","title":"save_time_serie – FOODIE"},{"text":"private pure function output(self) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~5.html","title":"output – FOODIE"},{"text":"private pure function compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. Calls proc~~compute_dt~4~~CallsGraph proc~compute_dt~4 compute_dt proc~a~4 a proc~compute_dt~4->proc~a~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: P (:) Primitive variables. real(kind=R_P), public :: vmax Maximum propagation speed of signals. integer(kind=I_P), public :: i Counter. Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~4.html","title":"compute_dt – FOODIE"},{"text":"private function dEuler_dt(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: F (:,:) Fluxes of conservative variables. real(kind=R_P), public, allocatable :: P (:,:) Primitive variables. real(kind=R_P), public, allocatable :: PR (:,:,:) Left (1) and right (2) (reconstructed) interface values of primitive variables. integer(kind=I_P), public :: i Counter. Source Code function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F, PR) do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D_openmp :: dState_dt ) select type ( dState_dt ) class is ( euler_1D_openmp ) dState_dt = self endselect !$OMP PARALLEL PRIVATE(i) SHARED(self, dState_dt, F) select type ( dState_dt ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt~4.html","title":"dEuler_dt – FOODIE"},{"text":"private function euler_local_error(lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 euler approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. integer(kind=I_P), public :: v Variables counter. Source Code function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_openmp ) error = 0._R_P do i = 1 , lhs % Ni do v = 1 , lhs % Nc error = error + ( lhs % U ( v , i ) - rhs % U ( v , i )) ** 2 / lhs % U ( v , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error","tags":"","loc":"proc/euler_local_error~2.html","title":"euler_local_error – FOODIE"},{"text":"private function euler_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) * rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler","tags":"","loc":"proc/euler_multiply_euler~2.html","title":"euler_multiply_euler – FOODIE"},{"text":"private function euler_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) * rhs enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real","tags":"","loc":"proc/euler_multiply_real~2.html","title":"euler_multiply_real – FOODIE"},{"text":"private function real_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D_openmp ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D_openmp ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = rhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , rhs % Ni opr % U (:, i ) = rhs % U (:, i ) * lhs enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler","tags":"","loc":"proc/real_multiply_euler~2.html","title":"real_multiply_euler – FOODIE"},{"text":"private function add_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) + rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler","tags":"","loc":"proc/add_euler~2.html","title":"add_euler – FOODIE"},{"text":"private function sub_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) - rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler","tags":"","loc":"proc/sub_euler~2.html","title":"sub_euler – FOODIE"},{"text":"private pure function primitive2conservative(self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative~4.html","title":"primitive2conservative – FOODIE"},{"text":"private pure function conservative2primitive(self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: c (:) Species concentration. Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive~4.html","title":"conservative2primitive – FOODIE"},{"text":"private elemental function p(r, a, g) result(pressure) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Description Compute the pressure for an ideal calorically perfect gas. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p~4.html","title":"p – FOODIE"},{"text":"private elemental function r(p, a, g) result(density) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Description Compute the density for an ideal calorically perfect gas. Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r~4.html","title":"r – FOODIE"},{"text":"private elemental function a(p, r, g) result(ss) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Description Compute the speed of sound for an ideal calorically perfect gas. Called By proc~~a~4~~CalledByGraph proc~a~4 a proc~compute_dt~4 compute_dt proc~compute_dt~4->proc~a~4 none~eigen_vect_r~4 eigen_vect_R none~eigen_vect_r~4->proc~a~4 none~eigen_vect_l~4 eigen_vect_L none~eigen_vect_l~4->proc~a~4 proc~reconstruct_interfaces_states~4 reconstruct_interfaces_states proc~reconstruct_interfaces_states~4->none~eigen_vect_r~4 proc~reconstruct_interfaces_states~4->none~eigen_vect_l~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a~4.html","title":"a – FOODIE"},{"text":"private elemental function E(p, r, u, g) result(energy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Description Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~e~4~~CalledByGraph proc~e~4 E proc~riemann_solver~4 riemann_solver proc~riemann_solver~4->proc~e~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e~4.html","title":"E – FOODIE"},{"text":"private elemental function H(p, r, u, g) result(entalpy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Description Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~h~4~~CalledByGraph proc~h~4 H none~fluxes~4 fluxes none~fluxes~4->proc~h~4 proc~riemann_solver~4 riemann_solver proc~riemann_solver~4->none~fluxes~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h~4.html","title":"H – FOODIE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, ord) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. Calls proc~~init~18~~CallsGraph proc~init~18 init interface~weno_constructor_upwind weno_constructor_upwind proc~init~18->interface~weno_constructor_upwind proc~weno_constructor_upwind_init weno_constructor_upwind_init interface~weno_constructor_upwind->proc~weno_constructor_upwind_init Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( weno_factory ), public :: factory WENO factory. class( weno_interpolator ), public, allocatable :: weno WENO interpolator. integer(kind=I_P), public :: i Space counter. Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~18.html","title":"init – FOODIE"},{"text":"private pure subroutine destroy(self) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: self Euler field. Description Destroy field. Source Code pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~11.html","title":"destroy – FOODIE"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_openmp ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Nc , 1 : lhs % Ni )) endif if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) select type ( rhs ) class is ( euler_1D_openmp ) if ( allocated ( rhs % U )) then !$OMP DO do i = 1 , lhs % Ni lhs % U (:, i ) = rhs % U (:, i ) enddo endif endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler~4.html","title":"euler_assign_euler – FOODIE"},{"text":"private subroutine euler_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) then !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) do i = 1 , lhs % Ni lhs % U (:, i ) = rhs enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real","tags":"","loc":"proc/euler_assign_real~2.html","title":"euler_assign_real – FOODIE"},{"text":"private pure subroutine impose_boundary_conditions(self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions~4.html","title":"impose_boundary_conditions – FOODIE"},{"text":"private subroutine reconstruct_interfaces_states(self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Calls proc~~reconstruct_interfaces_states~4~~CallsGraph proc~reconstruct_interfaces_states~4 reconstruct_interfaces_states none~eigen_vect_l~4 eigen_vect_L proc~reconstruct_interfaces_states~4->none~eigen_vect_l~4 none~eigen_vect_r~4 eigen_vect_R proc~reconstruct_interfaces_states~4->none~eigen_vect_r~4 proc~a~4 a none~eigen_vect_l~4->proc~a~4 none~eigen_vect_r~4->proc~a~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: C (1:2,1-self%Ng:-1+self%Ng,1:self%Ns+2) Pseudo characteristic variables. real(kind=R_P), public :: CR (1:self%Ns+2,1:2) Pseudo characteristic reconst. vars. real(kind=R_P), public :: Pm (1:self%Np,1:2) Mean of primitive variables. real(kind=R_P), public :: LPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean left eigenvectors matrix. real(kind=R_P), public :: RPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean right eigenvectors matrix. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: j Counter. integer(kind=I_P), public :: f Counter. integer(kind=I_P), public :: v Counter. Functions pure function eigen_vect_L(Ns, Np, primitive) result(L) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Left eigenvectors matrix. Description Compute left eigenvectors from primitive variables. pure function eigen_vect_R(Ns, Np, primitive) result(R) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Right eigenvectors matrix. Description Compute right eigenvectors from primitive variables. Source Code subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- !$OMP PARALLEL PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) SHARED(self, primitive, r_primitive) select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction !$OMP DO do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction !$OMP DO do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect !$OMP END PARALLEL return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states~4.html","title":"reconstruct_interfaces_states – FOODIE"},{"text":"private pure subroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Calls proc~~riemann_solver~4~~CallsGraph proc~riemann_solver~4 riemann_solver proc~compute_inter_states~4 compute_inter_states proc~riemann_solver~4->proc~compute_inter_states~4 none~fluxes~4 fluxes proc~riemann_solver~4->none~fluxes~4 proc~e~4 E proc~riemann_solver~4->proc~e~4 proc~h~4 H none~fluxes~4->proc~h~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: F1 (1:3) State 1 fluxes. real(kind=R_P), public :: F4 (1:3) State 4 fluxes. real(kind=R_P), public :: u Velocity of the intermediate states. real(kind=R_P), public :: p Pressure of the intermediate states. real(kind=R_P), public :: S1 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: S4 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: lmax Maximum wave speed estimation. Functions pure function fluxes(p, r, u, g) result(Fc) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Velocity. real(kind=R_P), intent(in) :: g Specific heats ratio. Return Value real(kind=R_P)\n  (1:3) State fluxes. Description 1D Euler fluxes from primitive variables. Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver~4.html","title":"riemann_solver – FOODIE"},{"text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( euler_1D_openmp ), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~11.html","title":"finalize – FOODIE"},{"text":"private pure subroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Description Compute inter states (23*-states) from state1 and state4. Called By proc~~compute_inter_states~4~~CalledByGraph proc~compute_inter_states~4 compute_inter_states proc~riemann_solver~4 riemann_solver proc~riemann_solver~4->proc~compute_inter_states~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: a1 Speed of sound of state 1. real(kind=R_P), public :: a4 Speed of sound of state 4. real(kind=R_P), public :: ram Mean value of rho*a. real(kind=R_P), public, parameter :: toll = 1e-10_R_P Tollerance. Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states~4.html","title":"compute_inter_states – FOODIE"},{"text":"subroutine init() Arguments None Description Initialize the field. Called By proc~~init~19~~CalledByGraph proc~init~19 init program~integrate_burgers integrate_burgers program~integrate_burgers->proc~init~19 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, parameter :: pi = 4._R_P*atan(1._R_P) Pi greek. integer(kind=I_P), public :: i Space counter. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- h = 2._R_P * pi / Ni do i = 1 , Ni x ( i ) = h * ( i - 1 ) initial_state ( i ) = 1 0._R_P * sin ( x ( i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~19.html","title":"init – FOODIE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. Called By proc~~save_results~6~~CalledByGraph proc~save_results~6 save_results proc~test_ab test_ab proc~test_ab->proc~save_results~6 proc~test_leapfrog test_leapfrog proc~test_leapfrog->proc~save_results~6 proc~test_tvd_rk test_tvd_rk proc~test_tvd_rk->proc~save_results~6 proc~test_ls_rk test_ls_rk proc~test_ls_rk->proc~save_results~6 proc~test_euler test_euler proc~test_euler->proc~save_results~6 program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_ab program~integrate_burgers->proc~test_leapfrog program~integrate_burgers->proc~test_tvd_rk program~integrate_burgers->proc~test_ls_rk program~integrate_burgers->proc~test_euler Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type( pyplot ), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"U\"' do i = 1 , Ni write ( rawfile , '(2(' // FR_P // ',1X))' ) x ( i ), final_state ( i ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) call plt % add_plot ( x = x , y = final_state , label = 'U' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~6.html","title":"save_results – FOODIE"},{"text":"subroutine test_ab() Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Calls proc~~test_ab~~CallsGraph proc~test_ab test_ab str str proc~test_ab->str proc~save_results~6 save_results proc~test_ab->proc~save_results~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_ab~~CalledByGraph proc~test_ab test_ab program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_ab Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( burgers ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( adams_bashforth_integrator ), public :: ab_integrator Adams-Bashforth integrator. integer, public, parameter :: ab_steps = 4 Adams-Bashforth steps number. type( burgers ), public :: previous (1:ab_steps) Previous time steps solutions. integer, public :: step Time steps counter. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t (1:ab_steps) Times. integer(kind=I_P), public :: s AB steps counter. integer(kind=I_P), public :: ss AB substeps counter. Source Code subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( burgers ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = s ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t ( s ) < t_final ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), Dt = Dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit ' // & 'Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'burgers_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab.html","title":"test_ab – FOODIE"},{"text":"subroutine test_euler() Arguments None Description Test explicit forward Euler ODE solver. Calls proc~~test_euler~~CallsGraph proc~test_euler test_euler proc~save_results~6 save_results proc~test_euler->proc~save_results~6 str str proc~test_euler->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_euler~~CalledByGraph proc~test_euler test_euler program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_euler Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( euler_explicit_integrator ), public :: euler_integrator Euler integrator. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of explicit Euler solver' call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit Euler' , & filename = 'burgers_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler.html","title":"test_euler – FOODIE"},{"text":"subroutine test_leapfrog() Arguments None Description Test explicit leapfrog class of ODE solvers. Calls proc~~test_leapfrog~~CallsGraph proc~test_leapfrog test_leapfrog proc~save_results~6 save_results proc~test_leapfrog->proc~save_results~6 str str proc~test_leapfrog->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_leapfrog~~CalledByGraph proc~test_leapfrog test_leapfrog program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_leapfrog Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 2 Runge-Kutta stages number. type( burgers ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( burgers ), public :: filter Filter displacement. type( leapfrog_integrator ), public :: lf_integrator Leapfrog integrator. type( burgers ), public :: previous (1:2) Previous time steps solutions. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer, public :: step Time steps counter. Source Code subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( burgers ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( burgers ) :: previous ( 1 : 2 ) !< Previous time steps solutions. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = 2 ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t < t_final ) if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit leapfrog scheme' ,& filename = 'burgers_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog","tags":"","loc":"proc/test_leapfrog.html","title":"test_leapfrog – FOODIE"},{"text":"subroutine test_ls_rk() Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. Calls proc~~test_ls_rk~~CallsGraph proc~test_ls_rk test_ls_rk str str proc~test_ls_rk->str proc~save_results~6 save_results proc~test_ls_rk->proc~save_results~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_ls_rk~~CalledByGraph proc~test_ls_rk test_ls_rk program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_ls_rk Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( ls_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. integer, public, parameter :: registers = 2 Runge-Kutta stages number. type( burgers ), public :: rk_stage (1:registers) Runge-Kutta stages. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer(kind=I_P), public :: s RK stages counter. Source Code subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit low storage Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk","tags":"","loc":"proc/test_ls_rk.html","title":"test_ls_rk – FOODIE"},{"text":"subroutine test_tvd_rk() Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Calls proc~~test_tvd_rk~~CallsGraph proc~test_tvd_rk test_tvd_rk str str proc~test_tvd_rk->str proc~save_results~6 save_results proc~test_tvd_rk->proc~save_results~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_tvd_rk~~CalledByGraph proc~test_tvd_rk test_tvd_rk program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_tvd_rk Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( burgers ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer(kind=I_P), public :: s RK stages counter. Source Code subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit TVD Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk","tags":"","loc":"proc/test_tvd_rk.html","title":"test_tvd_rk – FOODIE"},{"text":"private pure function output(self) result(state) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value real(kind=R_P),\n  dimension(:),allocatable Burgers state variable. Description Output the Burgers field state. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Burgers field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), dimension (:), allocatable :: state !< Burgers state variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~6.html","title":"output – FOODIE"},{"text":"private pure function compute_dt(self, CFL) result(dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in) :: CFL Courant-Friedricks-Lewi stability coefficient. Return Value real(kind=R_P) Current time step. Description Compute the current time step, by means of CFL condition. Source Code pure function compute_dt ( self , CFL ) result ( dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step, by means of CFL condition. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), intent ( IN ) :: CFL !< Courant-Friedricks-Lewi stability coefficient. real ( R_P ) :: dt !< Current time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dt = CFL * self % h ** 2 / self % nu return !--------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~5.html","title":"compute_dt – FOODIE"},{"text":"private function dBurgers_dt(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Burgers field time derivative. Description Time derivative of Burgers field, residuals function. Source Code function dBurgers_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Burgers field, residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Burgers field time derivative. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: dState_dt ) select type ( dState_dt ) class is ( burgers ) dState_dt = self dState_dt = self % xx () * self % nu dState_dt = dState_dt - self * self % x () endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dBurgers_dt","tags":"","loc":"proc/dburgers_dt.html","title":"dBurgers_dt – FOODIE"},{"text":"private function previous_step(self, n) result(previous) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Burgers field. Description Extract previous time solution of Burgers field. Source Code function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: previous ) select type ( previous ) class is ( burgers ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step","tags":"","loc":"proc/previous_step.html","title":"previous_step – FOODIE"},{"text":"private function burgers_local_error(lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 burgers approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code function burgers_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 burgers approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( burgers ) error = 0._R_P do i = 1 , lhs % dims error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_local_error","tags":"","loc":"proc/burgers_local_error.html","title":"burgers_local_error – FOODIE"},{"text":"private function burgers_multiply_burgers(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by another one. Source Code function burgers_multiply_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_burgers","tags":"","loc":"proc/burgers_multiply_burgers.html","title":"burgers_multiply_burgers – FOODIE"},{"text":"private function burgers_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by a real scalar. Source Code function burgers_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_real","tags":"","loc":"proc/burgers_multiply_real.html","title":"burgers_multiply_real – FOODIE"},{"text":"private function real_multiply_burgers(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( burgers ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Burgers field. Source Code function real_multiply_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( burgers ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_burgers","tags":"","loc":"proc/real_multiply_burgers.html","title":"real_multiply_burgers – FOODIE"},{"text":"private function add_burgers(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Burgers fields. Source Code function add_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_burgers","tags":"","loc":"proc/add_burgers.html","title":"add_burgers – FOODIE"},{"text":"private function sub_burgers(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Burgers fields. Source Code function sub_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_burgers","tags":"","loc":"proc/sub_burgers.html","title":"sub_burgers – FOODIE"},{"text":"private function dBurgers_dx(self) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative. Description Compute the first order spatial derivative of Burgers field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter.","tags":"","loc":"proc/dburgers_dx.html","title":"dBurgers_dx – FOODIE"},{"text":"private function d2Burgers_dx2(self) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative. Description Compute the second order spatial derivative of Burgers field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter.","tags":"","loc":"proc/d2burgers_dx2.html","title":"d2Burgers_dx2 – FOODIE"},{"text":"private subroutine init(self, initial_state, Ni, h, nu, steps) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. real(kind=R_P), intent(in), dimension(1:Ni) :: initial_state Initial state of Burgers field domain. integer(kind=I_P), intent(in) :: Ni Number of grid nodes. real(kind=R_P), intent(in) :: h Space step discretization. real(kind=R_P), intent(in) :: nu Viscosity. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Burgers field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Time steps counter. Source Code subroutine init ( self , initial_state , Ni , h , nu , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: Ni !< Number of grid nodes. real ( R_P ), dimension ( 1 : Ni ), intent ( IN ) :: initial_state !< Initial state of Burgers field domain. real ( R_P ), intent ( IN ) :: h !< Space step discretization. real ( R_P ), intent ( IN ) :: nu !< Viscosity. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : Ni , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % Ni = Ni self % h = h self % nu = nu return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~20.html","title":"init – FOODIE"},{"text":"private subroutine update_previous_steps(self, filter, weights) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Time steps counter. Source Code subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( burgers ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps.html","title":"update_previous_steps – FOODIE"},{"text":"private subroutine burgers_assign_burgers(lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Burgers field to another. Source Code subroutine burgers_assign_burgers ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Burgers field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( burgers ) lhs % Ni = rhs % Ni lhs % steps = rhs % steps lhs % h = rhs % h lhs % nu = rhs % nu if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_burgers","tags":"","loc":"proc/burgers_assign_burgers.html","title":"burgers_assign_burgers – FOODIE"},{"text":"private subroutine burgers_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Burgers field. Source Code subroutine burgers_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_real","tags":"","loc":"proc/burgers_assign_real.html","title":"burgers_assign_real – FOODIE"},{"text":"subroutine init() Arguments None Description Initialize the field. Calls proc~~init~21~~CallsGraph proc~init~21 init str str proc~init~21->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~init~21~~CalledByGraph proc~init~21 init program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~init~21 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, parameter :: pi = 4._R_P*atan(1._R_P) Pi greek. integer(kind=I_P), public :: i Space counter. integer(kind=I_P), public :: s Species counter. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Species counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( xcenter ( 1 : Ni )) allocate ( xnode ( 0 : Ni )) Dx = 1._R_P / Ni do i = 1 , Ni xcenter ( i ) = Dx * i - 0.5_R_P * Dx enddo do i = 0 , Ni xnode ( i ) = Dx * i enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then allocate ( av_xnode ( 0 : av_Ni )) do i = 0 , av_Ni av_xnode ( i ) = 1._R_P / av_Ni * i enddo endif select case ( trim ( adjustl ( problem ))) case ( 'sod' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.2_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str (. true ., s )) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case ( 'smooth' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.1_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str (. true ., s )) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni initial_state (:, i ) = [ 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! rho(s) 0.5_R_P * ( xcenter ( i ) - 0.5_R_P ) ** 4 , & ! u 1 0._R_P + 2._R_P * xcenter ( i ) ** 4 , & ! p 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case default print \"(A)\" , 'Error: unknown problem \"' // trim ( adjustl ( problem )) // '\"' print \"(A)\" , 'Valid problem names are:' print \"(A)\" , '  + sod' print \"(A)\" , '  + smooth' stop endselect if ( trim ( adjustl ( output_cli )) /= 'unset' ) then output = trim ( adjustl ( output_cli )) // '-' // trim ( adjustl ( solver )) else output = 'euler_1D_integration-' // trim ( adjustl ( solver )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~21.html","title":"init – FOODIE"},{"text":"subroutine average_solution() Arguments None Description Average the solution over an average grid. Called By proc~~average_solution~~CalledByGraph proc~average_solution average_solution proc~save_results~7 save_results proc~save_results~7->proc~average_solution proc~test_ls_rk~2 test_ls_rk proc~test_ls_rk~2->proc~save_results~7 proc~test_ab~2 test_ab proc~test_ab~2->proc~save_results~7 proc~test_leapfrog~2 test_leapfrog proc~test_leapfrog~2->proc~save_results~7 proc~test_tvd_rk~2 test_tvd_rk proc~test_tvd_rk~2->proc~save_results~7 proc~test_euler~2 test_euler proc~test_euler~2->proc~save_results~7 program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_ls_rk~2 program~integrate_euler_1d->proc~test_ab~2 program~integrate_euler_1d->proc~test_leapfrog~2 program~integrate_euler_1d->proc~test_tvd_rk~2 program~integrate_euler_1d->proc~test_euler~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i integer(kind=I_P), public :: ii integer(kind=I_P), public :: i1 integer(kind=I_P), public :: i2 Counters. Source Code subroutine average_solution () !--------------------------------------------------------------------------------------------------------------------------------- !< Average the solution over an average grid. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i , ii , i1 , i2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then if ( allocated ( av_state )) deallocate ( av_state ) ; allocate ( av_state ( 1 : Np , 1 : av_Ni )) do i = 1 , av_Ni i1 = minloc ( array = xcenter , dim = 1 , mask = ( xcenter >= av_xnode ( i - 1 ))) i2 = maxloc ( array = xcenter , dim = 1 , mask = ( xcenter <= av_xnode ( i ))) av_state (:, i ) = 0._R_P do ii = i1 , i2 av_state (:, i ) = av_state (:, i ) + final_state (:, ii ) enddo av_state (:, i ) = av_state (:, i ) / ( i2 - i1 + 1 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine average_solution","tags":"","loc":"proc/average_solution.html","title":"average_solution – FOODIE"},{"text":"subroutine save_results(title, basename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: basename Output basename. Description Save results. Calls proc~~save_results~7~~CallsGraph proc~save_results~7 save_results str str proc~save_results~7->str proc~average_solution average_solution proc~save_results~7->proc~average_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_results~7~~CalledByGraph proc~save_results~7 save_results proc~test_ls_rk~2 test_ls_rk proc~test_ls_rk~2->proc~save_results~7 proc~test_ab~2 test_ab proc~test_ab~2->proc~save_results~7 proc~test_leapfrog~2 test_leapfrog proc~test_leapfrog~2->proc~save_results~7 proc~test_tvd_rk~2 test_tvd_rk proc~test_tvd_rk~2->proc~save_results~7 proc~test_euler~2 test_euler proc~test_euler~2->proc~save_results~7 program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_ls_rk~2 program~integrate_euler_1d->proc~test_ab~2 program~integrate_euler_1d->proc~test_leapfrog~2 program~integrate_euler_1d->proc~test_tvd_rk~2 program~integrate_euler_1d->proc~test_euler~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type( pyplot ), public :: plt Plot file handler. integer(kind=I_P), public :: v Counter. Source Code subroutine save_results ( title , basename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: basename !< Output basename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = basename // '-' // trim ( str (. true ., Ni )) // '_cells.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) variables write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str (. true ., Ni )) // ' cells\", I=' // trim ( str (. true ., Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 1 )) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str (. true ., Ni + 1 )) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( rawfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then print \"(A)\" , ' Average solution from Ni: ' // trim ( str (. true ., Ni )) // ' to av_Ni: ' // trim ( str (. true ., av_Ni )) call average_solution write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str (. true ., Ni )) // ' cells averaged over ' // trim ( str (. true ., av_Ni )) // & ' cells\", I=' // trim ( str (. true ., av_Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 1 )) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str (. true ., av_Ni + 1 )) // '(' // FR_P // ',1X))' ) av_xnode do v = 1 , Np write ( rawfile , '(' // trim ( str (. true ., av_Ni )) // '(' // FR_P // ',1X))' ) av_state ( v , :) enddo endif close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = xcenter , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = xcenter , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( basename // '-' // trim ( str (. true ., Ni )) // '_cells.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~7.html","title":"save_results – FOODIE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Calls proc~~save_time_serie~5~~CallsGraph proc~save_time_serie~5 save_time_serie str str proc~save_time_serie~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~5~~CalledByGraph proc~save_time_serie~5 save_time_serie proc~test_ls_rk~2 test_ls_rk proc~test_ls_rk~2->proc~save_time_serie~5 proc~test_ab~2 test_ab proc~test_ab~2->proc~save_time_serie~5 proc~test_leapfrog~2 test_leapfrog proc~test_leapfrog~2->proc~save_time_serie~5 proc~test_tvd_rk~2 test_tvd_rk proc~test_tvd_rk~2->proc~save_time_serie~5 proc~test_euler~2 test_euler proc~test_euler~2->proc~save_time_serie~5 program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_ls_rk~2 program~integrate_euler_1d->proc~test_ab~2 program~integrate_euler_1d->proc~test_leapfrog~2 program~integrate_euler_1d->proc~test_tvd_rk~2 program~integrate_euler_1d->proc~test_euler~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public, save :: tsfile File unit for saving time serie results. integer(kind=I_P), public :: v Counter. Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) 'TITLE=\"' // title // '\"' endif write ( tsfile , '(A)' ) variables // ' \"t\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\", I=' // trim ( str (. true ., Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 2 )) // ']=CELLCENTERED)' write ( tsfile , '(' // trim ( str (. true ., Ni + 1 )) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( tsfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo write ( tsfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' )( t , v = 1 , Ni ) if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie~5.html","title":"save_time_serie – FOODIE"},{"text":"subroutine test_ab() Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Calls proc~~test_ab~2~~CallsGraph proc~test_ab~2 test_ab proc~save_time_serie~5 save_time_serie proc~test_ab~2->proc~save_time_serie~5 str str proc~test_ab~2->str proc~save_results~7 save_results proc~test_ab~2->proc~save_results~7 proc~save_time_serie~5->str proc~save_results~7->str proc~average_solution average_solution proc~save_results~7->proc~average_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_ab~2~~CalledByGraph proc~test_ab~2 test_ab program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_ab~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( adams_bashforth_integrator ), public :: ab_integrator Adams-Bashforth integrator. integer, public, parameter :: ab_steps = 4 Adams-Bashforth steps number. type(euler_1D), public :: previous (1:ab_steps) Previous time steps solutions. integer, public :: step Time steps counter. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t (1:ab_steps) Times. integer(kind=I_P), public :: s AB steps counter. integer(kind=I_P), public :: ss AB substeps counter. integer(kind=I_P), public :: steps_range (1:2) Steps used. character(len=:), public, allocatable :: title Output files title. Source Code subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( euler_1D ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of Adams-Bashforth class of solvers' steps_range = [ 1 , ab_steps ] ; if ( stages_steps > 0 ) steps_range = [ stages_steps , stages_steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' AB-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' steps' call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 1 ) call rk_integrator % init ( stages = s ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 3 ) call rk_integrator % init ( stages = s ) case ( 4 , 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 7 ) call rk_integrator % init ( stages = 5 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , t = t ( s )) step = 1 do while ( t ( s ) < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t ( s ), CFL = 0.1_R_P * CFL ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), dt = dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 call save_time_serie ( t = t ( s )) enddo call save_time_serie ( t = t ( s ), finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab~2.html","title":"test_ab – FOODIE"},{"text":"subroutine test_euler() Arguments None Description Test explicit forward Euler ODE solver. Calls proc~~test_euler~2~~CallsGraph proc~test_euler~2 test_euler proc~save_time_serie~5 save_time_serie proc~test_euler~2->proc~save_time_serie~5 str str proc~test_euler~2->str proc~save_results~7 save_results proc~test_euler~2->proc~save_results~7 proc~save_time_serie~5->str proc~save_results~7->str proc~average_solution average_solution proc~save_results~7->proc~average_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_euler~2~~CalledByGraph proc~test_euler~2 test_euler program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_euler~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( euler_explicit_integrator ), public :: euler_integrator Euler integrator. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. character(len=:), public, allocatable :: title Output files title. Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of explicit Euler solver' title = '1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '  Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler~2.html","title":"test_euler – FOODIE"},{"text":"subroutine test_leapfrog() Arguments None Description Test explicit leapfrog class of ODE solvers. Calls proc~~test_leapfrog~2~~CallsGraph proc~test_leapfrog~2 test_leapfrog proc~save_time_serie~5 save_time_serie proc~test_leapfrog~2->proc~save_time_serie~5 str str proc~test_leapfrog~2->str proc~save_results~7 save_results proc~test_leapfrog~2->proc~save_results~7 proc~save_time_serie~5->str proc~save_results~7->str proc~average_solution average_solution proc~save_results~7->proc~average_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_leapfrog~2~~CalledByGraph proc~test_leapfrog~2 test_leapfrog program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_leapfrog~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 2 Runge-Kutta stages number. type(euler_1D), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type(euler_1D), public :: filter Filter displacement. type( leapfrog_integrator ), public :: lf_integrator Leapfrog integrator. type(euler_1D), public :: previous (1:2) Previous time steps solutions. integer, public :: step Time steps counter. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. character(len=:), public, allocatable :: title Output files title. Source Code subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( euler_1D ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( euler_1D ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of leapfrog (RAW filtered) class of solvers' title = '1D Euler equations integration, explicit leapfrog (RAW filtered), t=' // str ( n = t_final ) call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = 2 , ord = 3 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) step = 1 do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = 0.1_R_P * CFL ) if ( 2 >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog","tags":"","loc":"proc/test_leapfrog~2.html","title":"test_leapfrog – FOODIE"},{"text":"subroutine test_ls_rk() Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. Calls proc~~test_ls_rk~2~~CallsGraph proc~test_ls_rk~2 test_ls_rk proc~save_time_serie~5 save_time_serie proc~test_ls_rk~2->proc~save_time_serie~5 str str proc~test_ls_rk~2->str proc~save_results~7 save_results proc~test_ls_rk~2->proc~save_results~7 proc~save_time_serie~5->str proc~save_results~7->str proc~average_solution average_solution proc~save_results~7->proc~average_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_ls_rk~2~~CalledByGraph proc~test_ls_rk~2 test_ls_rk program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_ls_rk~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( ls_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. integer, public, parameter :: registers = 2 Runge-Kutta stages number. type(euler_1D), public :: rk_stage (1:registers) Runge-Kutta stages. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: stages_range (1:2) Stages used. character(len=:), public, allocatable :: title Output files title. Source Code subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of low storage (2N) Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk","tags":"","loc":"proc/test_ls_rk~2.html","title":"test_ls_rk – FOODIE"},{"text":"subroutine test_tvd_rk() Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Calls proc~~test_tvd_rk~2~~CallsGraph proc~test_tvd_rk~2 test_tvd_rk proc~save_time_serie~5 save_time_serie proc~test_tvd_rk~2->proc~save_time_serie~5 str str proc~test_tvd_rk~2->str proc~save_results~7 save_results proc~test_tvd_rk~2->proc~save_results~7 proc~save_time_serie~5->str proc~save_results~7->str proc~average_solution average_solution proc~save_results~7->proc~average_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_tvd_rk~2~~CalledByGraph proc~test_tvd_rk~2 test_tvd_rk program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_tvd_rk~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D), public :: rk_stage (1:rk_stages) Runge-Kutta stages. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: stages_range (1:2) Stages used. character(len=:), public, allocatable :: title Output files title. Source Code subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of TVD/SSP Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit TVD/SSP Runge-Kutta, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk","tags":"","loc":"proc/test_tvd_rk~2.html","title":"test_tvd_rk – FOODIE"},{"text":"private pure function output(self) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~7.html","title":"output – FOODIE"},{"text":"private pure function compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. Calls proc~~compute_dt~6~~CallsGraph proc~compute_dt~6 compute_dt proc~a~5 a proc~compute_dt~6->proc~a~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: P (:) Primitive variables. real(kind=R_P), public :: vmax Maximum propagation speed of signals. integer(kind=I_P), public :: i Counter. Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~6.html","title":"compute_dt – FOODIE"},{"text":"private function dEuler_dt(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. Calls proc~~deuler_dt~5~~CallsGraph proc~deuler_dt~5 dEuler_dt u u proc~deuler_dt~5->u Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: F (:,:) Fluxes of conservative variables. real(kind=R_P), public, allocatable :: P (:,:) Primitive variables. real(kind=R_P), public, allocatable :: PR (:,:,:) Left (1) and right (2) (reconstructed) interface values of primitive variables. integer(kind=I_P), public :: i Counter. Source Code function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Nc => self % Nc , Np => self % Np , Ns => self % Ns , U => self % U , previous => self % previous ) ! allocate temporary arrays allocate ( F ( 1 : Nc , 0 : Ni )) ; F = 0._R_P allocate ( P ( 1 : Np , 1 - Ng : Ni + Ng )) ; P = 0._R_P allocate ( PR ( 1 : Np , 1 : 2 , 0 : Ni + 1 )) ; PR = 0._R_P ! compute primitive variables do i = 1 , Ni P (:, i ) = self % conservative2primitive ( U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , Ni call self % riemann_solver ( r1 = PR ( Ns + 3 , 2 , i ), u1 = PR ( Ns + 1 , 2 , i ), p1 = PR ( Ns + 2 , 2 , i ), g1 = PR ( Ns + 4 , 2 , i ), & r4 = PR ( Ns + 3 , 1 , i + 1 ), u4 = PR ( Ns + 1 , 1 , i + 1 ), p4 = PR ( Ns + 2 , 1 , i + 1 ), g4 = PR ( Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : Ns , 2 , i ) / PR ( Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : Ns , 1 , i + 1 ) / PR ( Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D :: dState_dt ) select type ( dState_dt ) class is ( euler_1D ) dState_dt = self do i = 1 , Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt~5.html","title":"dEuler_dt – FOODIE"},{"text":"private function previous_step(self, n) result(previous) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Euler field. Description Extract previous time solution of Euler field. Source Code function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: previous ) select type ( previous ) class is ( euler_1D ) previous = self previous % U = self % previous (:, :, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step","tags":"","loc":"proc/previous_step~2.html","title":"previous_step – FOODIE"},{"text":"private function euler_local_error(lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 euler approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. integer(kind=I_P), public :: j Species counter. Source Code function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: j !< Species counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) error = 0._R_P do i = 1 , lhs % Ni do j = 1 , lhs % Nc error = error + ( lhs % U ( j , i ) - rhs % U ( j , i )) ** 2 / lhs % U ( j , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error","tags":"","loc":"proc/euler_local_error~3.html","title":"euler_local_error – FOODIE"},{"text":"private function euler_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. Source Code function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler","tags":"","loc":"proc/euler_multiply_euler~3.html","title":"euler_multiply_euler – FOODIE"},{"text":"private function euler_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. Source Code function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real","tags":"","loc":"proc/euler_multiply_real~3.html","title":"euler_multiply_real – FOODIE"},{"text":"private function real_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. Source Code function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler","tags":"","loc":"proc/real_multiply_euler~3.html","title":"real_multiply_euler – FOODIE"},{"text":"private function add_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. Source Code function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler","tags":"","loc":"proc/add_euler~3.html","title":"add_euler – FOODIE"},{"text":"private function sub_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. Source Code function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler","tags":"","loc":"proc/sub_euler~3.html","title":"sub_euler – FOODIE"},{"text":"private pure function primitive2conservative(self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative~5.html","title":"primitive2conservative – FOODIE"},{"text":"private pure function conservative2primitive(self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: c (:) Species concentration. Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive~5.html","title":"conservative2primitive – FOODIE"},{"text":"private elemental function p(r, a, g) result(pressure) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Description Compute the pressure for an ideal calorically perfect gas. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p~5.html","title":"p – FOODIE"},{"text":"private elemental function r(p, a, g) result(density) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Description Compute the density for an ideal calorically perfect gas. Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r~5.html","title":"r – FOODIE"},{"text":"private elemental function a(p, r, g) result(ss) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Description Compute the speed of sound for an ideal calorically perfect gas. Called By proc~~a~5~~CalledByGraph proc~a~5 a none~eigen_vect_r~5 eigen_vect_R none~eigen_vect_r~5->proc~a~5 proc~compute_dt~6 compute_dt proc~compute_dt~6->proc~a~5 none~eigen_vect_l~5 eigen_vect_L none~eigen_vect_l~5->proc~a~5 proc~reconstruct_interfaces_states~5 reconstruct_interfaces_states proc~reconstruct_interfaces_states~5->none~eigen_vect_r~5 proc~reconstruct_interfaces_states~5->none~eigen_vect_l~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a~5.html","title":"a – FOODIE"},{"text":"private elemental function E(p, r, u, g) result(energy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Description Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~e~5~~CalledByGraph proc~e~5 E proc~riemann_solver~5 riemann_solver proc~riemann_solver~5->proc~e~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e~5.html","title":"E – FOODIE"},{"text":"private elemental function H(p, r, u, g) result(entalpy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Description Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~h~5~~CalledByGraph proc~h~5 H none~fluxes~5 fluxes none~fluxes~5->proc~h~5 proc~riemann_solver~5 riemann_solver proc~riemann_solver~5->none~fluxes~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h~5.html","title":"H – FOODIE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, steps, ord) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: steps Time steps stored. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. Calls proc~~init~22~~CallsGraph proc~init~22 init interface~weno_constructor_upwind weno_constructor_upwind proc~init~22->interface~weno_constructor_upwind proc~weno_constructor_upwind_init weno_constructor_upwind_init interface~weno_constructor_upwind->proc~weno_constructor_upwind_init Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( weno_factory ), public :: factory WENO factory. class( weno_interpolator ), public, allocatable :: weno WENO interpolator. integer(kind=I_P), public :: i Space counter. integer(kind=I_P), public :: s Steps counter. Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , steps , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 ; if ( present ( steps )) self % steps = steps self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % Nc , 1 : Ni , 1 : self % steps )) endif self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo if ( self % steps > 0 ) then do s = 1 , self % steps do i = 1 , Ni self % previous (:, i , s ) = self % primitive2conservative ( initial_state (:, i )) enddo enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~22.html","title":"init – FOODIE"},{"text":"private pure subroutine destroy(self) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. Description Destroy field. Source Code pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % previous )) deallocate ( self % previous ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~12.html","title":"destroy – FOODIE"},{"text":"private subroutine update_previous_steps(self, filter, weights) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. Variables Type Visibility Attributes Name Initial integer, public :: s Time steps counter. Source Code subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, :, s ) = self % previous (:, :, s + 1 ) enddo self % previous (:, :, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( euler_1D ) do s = 1 , self % steps self % previous (:, :, s ) = self % previous (:, :, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps~2.html","title":"update_previous_steps – FOODIE"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) lhs % steps = rhs % steps lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler~5.html","title":"euler_assign_euler – FOODIE"},{"text":"private subroutine euler_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. Source Code subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real","tags":"","loc":"proc/euler_assign_real~3.html","title":"euler_assign_real – FOODIE"},{"text":"private pure subroutine impose_boundary_conditions(self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions~5.html","title":"impose_boundary_conditions – FOODIE"},{"text":"private pure subroutine reconstruct_interfaces_states(self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Calls proc~~reconstruct_interfaces_states~5~~CallsGraph proc~reconstruct_interfaces_states~5 reconstruct_interfaces_states none~eigen_vect_r~5 eigen_vect_R proc~reconstruct_interfaces_states~5->none~eigen_vect_r~5 none~eigen_vect_l~5 eigen_vect_L proc~reconstruct_interfaces_states~5->none~eigen_vect_l~5 proc~a~5 a none~eigen_vect_r~5->proc~a~5 none~eigen_vect_l~5->proc~a~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: C (1:2,1-self%Ng:-1+self%Ng,1:self%Ns+2) Pseudo characteristic variables. real(kind=R_P), public :: CR (1:self%Ns+2,1:2) Pseudo characteristic reconst. vars. real(kind=R_P), public :: Pm (1:self%Np,1:2) Mean of primitive variables. real(kind=R_P), public :: LPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean left eigenvectors matrix. real(kind=R_P), public :: RPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean right eigenvectors matrix. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: j Counter. integer(kind=I_P), public :: f Counter. integer(kind=I_P), public :: v Counter. Functions pure function eigen_vect_L(Ns, Np, primitive) result(L) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Left eigenvectors matrix. Description Compute left eigenvectors from primitive variables. pure function eigen_vect_R(Ns, Np, primitive) result(R) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Right eigenvectors matrix. Description Compute right eigenvectors from primitive variables. Source Code pure subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Ns => self % Ns , Np => self % Np , ord => self % ord , cv0 => self % cv0 , cp0 => self % cp0 , weno => self % weno ) select case ( ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = Ns , Np = Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = Ns , Np = Np , primitive = Pm (:, f )) enddo do j = i + 1 - Ng , i - 1 + Ng do f = 1 , 2 do v = 1 , Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : Ns + 2 , f ), primitive ( 1 : Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , Ns + 2 call weno % interpolate ( S = Ng , & stencil = C ( 1 : 2 , 1 - Ng : - 1 + Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : Ns + 2 , f ), CR ( 1 : Ns + 2 , f )) enddo r_primitive ( Ns + 3 , f , i ) = sum ( r_primitive ( 1 : Ns , f , i )) r_primitive ( Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cp0 ) / & dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cv0 ) enddo enddo endselect endassociate return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states~5.html","title":"reconstruct_interfaces_states – FOODIE"},{"text":"private pure subroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Calls proc~~riemann_solver~5~~CallsGraph proc~riemann_solver~5 riemann_solver none~fluxes~5 fluxes proc~riemann_solver~5->none~fluxes~5 proc~compute_inter_states~5 compute_inter_states proc~riemann_solver~5->proc~compute_inter_states~5 proc~e~5 E proc~riemann_solver~5->proc~e~5 proc~h~5 H none~fluxes~5->proc~h~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: F1 (1:3) State 1 fluxes. real(kind=R_P), public :: F4 (1:3) State 4 fluxes. real(kind=R_P), public :: u Velocity of the intermediate states. real(kind=R_P), public :: p Pressure of the intermediate states. real(kind=R_P), public :: S1 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: S4 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: lmax Maximum wave speed estimation. Functions pure function fluxes(p, r, u, g) result(Fc) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Velocity. real(kind=R_P), intent(in) :: g Specific heats ratio. Return Value real(kind=R_P)\n  (1:3) State fluxes. Description 1D Euler fluxes from primitive variables. Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver~5.html","title":"riemann_solver – FOODIE"},{"text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( euler_1D ), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~12.html","title":"finalize – FOODIE"},{"text":"private pure subroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Description Compute inter states (23*-states) from state1 and state4. Called By proc~~compute_inter_states~5~~CalledByGraph proc~compute_inter_states~5 compute_inter_states proc~riemann_solver~5 riemann_solver proc~riemann_solver~5->proc~compute_inter_states~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: a1 Speed of sound of state 1. real(kind=R_P), public :: a4 Speed of sound of state 4. real(kind=R_P), public :: ram Mean value of rho*a. real(kind=R_P), public, parameter :: toll = 1e-10_R_P Tollerance. Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states~5.html","title":"compute_inter_states – FOODIE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. Called By proc~~save_results~8~~CalledByGraph proc~save_results~8 save_results proc~test_tvd_rk~3 test_tvd_rk proc~test_tvd_rk~3->proc~save_results~8 proc~test_leapfrog~3 test_leapfrog proc~test_leapfrog~3->proc~save_results~8 proc~test_ls_rk~3 test_ls_rk proc~test_ls_rk~3->proc~save_results~8 proc~test_ab~3 test_ab proc~test_ab~3->proc~save_results~8 proc~test_euler~3 test_euler proc~test_euler~3->proc~save_results~8 program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_tvd_rk~3 program~integrate_lorenz->proc~test_leapfrog~3 program~integrate_lorenz->proc~test_ls_rk~3 program~integrate_lorenz->proc~test_ab~3 program~integrate_lorenz->proc~test_euler~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type( pyplot ), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: s Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\" \"z\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 3 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'x' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'y' , linestyle = 'b-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 3 , :), label = 'z' , linestyle = 'g-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'x-y path' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 3 , :), label = 'x-z path' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 2 , :), y = solution ( 3 , :), label = 'y-z path' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~8.html","title":"save_results – FOODIE"},{"text":"subroutine test_ab() Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Calls proc~~test_ab~3~~CallsGraph proc~test_ab~3 test_ab proc~save_results~8 save_results proc~test_ab~3->proc~save_results~8 str str proc~test_ab~3->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_ab~3~~CalledByGraph proc~test_ab~3 test_ab program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_ab~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( lorenz ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( adams_bashforth_integrator ), public :: ab_integrator Adams-Bashforth integrator. integer, public, parameter :: ab_steps = 4 Adams-Bashforth steps number. type( lorenz ), public :: previous (1:ab_steps) Previous time steps solutions. integer(kind=I_P), public :: s AB steps counter. integer, public :: step Time steps counter. Source Code subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( lorenz ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call ab_integrator % integrate ( U = attractor , previous = previous ( 1 : s ), dt = dt , t = solution ( 0 , step - s : step - 1 )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'lorenz_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab~3.html","title":"test_ab – FOODIE"},{"text":"subroutine test_euler() Arguments None Description Test explicit forward Euler ODE solver. Calls proc~~test_euler~3~~CallsGraph proc~test_euler~3 test_euler proc~save_results~8 save_results proc~test_euler~3->proc~save_results~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_euler~3~~CalledByGraph proc~test_euler~3 test_euler program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_euler~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( euler_explicit_integrator ), public :: euler_integrator Euler integrator. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of explicit Euler solver' call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call euler_integrator % integrate ( U = attractor , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Euler' , & filename = 'lorenz_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler~3.html","title":"test_euler – FOODIE"},{"text":"subroutine test_leapfrog() Arguments None Description Test explicit leapfrog class of ODE solvers. Calls proc~~test_leapfrog~3~~CallsGraph proc~test_leapfrog~3 test_leapfrog proc~save_results~8 save_results proc~test_leapfrog~3->proc~save_results~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_leapfrog~3~~CalledByGraph proc~test_leapfrog~3 test_leapfrog program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_leapfrog~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( lorenz ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( lorenz ), public :: filter Filter displacement. type( leapfrog_integrator ), public :: lf_integrator Leapfrog integrator. type( lorenz ), public :: previous (1:2) Previous time steps solutions. integer, public :: step Time steps counter. Source Code subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( lorenz ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( lorenz ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = 2 ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call lf_integrator % integrate ( U = attractor , previous = previous , dt = dt , t = solution ( 0 , step ), filter = filter ) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit leapfrog scheme' ,& filename = 'lorenz_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog","tags":"","loc":"proc/test_leapfrog~3.html","title":"test_leapfrog – FOODIE"},{"text":"subroutine test_ls_rk() Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. Calls proc~~test_ls_rk~3~~CallsGraph proc~test_ls_rk~3 test_ls_rk proc~save_results~8 save_results proc~test_ls_rk~3->proc~save_results~8 str str proc~test_ls_rk~3->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_ls_rk~3~~CalledByGraph proc~test_ls_rk~3 test_ls_rk program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_ls_rk~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( ls_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. integer, public, parameter :: registers = 2 Runge-Kutta stages number. type( lorenz ), public :: rk_stage (1:registers) Runge-Kutta stages. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit low storage Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'lorenz_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk","tags":"","loc":"proc/test_ls_rk~3.html","title":"test_ls_rk – FOODIE"},{"text":"subroutine test_tvd_rk() Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Calls proc~~test_tvd_rk~3~~CallsGraph proc~test_tvd_rk~3 test_tvd_rk proc~save_results~8 save_results proc~test_tvd_rk~3->proc~save_results~8 str str proc~test_tvd_rk~3->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_tvd_rk~3~~CalledByGraph proc~test_tvd_rk~3 test_tvd_rk program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_tvd_rk~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( lorenz ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit TVD Runge-Kutta ' // trim ( str (. true ., s )) // ' stages' ,& filename = 'lorenz_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk","tags":"","loc":"proc/test_tvd_rk~3.html","title":"test_tvd_rk – FOODIE"},{"text":"private pure function output(self) result(state) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value real(kind=R_P),\n  dimension(:),allocatable Lorenz state vector. Description Output the Lorenz field state. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Lorenz field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), dimension (:), allocatable :: state !< Lorenz state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~8.html","title":"output – FOODIE"},{"text":"private function dLorenz_dt(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Lorenz field time derivative. Description Time derivative of Lorenz field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: dn Time level, dummy variable. Source Code function dLorenz_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Lorenz field time derivative. integer ( I_P ) :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: dState_dt ) select type ( dState_dt ) class is ( lorenz ) dState_dt = self dState_dt % U ( 1 ) = self % sigma * ( self % U ( 2 ) - self % U ( 1 )) dState_dt % U ( 2 ) = self % U ( 1 ) * ( self % rho - self % U ( 3 )) - self % U ( 2 ) dState_dt % U ( 3 ) = self % U ( 1 ) * self % U ( 2 ) - self % beta * self % U ( 3 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dLorenz_dt","tags":"","loc":"proc/dlorenz_dt.html","title":"dLorenz_dt – FOODIE"},{"text":"private function previous_step(self, n) result(previous) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Lorenz field. Description Extract previous time solution of Lorenz field. Source Code function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: previous ) select type ( previous ) class is ( lorenz ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step","tags":"","loc":"proc/previous_step~3.html","title":"previous_step – FOODIE"},{"text":"private function lorenz_local_error(lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 lorenz approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code function lorenz_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 lorenz approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) error = 0._R_P do i = 1 , lhs % dims error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_local_error","tags":"","loc":"proc/lorenz_local_error.html","title":"lorenz_local_error – FOODIE"},{"text":"private function lorenz_multiply_lorenz(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a lorenz field by another one. Source Code function lorenz_multiply_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a lorenz field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_lorenz","tags":"","loc":"proc/lorenz_multiply_lorenz.html","title":"lorenz_multiply_lorenz – FOODIE"},{"text":"private function lorenz_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Lorenz field by a real scalar. Source Code function lorenz_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Lorenz field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_real","tags":"","loc":"proc/lorenz_multiply_real.html","title":"lorenz_multiply_real – FOODIE"},{"text":"private function real_multiply_lorenz(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( lorenz ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Lorenz field. Source Code function real_multiply_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( lorenz ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_lorenz","tags":"","loc":"proc/real_multiply_lorenz.html","title":"real_multiply_lorenz – FOODIE"},{"text":"private function add_lorenz(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Lorenz fields. Source Code function add_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Lorenz","tags":"","loc":"proc/add_lorenz.html","title":"add_lorenz – FOODIE"},{"text":"private function sub_lorenz(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Lorenz fields. Source Code function sub_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_lorenz","tags":"","loc":"proc/sub_lorenz.html","title":"sub_lorenz – FOODIE"},{"text":"private subroutine init(self, initial_state, sigma, rho, beta, steps) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Lorenz field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Time steps counter. Source Code subroutine init ( self , initial_state , sigma , rho , beta , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Initial state of Lorenz field vector. real ( R_P ), intent ( IN ) :: sigma !< Lorenz  \\sigma. real ( R_P ), intent ( IN ) :: rho !< Lorenz  \\rho. real ( R_P ), intent ( IN ) :: beta !< Lorenz  \\beta. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % dims )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % dims , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % sigma = sigma self % rho = rho self % beta = beta return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~23.html","title":"init – FOODIE"},{"text":"private subroutine update_previous_steps(self, filter, weights) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. Variables Type Visibility Attributes Name Initial integer, public :: s Time steps counter. Source Code subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( lorenz ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps~3.html","title":"update_previous_steps – FOODIE"},{"text":"private subroutine lorenz_assign_lorenz(lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Lorenz field to another. Source Code subroutine lorenz_assign_lorenz ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Lorenz field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) lhs % dims = rhs % dims lhs % steps = rhs % steps if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous lhs % sigma = rhs % sigma lhs % rho = rhs % rho lhs % beta = rhs % beta endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_lorenz","tags":"","loc":"proc/lorenz_assign_lorenz.html","title":"lorenz_assign_lorenz – FOODIE"},{"text":"private subroutine lorenz_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Lorenz field. Source Code subroutine lorenz_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_real","tags":"","loc":"proc/lorenz_assign_real.html","title":"lorenz_assign_real – FOODIE"},{"text":"private pure function Upper_Case(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be converted. Return Value character(len=len(string)) Converted string. Description Convert the lower case characters of a string to upper case one. Called By proc~~upper_case~~CalledByGraph proc~upper_case Upper_Case proc~add add proc~add->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. character(len=26), public, parameter :: upper_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' Upper case alphabet. character(len=26), public, parameter :: lower_alphabet = 'abcdefghijklmnopqrstuvwxyz' Lower case alphabet. Source Code pure function Upper_Case ( string ) ! elemental function Upper_Case(string) ! 1513-209 (S) The result of an elemental function must be a nonpointer, nonallocatable scalar, and its type parameters must be constant expressions. !--------------------------------------------------------------------------------------------------------------------------------- !< Convert the lower case characters of a string to upper case one. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len =* ), intent ( IN ) :: string !< String to be converted. character ( len = len ( string )) :: Upper_Case !< Converted string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. character ( len = 26 ), parameter :: upper_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( len = 26 ), parameter :: lower_alphabet = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Upper_Case = string do n1 = 1 , len ( string ) n2 = index ( lower_alphabet , string ( n1 : n1 )) if ( n2 > 0 ) Upper_Case ( n1 : n1 ) = upper_alphabet ( n2 : n2 ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction Upper_Case","tags":"","loc":"proc/upper_case.html","title":"Upper_Case – FOODIE"},{"text":"private function check_list_size_cla(cla, Nv, val, pref) result(is_ok) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I4P), intent(in) :: Nv Number of values. character(len=*), intent(in) :: val First value. character(len=*), intent(in), optional :: pref Prefixing string. Return Value logical Check result. Description Check CLA multiple values list size consistency. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code function check_list_size_cla ( cla , Nv , val , pref ) result ( is_ok ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA multiple values list size consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), intent ( IN ) :: Nv !< Number of values. character ( * ), intent ( IN ) :: val !< First value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical :: is_ok !< Check result. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref is_ok = . true . if ( Nv == 1 ) then if ( trim ( adjustl ( val )) == '' ) then ! there is no real value, but only for nargs=+ this is a real error is_ok = . false . if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction check_list_size_cla","tags":"","loc":"proc/check_list_size_cla.html","title":"check_list_size_cla – FOODIE"},{"text":"private function usage_cla(cla, pref) result(usage) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(in) :: cla CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Return Value character(len=:),\n  allocatable Usage string. Description Get correct CLA usage. Calls proc~~usage_cla~~CallsGraph proc~usage_cla usage_cla cton cton proc~usage_cla->cton str str proc~usage_cla->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: a Counter. Source Code function usage_cla ( cla , pref ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLA usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: usage !< Usage string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then prefd = '' ; if ( present ( pref )) prefd = pref if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then usage = '' select case ( cla % nargs ) case ( '+' ) usage = usage // ' value#1 [value#2...]' case ( '*' ) usage = usage // ' [value#1 value#2...]' case default do a = 1 , cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) usage = usage // ' value#' // trim ( str (. true ., a )) enddo endselect if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // usage // ', ' // trim ( adjustl ( cla % switch_ab )) // usage else usage = '   ' // trim ( adjustl ( cla % switch )) // usage endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ' value, ' // trim ( adjustl ( cla % switch_ab )) // ' value' else usage = '   ' // trim ( adjustl ( cla % switch )) // ' value' endif endif else usage = '  value' endif if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif elseif ( cla % act == action_store_star ) then usage = '  [value]' if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ', ' // trim ( adjustl ( cla % switch_ab )) else usage = '   ' // trim ( adjustl ( cla % switch )) endif endif usage = prefd // usage if ( cla % positional ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( str (. true ., cla % position )) // '-th argument' if ( allocated ( cla % envvar )) then if ( cla % envvar /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'environment variable name \"' // trim ( adjustl ( cla % envvar )) // '\"' endif endif if (. not . cla % required ) then if ( cla % def /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'default value ' // trim ( adjustl ( cla % def )) endif endif if ( cla % m_exclude /= '' ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'mutually exclude \"' // cla % m_exclude // '\"' usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( adjustl ( cla % help )) else usage = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_cla","tags":"","loc":"proc/usage_cla.html","title":"usage_cla – FOODIE"},{"text":"private function signature_cla(cla) result(signd) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(in) :: cla CLA data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLA signature for adding to the CLI one. Calls proc~~signature_cla~~CallsGraph proc~signature_cla signature_cla cton cton proc~signature_cla->cton str str proc~signature_cla->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: nargs Number of arguments consumed by CLA. integer(kind=I4P), public :: a Counter. Source Code function signature_cla ( cla ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: nargs !< Number of arguments consumed by CLA. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then select case ( cla % nargs ) case ( '+' ) signd = ' value#1 [value#2 value#3...]' case ( '*' ) signd = ' [value#1 value#2 value#3...]' case default nargs = cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) signd = '' do a = 1 , nargs signd = signd // ' value#' // trim ( str (. true ., a )) enddo endselect else signd = ' value' endif if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) // signd else signd = ' [' // trim ( adjustl ( cla % switch )) // signd // ']' endif else if ( cla % required ) then signd = ' value' else signd = ' [value]' endif endif elseif ( cla % act == action_store_star ) then signd = ' [value]' else if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) else signd = ' [' // trim ( adjustl ( cla % switch )) // ']' endif endif else signd = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_cla","tags":"","loc":"proc/signature_cla.html","title":"signature_cla – FOODIE"},{"text":"private pure function passed_clasg(clasg, switch, position) result(passed) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Description Check if a CLA has been passed. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: a CLA counter. Source Code pure function passed_clasg ( clasg , switch , position ) result ( passed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if ( clasg % Na > 0 ) then if ( present ( switch )) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then passed = clasg % cla ( a )% passed exit endif endif enddo elseif ( present ( position )) then passed = clasg % cla ( position )% passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed_clasg","tags":"","loc":"proc/passed_clasg.html","title":"passed_clasg – FOODIE"},{"text":"private function defined_clasg(clasg, switch, pos) result(defined) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in) :: switch Switch name. integer(kind=I4P), intent(out), optional :: pos CLA position. Return Value logical Check if a CLA has been defined. Description Check if a CLA has been defined. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: a CLA counter. Source Code function defined_clasg ( clasg , switch , pos ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( OUT ) :: pos !< CLA position. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if ( present ( pos )) pos = 0 if ( clasg % Na > 0 ) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_clasg","tags":"","loc":"proc/defined_clasg.html","title":"defined_clasg – FOODIE"},{"text":"private function usage_clasg(clasg, pref, no_header) result(usage) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. Return Value character(len=:),\n  allocatable Usage string. Description Get correct CLAs group usage. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: a Counters. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function usage_clasg ( clasg , pref , no_header ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAs group usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref usage = clasg % progname ; if ( clasg % group /= '' ) usage = clasg % progname // ' ' // clasg % group usage = prefd // clasg % help // ' ' // usage // clasg % signature () if ( clasg % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // clasg % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( clasg % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif if ( clasg % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , clasg % Na if (. not . clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_clasg","tags":"","loc":"proc/usage_clasg.html","title":"usage_clasg – FOODIE"},{"text":"private function signature_clasg(clasg) result(signd) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLAs group signature for adding to the CLI one. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: a Counters. Source Code function signature_clasg ( clasg ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs group signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = '' do a = 1 , clasg % Na signd = signd // clasg % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_clasg","tags":"","loc":"proc/signature_clasg.html","title":"signature_clasg – FOODIE"},{"text":"private function passed(cli, group, switch, position) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Description Check if a CLA has been passed. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g Counter. Source Code function passed ( cli , group , switch , position ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if (. not . present ( group )) then if ( present ( switch )) then passed = cli % clasg ( 0 )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( 0 )% passed ( position = position ) endif else if ( cli % defined_group ( group = group , g = g )) then if ( present ( switch )) then passed = cli % clasg ( g )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( g )% passed ( position = position ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed","tags":"","loc":"proc/passed.html","title":"passed – FOODIE"},{"text":"private function defined_group(cli, group, g) result(defined) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. integer(kind=I4P), intent(out), optional :: g Index of group. Return Value logical Check if a CLAs group has been defined. Description Check if a CLAs group has been defined. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: gg Counter. integer(kind=I4P), public :: ggg Counter. Source Code function defined_group ( cli , group , g ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. integer ( I4P ), optional , intent ( OUT ) :: g !< Index of group. logical :: defined !< Check if a CLAs group has been defined. integer ( I4P ) :: gg !< Counter. integer ( I4P ) :: ggg !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . do gg = 0 , size ( cli % clasg , dim = 1 ) - 1 ggg = gg if ( allocated ( cli % clasg ( gg )% group )) defined = ( cli % clasg ( gg )% group == group ) if ( defined ) exit enddo if ( present ( g )) g = ggg return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_group","tags":"","loc":"proc/defined_group.html","title":"defined_group – FOODIE"},{"text":"private function called_group(cli, group) result(called) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. Return Value logical Check if a CLAs group has been runned. Description Check if a CLAs group has been runned. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g Counter. Source Code function called_group ( cli , group ) result ( called ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been runned. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: called !< Check if a CLAs group has been runned. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- called = . false . if ( cli % defined_group ( group = group , g = g )) called = cli % clasg ( g )% called return !--------------------------------------------------------------------------------------------------------------------------------- endfunction called_group","tags":"","loc":"proc/called_group.html","title":"called_group – FOODIE"},{"text":"private function defined(cli, switch, group) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: switch Switch name. character(len=*), intent(in), optional :: group Name of group (command) of CLAs. Return Value logical Check if a CLA has been defined. Description Check if a CLA has been defined. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g Counter. Source Code function defined ( cli , switch , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if (. not . present ( group )) then defined = cli % clasg ( 0 )% defined ( switch = switch ) else if ( cli % defined_group ( group = group , g = g )) defined = cli % clasg ( g )% defined ( switch = switch ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined","tags":"","loc":"proc/defined.html","title":"defined – FOODIE"},{"text":"private function usage(cli, g, pref, no_header, no_examples, no_epilog) result(usaged) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. integer(kind=I4P), intent(in) :: g Group index. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: no_examples Avoid insert examples to usage. logical, intent(in), optional :: no_epilog Avoid insert epilogue to usage. Return Value character(len=:),\n  allocatable Usage string. Description Print correct usage of CLI. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: no_headerd Avoid insert header to usage. logical, public :: no_examplesd Avoid insert examples to usage. logical, public :: no_epilogd Avoid insert epilogue to usage. integer(kind=I4P), public :: gi Counter. integer(kind=I4P), public :: e Counter. Source Code function usage ( cli , g , pref , no_header , no_examples , no_epilog ) result ( usaged ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print correct usage of CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. integer ( I4P ), intent ( IN ) :: g !< Group index. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( IN ) :: no_examples !< Avoid insert examples to usage. logical , optional , intent ( IN ) :: no_epilog !< Avoid insert epilogue to usage. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len = :), allocatable :: usaged !< Usage string. logical :: no_headerd !< Avoid insert header to usage. logical :: no_examplesd !< Avoid insert examples to usage. logical :: no_epilogd !< Avoid insert epilogue to usage. integer ( I4P ) :: gi !< Counter. integer ( I4P ) :: e !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- no_headerd = . false . ; if ( present ( no_header )) no_headerd = no_header no_examplesd = . false . ; if ( present ( no_examples )) no_examplesd = no_examples no_epilogd = . false . ; if ( present ( no_epilog )) no_epilogd = no_epilog prefd = '' ; if ( present ( pref )) prefd = pref if ( g > 0 ) then ! usage of a specific command usaged = cli % clasg ( g )% usage ( pref = prefd , no_header = no_headerd ) else ! usage of whole CLI if ( no_headerd ) then usaged = '' else usaged = prefd // cli % help // cli % progname // ' ' // cli % signature () if ( cli % description /= '' ) usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // cli % description endif if ( cli % clasg ( 0 )% Na > 0 ) usaged = usaged // new_line ( 'a' ) // cli % clasg ( 0 )% usage ( pref = prefd , no_header = . true .) if ( size ( cli % clasg , dim = 1 ) > 1 ) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Commands:' do gi = 1 , size ( cli % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // cli % clasg ( gi )% group usaged = usaged // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // cli % clasg ( gi )% description enddo usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'For more detailed commands help try:' do gi = 1 , size ( cli % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // cli % progname // ' ' // cli % clasg ( gi )% group // ' -h,--help' enddo endif endif if ( allocated ( cli % examples ). and .(. not . no_examplesd )) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Examples:' do e = 1 , size ( cli % examples , dim = 1 ) usaged = usaged // new_line ( 'a' ) // prefd // '   ' // trim ( cli % examples ( e )) enddo endif if ( cli % epilog /= '' . and .(. not . no_epilogd )) usaged = usaged // new_line ( 'a' ) // prefd // cli % epilog return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage","tags":"","loc":"proc/usage.html","title":"usage – FOODIE"},{"text":"private function signature(cli) result(signd) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLI signature. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g Counter. Source Code function signature ( cli ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLI signature. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = cli % clasg ( 0 )% signature () if ( size ( cli % clasg , dim = 1 ) > 1 ) then signd = signd // ' {' // cli % clasg ( 1 )% group do g = 2 , size ( cli % clasg , dim = 1 ) - 1 signd = signd // ',' // cli % clasg ( g )% group enddo signd = signd // '} ...' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature","tags":"","loc":"proc/signature.html","title":"signature – FOODIE"},{"text":"private pure subroutine tokenize(strin, delimiter, toks, Nt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strin String to be tokenized. character(len=*), intent(in) :: delimiter Delimiter of tokens. character(len=len(strin)), intent(out), allocatable :: toks (:) Tokens. integer(kind=I4P), intent(out), optional :: Nt Number of tokens. Description Tokenize a string in order to parse it. Note The dummy array containing tokens must allocatable and its character elements must have the same length of the input\n string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with\n only one element set to char(0). Called By proc~~tokenize~2~~CalledByGraph proc~tokenize~2 tokenize proc~get_cla_list_varying_r8p get_cla_list_varying_R8P proc~get_cla_list_varying_r8p->proc~tokenize~2 none~sanitize_args sanitize_args none~sanitize_args->proc~tokenize~2 proc~get_cla_list_varying_i2p get_cla_list_varying_I2P proc~get_cla_list_varying_i2p->proc~tokenize~2 proc~get_cla_list_varying_r4p get_cla_list_varying_R4P proc~get_cla_list_varying_r4p->proc~tokenize~2 proc~get_cla_list get_cla_list proc~get_cla_list->proc~tokenize~2 proc~get_cla_list_varying_logical get_cla_list_varying_logical proc~get_cla_list_varying_logical->proc~tokenize~2 proc~get_cla_list_varying_i8p get_cla_list_varying_I8P proc~get_cla_list_varying_i8p->proc~tokenize~2 proc~get_cla_list_varying_char get_cla_list_varying_char proc~get_cla_list_varying_char->proc~tokenize~2 proc~get_cla_list_varying_i4p get_cla_list_varying_I4P proc~get_cla_list_varying_i4p->proc~tokenize~2 proc~get_cla_list_varying_r16p get_cla_list_varying_R16P proc~get_cla_list_varying_r16p->proc~tokenize~2 proc~get_args_from_string get_args_from_string proc~get_args_from_string->proc~tokenize~2 proc~get_args_from_string->none~sanitize_args proc~check_choices_cla check_choices_cla proc~check_choices_cla->proc~tokenize~2 proc~get_cla_list_varying_i1p get_cla_list_varying_I1P proc~get_cla_list_varying_i1p->proc~tokenize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=len(strin)), public :: strsub Temporary string. integer(kind=I4P), public :: dlen Delimiter length. integer(kind=I4P), public :: c Counter. integer(kind=I4P), public :: n Counter. integer(kind=I4P), public :: t Counter. Source Code pure subroutine tokenize ( strin , delimiter , toks , Nt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to char(0). !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( IN ) :: strin !< String to be tokenized. character ( len =* ), intent ( IN ) :: delimiter !< Delimiter of tokens. character ( len = len ( strin )), intent ( OUT ), allocatable :: toks (:) !< Tokens. integer ( I4P ), intent ( OUT ), optional :: Nt !< Number of tokens. character ( len = len ( strin )) :: strsub !< Temporary string. integer ( I4P ) :: dlen !< Delimiter length. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: n !< Counter. integer ( I4P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialization if ( allocated ( toks )) deallocate ( toks ) strsub = strin dlen = len ( delimiter ) if ( dlen > len ( strin )) then allocate ( toks ( 1 : 1 )) ; toks ( 1 ) = char ( 0 ) ; if ( present ( Nt )) Nt = 1 ; return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenization do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tokenize","tags":"","loc":"proc/tokenize~2.html","title":"tokenize – FOODIE"},{"text":"private elemental subroutine free_object(obj) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: obj Object data. Description Free dynamic memory. Source Code elemental subroutine free_object ( obj ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: obj !< Object data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( obj % progname )) deallocate ( obj % progname ) if ( allocated ( obj % version )) deallocate ( obj % version ) if ( allocated ( obj % help )) deallocate ( obj % help ) if ( allocated ( obj % description )) deallocate ( obj % description ) if ( allocated ( obj % license )) deallocate ( obj % license ) if ( allocated ( obj % authors )) deallocate ( obj % authors ) if ( allocated ( obj % epilog )) deallocate ( obj % epilog ) if ( allocated ( obj % m_exclude )) deallocate ( obj % m_exclude ) obj % error = 0_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_object","tags":"","loc":"proc/free_object.html","title":"free_object – FOODIE"},{"text":"private subroutine errored(obj, error, pref, group, switch, val_str, log_value, a1, a2) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: obj Object data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Group name. character(len=*), intent(in), optional :: switch CLA switch name. character(len=*), intent(in), optional :: val_str Value string. character(len=*), intent(in), optional :: log_value Logical value to be casted. integer(kind=I4P), intent(in), optional :: a1 First index CLAs group inconsistent. integer(kind=I4P), intent(in), optional :: a2 Second index CLAs group inconsistent. Description Trig error occurence and print meaningful message. Calls proc~~errored~~CallsGraph proc~errored errored str str proc~errored->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code subroutine errored ( obj , error , pref , group , switch , val_str , log_value , a1 , a2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Trig error occurence and print meaningful message. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: obj !< Object data. integer ( I4P ), intent ( IN ) :: error !< Error occurred. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Group name. character ( * ), optional , intent ( IN ) :: switch !< CLA switch name. character ( * ), optional , intent ( IN ) :: val_str !< Value string. character ( * ), optional , intent ( IN ) :: log_value !< Logical value to be casted. integer ( I4P ), optional , intent ( IN ) :: a1 !< First index CLAs group inconsistent. integer ( I4P ), optional , intent ( IN ) :: a2 !< Second index CLAs group inconsistent. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- obj % error = error if ( obj % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref select type ( obj ) class is ( Type_Command_Line_Argument ) select case ( obj % error ) case ( error_cla_optional_no_def ) if ( obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str ( n = obj % position )) // & '-th\" positional option has not a default value!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // obj % switch // '\" has not a default value!' endif case ( error_cla_required_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // obj % switch // '\" cannot exclude others' // & ', it being requiredi, only optional ones can!' case ( error_cla_positional_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str ( n = obj % position )) // & '-th\" positional option cannot exclude others, only optional named options can!' case ( error_cla_named_no_name ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a non positional optiona must have a switch name!' case ( error_cla_positional_no_position ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a positional option must have a position number different from 0!' case ( error_cla_positional_no_store ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a positional option must have action set to \"' // action_store // '\"!' case ( error_cla_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: the options \"' // obj % switch // '\" and \"' // obj % m_exclude // '\" are mutually' // & ' exclusive, but both have been passed!' case ( error_cla_not_in_choices ) if ( obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: value of \"' // trim ( str ( n = obj % position )) // & '-th\" positional option must be chosen in:' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: value of named option \"' // obj % switch // '\" must be chosen in:' endif write ( stderr , '(A)' ) prefd // '(' // obj % choices // ')' write ( stderr , '(A)' ) prefd // '\"' // trim ( val_str ) // '\" has been passed!' case ( error_cla_missing_required ) if (. not . obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" is required!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option is required!' endif case ( error_cla_casting_logical ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: cannot convert \"' // log_value // '\" of option \"' // obj % switch // & '\" to logical type!' case ( error_cla_choices_logical ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: cannot use \"choices\" value check for option \"' // obj % switch // & '\" it being of logical type! The choices is, by definition of logical, limited to \".true.\" or \".false.\"' case ( error_cla_no_list ) if (. not . obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" has not \"nargs\" value' // & ' but an array has been passed to \"get\" method!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has not \"nargs\" value but an array has been passed to \"get\" method!' endif case ( error_cla_nargs_insufficient ) if (. not . obj % positional ) then if ( obj % nargs == '+' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" requires at least ' // & '1 argument but no one remains!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" requires ' // & trim ( adjustl ( obj % nargs )) // ' arguments but no enough ones remain!' endif else if ( obj % nargs == '+' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option requires at least 1 argument but no one remains' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option requires ' // & trim ( adjustl ( obj % nargs )) // ' arguments but no enough ones remain!' endif endif case ( error_cla_value_missing ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" needs a value that is not passed!' case ( error_cla_unknown ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: switch \"' // trim ( adjustl ( switch )) // '\" is unknown!' case ( error_cla_envvar_positional ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has \"envvar\" value that is not allowed for positional option!' case ( error_cla_envvar_not_store ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" is an envvar with action different from \"' // action_store // '\" that is not allowed!' case ( error_cla_envvar_nargs ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" is an envvar that is not allowed for list valued option!' case ( error_cla_store_star_positional ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has \"' // action_store_star // '\" action that is not allowed for positional option!' case ( error_cla_store_star_nargs ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for list valued option!' case ( error_cla_store_star_envvar ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for environment variable option!' case ( error_cla_action_unknown ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has unknown \"' // obj % act // '\" action!' endselect class is ( Type_Command_Line_Arguments_Group ) select case ( obj % error ) case ( error_clasg_consistency ) if ( obj % group /= '' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: group (command) name: \"' // obj % group // '\" consistency error:' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: consistency error:' endif write ( stderr , '(A)' ) prefd // ' \"' // trim ( str (. true ., a1 )) // '-th\" option has the same switch or abbreviated switch of \"' & // trim ( str (. true ., a2 )) // '-th\" option:' write ( stderr , '(A)' ) prefd // ' CLA(' // trim ( str (. true ., a1 )) // ') switches = ' // obj % cla ( a1 )% switch // ' ' // & obj % cla ( a1 )% switch_ab write ( stderr , '(A)' ) prefd // ' CLA(' // trim ( str (. true ., a2 )) // ') switches = ' // obj % cla ( a2 )% switch // ' ' // & obj % cla ( a2 )% switch_ab case ( error_clasg_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: the group \"' // obj % group // '\" and \"' // obj % m_exclude // '\" are mutually' // & ' exclusive, but both have been called!' endselect class is ( Type_Command_Line_Interface ) select case ( obj % error ) case ( error_cli_missing_cla ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: there is no option \"' // trim ( adjustl ( switch )) // '\"!' case ( error_cli_missing_selection_cla ) write ( stderr , '(A)' ) prefd // obj % progname // & ': error: to get an option value one of switch \"name\" or \"position\" must be provided!' case ( error_cli_missing_group ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: ther is no group (command) named \"' // trim ( adjustl ( group )) // '\"!' case ( error_cli_too_few_clas ) ! write(stderr,'(A)')prefd//obj%progname//': error: too few arguments ('//trim(str(.true.,Na))//')'//& ! ' respect the required ('//trim(str(.true.,obj%Na_required))//')' endselect endselect write ( stderr , '(A)' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine errored","tags":"","loc":"proc/errored.html","title":"errored – FOODIE"},{"text":"private subroutine print_version(obj, pref) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(in) :: obj Object data. character(len=*), intent(in), optional :: pref Prefixing string. Description Print version. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code subroutine print_version ( obj , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print version. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( IN ) :: obj !< Object data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref write ( stdout , '(A)' ) prefd // obj % progname // ' version ' // obj % version if ( obj % license /= '' ) then write ( stdout , '(A)' ) prefd // obj % license endif if ( obj % authors /= '' ) then write ( stdout , '(A)' ) prefd // obj % authors endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_version","tags":"","loc":"proc/print_version.html","title":"print_version – FOODIE"},{"text":"private elemental subroutine assign_object(lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: lhs Left hand side. class( Type_Object ), intent(in) :: rhs Rigth hand side. Description Assign two abstract objects. Source Code elemental subroutine assign_object ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign two abstract objects. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: lhs !< Left hand side. class ( Type_Object ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members if ( allocated ( rhs % progname )) lhs % progname = rhs % progname if ( allocated ( rhs % version )) lhs % version = rhs % version if ( allocated ( rhs % help )) lhs % help = rhs % help if ( allocated ( rhs % description )) lhs % description = rhs % description if ( allocated ( rhs % license )) lhs % license = rhs % license if ( allocated ( rhs % authors )) lhs % authors = rhs % authors if ( allocated ( rhs % epilog )) lhs % epilog = rhs % epilog if ( allocated ( rhs % m_exclude )) lhs % m_exclude = rhs % m_exclude lhs % error = rhs % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_object","tags":"","loc":"proc/assign_object.html","title":"assign_object – FOODIE"},{"text":"private elemental subroutine free_cla(cla) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. Description Free dynamic memory. Source Code elemental subroutine free_cla ( cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cla % free_object ! Type_Command_Line_Argument members if ( allocated ( cla % switch )) deallocate ( cla % switch ) if ( allocated ( cla % switch_ab )) deallocate ( cla % switch_ab ) if ( allocated ( cla % act )) deallocate ( cla % act ) if ( allocated ( cla % def )) deallocate ( cla % def ) if ( allocated ( cla % nargs )) deallocate ( cla % nargs ) if ( allocated ( cla % choices )) deallocate ( cla % choices ) if ( allocated ( cla % val )) deallocate ( cla % val ) if ( allocated ( cla % envvar )) deallocate ( cla % envvar ) cla % required = . false . cla % positional = . false . cla % position = 0_I4P cla % passed = . false . cla % hidden = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_cla","tags":"","loc":"proc/free_cla.html","title":"free_cla – FOODIE"},{"text":"private elemental subroutine finalize_cla(cla) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. Description Free dynamic memory when finalizing. Source Code elemental subroutine finalize_cla ( cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cla % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_cla","tags":"","loc":"proc/finalize_cla.html","title":"finalize_cla – FOODIE"},{"text":"private subroutine check_cla(cla, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check CLA data consistency. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code subroutine check_cla ( cla , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( allocated ( cla % envvar )) then if ( cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_envvar_positional ) return endif if (. not . allocated ( cla % act )) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return else if ( cla % act /= action_store ) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return endif endif if ( allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_envvar_nargs ) return endif endif if ( allocated ( cla % act )) then if ( cla % act == action_store_star . and . cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_store_star_positional ) return endif if ( cla % act == action_store_star . and . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_store_star_nargs ) return endif if ( cla % act == action_store_star . and . allocated ( cla % envvar )) then call cla % errored ( pref = prefd , error = error_cla_store_star_envvar ) return endif if ( cla % act /= action_store . and . & cla % act /= action_store_star . and . & cla % act /= action_store_true . and . & cla % act /= action_store_false . and .& cla % act /= action_print_help . and . & cla % act /= action_print_vers ) then call cla % errored ( pref = prefd , error = error_cla_action_unknown ) return endif endif if ((. not . cla % required ). and .(. not . allocated ( cla % def ))) then call cla % errored ( pref = prefd , error = error_cla_optional_no_def ) return endif if (( cla % required ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_required_m_exclude ) return endif if (( cla % positional ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_positional_m_exclude ) return endif if ((. not . cla % positional ). and .(. not . allocated ( cla % switch ))) then call cla % errored ( pref = prefd , error = error_cla_named_no_name ) return elseif (( cla % positional ). and .( cla % position == 0_I4P )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_position ) return elseif (( cla % positional ). and .( cla % act /= action_store )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_store ) return endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_cla","tags":"","loc":"proc/check_cla.html","title":"check_cla – FOODIE"},{"text":"private subroutine check_choices_cla(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. class(*), intent(in) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if CLA value is in allowed choices. Note This procedure can be called if and only if cla%choices has been allocated. Calls proc~~check_choices_cla~~CallsGraph proc~check_choices_cla check_choices_cla proc~tokenize~2 tokenize proc~check_choices_cla->proc~tokenize~2 str str proc~check_choices_cla->str cton cton proc~check_choices_cla->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. character(len=len(cla%choices)), public, allocatable :: toks (:) Tokens for parsing choices list. integer(kind=I4P), public :: Nc Number of choices. logical, public :: val_in Flag for checking if val is in the choosen range. character(len=:), public, allocatable :: val_str Value in string form. character(len=:), public, allocatable :: tmp Temporary string for avoiding GNU gfrotran bug. integer(kind=I4P), public :: c Counter. Source Code subroutine check_choices_cla ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if CLA value is in allowed choices. !< !< @note This procedure can be called if and only if cla%choices has been allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. class ( * ), intent ( IN ) :: val !< CLA value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len ( cla % choices )), allocatable :: toks (:) !< Tokens for parsing choices list. integer ( I4P ) :: Nc !< Number of choices. logical :: val_in !< Flag for checking if val is in the choosen range. character ( len = :), allocatable :: val_str !< Value in string form. character ( len = :), allocatable :: tmp !< Temporary string for avoiding GNU gfrotran bug. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- val_in = . false . val_str = '' tmp = cla % choices call tokenize ( strin = tmp , delimiter = ',' , toks = toks , Nt = Nc ) select type ( val ) #ifdef r16p type is ( real ( R16P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R16P )) val_in = . true . enddo #endif type is ( real ( R8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R8P )) val_in = . true . enddo type is ( real ( R4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R4P )) val_in = . true . enddo type is ( integer ( I8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I8P )) val_in = . true . enddo type is ( integer ( I4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I4P )) val_in = . true . enddo type is ( integer ( I2P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I2P )) val_in = . true . enddo type is ( integer ( I1P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I1P )) val_in = . true . enddo type is ( character ( * )) val_str = val do c = 1 , Nc if ( val == toks ( c )) val_in = . true . enddo type is ( logical ) prefd = '' ; if ( present ( pref )) prefd = pref call cla % errored ( pref = prefd , error = error_cla_choices_logical ) endselect if (. not . val_in . and .( cla % error == 0 )) then prefd = '' ; if ( present ( pref )) prefd = pref call cla % errored ( pref = prefd , error = error_cla_not_in_choices , val_str = val_str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_choices_cla","tags":"","loc":"proc/check_choices_cla.html","title":"check_choices_cla – FOODIE"},{"text":"private subroutine get_cla(cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val CLA value. Description Get CLA (single) value. Calls proc~~get_cla~~CallsGraph proc~get_cla get_cla cton cton proc~get_cla->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code subroutine get_cla ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val !< CLA value. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if ( cla % act == action_store . or . cla % act == action_store_star ) then if ( cla % passed . and . allocated ( cla % val )) then select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I1P ) type is ( logical ) read ( cla % val , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % val ) type is ( character ( * )) val = cla % val endselect elseif ( allocated ( cla % def )) then ! using default value select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I1P ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) type is ( character ( * )) val = cla % def endselect endif if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val , pref = prefd ) elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla","tags":"","loc":"proc/get_cla.html","title":"get_cla – FOODIE"},{"text":"private subroutine get_cla_list(cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. Description Get CLA (multiple) value. Calls proc~~get_cla_list~~CallsGraph proc~get_cla_list get_cla_list proc~tokenize~2 tokenize proc~get_cla_list->proc~tokenize~2 cton cton proc~get_cla_list->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val ( 1 :) !< CLA values. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsV ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsD ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect endif elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list","tags":"","loc":"proc/get_cla_list.html","title":"get_cla_list – FOODIE"},{"text":"private subroutine get_cla_list_varying_R16P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R16P). Calls proc~~get_cla_list_varying_r16p~~CallsGraph proc~get_cla_list_varying_r16p get_cla_list_varying_R16P proc~tokenize~2 tokenize proc~get_cla_list_varying_r16p->proc~tokenize~2 cton cton proc~get_cla_list_varying_r16p->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_R16P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R16P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return if ( Nv == 1 ) then if ( trim ( adjustl ( valsD ( 1 ))) == '' ) then if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif return endif endif allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P","tags":"","loc":"proc/get_cla_list_varying_r16p.html","title":"get_cla_list_varying_R16P – FOODIE"},{"text":"private subroutine get_cla_list_varying_R8P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R8P). Calls proc~~get_cla_list_varying_r8p~~CallsGraph proc~get_cla_list_varying_r8p get_cla_list_varying_R8P proc~tokenize~2 tokenize proc~get_cla_list_varying_r8p->proc~tokenize~2 cton cton proc~get_cla_list_varying_r8p->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_R8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P","tags":"","loc":"proc/get_cla_list_varying_r8p.html","title":"get_cla_list_varying_R8P – FOODIE"},{"text":"private subroutine get_cla_list_varying_R4P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R4P). Calls proc~~get_cla_list_varying_r4p~~CallsGraph proc~get_cla_list_varying_r4p get_cla_list_varying_R4P proc~tokenize~2 tokenize proc~get_cla_list_varying_r4p->proc~tokenize~2 cton cton proc~get_cla_list_varying_r4p->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_R4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P","tags":"","loc":"proc/get_cla_list_varying_r4p.html","title":"get_cla_list_varying_R4P – FOODIE"},{"text":"private subroutine get_cla_list_varying_I8P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I8P). Calls proc~~get_cla_list_varying_i8p~~CallsGraph proc~get_cla_list_varying_i8p get_cla_list_varying_I8P proc~tokenize~2 tokenize proc~get_cla_list_varying_i8p->proc~tokenize~2 cton cton proc~get_cla_list_varying_i8p->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_I8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P","tags":"","loc":"proc/get_cla_list_varying_i8p.html","title":"get_cla_list_varying_I8P – FOODIE"},{"text":"private subroutine get_cla_list_varying_I4P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I4P). Calls proc~~get_cla_list_varying_i4p~~CallsGraph proc~get_cla_list_varying_i4p get_cla_list_varying_I4P proc~tokenize~2 tokenize proc~get_cla_list_varying_i4p->proc~tokenize~2 cton cton proc~get_cla_list_varying_i4p->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_I4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P","tags":"","loc":"proc/get_cla_list_varying_i4p.html","title":"get_cla_list_varying_I4P – FOODIE"},{"text":"private subroutine get_cla_list_varying_I2P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I2P). Calls proc~~get_cla_list_varying_i2p~~CallsGraph proc~get_cla_list_varying_i2p get_cla_list_varying_I2P proc~tokenize~2 tokenize proc~get_cla_list_varying_i2p->proc~tokenize~2 cton cton proc~get_cla_list_varying_i2p->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_I2P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I2P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P","tags":"","loc":"proc/get_cla_list_varying_i2p.html","title":"get_cla_list_varying_I2P – FOODIE"},{"text":"private subroutine get_cla_list_varying_I1P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I1P). Calls proc~~get_cla_list_varying_i1p~~CallsGraph proc~get_cla_list_varying_i1p get_cla_list_varying_I1P proc~tokenize~2 tokenize proc~get_cla_list_varying_i1p->proc~tokenize~2 cton cton proc~get_cla_list_varying_i1p->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_I1P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I1P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P","tags":"","loc":"proc/get_cla_list_varying_i1p.html","title":"get_cla_list_varying_I1P – FOODIE"},{"text":"private subroutine get_cla_list_varying_logical(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, logical. Calls proc~~get_cla_list_varying_logical~~CallsGraph proc~get_cla_list_varying_logical get_cla_list_varying_logical proc~tokenize~2 tokenize proc~get_cla_list_varying_logical->proc~tokenize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_logical ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, logical. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. logical , allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical","tags":"","loc":"proc/get_cla_list_varying_logical.html","title":"get_cla_list_varying_logical – FOODIE"},{"text":"private subroutine get_cla_list_varying_char(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, character. Calls proc~~get_cla_list_varying_char~~CallsGraph proc~get_cla_list_varying_char get_cla_list_varying_char proc~tokenize~2 tokenize proc~get_cla_list_varying_char->proc~tokenize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_char ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, character. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsV ( v ))) enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsD ( v ))) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char","tags":"","loc":"proc/get_cla_list_varying_char.html","title":"get_cla_list_varying_char – FOODIE"},{"text":"private elemental subroutine assign_cla(lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Argument ), intent(in) :: rhs Rigth hand side. Description Assign two CLA. Source Code elemental subroutine assign_cla ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign two CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Argument ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Argument members if ( allocated ( rhs % switch )) lhs % switch = rhs % switch if ( allocated ( rhs % switch_ab )) lhs % switch_ab = rhs % switch_ab if ( allocated ( rhs % act )) lhs % act = rhs % act if ( allocated ( rhs % def )) lhs % def = rhs % def if ( allocated ( rhs % nargs )) lhs % nargs = rhs % nargs if ( allocated ( rhs % choices )) lhs % choices = rhs % choices if ( allocated ( rhs % val )) lhs % val = rhs % val if ( allocated ( rhs % envvar )) lhs % envvar = rhs % envvar lhs % required = rhs % required lhs % positional = rhs % positional lhs % position = rhs % position lhs % passed = rhs % passed lhs % hidden = rhs % hidden return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_cla","tags":"","loc":"proc/assign_cla.html","title":"assign_cla – FOODIE"},{"text":"private elemental subroutine free_clasg(clasg) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. Description Free dynamic memory. Source Code elemental subroutine free_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call clasg % free_object ! Type_Command_Line_Arguments_Group members if ( allocated ( clasg % group )) deallocate ( clasg % group ) if ( allocated ( clasg % cla )) then call clasg % cla % free deallocate ( clasg % cla ) endif clasg % Na = 0_I4P clasg % Na_required = 0_I4P clasg % Na_optional = 0_I4P clasg % called = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_clasg","tags":"","loc":"proc/free_clasg.html","title":"free_clasg – FOODIE"},{"text":"private elemental subroutine finalize_clasg(clasg) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. Description Free dynamic memory when finalizing. Source Code elemental subroutine finalize_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call clasg % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_clasg","tags":"","loc":"proc/finalize_clasg.html","title":"finalize_clasg – FOODIE"},{"text":"private subroutine check_clasg(clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check CLA data consistency. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: a Counter. integer(kind=I4P), public :: aa Counter. Source Code subroutine check_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! verifing if CLAs switches are unique CLA_unique : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then do aa = 1 , clasg % Na if (( a /= aa ). and .(. not . clasg % cla ( aa )% positional )) then if (( clasg % cla ( a )% switch == clasg % cla ( aa )% switch ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch ). or .& ( clasg % cla ( a )% switch == clasg % cla ( aa )% switch_ab ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch_ab )) then call clasg % errored ( pref = prefd , error = error_clasg_consistency , a1 = a , a2 = aa ) exit CLA_unique endif endif enddo endif enddo CLA_unique ! updating mutually exclusive relations CLA_exclude : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % defined ( switch = clasg % cla ( a )% m_exclude , pos = aa )) then clasg % cla ( aa )% m_exclude = clasg % cla ( a )% switch endif endif endif enddo CLA_exclude return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_clasg","tags":"","loc":"proc/check_clasg.html","title":"check_clasg – FOODIE"},{"text":"private subroutine check_required_clasg(clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if required CLAs are passed. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: a Counter. Source Code subroutine check_required_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLAs are passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( clasg % called ) then do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) then if (. not . clasg % cla ( a )% passed ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_missing_required ) clasg % error = clasg % cla ( a )% error write ( stdout , '(A)' ) clasg % usage ( pref = prefd ) return endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_required_clasg","tags":"","loc":"proc/check_required_clasg.html","title":"check_required_clasg – FOODIE"},{"text":"private subroutine check_m_exclusive_clasg(clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if two mutually exclusive CLAs have been passed. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: a Counter. Source Code subroutine check_m_exclusive_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs have been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref do a = 1 , clasg % Na if ( clasg % cla ( a )% passed ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % passed ( switch = clasg % cla ( a )% m_exclude )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_m_exclude ) clasg % error = clasg % cla ( a )% error return endif endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive_clasg","tags":"","loc":"proc/check_m_exclusive_clasg.html","title":"check_m_exclusive_clasg – FOODIE"},{"text":"private subroutine add_cla_clasg(clasg, pref, cla) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. type( Type_Command_Line_Argument ), intent(in) :: cla CLA data. Description Add CLA to CLAs list. Note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name\n or directly passed in case of positional CLA. Variables Type Visibility Attributes Name Initial type( Type_Command_Line_Argument ), public, allocatable :: cla_list_new (:) New (extended) CLA list. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: c Counter. Source Code subroutine add_cla_clasg ( clasg , pref , cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. type ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. type ( Type_Command_Line_Argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % Na > 0_I4P ) then if (. not . cla % positional ) then allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , clasg % Na cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( clasg % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , clasg % Na + 1 cla_list_new ( c ) = clasg % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = clasg % cla ) clasg % Na = clasg % Na + 1 if ( cla % required ) then clasg % Na_required = clasg % Na_required + 1 else clasg % Na_optional = clasg % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) prefd = '' ; if ( present ( pref )) prefd = pref call clasg % check ( pref = prefd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_cla_clasg","tags":"","loc":"proc/add_cla_clasg.html","title":"add_cla_clasg – FOODIE"},{"text":"private subroutine parse_clasg(clasg, pref, args) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in) :: args (:) Command line arguments. Description Parse CLAs group arguments. Calls proc~~parse_clasg~~CallsGraph proc~parse_clasg parse_clasg cton cton proc~parse_clasg->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=500), public :: envvar Environment variables buffer. integer(kind=I4P), public :: arg Argument counter. integer(kind=I4P), public :: a Counter. integer(kind=I4P), public :: aa Counter. integer(kind=I4P), public :: aaa Counter. integer(kind=I4P), public :: nargs Number of arguments consumed by a CLA. character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if switch is a defined CLA. logical, public :: found_val Flag for checking if switch value is found. Source Code subroutine parse_clasg ( clasg , pref , args ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAs group arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), intent ( IN ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , clasg % Na ! loop ver CLAs group clas named options if (. not . clasg % cla ( a )% positional ) then if ( trim ( adjustl ( clasg % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( clasg % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( clasg % cla ( a )% act == action_store ) then found_val = . false . if ( allocated ( clasg % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = clasg % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then clasg % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) then clasg % cla ( a )% val = clasg % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( clasg % cla ( a )% nargs )) then clasg % cla ( a )% val = '' select case ( clasg % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( clasg % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) enddo arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_value_missing ) clasg % error = clasg % cla ( a )% error return endif arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( clasg % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . endif endif if (. not . found ) then ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) clasg % cla ( a )% val = clasg % cla ( a )% def endif elseif ( clasg % cla ( a )% act == action_print_help ) then clasg % error = status_clasg_print_h elseif ( clasg % cla ( a )% act == action_print_vers ) then clasg % error = status_clasg_print_v endif clasg % cla ( a )% passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . clasg % cla ( arg )% positional ) then ! current argument (arg-th) is not positional... there is a problem! call clasg % cla ( arg )% errored ( pref = prefd , error = error_cla_unknown , switch = trim ( adjustl ( args ( arg )))) clasg % error = clasg % cla ( arg )% error return else ! positional CLA always stores a value clasg % cla ( arg )% val = trim ( adjustl ( args ( arg ))) clasg % cla ( arg )% passed = . true . endif endif enddo call clasg % check_m_exclusive ( pref = prefd ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_clasg","tags":"","loc":"proc/parse_clasg.html","title":"parse_clasg – FOODIE"},{"text":"private elemental subroutine assign_clasg(lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Arguments_Group ), intent(in) :: rhs Right hand side. Description Assign two CLASg. Source Code elemental subroutine assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign two CLASg. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Arguments_Group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % called = rhs % called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_clasg","tags":"","loc":"proc/assign_clasg.html","title":"assign_clasg – FOODIE"},{"text":"private elemental subroutine free(cli) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. Description Free dynamic memory. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g Counter. Source Code elemental subroutine free ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cli % free_object ! Type_Command_Line_Interface members if ( allocated ( cli % clasg )) then do g = 0 , size ( cli % clasg , dim = 1 ) - 1 call cli % clasg ( g )% free enddo deallocate ( cli % clasg ) endif if ( allocated ( cli % examples )) deallocate ( cli % examples ) cli % disable_hv = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free.html","title":"free – FOODIE"},{"text":"private elemental subroutine finalize(cli) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. Description Free dynamic memory when finalizing. Source Code elemental subroutine finalize ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~13.html","title":"finalize – FOODIE"},{"text":"private subroutine init(cli, progname, version, help, description, license, authors, examples, epilog, disable_hv) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: progname Program name. character(len=*), intent(in), optional :: version Program version. character(len=*), intent(in), optional :: help Help message introducing the CLI usage. character(len=*), intent(in), optional :: description Detailed description message introducing the program. character(len=*), intent(in), optional :: license License description. character(len=*), intent(in), optional :: authors Authors list. character(len=*), intent(in), optional :: examples (1:) Examples of correct usage. character(len=*), intent(in), optional :: epilog Epilog message. logical, intent(in), optional :: disable_hv Disable automatic insert of 'help' and 'version' CLAs. Description Initialize CLI. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prog_invocation Complete program invocation. integer(kind=I4P), public :: invocation_length Length of invocation. integer(kind=I4P), public :: retrieval_status Retrieval status. Source Code subroutine init ( cli , progname , version , help , description , license , authors , examples , epilog , disable_hv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: progname !< Program name. character ( * ), optional , intent ( IN ) :: version !< Program version. character ( * ), optional , intent ( IN ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( IN ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( IN ) :: license !< License description. character ( * ), optional , intent ( IN ) :: authors !< Authors list. character ( * ), optional , intent ( IN ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( IN ) :: epilog !< Epilog message. logical , optional , intent ( IN ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free if ( present ( progname )) then cli % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then cli % progname = prog_invocation else cli % progname = 'program' endif endif cli % version = 'unknown' ; if ( present ( version )) cli % version = version cli % help = 'usage: ' ; if ( present ( help )) cli % help = help cli % description = '' ; if ( present ( description )) cli % description = description cli % license = '' ; if ( present ( license )) cli % license = license cli % authors = '' ; if ( present ( authors )) cli % authors = authors cli % epilog = '' ; if ( present ( epilog )) cli % epilog = epilog if ( present ( disable_hv )) cli % disable_hv = disable_hv if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( cli % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: cli % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif cli % examples = examples endif ! initialize only the first default group allocate ( cli % clasg ( 0 : 0 )) call cli % clasg ( 0 )% assign_object ( cli ) cli % clasg ( 0 )% group = '' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~24.html","title":"init – FOODIE"},{"text":"private subroutine add_group(cli, help, description, exclude, group) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: help Help message. character(len=*), intent(in), optional :: description Detailed description. character(len=*), intent(in), optional :: exclude Group name of the mutually exclusive group. character(len=*), intent(in) :: group Name of the grouped CLAs. Description Add CLAs group to CLI. Variables Type Visibility Attributes Name Initial type( Type_Command_Line_Arguments_Group ), public, allocatable :: clasg_list_new (:) New (extended) CLAs group list. character(len=:), public, allocatable :: helpd Help message. character(len=:), public, allocatable :: descriptiond Detailed description. character(len=:), public, allocatable :: excluded Group name of the mutually exclusive group. integer(kind=I4P), public :: Ng Number of groups. integer(kind=I4P), public :: gi Group index Source Code subroutine add_group ( cli , help , description , exclude , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLAs group to CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: help !< Help message. character ( * ), optional , intent ( IN ) :: description !< Detailed description. character ( * ), optional , intent ( IN ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( IN ) :: group !< Name of the grouped CLAs. type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. integer ( I4P ) :: gi !< Group index !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cli % defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( cli % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) !    clasg_list_new(0:Ng-1) = cli%clasg(0:Ng-1) ! Not working on Intel Fortran 15.0.2 do gi = 0 , Ng - 1 clasg_list_new ( gi ) = cli % clasg ( gi ) enddo call clasg_list_new ( Ng )% assign_object ( cli ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( cli % clasg ) allocate ( cli % clasg ( 0 : Ng )) cli % clasg = clasg_list_new deallocate ( clasg_list_new ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_group","tags":"","loc":"proc/add_group.html","title":"add_group – FOODIE"},{"text":"private subroutine set_mutually_exclusive_groups(cli, group1, group2) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in) :: group1 Name of the first grouped CLAs. character(len=*), intent(in) :: group2 Name of the second grouped CLAs. Description Set two CLAs group ad mutually exclusive. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g1 Counter. integer(kind=I4P), public :: g2 Counter. Source Code subroutine set_mutually_exclusive_groups ( cli , group1 , group2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set two CLAs group ad mutually exclusive. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( IN ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 !< Counter. integer ( I4P ) :: g2 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( cli % defined_group ( group = group1 , g = g1 ). and . cli % defined_group ( group = group2 , g = g2 )) then cli % clasg ( g1 )% m_exclude = group2 cli % clasg ( g2 )% m_exclude = group1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_mutually_exclusive_groups","tags":"","loc":"proc/set_mutually_exclusive_groups.html","title":"set_mutually_exclusive_groups – FOODIE"},{"text":"private subroutine add(cli, pref, group, group_index, switch, switch_ab, help, required, positional, position, hidden, act, def, nargs, choices, exclude, envvar, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of the grouped CLAs. integer(kind=I4P), intent(in), optional :: group_index Index of the grouped CLAs. character(len=*), intent(in), optional :: switch Switch name. character(len=*), intent(in), optional :: switch_ab Abbreviated switch name. character(len=*), intent(in), optional :: help Help message describing the CLA. logical, intent(in), optional :: required Flag for set required argument. logical, intent(in), optional :: positional Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. logical, intent(in), optional :: hidden Flag for hiding CLA, thus it does not compare into help. character(len=*), intent(in), optional :: act CLA value action. character(len=*), intent(in), optional :: def Default value. character(len=*), intent(in), optional :: nargs Number of arguments consumed by CLA. character(len=*), intent(in), optional :: choices List of allowable values for the argument. character(len=*), intent(in), optional :: exclude Switch name of the mutually exclusive CLA. character(len=*), intent(in), optional :: envvar Environment variable from which take value. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Add CLA to CLI. Note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name\n or directly passed in case of positional CLA. Note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. Note If CLA belongs to a not yet present group it is created on the fly. Calls proc~~add~~CallsGraph proc~add add proc~upper_case Upper_Case proc~add->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( Type_Command_Line_Argument ), public :: cla CLA data. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: g Counter. Source Code subroutine add ( cli , pref , group , group_index , switch , switch_ab , help , required , positional , position , hidden , act , def , nargs ,& choices , exclude , envvar , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( IN ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( IN ) :: help !< Help message describing the CLA. logical , optional , intent ( IN ) :: required !< Flag for set required argument. logical , optional , intent ( IN ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical , optional , intent ( IN ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( IN ) :: act !< CLA value action. character ( * ), optional , intent ( IN ) :: def !< Default value. character ( * ), optional , intent ( IN ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( IN ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( IN ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( IN ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. type ( Type_Command_Line_Argument ) :: cla !< CLA data. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initializing CLA call cla % assign_object ( cli ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % required = . false . ; if ( present ( required )) cla % required = required cla % positional = . false . ; if ( present ( positional )) cla % positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % hidden = . false . ; if ( present ( hidden )) cla % hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( def )) cla % val = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar prefd = '' ; if ( present ( pref )) prefd = pref call cla % check ( pref = prefd ) ; cli % error = cla % error if ( cli % error /= 0 ) then if ( present ( error )) error = cli % error return endif ! adding CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call cli % clasg ( 0 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( 0 )% error elseif ( present ( group )) then if ( cli % defined_group ( group = group , g = g )) then call cli % clasg ( g )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( g )% error else call cli % add_group ( group = group ) call cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( cli % clasg , dim = 1 ) - 1 ) then call cli % clasg ( group_index )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( group_index )% error endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add","tags":"","loc":"proc/add.html","title":"add – FOODIE"},{"text":"private subroutine check(cli, pref, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Check CLAs data consistency. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: g Counter. integer(kind=I4P), public :: gg Counter. Source Code subroutine check ( cli , pref , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLAs data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter. integer ( I4P ) :: gg !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref do g = 0 , size ( cli % clasg , dim = 1 ) - 1 ! check group consistency call cli % clasg ( g )% check ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( present ( error )) error = cli % error if ( cli % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( cli % clasg ( g )% m_exclude /= '' ) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) cli % clasg ( gg )% m_exclude = cli % clasg ( g )% group endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check","tags":"","loc":"proc/check.html","title":"check – FOODIE"},{"text":"private subroutine check_m_exclusive(cli, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if two mutually exclusive CLAs group have been called. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: g Counter. integer(kind=I4P), public :: gg Counter. Source Code subroutine check_m_exclusive ( cli , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs group have been called. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter. integer ( I4P ) :: gg !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do g = 1 , size ( cli % clasg , dim = 1 ) - 1 if ( cli % clasg ( g )% called . and .( cli % clasg ( g )% m_exclude /= '' )) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) then if ( cli % clasg ( gg )% called ) then prefd = '' ; if ( present ( pref )) prefd = pref call cli % clasg ( g )% errored ( pref = prefd , error = error_clasg_m_exclude ) cli % error = cli % clasg ( g )% error exit endif endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive","tags":"","loc":"proc/check_m_exclusive.html","title":"check_m_exclusive – FOODIE"},{"text":"private subroutine parse(cli, pref, args, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Parse Command Line Interfaces by means of a previously initialized CLAs groups list. Note The leading and trailing white spaces are removed from CLA values. Note If the args argument is passed the command line arguments are taken from it and not from the actual program CLI\n invocations. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: g Counter for CLAs group. integer(kind=I4P), public, allocatable :: ai (:,:) Counter for CLAs grouped. Source Code subroutine parse ( cli , pref , args , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse Command Line Interfaces by means of a previously initialized CLAs groups list. !< !< @note The leading and trailing white spaces are removed from CLA values. !< !< @note If the *args* argument is passed the command line arguments are taken from it and not from the actual program CLI !< invocations. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: args !< String containing command line arguments. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter for CLAs group. integer ( I4P ), allocatable :: ai (:,:) !< Counter for CLAs grouped. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! add help and version switches if not done by user if (. not . cli % disable_hv ) then do g = 0 , size ( cli % clasg , dim = 1 ) - 1 if (. not .( cli % defined ( group = cli % clasg ( g )% group , switch = '--help' ). and . cli % defined ( group = cli % clasg ( g )% group , switch = '-h' ))) & call cli % add ( pref = prefd , & group_index = g , & switch = '--help' , & switch_ab = '-h' , & help = 'Print this help message' , & required = . false ., & def = '' , & act = 'print_help' ) if (. not .( cli % defined ( group = cli % clasg ( g )% group , switch = '--version' ). and . cli % defined ( group = cli % clasg ( g )% group , switch = '-v' ))) & call cli % add ( pref = prefd , & group_index = g , & switch = '--version' , & switch_ab = '-v' , & help = 'Print version' , & required = . false ., & def = '' , & act = 'print_version' ) enddo endif ! add hidden CLA '--' for getting the rid of eventual trailing CLAs garbage do g = 0 , size ( cli % clasg , dim = 1 ) - 1 if (. not . cli % defined ( group = cli % clasg ( g )% group , switch = '--' )) & call cli % add ( pref = prefd , & group_index = g , & switch = '--' , & required = . false ., & hidden = . true ., & nargs = '*' , & def = '' , & act = 'store' ) enddo ! parsing passed CLAs grouping in indexes if ( present ( args )) then call cli % get_args ( args = args , ai = ai ) else call cli % get_args ( ai = ai ) endif ! checking CLI consistency call cli % check ( pref = prefd ) if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! parsing cli do g = 0 , size ( ai , dim = 1 ) - 1 if ( ai ( g , 1 ) > 0 ) call cli % clasg ( g )% parse ( pref = prefd , args = cli % args ( ai ( g , 1 ): ai ( g , 2 ))) cli % error = cli % clasg ( g )% error if ( cli % error /= 0 ) exit enddo if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! trapping the special cases of version/help printing if ( cli % error == status_clasg_print_v ) then call cli % print_version ( pref = prefd ) stop elseif ( cli % error == status_clasg_print_h ) then write ( stdout , '(A)' ) cli % usage ( pref = prefd , g = g ) stop endif ! checking if all required CLAs have been passed do g = 0 , size ( ai , dim = 1 ) - 1 call cli % clasg ( g )% check_required ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( cli % error > 0 ) exit enddo if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! check mutually exclusive interaction call cli % check_m_exclusive ( pref = prefd ) if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse","tags":"","loc":"proc/parse.html","title":"parse – FOODIE"},{"text":"private subroutine get_clasg_indexes(cli, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Na Number of command line arguments passed. integer(kind=I4P), public :: a Counter for CLAs. integer(kind=I4P), public :: aa Counter for CLAs. integer(kind=I4P), public :: g Counter for CLAs group. logical, public :: found Flag for inquiring if a named group is found. Source Code subroutine get_clasg_indexes ( cli , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. integer ( I4P ) :: g !< Counter for CLAs group. logical :: found !< Flag for inquiring if a named group is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( ai ( 0 : size ( cli % clasg , dim = 1 ) - 1 , 1 : 2 )) ai = 0 if ( allocated ( cli % args )) then Na = size ( cli % args , dim = 1 ) a = 0 found = . false . search_named : do while ( a < Na ) a = a + 1 if ( cli % defined_group ( group = trim ( cli % args ( a )), g = g )) then found = . true . cli % clasg ( g )% called = . true . ai ( g , 1 ) = a + 1 aa = a do while ( aa < Na ) aa = aa + 1 if ( cli % defined_group ( group = trim ( cli % args ( aa )))) then a = aa - 1 ai ( g , 2 ) = a exit else ai ( g , 2 ) = aa endif enddo elseif (. not . found ) then ai ( 0 , 2 ) = a endif enddo search_named if ( ai ( 0 , 2 ) > 0 ) then ai ( 0 , 1 ) = 1 cli % clasg ( 0 )% called = . true . elseif ( all ( ai == 0 )) then cli % clasg ( 0 )% called = . true . endif else cli % clasg ( 0 )% called = . true . endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_clasg_indexes","tags":"","loc":"proc/get_clasg_indexes.html","title":"get_clasg_indexes – FOODIE"},{"text":"private subroutine get_args_from_string(cli, args, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from string. Calls proc~~get_args_from_string~~CallsGraph proc~get_args_from_string get_args_from_string proc~tokenize~2 tokenize proc~get_args_from_string->proc~tokenize~2 none~sanitize_args sanitize_args proc~get_args_from_string->none~sanitize_args none~sanitize_args->proc~tokenize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=len_trim(args)), public :: argsd Dummy string containing command line arguments. character(len=len_trim(args)), public, allocatable :: toks (:) CLAs tokenized. integer(kind=I4P), public :: Nt Number of tokens. integer(kind=I4P), public :: Na Number of command line arguments passed. integer(kind=I4P), public :: a Counter for CLAs. integer(kind=I4P), public :: t Counter for tokens. integer(kind=I4P), public :: c Counter for characters inside tokens. Functions function sanitize_args(argsin, delimiter) result(sanitized) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: argsin Arguments string. character(len=*), intent(in) :: delimiter Delimiter enclosing string argument. Return Value character(len=len_trim(argsin)) Arguments string sanitized. Description Sanitize arguments string. Source Code subroutine get_args_from_string ( cli , args , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from string. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: args !< String containing command line arguments. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. character ( len = len_trim ( args )) :: argsd !< Dummy string containing command line arguments. character ( len = len_trim ( args )), allocatable :: toks (:) !< CLAs tokenized. integer ( I4P ) :: Nt !< Number of tokens. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: t !< Counter for tokens. integer ( I4P ) :: c !< Counter for characters inside tokens. #ifndef __GFORTRAN__ integer ( I4P ) :: length !< Maxium lenght of arguments string. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! prepare cli arguments list if ( allocated ( cli % args )) deallocate ( cli % args ) ! sanitize arguments string argsd = trim ( args ) if ( index ( args , \"'\" ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = \"'\" ) elseif ( index ( args , '\"' ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = '\"' ) endif ! tokenize arguments string; the previously sanitized white spaces inside tokens are restored call tokenize ( strin = argsd , delimiter = ' ' , toks = toks , Nt = Nt ) Na = 0 find_number_of_valid_arguments : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then Na = Na + 1 do c = 1 , len ( toks ( t )) if ( toks ( t )( c : c ) == \"'\" ) toks ( t )( c : c ) = \" \" enddo endif enddo find_number_of_valid_arguments if ( Na > 0 ) then ! allocate cli arguments list #ifdef __GFORTRAN__ allocate ( cli % args ( 1 : Na )) #else length = 0 find_longest_arg : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) length = max ( length , len_trim ( adjustl ( toks ( t )))) enddo find_longest_arg allocate ( character ( length ) :: cli % args ( 1 : Na )) #endif ! construct arguments list a = 0 get_args : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then a = a + 1 cli % args ( a ) = trim ( adjustl ( toks ( t ))) endif enddo get_args endif call cli % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- contains function sanitize_args ( argsin , delimiter ) result ( sanitized ) !------------------------------------------------------------------------------------------------------------------------------- !< Sanitize arguments string. !< !< Substitute white spaces enclosed into string-arguments, i.e. 'string argument with spaces...' or !< \"string argument with spaces...\" with a safe equivalent for tokenization against white spaces, i.e. the finally tokenized !< string is string'argument'with'spaces... !< !< @note The white spaces are reintroduce later. !------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: argsin !< Arguments string. character ( * ), intent ( IN ) :: delimiter !< Delimiter enclosing string argument. character ( len = len_trim ( argsin )) :: sanitized !< Arguments string sanitized. character ( len = len_trim ( argsin )), allocatable :: tok (:) !< Arguments string tokens. integer ( I4P ) :: Nt !< Number of command line arguments passed. integer ( I4P ) :: t !< Counter. integer ( I4P ) :: tt !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- call tokenize ( strin = trim ( argsin ), delimiter = delimiter , toks = tok , Nt = Nt ) do t = 2 , Nt , 2 do tt = 1 , len_trim ( adjustl ( tok ( t ))) if ( tok ( t )( tt : tt ) == ' ' ) tok ( t )( tt : tt ) = \"'\" enddo enddo sanitized = '' do t = 1 , Nt sanitized = trim ( sanitized ) // \" \" // trim ( adjustl ( tok ( t ))) enddo sanitized = trim ( adjustl ( sanitized )) return !------------------------------------------------------------------------------------------------------------------------------- endfunction sanitize_args endsubroutine get_args_from_string","tags":"","loc":"proc/get_args_from_string.html","title":"get_args_from_string – FOODIE"},{"text":"private subroutine get_args_from_invocation(cli, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from CLI invocation. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Na Number of command line arguments passed. character(len=max_val_len), public :: switch Switch name. integer(kind=I4P), public :: a Counter for CLAs. integer(kind=I4P), public :: aa Counter for CLAs. Source Code subroutine get_args_from_invocation ( cli , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from CLI invocation. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. character ( max_val_len ) :: switch !< Switch name. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( cli % args )) deallocate ( cli % args ) Na = command_argument_count () if ( Na > 0 ) then #ifdef __GFORTRAN__ allocate ( cli % args ( 1 : Na )) #else aa = 0 find_longest_arg : do a = 1 , Na call get_command_argument ( a , switch ) aa = max ( aa , len_trim ( switch )) enddo find_longest_arg allocate ( character ( aa ) :: cli % args ( 1 : Na )) #endif get_args : do a = 1 , Na call get_command_argument ( a , switch ) cli % args ( a ) = trim ( adjustl ( switch )) enddo get_args endif call cli % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_args_from_invocation","tags":"","loc":"proc/get_args_from_invocation.html","title":"get_args_from_invocation – FOODIE"},{"text":"private subroutine get_cla_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA (single) value from CLAs list parsed. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. class ( * ), intent ( INOUT ) :: val !< CLA value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( cli % error == 0. and . cli % clasg ( g )% called ) then if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( position )% error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_cli","tags":"","loc":"proc/get_cla_cli.html","title":"get_cla_cli – FOODIE"},{"text":"private subroutine get_cla_list_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val (1:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. class ( * ), intent ( INOUT ) :: val ( 1 :) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_cli","tags":"","loc":"proc/get_cla_list_cli.html","title":"get_cla_list_cli – FOODIE"},{"text":"private subroutine get_cla_list_varying_R16P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_R16P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R16P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P_cli","tags":"","loc":"proc/get_cla_list_varying_r16p_cli.html","title":"get_cla_list_varying_R16P_cli – FOODIE"},{"text":"private subroutine get_cla_list_varying_R8P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_R8P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P_cli","tags":"","loc":"proc/get_cla_list_varying_r8p_cli.html","title":"get_cla_list_varying_R8P_cli – FOODIE"},{"text":"private subroutine get_cla_list_varying_R4P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_R4P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P_cli","tags":"","loc":"proc/get_cla_list_varying_r4p_cli.html","title":"get_cla_list_varying_R4P_cli – FOODIE"},{"text":"private subroutine get_cla_list_varying_I8P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_I8P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P_cli","tags":"","loc":"proc/get_cla_list_varying_i8p_cli.html","title":"get_cla_list_varying_I8P_cli – FOODIE"},{"text":"private subroutine get_cla_list_varying_I4P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_I4P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P_cli","tags":"","loc":"proc/get_cla_list_varying_i4p_cli.html","title":"get_cla_list_varying_I4P_cli – FOODIE"},{"text":"private subroutine get_cla_list_varying_I2P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_I2P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I2P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P_cli","tags":"","loc":"proc/get_cla_list_varying_i2p_cli.html","title":"get_cla_list_varying_I2P_cli – FOODIE"},{"text":"private subroutine get_cla_list_varying_I1P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_I1P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I1P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P_cli","tags":"","loc":"proc/get_cla_list_varying_i1p_cli.html","title":"get_cla_list_varying_I1P_cli – FOODIE"},{"text":"private subroutine get_cla_list_varying_logical_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, logical. Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_logical_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, logical. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. logical , allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical_cli","tags":"","loc":"proc/get_cla_list_varying_logical_cli.html","title":"get_cla_list_varying_logical_cli – FOODIE"},{"text":"private subroutine get_cla_list_varying_char_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, character. Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_char_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, character. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char_cli","tags":"","loc":"proc/get_cla_list_varying_char_cli.html","title":"get_cla_list_varying_char_cli – FOODIE"},{"text":"private subroutine print_usage(cli, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Description Print correct usage of CLI. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code subroutine print_usage ( cli , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print correct usage of CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref write ( stdout , '(A)' ) cli % usage ( pref = prefd , g = 0 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_usage","tags":"","loc":"proc/print_usage.html","title":"print_usage – FOODIE"},{"text":"private subroutine save_man_page(cli, man_file, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: man_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Save man page build on the CLI. Calls proc~~save_man_page~~CallsGraph proc~save_man_page save_man_page strz strz proc~save_man_page->strz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: man Man page. integer(kind=I4P), public :: idate (1:8) Integer array for handling the date. integer(kind=I4P), public :: e Counter. integer(kind=I4P), public :: u Unit file handler. character(len=*), public, parameter :: month (12) = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"] Months list. Source Code subroutine save_man_page ( cli , man_file , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save man page build on the CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: man_file !< Output file name for saving man page. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: man !< Man page. integer ( I4P ) :: idate ( 1 : 8 ) !< Integer array for handling the date. integer ( I4P ) :: e !< Counter. integer ( I4P ) :: u !< Unit file handler. character ( * ), parameter :: month ( 12 ) = [ \"Jan\" ,& \"Feb\" ,& \"Mar\" ,& \"Apr\" ,& \"May\" ,& \"Jun\" ,& \"Jul\" ,& \"Aug\" ,& \"Sep\" ,& \"Oct\" ,& \"Nov\" ,& \"Dec\" ] !< Months list. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call date_and_time ( values = idate ) man = '.TH ' // cli % progname // ' \"1\" \"' // month ( idate ( 2 )) // ' ' // trim ( adjustl ( strz ( 4 , idate ( 1 )))) // '\" \"version ' // cli % version // & '\" \"' // cli % progname // ' Manual\"' man = man // new_line ( 'a' ) // '.SH NAME' man = man // new_line ( 'a' ) // cli % progname // ' - manual page for ' // cli % progname // ' version ' // cli % version man = man // new_line ( 'a' ) // '.SH SYNOPSIS' man = man // new_line ( 'a' ) // '.B ' // cli % progname // new_line ( 'a' ) // trim ( adjustl ( cli % signature ())) if ( cli % description /= '' ) man = man // new_line ( 'a' ) // '.SH DESCRIPTION' // new_line ( 'a' ) // cli % description if ( cli % clasg ( 0 )% Na > 0 ) then man = man // new_line ( 'a' ) // '.SH OPTIONS' man = man // new_line ( 'a' ) // cli % usage ( no_header = . true ., no_examples = . true ., no_epilog = . true ., g = 0 ) endif if ( allocated ( cli % examples )) then man = man // new_line ( 'a' ) // '.SH EXAMPLES' man = man // new_line ( 'a' ) // '.PP' man = man // new_line ( 'a' ) // '.nf' man = man // new_line ( 'a' ) // '.RS' do e = 1 , size ( cli % examples , dim = 1 ) man = man // new_line ( 'a' ) // trim ( cli % examples ( e )) enddo man = man // new_line ( 'a' ) // '.RE' man = man // new_line ( 'a' ) // '.fi' man = man // new_line ( 'a' ) // '.PP' endif if ( cli % authors /= '' ) man = man // new_line ( 'a' ) // '.SH AUTHOR' // new_line ( 'a' ) // cli % authors if ( cli % license /= '' ) man = man // new_line ( 'a' ) // '.SH COPYRIGHT' // new_line ( 'a' ) // cli % license open ( newunit = u , file = trim ( adjustl ( man_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) man else write ( u , \"(A)\" ) man endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_man_page","tags":"","loc":"proc/save_man_page.html","title":"save_man_page – FOODIE"},{"text":"private elemental subroutine assign_cli(lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Interface ), intent(in) :: rhs Right hand side. Description Assign two CLI. Source Code elemental subroutine assign_cli ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign two CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Interface ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Interface members if ( allocated ( rhs % clasg )) lhs % clasg = rhs % clasg if ( allocated ( rhs % examples )) lhs % examples = rhs % examples lhs % disable_hv = rhs % disable_hv return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_cli","tags":"","loc":"proc/assign_cli.html","title":"assign_cli – FOODIE"},{"text":"private elemental function weno_constructor_upwind_init(S, eps) result(constructor) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: S Maximum stencils dimension. real(kind=R_P), intent(in), optional :: eps Parameter for avoiding divided by zero when computing smoothness indicators. Return Value type( weno_constructor_upwind ) WENO constructor. Description Create (initialize) the WENO interpolator. Note For this class of interpolators it is sufficient to provide the maximum number of stencils used (that is also the\n dimension, i.e. number of values, of each stencil). During the actual interpolation phase the client code can specify, for each\n intepolation a different number of stencil bounded by this maximum value. This is useful for coupling the interpolator with\n algorithm like the Recursive Order Reduction (ROR) strategy. Called By proc~~weno_constructor_upwind_init~~CalledByGraph proc~weno_constructor_upwind_init weno_constructor_upwind_init interface~weno_constructor_upwind weno_constructor_upwind interface~weno_constructor_upwind->proc~weno_constructor_upwind_init proc~init~18 init proc~init~18->interface~weno_constructor_upwind proc~init~12 init proc~init~12->interface~weno_constructor_upwind proc~init~22 init proc~init~22->interface~weno_constructor_upwind proc~init~16 init proc~init~16->interface~weno_constructor_upwind proc~init~14 init proc~init~14->interface~weno_constructor_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function weno_constructor_upwind_init ( S , eps ) result ( constructor ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create (initialize) the WENO interpolator. !< !< @note For this class of interpolators it is sufficient to provide the maximum number of stencils used (that is also the !< dimension, i.e. number of values, of each stencil). During the actual interpolation phase the client code can specify, for each !< intepolation a different number of stencil bounded by this maximum value. This is useful for coupling the interpolator with !< algorithm like the Recursive Order Reduction (ROR) strategy. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: S !< Maximum stencils dimension. real ( R_P ), intent ( IN ), optional :: eps !< Parameter for avoiding divided by zero when computing smoothness indicators. type ( weno_constructor_upwind ) :: constructor !<WENO constructor. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- constructor % S = S if ( present ( eps )) constructor % eps = eps return !--------------------------------------------------------------------------------------------------------------------------------- endfunction weno_constructor_upwind_init","tags":"","loc":"proc/weno_constructor_upwind_init.html","title":"weno_constructor_upwind_init – FOODIE"},{"text":"private elemental subroutine destroy(self) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(inout) :: self WENO interpolator. Description Destoy the WENO interpolator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( INOUT ) :: self !< WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % S = 0_I_P self % eps = 0._R_P if ( allocated ( self % weights_opt )) deallocate ( self % weights_opt ) if ( allocated ( self % poly_coef )) deallocate ( self % poly_coef ) if ( allocated ( self % smooth_coef )) deallocate ( self % smooth_coef ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~13.html","title":"destroy – FOODIE"},{"text":"private subroutine create(self, constructor) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(inout) :: self WENO interpolator. class( weno_constructor ), intent(in) :: constructor WENO constructor. Description Create the WENO interpolator. Calls proc~~create~~CallsGraph proc~create create none~set_weights_optimal set_weights_optimal proc~create->none~set_weights_optimal none~set_polynomial_coefficients set_polynomial_coefficients proc~create->none~set_polynomial_coefficients none~set_smoothness_indicators_coefficients set_smoothness_indicators_coefficients proc~create->none~set_smoothness_indicators_coefficients coef coef none~set_polynomial_coefficients->coef none~set_smoothness_indicators_coefficients->coef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Subroutines subroutine set_weights_optimal() Arguments None Description Set the values of optimial weights. subroutine set_polynomial_coefficients() Arguments None Description Set the values of polynomial_coefficient. subroutine set_smoothness_indicators_coefficients() Arguments None Description Set the values of smoothness indicators coefficients. Source Code subroutine create ( self , constructor ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( INOUT ) :: self !< WENO interpolator. class ( weno_constructor ), intent ( IN ) :: constructor !< WENO constructor. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( constructor ) type is ( weno_constructor_upwind ) call self % destroy self % S = constructor % S self % eps = constructor % eps allocate ( self % weights_opt ( 1 : 2 , 0 : self % S - 1 )) allocate ( self % poly_coef ( 1 : 2 , 0 : self % S - 1 , 0 : self % S - 1 )) allocate ( self % smooth_coef ( 0 : self % S - 1 , 0 : self % S - 1 , 0 : self % S - 1 )) call set_weights_optimal call set_polynomial_coefficients call set_smoothness_indicators_coefficients endselect return !--------------------------------------------------------------------------------------------------------------------------------- contains subroutine set_weights_optimal () !------------------------------------------------------------------------------------------------------------------------------- !< Set the values of optimial weights. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- select case ( self % S ) case ( 2 ) ! 3rd order ! 1 => left interface (i-1/2) self % weights_opt ( 1 , 0 ) = 2._R_P / 3._R_P ! stencil 0 self % weights_opt ( 1 , 1 ) = 1._R_P / 3._R_P ! stencil 1 ! 2 => right interface (i+1/2) self % weights_opt ( 2 , 0 ) = 1._R_P / 3._R_P ! stencil 0 self % weights_opt ( 2 , 1 ) = 2._R_P / 3._R_P ! stencil 1 case ( 3 ) ! 5th order ! 1 => left interface (i-1/2) self % weights_opt ( 1 , 0 ) = 0.3_R_P ! stencil 0 self % weights_opt ( 1 , 1 ) = 0.6_R_P ! stencil 1 self % weights_opt ( 1 , 2 ) = 0.1_R_P ! stencil 2 ! 2 => right interface (i+1/2) self % weights_opt ( 2 , 0 ) = 0.1_R_P ! stencil 0 self % weights_opt ( 2 , 1 ) = 0.6_R_P ! stencil 1 self % weights_opt ( 2 , 2 ) = 0.3_R_P ! stencil 2 case ( 4 ) ! 7th order ! 1 => left interface (i-1/2) self % weights_opt ( 1 , 0 ) = 4._R_P / 3 5._R_P ! stencil 0 self % weights_opt ( 1 , 1 ) = 1 8._R_P / 3 5._R_P ! stencil 1 self % weights_opt ( 1 , 2 ) = 1 2._R_P / 3 5._R_P ! stencil 2 self % weights_opt ( 1 , 3 ) = 1._R_P / 3 5._R_P ! stencil 3 ! 2 => right interface (i+1/2) self % weights_opt ( 2 , 0 ) = 1._R_P / 3 5._R_P ! stencil 0 self % weights_opt ( 2 , 1 ) = 1 2._R_P / 3 5._R_P ! stencil 1 self % weights_opt ( 2 , 2 ) = 1 8._R_P / 3 5._R_P ! stencil 2 self % weights_opt ( 2 , 3 ) = 4._R_P / 3 5._R_P ! stencil 3 endselect return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_weights_optimal subroutine set_polynomial_coefficients () !------------------------------------------------------------------------------------------------------------------------------- !< Set the values of polynomial_coefficient. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- associate ( coef => self % poly_coef ) select case ( self % S ) case ( 2 ) ! 3rd order ! 1 => left interface (i-1/2) !  cell  0               ;    cell  1 coef ( 1 , 0 , 0 ) = 0.5_R_P ; coef ( 1 , 1 , 0 ) = 0.5_R_P ! stencil 0 coef ( 1 , 0 , 1 ) = - 0.5_R_P ; coef ( 1 , 1 , 1 ) = 1.5_R_P ! stencil 1 ! 2 => right interface (i+1/2) !  cell  0               ;    cell  1 coef ( 2 , 0 , 0 ) = 1.5_R_P ; coef ( 2 , 1 , 0 ) = - 0.5_R_P ! stencil 0 coef ( 2 , 0 , 1 ) = 0.5_R_P ; coef ( 2 , 1 , 1 ) = 0.5_R_P ! stencil 1 case ( 3 ) ! 5th order ! 1 => left interface (i-1/2) !  cell  0                     ;    cell  1                     ;    cell  2 coef ( 1 , 0 , 0 ) = 1._R_P / 3._R_P ; coef ( 1 , 1 , 0 ) = 5._R_P / 6._R_P ; coef ( 1 , 2 , 0 ) = - 1._R_P / 6._R_P ! stencil 0 coef ( 1 , 0 , 1 ) = - 1._R_P / 6._R_P ; coef ( 1 , 1 , 1 ) = 5._R_P / 6._R_P ; coef ( 1 , 2 , 1 ) = 1._R_P / 3._R_P ! stencil 1 coef ( 1 , 0 , 2 ) = 1._R_P / 3._R_P ; coef ( 1 , 1 , 2 ) = - 7._R_P / 6._R_P ; coef ( 1 , 2 , 2 ) = 1 1._R_P / 6._R_P ! stencil 2 ! 2 => right interface (i+1/2) !  cell  0                     ;    cell  1                     ;    cell  2 coef ( 2 , 0 , 0 ) = 1 1._R_P / 6._R_P ; coef ( 2 , 1 , 0 ) = - 7._R_P / 6._R_P ; coef ( 2 , 2 , 0 ) = 1._R_P / 3._R_P ! stencil 0 coef ( 2 , 0 , 1 ) = 1._R_P / 3._R_P ; coef ( 2 , 1 , 1 ) = 5._R_P / 6._R_P ; coef ( 2 , 2 , 1 ) = - 1._R_P / 6._R_P ! stencil 1 coef ( 2 , 0 , 2 ) = - 1._R_P / 6._R_P ; coef ( 2 , 1 , 2 ) = 5._R_P / 6._R_P ; coef ( 2 , 2 , 2 ) = 1._R_P / 3._R_P ! stencil 2 case ( 4 ) ! 7th order ! 1 => left interface (i-1/2) !  cell  0                 ;   cell  1                 ;   cell  2                  ;   cell  3 coef ( 1 , 0 , 0 ) = 1._R_P / 4._R_P ; coef ( 1 , 1 , 0 ) = 1 3._R_P / 1 2._R_P ; coef ( 1 , 2 , 0 ) = - 5._R_P / 1 2._R_P ; coef ( 1 , 3 , 0 ) = 1._R_P / 1 2._R_P ! sten 0 coef ( 1 , 0 , 1 ) =- 1._R_P / 1 2._R_P ; coef ( 1 , 1 , 1 ) = 7._R_P / 1 2._R_P ; coef ( 1 , 2 , 1 ) = 7._R_P / 1 2._R_P ; coef ( 1 , 3 , 1 ) =- 1._R_P / 1 2._R_P ! sten 1 coef ( 1 , 0 , 2 ) = 1._R_P / 1 2._R_P ; coef ( 1 , 1 , 2 ) =- 5._R_P / 1 2._R_P ; coef ( 1 , 2 , 2 ) = 1 3._R_P / 1 2._R_P ; coef ( 1 , 3 , 2 ) = 1._R_P / 4._R_P ! sten 2 coef ( 1 , 0 , 3 ) =- 1._R_P / 4._R_P ; coef ( 1 , 1 , 3 ) = 1 3._R_P / 1 2._R_P ; coef ( 1 , 2 , 3 ) =- 2 3._R_P / 1 2._R_P ; coef ( 1 , 3 , 3 ) = 2 5._R_P / 1 2._R_P ! sten 3 ! 2 => right interface (i+1/2) !  cell  0                 ;   cell  1                  ;   cell  2                 ;   cell  3 coef ( 2 , 0 , 0 ) = 2 5._R_P / 1 2._R_P ; coef ( 2 , 1 , 0 ) =- 2 3._R_P / 1 2._R_P ; coef ( 2 , 2 , 0 ) = 1 3._R_P / 1 2._R_P ; coef ( 2 , 3 , 0 ) =- 1._R_P / 4._R_P ! sten 0 coef ( 2 , 0 , 1 ) = 1._R_P / 4._R_P ; coef ( 2 , 1 , 1 ) = 1 3._R_P / 1 2._R_P ; coef ( 2 , 2 , 1 ) =- 5._R_P / 1 2._R_P ; coef ( 2 , 3 , 1 ) = 1._R_P / 1 2._R_P ! sten 1 coef ( 2 , 0 , 2 ) =- 1._R_P / 1 2._R_P ; coef ( 2 , 1 , 2 ) = 7._R_P / 1 2._R_P ; coef ( 2 , 2 , 2 ) = 7._R_P / 1 2._R_P ; coef ( 2 , 3 , 2 ) =- 1._R_P / 1 2._R_P ! sten 2 coef ( 2 , 0 , 3 ) = 1._R_P / 1 2._R_P ; coef ( 2 , 1 , 3 ) = - 5._R_P / 1 2._R_P ; coef ( 2 , 2 , 3 ) = 1 3._R_P / 1 2._R_P ; coef ( 2 , 3 , 3 ) = 1._R_P / 4._R_P ! sten 3 endselect endassociate return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_polynomial_coefficients subroutine set_smoothness_indicators_coefficients () !------------------------------------------------------------------------------------------------------------------------------- !< Set the values of smoothness indicators coefficients. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- associate ( coef => self % smooth_coef ) select case ( self % S ) case ( 2 ) ! 3rd order ! stencil 0 !      i*i             ;       (i-1)*i coef ( 0 , 0 , 0 ) = 1._R_P ; coef ( 1 , 0 , 0 ) = - 2._R_P !      /               ;       (i-1)*(i-1) coef ( 0 , 1 , 0 ) = 0._R_P ; coef ( 1 , 1 , 0 ) = 1._R_P ! stencil 1 !     (i+1)*(i+1)      ;       (i+1)*i coef ( 0 , 0 , 1 ) = 1._R_P ; coef ( 1 , 0 , 1 ) = - 2._R_P !      /               ;        i*i coef ( 0 , 1 , 1 ) = 0._R_P ; coef ( 1 , 1 , 1 ) = 1._R_P case ( 3 ) ! 5th order ! stencil 0 !      i*i                      ;       (i-1)*i                   ;       (i-2)*i coef ( 0 , 0 , 0 ) = 1 0._R_P / 3._R_P ; coef ( 1 , 0 , 0 ) = - 3 1._R_P / 3._R_P ; coef ( 2 , 0 , 0 ) = 1 1._R_P / 3._R_P !      /                        ;       (i-1)*(i-1)               ;       (i-2)*(i-1) coef ( 0 , 1 , 0 ) = 0._R_P ; coef ( 1 , 1 , 0 ) = 2 5._R_P / 3._R_P ; coef ( 2 , 1 , 0 ) = - 1 9._R_P / 3._R_P !      /                        ;        /                        ;       (i-2)*(i-2) coef ( 0 , 2 , 0 ) = 0._R_P ; coef ( 1 , 2 , 0 ) = 0._R_P ; coef ( 2 , 2 , 0 ) = 4._R_P / 3._R_P ! stencil 1 !     (i+1)*(i+1)               ;        i*(i+1)                  ;       (i-1)*(i+1) coef ( 0 , 0 , 1 ) = 4._R_P / 3._R_P ; coef ( 1 , 0 , 1 ) = - 1 3._R_P / 3._R_P ; coef ( 2 , 0 , 1 ) = 5._R_P / 3._R_P !      /                        ;        i*i                      ;       (i-1)*i coef ( 0 , 1 , 1 ) = 0._R_P ; coef ( 1 , 1 , 1 ) = 1 3._R_P / 3._R_P ; coef ( 2 , 1 , 1 ) = - 1 3._R_P / 3._R_P !      /                        ;        /                        ;       (i-1)*(i-1) coef ( 0 , 2 , 1 ) = 0._R_P ; coef ( 1 , 2 , 1 ) = 0._R_P ; coef ( 2 , 2 , 1 ) = 4._R_P / 3._R_P ! stencil 2 !     (i+2)*(i+2)               ;       (i+1)*(i+2)               ;        i*(i+2) coef ( 0 , 0 , 2 ) = 4._R_P / 3._R_P ; coef ( 1 , 0 , 2 ) = - 1 9._R_P / 3._R_P ; coef ( 2 , 0 , 2 ) = 1 1._R_P / 3._R_P !      /                        ;       (i+1)*(i+1)               ;        i*(i+1) coef ( 0 , 1 , 2 ) = 0._R_P ; coef ( 1 , 1 , 2 ) = 2 5._R_P / 3._R_P ; coef ( 2 , 1 , 2 ) = - 3 1._R_P / 3._R_P !      /                        ;        /                        ;        i*i coef ( 0 , 2 , 2 ) = 0._R_P ; coef ( 1 , 2 , 2 ) = 0._R_P ; coef ( 2 , 2 , 2 ) = 1 0._R_P / 3._R_P case ( 4 ) ! 7th order ! stencil 0 !      i*i                ;       (i-1)*i             ;       (i-2)*i              ;       (i-3)*i coef ( 0 , 0 , 0 ) = 210 7._R_P ; coef ( 1 , 0 , 0 ) =- 940 2._R_P ; coef ( 2 , 0 , 0 ) = 704 2._R_P ; coef ( 3 , 0 , 0 ) = - 185 4._R_P !      /                  ;       (i-1)*(i-1)         ;       (i-2)*(i-1)          ;       (i-3)*(i-1) coef ( 0 , 1 , 0 ) = 0._R_P ; coef ( 1 , 1 , 0 ) = 1100 3._R_P ; coef ( 2 , 1 , 0 ) =- 1724 6._R_P ; coef ( 3 , 1 , 0 ) = 464 2._R_P !      /                  ;        /                  ;       (i-2)*(i-2)          ;       (i-3)*(i-2) coef ( 0 , 2 , 0 ) = 0._R_P ; coef ( 1 , 2 , 0 ) = 0._R_P ; coef ( 2 , 2 , 0 ) = 704 3._R_P ; coef ( 3 , 2 , 0 ) = - 388 2._R_P !      /                  ;        /                  ;        /                   ;       (i-3)*(i-3) coef ( 0 , 3 , 0 ) = 0._R_P ; coef ( 1 , 3 , 0 ) = 0._R_P ; coef ( 2 , 3 , 0 ) = 0._R_P ; coef ( 3 , 3 , 0 ) = 54 7._R_P ! stencil 1 !     (i+1)*(i+1)         ;        i*(i+1)            ;       (i-1)*(i+1)          ;       (i-2)*(i+1) coef ( 0 , 0 , 1 ) = 54 7._R_P ; coef ( 1 , 0 , 1 ) =- 252 2._R_P ; coef ( 2 , 0 , 1 ) = 192 2._R_P ; coef ( 3 , 0 , 1 ) = - 49 4._R_P !       /                 ;          i*i              ;       (i-1)*i              ;       (i-2)*i coef ( 0 , 1 , 1 ) = 0._R_P ; coef ( 1 , 1 , 1 ) = 344 3._R_P ; coef ( 2 , 1 , 1 ) = - 596 6._R_P ; coef ( 3 , 1 , 1 ) = 160 2._R_P !       /                 ;          /                ;       (i-1)*(i-1)          ;       (i-2)*(i-1) coef ( 0 , 2 , 1 ) = 0._R_P ; coef ( 1 , 2 , 1 ) = 0._R_P ; coef ( 2 , 2 , 1 ) = 284 3._R_P ; coef ( 3 , 2 , 1 ) = - 164 2._R_P !       /                 ;          /                ;        /                   ;       (i-2)*(i-2) coef ( 0 , 3 , 1 ) = 0._R_P ; coef ( 1 , 3 , 1 ) = 0._R_P ; coef ( 2 , 3 , 1 ) = 0._R_P ; coef ( 3 , 3 , 1 ) = 26 7._R_P ! stencil 2 !     (i+2)*(i+2)         ;       (i+1)*(i+2)         ;            i*(i+2)         ;       (i-1)*(i+2) coef ( 0 , 0 , 2 ) = 26 7._R_P ; coef ( 1 , 0 , 2 ) =- 164 2._R_P ; coef ( 2 , 0 , 2 ) = 160 2._R_P ; coef ( 3 , 0 , 2 ) = - 49 4._R_P !      /                  ;       (i+1)*(i+1)         ;        i*(i+1)             ;       (i-1)*(i+1) coef ( 0 , 1 , 2 ) = 0._R_P ; coef ( 1 , 1 , 2 ) = 284 3._R_P ; coef ( 2 , 1 , 2 ) = - 596 6._R_P ; coef ( 3 , 1 , 2 ) = 192 2._R_P !      /                  ;        /                  ;        i*i                 ;       (i-1)*i coef ( 0 , 2 , 2 ) = 0._R_P ; coef ( 1 , 2 , 2 ) = 0._R_P ; coef ( 2 , 2 , 2 ) = 344 3._R_P ; coef ( 3 , 2 , 2 ) = - 252 2._R_P !      /                  ;        /                  ;        /                   ;       (i-1)*(i-1) coef ( 0 , 3 , 2 ) = 0._R_P ; coef ( 1 , 3 , 2 ) = 0._R_P ; coef ( 2 , 3 , 2 ) = 0._R_P ; coef ( 3 , 3 , 2 ) = 54 7._R_P ! stencil 3 !     (i+3)*(i+3)         ;       (i+2)*(i+3)         ;           (i+1)*(i+3)      ;        i*(i+3) coef ( 0 , 0 , 3 ) = 54 7._R_P ; coef ( 1 , 0 , 3 ) =- 388 2._R_P ; coef ( 2 , 0 , 3 ) = 464 2._R_P ; coef ( 3 , 0 , 3 ) = - 185 4._R_P !      /                  ;       (i+2)*(i+2)         ;       (i+1)*(i+2)          ;        i*(i+2) coef ( 0 , 1 , 3 ) = 0._R_P ; coef ( 1 , 1 , 3 ) = 704 3._R_P ; coef ( 2 , 1 , 3 ) =- 1724 6._R_P ; coef ( 3 , 1 , 3 ) = 704 2._R_P !      /                  ;        /                  ;       (i+1)*(i+1)          ;        i*(i+1) coef ( 0 , 2 , 3 ) = 0._R_P ; coef ( 1 , 2 , 3 ) = 0._R_P ; coef ( 2 , 2 , 3 ) = 1100 3._R_P ; coef ( 3 , 2 , 3 ) = - 940 2._R_P !      /                  ;        /                  ;        /                   ;        i*i coef ( 0 , 3 , 3 ) = 0._R_P ; coef ( 1 , 3 , 3 ) = 0._R_P ; coef ( 2 , 3 , 3 ) = 0._R_P ; coef ( 3 , 3 , 3 ) = 210 7._R_P endselect endassociate return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_smoothness_indicators_coefficients endsubroutine create","tags":"","loc":"proc/create.html","title":"create – FOODIE"},{"text":"private pure subroutine description(self, string) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(in) :: self WENO interpolator. character(len=:), intent(out), allocatable :: string String returned. Description Return a string describing the WENO interpolator. Calls proc~~description~~CallsGraph proc~description description str str proc~description->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=1), public :: dummy Dummy string. character(len=1), public, parameter :: nl = new_line('a') New line character. Source Code pure subroutine description ( self , string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string describing the WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( IN ) :: self !< WENO interpolator. character ( len = :), allocatable , intent ( OUT ) :: string !< String returned. character ( len = 1 ) :: dummy !< Dummy string. character ( len = 1 ), parameter :: nl = new_line ( 'a' ) !< New line character. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- string = 'WENO upwind-biased interpolator' // nl string = string // '  Based on the scheme proposed by Jiang and Shu \"Efficient Implementation of Weighted ENO Schemes\", see ' // & 'JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130' // nl string = string // '  Provide a formal order of accuracy equals to: ' // trim ( str (. true ., 2 * self % S - 1 )) // nl string = string // '  Use ' // trim ( str (. true ., self % S )) // ' stencils composed by ' // trim ( str (. true ., self % S )) // ' values' // nl string = string // '  The eps value used for avoiding division by zero is ' // trim ( str (. true ., self % eps )) // nl string = string // '  The \"interpolate\" method has the following public API' // nl string = string // '    interpolate(S, stencil, location, interpolation)' // nl string = string // '  where:' // nl string = string // '    S: integer(I_P), intent(IN), the number of stencils actually used' // nl string = string // '    stencil(1:, 1-S:-1+S): real(R_P), intent(IN), the stencils used' // nl string = string // '    location: character(*), intent(IN), the location of interpolation {left, right, both}' // nl string = string // '    interpolation(1:, 1-S:-1+S): realR_P, intent(OUT), the interpolated values' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine description","tags":"","loc":"proc/description.html","title":"description – FOODIE"},{"text":"private pure subroutine interpolate(self, S, stencil, location, interpolation) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(in) :: self WENO interpolator. integer, intent(in) :: S Number of stencils actually used. real(kind=R_P), intent(in) :: stencil (1:,1-S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. character(len=*), intent(in) :: location Location of interpolated value(s): left, right, both. real(kind=R_P), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Description Interpolate the stecil input values computing the actual interpolation. Calls proc~~interpolate~~CallsGraph proc~interpolate interpolate none~compute_polynomials compute_polynomials proc~interpolate->none~compute_polynomials none~compute_convolution compute_convolution proc~interpolate->none~compute_convolution none~compute_weights compute_weights proc~interpolate->none~compute_weights stencil stencil none~compute_polynomials->stencil none~compute_weights->stencil Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: polynomials (1:2,0:S-1) Polynomial reconstructions. real(kind=R_P), public :: weights (1:2,0:S-1) Weights of the stencils. Subroutines pure subroutine compute_polynomials(f1, f2, ff, polynomials) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: f1 integer(kind=I_P), intent(in) :: f2 integer(kind=I_P), intent(in) :: ff Faces to be computed. real(kind=R_P), intent(out) :: polynomials (1:,0:) Polynomial reconstructions. Description Compute the polynomials reconstructions. pure subroutine compute_weights(f1, f2, ff, weights) Arguments Type Intent Optional Attributes Name integer, intent(in) :: f1 integer, intent(in) :: f2 integer, intent(in) :: ff Faces to be computed. real(kind=R_P), intent(out) :: weights (1:,0:) Weights of the stencils, [1:2, 0:S - 1 ]. Description Compute the stencils weights. pure subroutine compute_convolution(f1, f2, ff, interpolation) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: f1 integer(kind=I_P), intent(in) :: f2 integer(kind=I_P), intent(in) :: ff Faces to be computed. real(kind=R_P), intent(out) :: interpolation (1:) Left and right (1,2) interface value of reconstructed. Description Compute the polynomials convolution. Source Code pure subroutine interpolate ( self , S , stencil , location , interpolation ) !--------------------------------------------------------------------------------------------------------------------------------- !< Interpolate the stecil input values computing the actual interpolation. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( IN ) :: self !< WENO interpolator. integer , intent ( IN ) :: S !< Number of stencils actually used. real ( R_P ), intent ( IN ) :: stencil ( 1 :, 1 - S :) !< Stencil used for the interpolation, [1:2, 1-S:-1+S]. character ( * ), intent ( IN ) :: location !< Location of interpolated value(s): left, right, both. real ( R_P ), intent ( OUT ) :: interpolation ( 1 :) !< Result of the interpolation, [1:2]. real ( R_P ) :: polynomials ( 1 : 2 , 0 : S - 1 ) !< Polynomial reconstructions. real ( R_P ) :: weights ( 1 : 2 , 0 : S - 1 ) !< Weights of the stencils. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( location ) case ( 'both' , 'b' ) call compute_polynomials ( f1 = 1_I_P , f2 = 2_I_P , ff = 0_I_P , polynomials = polynomials ) call compute_weights ( f1 = 1_I_P , f2 = 2_I_P , ff = 0_I_P , weights = weights ) call compute_convolution ( f1 = 1_I_P , f2 = 2_I_P , ff = 0_I_P , interpolation = interpolation ) case ( 'left' , 'l' ) call compute_polynomials ( f1 = 1_I_P , f2 = 1_I_P , ff = 0_I_P , polynomials = polynomials ) call compute_weights ( f1 = 1_I_P , f2 = 1_I_P , ff = 0_I_P , weights = weights ) call compute_convolution ( f1 = 1_I_P , f2 = 1_I_P , ff = 0_I_P , interpolation = interpolation ) case ( 'right' , 'r' ) call compute_polynomials ( f1 = 2_I_P , f2 = 2_I_P , ff =- 1_I_P , polynomials = polynomials ) call compute_weights ( f1 = 2_I_P , f2 = 2_I_P , ff =- 1_I_P , weights = weights ) call compute_convolution ( f1 = 2_I_P , f2 = 2_I_P , ff =- 1_I_P , interpolation = interpolation ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- contains pure subroutine compute_polynomials ( f1 , f2 , ff , polynomials ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute the polynomials reconstructions. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: f1 , f2 , ff !< Faces to be computed. real ( R_P ), intent ( OUT ) :: polynomials ( 1 :, 0 :) !< Polynomial reconstructions. integer ( I_P ) :: s1 , s2 , f !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- polynomials = 0. do s1 = 0 , S - 1 ! stencils loop do s2 = 0 , S - 1 ! values loop do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) polynomials ( f , s1 ) = polynomials ( f , s1 ) + self % poly_coef ( f , s2 , s1 ) * stencil ( f + ff , - s2 + s1 ) enddo enddo enddo return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine compute_polynomials pure subroutine compute_weights ( f1 , f2 , ff , weights ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute the stencils weights. !------------------------------------------------------------------------------------------------------------------------------- integer , intent ( IN ) :: f1 , f2 , ff !< Faces to be computed. real ( R_P ), intent ( OUT ) :: weights ( 1 :, 0 :) !< Weights of the stencils, [1:2, 0:S - 1 ]. real ( R_P ) :: IS ( 1 : 2 , 0 : S - 1 ) !< Smoothness indicators of the stencils. real ( R_P ) :: a ( 1 : 2 , 0 : S - 1 ) !< Alpha coefficients for the weights. real ( R_P ) :: a_tot ( 1 : 2 ) !< Sum of the alpha coefficients. integer ( I_P ) :: s1 , s2 , s3 , f !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- ! computing smoothness indicators do s1 = 0 , S - 1 ! stencils loop do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) IS ( f , s1 ) = 0. do s2 = 0 , S - 1 do s3 = 0 , S - 1 IS ( f , s1 ) = IS ( f , s1 ) + self % smooth_coef ( s3 , s2 , s1 ) * stencil ( f + ff , s1 - s3 ) * stencil ( f + ff , s1 - s2 ) enddo enddo enddo enddo ! computing alfa coefficients a_tot = 0. do s1 = 0 , S - 1 ! stencil loops do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) a ( f , s1 ) = self % weights_opt ( f , s1 ) * ( 1. / ( self % eps + IS ( f , s1 )) ** S ) ; a_tot ( f ) = a_tot ( f ) + a ( f , s1 ) enddo enddo ! computing the weights do s1 = 0 , S - 1 ! stencils loop do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) weights ( f , s1 ) = a ( f , s1 ) / a_tot ( f ) enddo enddo return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine compute_weights pure subroutine compute_convolution ( f1 , f2 , ff , interpolation ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute the polynomials convolution. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: f1 , f2 , ff !< Faces to be computed. real ( R_P ), intent ( OUT ) :: interpolation ( 1 :) !< Left and right (1,2) interface value of reconstructed. integer ( I_P ) :: k , f !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- ! computing the convultion interpolation = 0. do k = 0 , S - 1 ! stencils loop do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) interpolation ( f + ff ) = interpolation ( f + ff ) + weights ( f , k ) * polynomials ( f , k ) enddo enddo return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine compute_convolution endsubroutine interpolate","tags":"","loc":"proc/interpolate.html","title":"interpolate – FOODIE"},{"text":"private pure subroutine assign_interpolator(lhs, rhs) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(inout) :: lhs Left hand side. class( weno_interpolator ), intent(in) :: rhs Right hand side. Description Assign one interpolator to another. Source Code pure subroutine assign_interpolator ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one interpolator to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( INOUT ) :: lhs !< Left hand side. class ( weno_interpolator ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( weno_interpolator_upwind ) lhs % S = rhs % S lhs % eps = rhs % eps if ( allocated ( rhs % weights_opt )) then if ( allocated ( lhs % weights_opt )) deallocate ( lhs % weights_opt ) ; allocate ( lhs % weights_opt ( 1 : 2 , 0 : lhs % S - 1 )) lhs % weights_opt = rhs % weights_opt endif if ( allocated ( rhs % poly_coef )) then if ( allocated ( lhs % poly_coef )) deallocate ( lhs % poly_coef ) ; allocate ( lhs % poly_coef ( 1 : 2 , 0 : lhs % S - 1 , 0 : lhs % S - 1 )) lhs % poly_coef = rhs % poly_coef endif if ( allocated ( rhs % smooth_coef )) then if ( allocated ( lhs % smooth_coef )) deallocate ( lhs % smooth_coef ) ; allocate ( lhs % smooth_coef ( 0 : lhs % S - 1 , 0 : lhs % S - 1 , 0 : lhs % S - 1 )) lhs % smooth_coef = rhs % smooth_coef endif endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_interpolator","tags":"","loc":"proc/assign_interpolator.html","title":"assign_interpolator – FOODIE"},{"text":"private elemental subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( weno_interpolator_upwind ), intent(inout) :: self WENO interpolator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( weno_interpolator_upwind ), intent ( INOUT ) :: self !< WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~14.html","title":"finalize – FOODIE"},{"text":"public interface weno_constructor_upwind Calls interface~~weno_constructor_upwind~~CallsGraph interface~weno_constructor_upwind weno_constructor_upwind proc~weno_constructor_upwind_init weno_constructor_upwind_init interface~weno_constructor_upwind->proc~weno_constructor_upwind_init Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~weno_constructor_upwind~~CalledByGraph interface~weno_constructor_upwind weno_constructor_upwind proc~init~18 init proc~init~18->interface~weno_constructor_upwind proc~init~12 init proc~init~12->interface~weno_constructor_upwind proc~init~22 init proc~init~22->interface~weno_constructor_upwind proc~init~16 init proc~init~16->interface~weno_constructor_upwind proc~init~14 init proc~init~14->interface~weno_constructor_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function weno_constructor_upwind_init (S, eps) result(constructor) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: S Maximum stencils dimension. real(kind=R_P), intent(in), optional :: eps Parameter for avoiding divided by zero when computing smoothness indicators. Return Value type( weno_constructor_upwind ) WENO constructor. Description Create (initialize) the WENO interpolator.","tags":"","loc":"interface/weno_constructor_upwind.html","title":"weno_constructor_upwind – FOODIE"},{"text":"private subroutine create(constructor, interpolator) Arguments Type Intent Optional Attributes Name class( weno_constructor ), intent(in) :: constructor The concrete WENO constructor selected by client code. class( weno_interpolator ), intent(out), allocatable :: interpolator The concrete WENO interpolator. Description Create and return a concrete WENO interpolator object being an extension of the abstract weno_interpolator type. Source Code subroutine create ( constructor , interpolator ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create and return a concrete WENO interpolator object being an extension of the abstract *weno_interpolator* type. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_constructor ), intent ( IN ) :: constructor !< The concrete WENO constructor selected by client code. class ( weno_interpolator ), allocatable , intent ( OUT ) :: interpolator !< The concrete WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( constructor ) type is ( weno_constructor_upwind ) allocate ( weno_interpolator_upwind :: interpolator ) call interpolator % create ( constructor = constructor ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine create","tags":"","loc":"proc/create~2.html","title":"create – FOODIE"},{"text":"private subroutine destroy(me) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me Source Code subroutine destroy ( me ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler if ( allocated ( me % str )) deallocate ( me % str ) if ( allocated ( me % real_fmt )) deallocate ( me % real_fmt ) end subroutine destroy","tags":"","loc":"proc/destroy~14.html","title":"destroy – FOODIE"},{"text":"private subroutine add_str(me, str) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in) :: str Source Code subroutine add_str ( me , str ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler character ( len =* ), intent ( in ) :: str !! str to be added to pyplot handler buffer me % str = me % str // str // new_line ( ' ' ) end subroutine add_str","tags":"","loc":"proc/add_str.html","title":"add_str – FOODIE"},{"text":"private subroutine initialize(me, grid, xlabel, ylabel, zlabel, title, legend, use_numpy, figsize, font_size, axes_labelsize, xtick_labelsize, ytick_labelsize, ztick_labelsize, legend_fontsize, mplot3d, axis_equal, polar, real_fmt) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me logical, intent(in), optional :: grid character(len=*), intent(in), optional :: xlabel character(len=*), intent(in), optional :: ylabel character(len=*), intent(in), optional :: zlabel character(len=*), intent(in), optional :: title logical, intent(in), optional :: legend logical, intent(in), optional :: use_numpy integer, intent(in), optional dimension(2) :: figsize integer, intent(in), optional :: font_size integer, intent(in), optional :: axes_labelsize integer, intent(in), optional :: xtick_labelsize integer, intent(in), optional :: ytick_labelsize integer, intent(in), optional :: ztick_labelsize integer, intent(in), optional :: legend_fontsize logical, intent(in), optional :: mplot3d logical, intent(in), optional :: axis_equal logical, intent(in), optional :: polar character(len=*), intent(in), optional :: real_fmt Calls proc~~initialize~~CallsGraph proc~initialize initialize proc~optional_int_to_string optional_int_to_string proc~initialize->proc~optional_int_to_string proc~integer_to_string integer_to_string proc~initialize->proc~integer_to_string proc~optional_int_to_string->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=max_int_len), public :: width_str character(len=max_int_len), public :: height_str character(len=max_int_len), public :: font_size_str character(len=max_int_len), public :: axes_labelsize_str character(len=max_int_len), public :: xtick_labelsize_str character(len=max_int_len), public :: ytick_labelsize_str character(len=max_int_len), public :: ztick_labelsize_str character(len=max_int_len), public :: legend_fontsize_str character(len=*), public, parameter :: default_font_size_str = '10' Source Code subroutine initialize ( me , grid , xlabel , ylabel , zlabel , title , legend , use_numpy , figsize , & font_size , axes_labelsize , xtick_labelsize , ytick_labelsize , ztick_labelsize , & legend_fontsize , mplot3d , axis_equal , polar , real_fmt ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler logical , intent ( in ), optional :: grid !! activate grid drawing character ( len =* ), intent ( in ), optional :: xlabel !! label of x axis character ( len =* ), intent ( in ), optional :: ylabel !! label of y axis character ( len =* ), intent ( in ), optional :: zlabel !! label of z axis character ( len =* ), intent ( in ), optional :: title !! plot title logical , intent ( in ), optional :: legend !! plot legend logical , intent ( in ), optional :: use_numpy !! activate usage of numpy python module integer , dimension ( 2 ), intent ( in ), optional :: figsize !! dimension of the figure integer , intent ( in ), optional :: font_size !! font size integer , intent ( in ), optional :: axes_labelsize !! size of axis labels integer , intent ( in ), optional :: xtick_labelsize !! size of x axis tick lables integer , intent ( in ), optional :: ytick_labelsize !! size of y axis tick lables integer , intent ( in ), optional :: ztick_labelsize !! size of z axis tick lables integer , intent ( in ), optional :: legend_fontsize !! size of legend font logical , intent ( in ), optional :: mplot3d !! set true for 3d plots (cannot use with polar) logical , intent ( in ), optional :: axis_equal !! set true for axis = 'equal' logical , intent ( in ), optional :: polar !! set true for polar plots (cannot use with mplot3d) character ( len =* ), intent ( in ), optional :: real_fmt !! format string for real numbers (examples: '(E30.16)' [default], '*') character ( len = max_int_len ) :: width_str !! figure width dummy string character ( len = max_int_len ) :: height_str !! figure height dummy string character ( len = max_int_len ) :: font_size_str !! font size dummy string character ( len = max_int_len ) :: axes_labelsize_str !! size of axis labels dummy string character ( len = max_int_len ) :: xtick_labelsize_str !! size of x axis tick labels dummy string character ( len = max_int_len ) :: ytick_labelsize_str !! size of x axis tick labels dummy string character ( len = max_int_len ) :: ztick_labelsize_str !! size of z axis tick labels dummy string character ( len = max_int_len ) :: legend_fontsize_str !! size of legend font dummy string character ( len =* ), parameter :: default_font_size_str = '10' !! the default font size for plots call me % destroy () if ( present ( legend )) then me % show_legend = legend else me % show_legend = . false . end if if ( present ( use_numpy )) then me % use_numpy = use_numpy else me % use_numpy = . true . end if if ( present ( figsize )) then call integer_to_string ( figsize ( 1 ), width_str ) call integer_to_string ( figsize ( 2 ), height_str ) end if if ( present ( mplot3d )) then me % mplot3d = mplot3d else me % mplot3d = . false . end if if ( present ( polar )) then me % polar = polar else me % polar = . false . end if if ( present ( axis_equal )) then me % axis_equal = axis_equal else me % axis_equal = . false . end if if ( present ( real_fmt )) then me % real_fmt = trim ( adjustl ( real_fmt )) else me % real_fmt = real_fmt_default end if call optional_int_to_string ( font_size , font_size_str , default_font_size_str ) call optional_int_to_string ( axes_labelsize , axes_labelsize_str , default_font_size_str ) call optional_int_to_string ( xtick_labelsize , xtick_labelsize_str , default_font_size_str ) call optional_int_to_string ( ytick_labelsize , ytick_labelsize_str , default_font_size_str ) call optional_int_to_string ( ztick_labelsize , ztick_labelsize_str , default_font_size_str ) call optional_int_to_string ( legend_fontsize , legend_fontsize_str , default_font_size_str ) me % str = '' call me % add_str ( '#!/usr/bin/python' ) call me % add_str ( '' ) call me % add_str ( 'import matplotlib' ) call me % add_str ( 'import matplotlib.pyplot as plt' ) if ( me % mplot3d ) call me % add_str ( 'from mpl_toolkits.mplot3d import Axes3D' ) if ( me % use_numpy ) call me % add_str ( 'import numpy as np' ) call me % add_str ( '' ) call me % add_str ( 'matplotlib.rcParams[\"font.family\"] = \"Serif\"' ) call me % add_str ( 'matplotlib.rcParams[\"font.size\"] = ' // trim ( font_size_str )) call me % add_str ( 'matplotlib.rcParams[\"axes.labelsize\"] = ' // trim ( axes_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"xtick.labelsize\"] = ' // trim ( xtick_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"ytick.labelsize\"] = ' // trim ( ytick_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"legend.fontsize\"] = ' // trim ( legend_fontsize_str )) call me % add_str ( '' ) if ( present ( figsize )) then !if specifying the figure size call me % add_str ( 'fig = plt.figure(figsize=(' // trim ( width_str ) // ',' // trim ( height_str ) // '))' ) else call me % add_str ( 'fig = plt.figure()' ) end if if ( me % mplot3d ) then call me % add_str ( 'ax = fig.gca(projection=''3d'')' ) elseif ( me % polar ) then call me % add_str ( 'ax = fig.gca(projection=''polar'')' ) else call me % add_str ( 'ax = fig.gca()' ) end if if ( present ( grid )) then if ( grid ) call me % add_str ( 'ax.grid()' ) end if if ( present ( xlabel )) call me % add_str ( 'ax.set_xlabel(\"' // trim ( xlabel ) // '\")' ) if ( present ( ylabel )) call me % add_str ( 'ax.set_ylabel(\"' // trim ( ylabel ) // '\")' ) if ( present ( zlabel )) call me % add_str ( 'ax.set_zlabel(\"' // trim ( zlabel ) // '\")' ) if ( present ( title )) call me % add_str ( 'ax.set_title(\"' // trim ( title ) // '\")' ) call me % add_str ( '' ) end subroutine initialize","tags":"","loc":"proc/initialize.html","title":"initialize – FOODIE"},{"text":"private subroutine add_plot(me, x, y, label, linestyle, markersize, linewidth, xlim, ylim, xscale, yscale) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y character(len=*), intent(in) :: label character(len=*), intent(in) :: linestyle integer, intent(in), optional :: markersize integer, intent(in), optional :: linewidth real(kind=wp), intent(in), optional dimension(2) :: xlim real(kind=wp), intent(in), optional dimension(2) :: ylim character(len=*), intent(in), optional :: xscale character(len=*), intent(in), optional :: yscale Calls proc~~add_plot~~CallsGraph proc~add_plot add_plot proc~optional_int_to_string optional_int_to_string proc~add_plot->proc~optional_int_to_string proc~vec_to_string vec_to_string proc~add_plot->proc~vec_to_string proc~integer_to_string integer_to_string proc~optional_int_to_string->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: xstr character(len=:), public, allocatable :: ystr character(len=:), public, allocatable :: xlimstr character(len=:), public, allocatable :: ylimstr character(len=max_int_len), public :: imark character(len=max_int_len), public :: iline character(len=*), public, parameter :: xname = 'x' character(len=*), public, parameter :: yname = 'y' Source Code subroutine add_plot ( me , x , y , label , linestyle , markersize , linewidth , xlim , ylim , xscale , yscale ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler real ( wp ), dimension (:), intent ( in ) :: x !! x values real ( wp ), dimension (:), intent ( in ) :: y !! y values character ( len =* ), intent ( in ) :: label !! plot label character ( len =* ), intent ( in ) :: linestyle !! style of the plot line integer , intent ( in ), optional :: markersize !! size of the plot markers integer , intent ( in ), optional :: linewidth !! width of the plot line real ( wp ), dimension ( 2 ), intent ( in ), optional :: xlim !! x-axis range real ( wp ), dimension ( 2 ), intent ( in ), optional :: ylim !! y-axis range character ( len =* ), intent ( in ), optional :: xscale !! example: 'linear' (default), 'log' character ( len =* ), intent ( in ), optional :: yscale !! example: 'linear' (default), 'log' character ( len = :), allocatable :: xstr !! x values stringified character ( len = :), allocatable :: ystr !! y values stringified character ( len = :), allocatable :: xlimstr !! xlim values stringified character ( len = :), allocatable :: ylimstr !! ylim values stringified character ( len = max_int_len ) :: imark !! actual markers size character ( len = max_int_len ) :: iline !! actual line width character ( len =* ), parameter :: xname = 'x' !! x variable name for script character ( len =* ), parameter :: yname = 'y' !! y variable name for script if ( allocated ( me % str )) then !axis limits (optional): if ( present ( xlim )) call vec_to_string ( xlim , me % real_fmt , xlimstr , me % use_numpy ) if ( present ( ylim )) call vec_to_string ( ylim , me % real_fmt , ylimstr , me % use_numpy ) !convert the arrays to strings: call vec_to_string ( x , me % real_fmt , xstr , me % use_numpy ) call vec_to_string ( y , me % real_fmt , ystr , me % use_numpy ) !get optional inputs (if not present, set default value): call optional_int_to_string ( markersize , imark , '3' ) call optional_int_to_string ( linewidth , iline , '3' ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) call me % add_str ( '' ) !write the plot statement: call me % add_str ( 'ax.plot(' // & trim ( xname ) // ',' // & trim ( yname ) // ',' // & '\"' // trim ( linestyle ) // '\",' // & 'linewidth=' // trim ( adjustl ( iline )) // ',' // & 'markersize=' // trim ( adjustl ( imark )) // ',' // & 'label=\"' // trim ( label ) // '\")' ) !axis limits: if ( allocated ( xlimstr )) call me % add_str ( 'ax.set_xlim(' // xlimstr // ')' ) if ( allocated ( ylimstr )) call me % add_str ( 'ax.set_ylim(' // ylimstr // ')' ) !axis scales: if ( present ( xscale )) call me % add_str ( 'ax.set_xscale(\"' // xscale // '\")' ) if ( present ( yscale )) call me % add_str ( 'ax.set_yscale(\"' // yscale // '\")' ) call me % add_str ( '' ) else error stop 'Error in add_plot: pyplot class not properly initialized.' end if end subroutine add_plot","tags":"","loc":"proc/add_plot.html","title":"add_plot – FOODIE"},{"text":"private subroutine add_contour(me, x, y, z, label, linestyle, linewidth, levels, color, filled, cmap) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:,:) :: z character(len=*), intent(in) :: label character(len=*), intent(in) :: linestyle integer, intent(in), optional :: linewidth real(kind=wp), intent(in), optional dimension(:) :: levels character(len=*), intent(in), optional :: color logical, intent(in), optional :: filled character(len=*), intent(in), optional :: cmap Calls proc~~add_contour~~CallsGraph proc~add_contour add_contour proc~optional_int_to_string optional_int_to_string proc~add_contour->proc~optional_int_to_string proc~vec_to_string vec_to_string proc~add_contour->proc~vec_to_string proc~matrix_to_string matrix_to_string proc~add_contour->proc~matrix_to_string proc~integer_to_string integer_to_string proc~optional_int_to_string->proc~integer_to_string proc~matrix_to_string->proc~vec_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: xstr character(len=:), public, allocatable :: ystr character(len=:), public, allocatable :: zstr character(len=:), public, allocatable :: levelstr character(len=max_int_len), public :: iline character(len=*), public, parameter :: xname = 'x' character(len=*), public, parameter :: yname = 'y' character(len=*), public, parameter :: zname = 'z' character(len=*), public, parameter :: xname_ = 'X' character(len=*), public, parameter :: yname_ = 'Y' character(len=*), public, parameter :: zname_ = 'Z' character(len=:), public, allocatable :: extras character(len=:), public, allocatable :: contourfunc Source Code subroutine add_contour ( me , x , y , z , label , linestyle , linewidth , levels , color , filled , cmap ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler real ( wp ), dimension (:), intent ( in ) :: x !! x values real ( wp ), dimension (:), intent ( in ) :: y !! y values real ( wp ), dimension (:,:), intent ( in ) :: z !! z values (a matrix) character ( len =* ), intent ( in ) :: label !! plot label character ( len =* ), intent ( in ) :: linestyle !! style of the plot line integer , intent ( in ), optional :: linewidth !! width of the plot line real ( wp ), dimension (:), intent ( in ), optional :: levels !! contour levels to plot character ( len =* ), intent ( in ), optional :: color !! color of the contour line logical , intent ( in ), optional :: filled !! use filled control (default=False) character ( len =* ), intent ( in ), optional :: cmap !! colormap if filled=True (examples: 'jet', 'bone') character ( len = :), allocatable :: xstr !! x values strinfied character ( len = :), allocatable :: ystr !! y values strinfied character ( len = :), allocatable :: zstr !! z values strinfied character ( len = :), allocatable :: levelstr !! levels vector strinfied character ( len = max_int_len ) :: iline !! actual line width character ( len =* ), parameter :: xname = 'x' !! x variable name for script character ( len =* ), parameter :: yname = 'y' !! y variable name for script character ( len =* ), parameter :: zname = 'z' !! z variable name for script character ( len =* ), parameter :: xname_ = 'X' !! X variable name for contour character ( len =* ), parameter :: yname_ = 'Y' !! Y variable name for contour character ( len =* ), parameter :: zname_ = 'Z' !! Z variable name for contour character ( len = :), allocatable :: extras !! optional stuff character ( len = :), allocatable :: contourfunc !! 'contour' or 'contourf' if ( allocated ( me % str )) then !convert the arrays to strings: call vec_to_string ( x , me % real_fmt , xstr , me % use_numpy ) call vec_to_string ( y , me % real_fmt , ystr , me % use_numpy ) call matrix_to_string ( z , me % real_fmt , zstr , me % use_numpy ) if ( present ( levels )) call vec_to_string ( levels , me % real_fmt , levelstr , me % use_numpy ) !get optional inputs (if not present, set default value): call optional_int_to_string ( linewidth , iline , '3' ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) call me % add_str ( trim ( zname ) // ' = ' // zstr ) call me % add_str ( '' ) !convert inputs for contour plotting: call me % add_str ( yname_ // ', ' // xname_ // ' = np.meshgrid(' // trim ( xname ) // ', ' // trim ( yname ) // ')' ) call me % add_str ( zname_ // ' = ' // zname ) !optional arguments: extras = '' if ( present ( levels )) extras = extras // ',' // 'levels=' // levelstr if ( present ( color )) extras = extras // ',' // 'colors=\"' // color // '\"' if ( present ( linewidth )) extras = extras // ',' // 'linewidths=' // trim ( adjustl ( iline )) if ( present ( cmap )) extras = extras // ',' // 'cmap=\"' // cmap // '\"' !filled or regular: contourfunc = 'contour' !default if ( present ( filled )) then if ( filled ) contourfunc = 'contourf' !filled contour end if !write the plot statement: call me % add_str ( 'CS = ax.' // contourfunc // '(' // xname_ // ',' // yname_ // ',' // zname_ // ',' // & 'label=\"' // trim ( label ) // '\",' // & 'linestyles=\"' // trim ( adjustl ( linestyle )) // '\"' // & extras // ')' ) call me % add_str ( 'ax.clabel(CS, fontsize=9, inline=1)' ) call me % add_str ( '' ) else error stop 'Error in add_plot: pyplot class not properly initialized.' end if end subroutine add_contour","tags":"","loc":"proc/add_contour.html","title":"add_contour – FOODIE"},{"text":"private subroutine add_3d_plot(me, x, y, z, label, linestyle, markersize, linewidth) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z character(len=*), intent(in) :: label character(len=*), intent(in) :: linestyle integer, intent(in), optional :: markersize integer, intent(in), optional :: linewidth Calls proc~~add_3d_plot~~CallsGraph proc~add_3d_plot add_3d_plot proc~optional_int_to_string optional_int_to_string proc~add_3d_plot->proc~optional_int_to_string proc~vec_to_string vec_to_string proc~add_3d_plot->proc~vec_to_string proc~integer_to_string integer_to_string proc~optional_int_to_string->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: xstr character(len=:), public, allocatable :: ystr character(len=:), public, allocatable :: zstr character(len=max_int_len), public :: imark character(len=max_int_len), public :: iline character(len=*), public, parameter :: xname = 'x' character(len=*), public, parameter :: yname = 'y' character(len=*), public, parameter :: zname = 'z' Source Code subroutine add_3d_plot ( me , x , y , z , label , linestyle , markersize , linewidth ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler real ( wp ), dimension (:), intent ( in ) :: x !! x values real ( wp ), dimension (:), intent ( in ) :: y !! y values real ( wp ), dimension (:), intent ( in ) :: z !! z values character ( len =* ), intent ( in ) :: label !! plot label character ( len =* ), intent ( in ) :: linestyle !! style of the plot line integer , intent ( in ), optional :: markersize !! size of the plot markers integer , intent ( in ), optional :: linewidth !! width of the plot line character ( len = :), allocatable :: xstr !! x values strinfied character ( len = :), allocatable :: ystr !! y values strinfied character ( len = :), allocatable :: zstr !! z values strinfied character ( len = max_int_len ) :: imark !! actual markers size character ( len = max_int_len ) :: iline !! actual line width character ( len =* ), parameter :: xname = 'x' !! x variable name for script character ( len =* ), parameter :: yname = 'y' !! y variable name for script character ( len =* ), parameter :: zname = 'z' !! z variable name for script if ( allocated ( me % str )) then !convert the arrays to strings: call vec_to_string ( x , me % real_fmt , xstr , me % use_numpy ) call vec_to_string ( y , me % real_fmt , ystr , me % use_numpy ) call vec_to_string ( z , me % real_fmt , zstr , me % use_numpy ) !get optional inputs (if not present, set default value): call optional_int_to_string ( markersize , imark , '3' ) call optional_int_to_string ( linewidth , iline , '3' ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) call me % add_str ( trim ( zname ) // ' = ' // zstr ) call me % add_str ( '' ) !write the plot statement: call me % add_str ( 'ax.plot(' // & trim ( xname ) // ',' // & trim ( yname ) // ',' // & trim ( zname ) // ',' // & '\"' // trim ( linestyle ) // '\",' // & 'linewidth=' // trim ( adjustl ( iline )) // ',' // & 'markersize=' // trim ( adjustl ( imark )) // ',' // & 'label=\"' // trim ( label ) // '\")' ) call me % add_str ( '' ) else error stop 'Error in add_3d_plot: pyplot class not properly initialized.' end if end subroutine add_3d_plot","tags":"","loc":"proc/add_3d_plot.html","title":"add_3d_plot – FOODIE"},{"text":"private subroutine add_bar(me, left, height, label, width, bottom, color, yerr, align, xlim, ylim, xscale, yscale) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: left real(kind=wp), intent(in), dimension(:) :: height character(len=*), intent(in) :: label real(kind=wp), intent(in), optional dimension(:) :: width real(kind=wp), intent(in), optional dimension(:) :: bottom character(len=*), intent(in), optional :: color real(kind=wp), intent(in), optional dimension(:) :: yerr character(len=*), intent(in), optional :: align real(kind=wp), intent(in), optional dimension(2) :: xlim real(kind=wp), intent(in), optional dimension(2) :: ylim character(len=*), intent(in), optional :: xscale character(len=*), intent(in), optional :: yscale Calls proc~~add_bar~~CallsGraph proc~add_bar add_bar proc~vec_to_string vec_to_string proc~add_bar->proc~vec_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: xstr character(len=:), public, allocatable :: ystr character(len=:), public, allocatable :: xlimstr character(len=:), public, allocatable :: ylimstr character(len=:), public, allocatable :: wstr character(len=:), public, allocatable :: bstr character(len=:), public, allocatable :: plt_str character(len=:), public, allocatable :: yerr_str character(len=*), public, parameter :: xname = 'x' character(len=*), public, parameter :: yname = 'y' character(len=*), public, parameter :: wname = 'w' character(len=*), public, parameter :: bname = 'b' character(len=*), public, parameter :: yerrname = 'yerr' Source Code subroutine add_bar ( me , left , height , label , width , bottom , color , yerr , align , xlim , ylim , xscale , yscale ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler real ( wp ), dimension (:), intent ( in ) :: left !! left bar values real ( wp ), dimension (:), intent ( in ) :: height !! height bar values character ( len =* ), intent ( in ) :: label !! plot label real ( wp ), dimension (:), intent ( in ), optional :: width !! width values real ( wp ), dimension (:), intent ( in ), optional :: bottom !! bottom values character ( len =* ), intent ( in ), optional :: color !! plot color real ( wp ), dimension (:), intent ( in ), optional :: yerr !! yerr values character ( len =* ), intent ( in ), optional :: align !! default: 'center' real ( wp ), dimension ( 2 ), intent ( in ), optional :: xlim !! x-axis range real ( wp ), dimension ( 2 ), intent ( in ), optional :: ylim !! y-axis range character ( len =* ), intent ( in ), optional :: xscale !! example: 'linear' (default), 'log' character ( len =* ), intent ( in ), optional :: yscale !! example: 'linear' (default), 'log' character ( len = :), allocatable :: xstr !! x axis values stringified character ( len = :), allocatable :: ystr !! y axis values stringified character ( len = :), allocatable :: xlimstr !! xlim values stringified character ( len = :), allocatable :: ylimstr !! ylim values stringified character ( len = :), allocatable :: wstr !! width values stringified character ( len = :), allocatable :: bstr !! bottom values stringified character ( len = :), allocatable :: plt_str !! plot string character ( len = :), allocatable :: yerr_str !!  yerr values stringified character ( len =* ), parameter :: xname = 'x' !! x axis name character ( len =* ), parameter :: yname = 'y' !! y axis name character ( len =* ), parameter :: wname = 'w' !! width name character ( len =* ), parameter :: bname = 'b' !! bottom name character ( len =* ), parameter :: yerrname = 'yerr' !! yerr name if ( allocated ( me % str )) then !axis limits (optional): if ( present ( xlim )) call vec_to_string ( xlim , me % real_fmt , xlimstr , me % use_numpy ) if ( present ( ylim )) call vec_to_string ( ylim , me % real_fmt , ylimstr , me % use_numpy ) !convert the arrays to strings: call vec_to_string ( left , me % real_fmt , xstr , me % use_numpy ) call vec_to_string ( height , me % real_fmt , ystr , me % use_numpy ) if ( present ( width )) call vec_to_string ( width , me % real_fmt , wstr , me % use_numpy ) if ( present ( bottom )) call vec_to_string ( bottom , me % real_fmt , bstr , me % use_numpy ) if ( present ( yerr )) call vec_to_string ( yerr , me % real_fmt , yerr_str , me % use_numpy ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) if ( present ( width )) call me % add_str ( trim ( wname ) // ' = ' // wstr ) if ( present ( bottom )) call me % add_str ( trim ( bname ) // ' = ' // bstr ) if ( present ( yerr )) call me % add_str ( trim ( yerrname ) // ' = ' // yerr_str ) call me % add_str ( '' ) !create the plot string: plt_str = 'ax.bar(' // & 'left=' // trim ( xname ) // ',' // & 'height=' // trim ( yname ) // ',' if ( present ( yerr )) plt_str = plt_str // 'yerr=' // trim ( yerrname ) // ',' if ( present ( width )) plt_str = plt_str // 'width=' // trim ( wname ) // ',' if ( present ( bottom )) plt_str = plt_str // 'bottom=' // trim ( bstr ) // ',' if ( present ( color )) plt_str = plt_str // 'color=\"' // trim ( color ) // '\",' if ( present ( align )) plt_str = plt_str // 'align=\"' // trim ( align ) // '\",' plt_str = plt_str // 'label=\"' // trim ( label ) // '\")' !write the plot statement: call me % add_str ( plt_str ) !axis limits: if ( allocated ( xlimstr )) call me % add_str ( 'ax.set_xlim(' // xlimstr // ')' ) if ( allocated ( ylimstr )) call me % add_str ( 'ax.set_ylim(' // ylimstr // ')' ) !axis scales: if ( present ( xscale )) call me % add_str ( 'ax.set_xscale(\"' // xscale // '\")' ) if ( present ( yscale )) call me % add_str ( 'ax.set_yscale(\"' // yscale // '\")' ) call me % add_str ( '' ) else error stop 'Error in add_bar: pyplot class not properly initialized.' end if end subroutine add_bar","tags":"","loc":"proc/add_bar.html","title":"add_bar – FOODIE"},{"text":"private subroutine optional_int_to_string(int_value, string_value, default_value) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: int_value character(len=*), intent(out) :: string_value character(len=*), intent(in) :: default_value Calls proc~~optional_int_to_string~~CallsGraph proc~optional_int_to_string optional_int_to_string proc~integer_to_string integer_to_string proc~optional_int_to_string->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~optional_int_to_string~~CalledByGraph proc~optional_int_to_string optional_int_to_string proc~initialize initialize proc~initialize->proc~optional_int_to_string proc~add_contour add_contour proc~add_contour->proc~optional_int_to_string proc~add_3d_plot add_3d_plot proc~add_3d_plot->proc~optional_int_to_string proc~add_plot add_plot proc~add_plot->proc~optional_int_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine optional_int_to_string ( int_value , string_value , default_value ) integer , intent ( in ), optional :: int_value !! integer value character ( len =* ), intent ( out ) :: string_value !! integer value stringified character ( len =* ), intent ( in ) :: default_value !! default integer value if ( present ( int_value )) then call integer_to_string ( int_value , string_value ) else string_value = default_value end if end subroutine optional_int_to_string","tags":"","loc":"proc/optional_int_to_string.html","title":"optional_int_to_string – FOODIE"},{"text":"private subroutine integer_to_string(i, s) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: i character(len=*), intent(out) :: s Called By proc~~integer_to_string~~CalledByGraph proc~integer_to_string integer_to_string proc~initialize initialize proc~initialize->proc~integer_to_string proc~optional_int_to_string optional_int_to_string proc~initialize->proc~optional_int_to_string proc~optional_int_to_string->proc~integer_to_string proc~add_contour add_contour proc~add_contour->proc~optional_int_to_string proc~add_3d_plot add_3d_plot proc~add_3d_plot->proc~optional_int_to_string proc~add_plot add_plot proc~add_plot->proc~optional_int_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: istat Source Code subroutine integer_to_string ( i , s ) integer , intent ( in ), optional :: i !! integer value character ( len =* ), intent ( out ) :: s !! integer value stringified integer :: istat !! IO status write ( s , int_fmt , iostat = istat ) i if ( istat /= 0 ) then error stop 'Error converting integer to string' else s = adjustl ( s ) end if end subroutine integer_to_string","tags":"","loc":"proc/integer_to_string.html","title":"integer_to_string – FOODIE"},{"text":"private subroutine vec_to_string(v, fmt, str, use_numpy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: v character(len=*), intent(in) :: fmt character(len=:), intent(out), allocatable :: str logical, intent(in) :: use_numpy Called By proc~~vec_to_string~~CalledByGraph proc~vec_to_string vec_to_string proc~add_plot add_plot proc~add_plot->proc~vec_to_string proc~add_bar add_bar proc~add_bar->proc~vec_to_string proc~add_3d_plot add_3d_plot proc~add_3d_plot->proc~vec_to_string proc~matrix_to_string matrix_to_string proc~matrix_to_string->proc~vec_to_string proc~add_contour add_contour proc~add_contour->proc~vec_to_string proc~add_contour->proc~matrix_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: istat character(len=max_real_len), public :: tmp Source Code subroutine vec_to_string ( v , fmt , str , use_numpy ) real ( wp ), dimension (:), intent ( in ) :: v !! real values character ( len =* ), intent ( in ) :: fmt !! real format string character ( len = :), allocatable , intent ( out ) :: str !! real values stringified logical , intent ( in ) :: use_numpy !! activate numpy python module usage integer :: i !! counter integer :: istat !! IO status character ( len = max_real_len ) :: tmp !! dummy string str = '[' do i = 1 , size ( v ) if ( fmt == '*' ) then write ( tmp , * , iostat = istat ) v ( i ) else write ( tmp , fmt , iostat = istat ) v ( i ) end if if ( istat /= 0 ) error stop 'Error in vec_to_string' str = str // trim ( adjustl ( tmp )) if ( i < size ( v )) str = str // ',' end do str = str // ']' !convert to numpy array if necessary: if ( use_numpy ) str = 'np.array(' // str // ')' end subroutine vec_to_string","tags":"","loc":"proc/vec_to_string.html","title":"vec_to_string – FOODIE"},{"text":"private subroutine matrix_to_string(v, fmt, str, use_numpy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: v character(len=*), intent(in) :: fmt character(len=:), intent(out), allocatable :: str logical, intent(in) :: use_numpy Calls proc~~matrix_to_string~~CallsGraph proc~matrix_to_string matrix_to_string proc~vec_to_string vec_to_string proc~matrix_to_string->proc~vec_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~matrix_to_string~~CalledByGraph proc~matrix_to_string matrix_to_string proc~add_contour add_contour proc~add_contour->proc~matrix_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i character(len=:), public, allocatable :: tmp Source Code subroutine matrix_to_string ( v , fmt , str , use_numpy ) real ( wp ), dimension (:,:), intent ( in ) :: v !! real values character ( len =* ), intent ( in ) :: fmt !! real format string character ( len = :), allocatable , intent ( out ) :: str !! real values stringified logical , intent ( in ) :: use_numpy !! activate numpy python module usage integer :: i !! counter character ( len = :), allocatable :: tmp !! dummy string str = '[' do i = 1 , size ( v , 1 ) !rows call vec_to_string ( v ( i ,:), fmt , tmp , use_numpy ) !one row at a time str = str // trim ( adjustl ( tmp )) if ( i < size ( v , 1 )) str = str // ',' end do str = str // ']' !convert to numpy array if necessary: if ( use_numpy ) str = 'np.array(' // str // ')' end subroutine matrix_to_string","tags":"","loc":"proc/matrix_to_string.html","title":"matrix_to_string – FOODIE"},{"text":"private subroutine execute(me, pyfile) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in), optional :: pyfile Variables Type Visibility Attributes Name Initial integer, public :: istat integer, public :: iunit character(len=:), public, allocatable :: file logical, public :: scratch Source Code subroutine execute ( me , pyfile ) class ( pyplot ), intent ( inout ) :: me !! pytplot handler character ( len =* ), intent ( in ), optional :: pyfile !! name of the python script to generate integer :: istat !! IO status integer :: iunit !! IO unit character ( len = :), allocatable :: file !! file name logical :: scratch !! if a scratch file is to be used if ( allocated ( me % str )) then scratch = (. not . present ( pyfile )) !file name to use: if ( scratch ) then file = trim ( tmp_file ) !use the default else file = trim ( pyfile ) !use the user-specified name end if !open the file: open ( newunit = iunit , file = file , status = 'REPLACE' , iostat = istat ) if ( istat /= 0 ) error stop 'Error opening file.' !write to the file: write ( iunit , '(A)' ) me % str !to ensure that the file is there for the next command line call: flush ( iunit ) !run the file using python: call execute_command_line ( python_exe // ' ' // file ) !close the file: if ( scratch ) then close ( iunit , status = 'DELETE' , iostat = istat ) else close ( iunit , iostat = istat ) end if if ( istat /= 0 ) error stop 'Error closing file.' !cleanup: if ( allocated ( file )) deallocate ( file ) end if end subroutine execute","tags":"","loc":"proc/execute~2.html","title":"execute – FOODIE"},{"text":"private subroutine savefig(me, figfile, pyfile) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in) :: figfile character(len=*), intent(in), optional :: pyfile Source Code subroutine savefig ( me , figfile , pyfile ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler character ( len =* ), intent ( in ) :: figfile !! file name for the figure character ( len =* ), intent ( in ), optional :: pyfile !! name of the Python script to generate if ( allocated ( me % str )) then !finish up the string: if ( me % show_legend ) then call me % add_str ( 'ax.legend(loc=\"best\")' ) call me % add_str ( '' ) end if if ( me % axis_equal ) then call me % add_str ( 'ax.axis(\"equal\")' ) call me % add_str ( '' ) end if call me % add_str ( 'plt.savefig(\"' // trim ( figfile ) // '\")' ) !run it: call me % execute ( pyfile ) else error stop 'error in savefig: pyplot class not properly initialized.' end if end subroutine savefig","tags":"","loc":"proc/savefig.html","title":"savefig – FOODIE"},{"text":"Uses: foodie_adt_integrand foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_moulton foodie_integrator_backward_differentiation_formula foodie_integrator_emd_runge_kutta foodie_integrator_euler_explicit foodie_integrator_leapfrog foodie_integrator_low_storage_runge_kutta foodie_integrator_tvd_runge_kutta module~~foodie~~UsesGraph module~foodie foodie module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_adams_bashforth var panmodulefoodieUsesGraph = svgPanZoom('#modulefoodieUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. FOODIE is a KISS library for solving systems of Ordinary Differential Equation (ODE) into the Initial Values Problems (IVP)\n contest. The mathematical formulation of the problem is: U_t = R(t,U)\n U_0 = F(0) where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function and F is the (vectorial) initial conditions function. FOODIE is aimed to the time-like integration of the above system of ODE. To this aim, different numerical schemes are provided: explicit Adams-Bashforth class of schemes: 1 step, namely the explicit forward Euler scheme, 1st order accurate; 2 steps, 2nd order accurate; 3 steps, 3rd order accurate; 4 steps, 4th order accurate; forward explicit Euler scheme, a 1st order accurate; explicit Leapfrog : Unfiltered, 2nd order accurate, (mostly) unstable; Robert-Asselin filtered, 1st order accurate; Robert-Asselin-Williams filter, 2nd order accurate; explicit low storage Runge-Kutta 2N class schemes: LS(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; LS(5,4): 5 stages, 4th order accurate; explicit TVD or SSP Runge-Kutta class schemes: TVD(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; SSP(2,2): 2 stages, 2nd order accurate; SSP(3,3): 3 stages, 3rd order accurate; SSP(5,4): 5 stages, 4th order accurate; explicit embedded Runge-Kutta class schemes: DP(7,4): 7 stages, 4th order accurate, Dormand and Prince scheme; implicit Adams-Moulton class of schemes: 0 step, namely the implicit backward Euler scheme, 1st order accurate; 1 step, 2nd order accurate; 2 steps, 3rd order accurate; 3 steps, 4th order accurate; predictor-corrector Adams-Bashforth-Moulton class of schemes: P=AB(1)-C=AM(0) step, namely the explicit/implicit forward/backward Euler scheme, 1st order accurate; P=AB(2)-C=AM(1) step, 2nd order accurate; P=AB(3)-C=AM(2) steps, 3rd order accurate; P=AB(4)-C=AM(3) steps, 4th order accurate; Usage FOODIE schemes must be applied to only subclass extensions of the abstract class integrand . To use FOODIE you must: extend integrand abstract class provided by FOODIE implementing your concrete integrand field For example for the Lorenz' ODE system type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODIE integrand class. private real ( R_P ), dimension (:), allocatable :: state !< Solution vector. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivate, resiuduals function. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz oprator. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. ... endtype lorenz use one of the provided FOODIE integrator For example using the forward explicit Euler scheme to the above Lorenz' ODE system use foodie , only : euler_explicit_integrator use type_lorenz , only : lorenz type ( euler_explicit_integrator ) :: euler_integrator type ( lorenz ) :: attractor real :: dt = 0.01 do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt ) enddo Used By module~~foodie~~UsedByGraph module~foodie foodie module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~oscillation_test_t oscillation_test_t module~foodie->module~oscillation_test_t module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_burgers type_burgers module~foodie->module~type_burgers module~oscillation_t oscillation_t module~foodie->module~oscillation_t module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~type_lorenz->program~integrate_lorenz program~integrate_oscillation integrate_oscillation module~oscillation_test_t->program~integrate_oscillation module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~oscillation_t->module~oscillation_test_t module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~type_euler_1d->program~integrate_euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"module/foodie.html","title":"foodie – FOODIE"},{"text":"Uses: foodie_kinds module~~foodie_adt_integrand~~UsesGraph module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_adt_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define the abstract type integrand for building FOODIE ODE integrators. Used By module~~foodie_adt_integrand~~UsedByGraph module~foodie_adt_integrand foodie_adt_integrand module~foodie foodie module~foodie_adt_integrand->module~foodie module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~oscillation_test_t oscillation_test_t module~foodie->module~oscillation_test_t module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_burgers type_burgers module~foodie->module~type_burgers module~oscillation_t oscillation_t module~foodie->module~oscillation_t module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~type_lorenz->program~integrate_lorenz program~integrate_oscillation integrate_oscillation module~oscillation_test_t->program~integrate_oscillation module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~oscillation_t->module~oscillation_test_t module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_adt_integrandUsedByGraph = svgPanZoom('#modulefoodie_adt_integrandUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private pure subroutine assignment_integrand (lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function time_derivative (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function local_error_operator (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 solution approximations. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function integrand_op_real (lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function real_op_integrand (lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function symmetric_operator (lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. Derived Types type, public, abstract :: integrand Components Type Visibility Attributes Name Initial class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. Type-Bound Procedures procedure(time_derivative), public, pass(self), deferred :: t Time derivative, residuals. procedure(local_error_operator), public, pass(lhs), deferred :: local_error ||integrand - integrand||. procedure(symmetric_operator), public, pass(lhs), deferred :: integrand_multiply_integrand Integrand * integrand operator. procedure(integrand_op_real), public, pass(lhs), deferred :: integrand_multiply_real Integrand * real operator. procedure(real_op_integrand), public, pass(rhs), deferred :: real_multiply_integrand Real * integrand operator. procedure(symmetric_operator), public, pass(lhs), deferred :: add Integrand + integrand operator. procedure(symmetric_operator), public, pass(lhs), deferred :: sub Integrand - integrand operator. procedure(assignment_integrand), public, pass(lhs), deferred :: assign_integrand Integrand = integrand. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. generic, public :: operator(+) => add Overloading + operator. generic, public :: operator(-) => sub Overloading - operator. generic, public :: operator(*) => integrand_multiply_integrand, real_multiply_integrand, integrand_multiply_real Overloading * operator. generic, public :: assignment(=) => assign_integrand Overloading = assignament. Description Abstract type for building FOODIE ODE integrators.","tags":"","loc":"module/foodie_adt_integrand.html","title":"foodie_adt_integrand – FOODIE"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_utils module~~foodie_integrator_adams_bashforth~~UsesGraph module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_utils->module~foodie_integrator_adams_bashforth Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Adams-Bashforth class scheme implemented is:  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s}{ b_s \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  where N_s is the number of previous steps considered. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit. The coefficients b define the actual scheme, that is selected accordingly to the number of steps used. Currently, the schemes provided have steps number in [1, 16] . Note that the scheme using only 1 step reverts\n to Explicit Forward Euler. The formal order of accuracy varies consistently in [1st, 16th] order. Bibliography [1] Cowell Type Numerical Integration As Applied to Satellite Orbit Computation , J. L. Maury Jr.,\n G. P. Segal, X-553-69-46, April 1969, NASA-TM-X-63542 . [2] Linear multistep method , wikipedia article . Used By module~~foodie_integrator_adams_bashforth~~UsedByGraph module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~oscillation_test_t oscillation_test_t module~foodie->module~oscillation_test_t module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_burgers type_burgers module~foodie->module~type_burgers module~oscillation_t oscillation_t module~foodie->module~oscillation_t module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_integrator_adams_bashforth_moulton->module~foodie module~type_lorenz->program~integrate_lorenz program~integrate_oscillation integrate_oscillation module~oscillation_test_t->program~integrate_oscillation module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~oscillation_t->module~oscillation_test_t module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_adams_bashforthUsedByGraph = svgPanZoom('#modulefoodie_integrator_adams_bashforthUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: supported_steps = '1-16' List of supported steps number. Valid format is 1-2,4,9-23... . integer(kind=I_P), private, parameter :: min_ss = 1 Minimum number of steps supported. integer(kind=I_P), private, parameter :: max_ss = 16 Maximum number of steps supported. Derived Types type, public :: adams_bashforth_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps. real(kind=R_P), private, allocatable :: b (:) b coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_adams_bashforth.html","title":"foodie_integrator_adams_bashforth – FOODIE"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_integrator_adams_bashforth foodie_integrator_adams_moulton foodie_utils module~~foodie_integrator_adams_bashforth_moulton~~UsesGraph module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton var panmodulefoodie_integrator_adams_bashforth_moultonUsesGraph = svgPanZoom('#modulefoodie_integrator_adams_bashforth_moultonUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order\n accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Adams-Bashforth-Moulton class scheme implemented is: predictor  U&#94;{n+N_s&#94;p} = U&#94;{n+N_s&#94;p-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s&#94;p}{ b_s&#94;p \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  corrector  U&#94;{n+N_s&#94;c} = U&#94;{n+N_s&#94;c-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s&#94;c}{ b_s&#94;c \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } \\right]  where N_s&#94;p is the number of previous steps considered for the predictor and N_s&#94;c is the number of previous steps\nconsidered for the corrector. Note The value of \\Delta t must be provided, it not being computed by the integrator. The coefficients b_s&#94;{p,c} define the actual scheme, that is selected accordingly to the number of steps used. The predictor and corrector schemes should have the same formal order of accuracy, thus N_s&#94;p=N_s&#94;c+1\n should hold. Currently, the following schemes are available: P=AB(1)-C=AM(0) step, Explicit/Implicit Farward/Backward Euler, 1st order This scheme is TVD and reverts to Explicit/Implicit Farward/Backward Euler, it being 1st order.\n The b coefficient is:\n b&#94;p = \\left[b_1\\right] = \\left[1\\right]\n b&#94;c = \\left[b_0\\right] = \\left[1\\right]\n The scheme is:\n  U&#94;{n+1,p} = U&#94;{n} + \\Delta t R(t&#94;{n},U&#94;{n}) \n  U&#94;{n+1,c} = U&#94;{n} + \\Delta t R(t&#94;{n+1},U&#94;{n+1,p})  P=AB(2)-C=AM(1) steps This scheme is 2nd order.\n The b coefficients are:\n b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right]\n b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2} & \\frac{1}{2} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+2,p} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right] \n  U&#94;{n+2,c} = U&#94;{n+1} +\\Delta t \\left[ \\frac{1}{2} R(t&#94;{n+2,p}, U&#94;{n+2})+\\frac{1}{2} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  P=AB(3)-C=AM(2) steps This scheme is 3rd order.\n The b coefficients are:\n b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right]\n b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{12} & \\frac{2}{3} & \\frac{5}{12} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+3,p} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1})\n +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right] \n  U&#94;{n+3,c} = U&#94;{n+2} +\\Delta t \\left[ \\frac{5}{12}R(t&#94;{n+3}, U&#94;{n+3,p}) + \\frac{2}{3}R(t&#94;{n+2}, U&#94;{n+2})\n -\\frac{1}{12} R(t&#94;{n+1}, U&#94;{n+1})  \\right]  P=AB(4)-C=AM(3) steps This scheme is 4th order.\n The b coefficients are:\n b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 & b_4 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} -\\frac{9}{24} & \\frac{37}{24} & -\\frac{59}{24} & \\frac{55}{24} \\end{array}} \\right]\n b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 & b_3 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{24} & -\\frac{5}{24} & \\frac{19}{24} & \\frac{9}{24} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+4,p} = U&#94;{n+3} +\\Delta t \\left[ \\frac{55}{24}R(t&#94;{n+3}, U&#94;{n+3}) - \\frac{59}{24}R(t&#94;{n+2}, U&#94;{n+2})\n +\\frac{37}{24} R(t&#94;{n+1}, U&#94;{n+1}) - \\frac{9}{24} R(t&#94;{n}, U&#94;{n}) \\right] \n  U&#94;{n+4,c} = U&#94;{n+3} +\\Delta t \\left[ \\frac{9}{24}R(t&#94;{n+4}, U&#94;{n+4,p}) + \\frac{19}{24}R(t&#94;{n+3}, U&#94;{n+3})\n -\\frac{5}{24} R(t&#94;{n+2}, U&#94;{n+2}) + \\frac{1}{24} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  Bibliography Used By module~~foodie_integrator_adams_bashforth_moulton~~UsedByGraph module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~oscillation_test_t oscillation_test_t module~foodie->module~oscillation_test_t module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_burgers type_burgers module~foodie->module~type_burgers module~oscillation_t oscillation_t module~foodie->module~oscillation_t module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~type_lorenz->program~integrate_lorenz program~integrate_oscillation integrate_oscillation module~oscillation_test_t->program~integrate_oscillation module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~oscillation_t->module~oscillation_test_t module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_adams_bashforth_moultonUsedByGraph = svgPanZoom('#modulefoodie_integrator_adams_bashforth_moultonUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: supported_steps = '1-16' List of supported steps number. Valid format is 1-2,4,9-23... . integer(kind=I_P), private, parameter :: min_ss = 1 Minimum number of steps supported. integer(kind=I_P), private, parameter :: max_ss = 16 Maximum number of steps supported. Derived Types type, public :: adams_bashforth_moulton_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = -1 Number of time steps. type( adams_bashforth_integrator ), private :: predictor Predictor solver. type( adams_moulton_integrator ), private :: corrector Corrector solver. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_adams_bashforth_moulton.html","title":"foodie_integrator_adams_bashforth_moulton – FOODIE"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_utils module~~foodie_integrator_adams_moulton~~UsesGraph module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_adams_moulton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 16th order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Adams-Moulton class scheme implemented is:  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s-1}{ b_s \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } +\n b_{N_S}\\cdot R(t&#94;{n+N_s}, U&#94;{n+N_s}) \\right]  where N_s is the number of previous steps considered. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are implicit. The coefficients b define the actual scheme, that is selected accordingly to the number of steps used. Currently, the schemes provided have steps number in [0, 15] . Note that the scheme using only 1 step reverts\n to Implciti Backwarad Euler. The formal order of accuracy varies consistently in [1st, 16th] order. Bibliography [1] Cowell Type Numerical Integration As Applied to Satellite Orbit Computation , J. L. Maury Jr.,\n G. P. Segal, X-553-69-46, April 1969, NASA-TM-X-63542 . [2] Linear multistep method , wikipedia article . Used By module~~foodie_integrator_adams_moulton~~UsedByGraph module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie foodie module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~oscillation_test_t oscillation_test_t module~foodie->module~oscillation_test_t module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_burgers type_burgers module~foodie->module~type_burgers module~oscillation_t oscillation_t module~foodie->module~oscillation_t module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~type_lorenz->program~integrate_lorenz program~integrate_oscillation integrate_oscillation module~oscillation_test_t->program~integrate_oscillation module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~oscillation_t->module~oscillation_test_t module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_adams_moultonUsedByGraph = svgPanZoom('#modulefoodie_integrator_adams_moultonUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: supported_steps = '0-15' List of supported steps number. Valid format is 1-2,4,9-23... . integer(kind=I_P), private, parameter :: min_ss = 0 Minimum number of steps supported. integer(kind=I_P), private, parameter :: max_ss = 15 Maximum number of steps supported. Derived Types type, public :: adams_moulton_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = -1 Number of time steps. real(kind=R_P), private, allocatable :: b (:) b coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_adams_moulton.html","title":"foodie_integrator_adams_moulton – FOODIE"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_utils module~~foodie_integrator_backward_differentiation_formula~~UsesGraph module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_backward_differentiation_formula Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an implicit class of Backward Differentiation Formula schemes, from 1st to 6th order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Backward Differentiation Formula class scheme implemented is:  U&#94;{n+N_s} + \\sum_{s=1}&#94;{N_s} \\alpha_s U&#94;{n+N_s-s} = \\Delta t \\left[ \\beta R(t&#94;{n+N_s}, U&#94;{n+N_s}) \\right]  where N_s is the number of previous steps considered. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are implicit. The coefficients \\alpha_s and \\beta define the actual scheme, that is selected accordingly\n to the number of steps used. Currently, the following schemes are available: Step beta alpha 1 alpha 2 alpha 3 alpha 4 alpha 5 alpha 6 1 1 -1 2 2/3 -4/3 1/3 3 6/11 -18/11 9/11 -2/11 4 12/25 -48/25 36/25 -16/25 3/25 5 60/137 -300/137 300/137 -200/137 75/137 -12/137 6 60/147 -360/147 450/147 -400/147 225/147 -72/147 10/147 Bibliography Used By module~~foodie_integrator_backward_differentiation_formula~~UsedByGraph module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~oscillation_test_t oscillation_test_t module~foodie->module~oscillation_test_t module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_burgers type_burgers module~foodie->module~type_burgers module~oscillation_t oscillation_t module~foodie->module~oscillation_t module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~type_lorenz->program~integrate_lorenz program~integrate_oscillation integrate_oscillation module~oscillation_test_t->program~integrate_oscillation module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~oscillation_t->module~oscillation_test_t module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_backward_differentiation_formulaUsedByGraph = svgPanZoom('#modulefoodie_integrator_backward_differentiation_formulaUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: supported_steps = '1-6' List of supported steps number. Valid format is 1-2,4,9-23... . integer(kind=I_P), private, parameter :: min_ss = 1 Minimum number of steps supported. integer(kind=I_P), private, parameter :: max_ss = 6 Maximum number of steps supported. Derived Types type, public :: back_df_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps. real(kind=R_P), private, allocatable :: a (:) \\alpha coefficients. real(kind=R_P), private :: b = 0.0_R_P \\beta coefficient. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_backward_differentiation_formula.html","title":"foodie_integrator_backward_differentiation_formula – FOODIE"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_utils module~~foodie_integrator_emd_runge_kutta~~UsesGraph module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_emd_runge_kutta Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 6th order accurate. The integrators provided have the embedded pairs property allowing for automatic step size control.\n The schemes are explicit and defined through the extended Butcher's table syntax, see[1] . Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form:  U_p&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_p&#94;s K&#94;s \n  U_{p+1}&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_{p+1}&#94;s K&#94;s  p is the lower accuracy order scheme and p+1 is the higher one; Ns is the number of stages used and K&#94;s is\n the s&#94;{th} stage computed as:  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are\n given in the extended Butcher table form: gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns}\n  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns}\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns}\n ------------|-------------------------------------------------------------\n             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns}\n             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: gamma&#94;1    | 0                 0                 ...        0\n  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0\n ------------|-------------------------------------------------------------\n             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns}\n             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} Moreover the following relation always holds:\n  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: Bug Presently, the 2 stages Heun-Euler seems to not work, do not use it . 2 stages, 2th order This scheme is due to Heun-Euler. 0  | 0\n  1  | 1     0\n ----------------\n     | 1/2   1/2\n     | 1      0 6 stages, 5th order This scheme is due to Cash and Karp, see [3]. 0    | 0\n  1/5    | 1/5\n  3/10 | 3/40            9/40\n  3/5    | 3/10          -9/10        6/5\n  1    | -11/54        5/2          -70/27      35/27\n  7/8    | 1631/55296    175/512      575/13824   44275/110592     253/4096     0\n ----------------------------------------------------------------------------------------\n       | 37/378        0           250/621      125/594          0            512/1771\n       | 2825/27648    0           18575/48384  13525/55296      277/14336    1/4 7 stages, 4th order This scheme is due to Dormand and Prince, see [1]. 0    | 0\n  1/5  | 1/5\n  3/10 | 3/40          9/40\n  4/5  | 44/45        -56/15        32/9\n  8/9  | 19372/6561   -25360/2187   64448/6561   -212/729\n  1    | 9017/3168    -355/33       46732/5247    49/176      -5103/18656\n  1    | 35/384        0            500/1113      125/192     -2187/6784      11/84      0\n --------------------------------------------------------------------------------------------\n       | 5179/57600    0            7571/16695    393/640     -92097/339200   187/2100   1/40\n       | 35/384        0            500/1113      125/192     -2187/6784      11/84      0 9 stages, 6th order This scheme is due to Calvo et al., see [2]. 0                 | 0\n  2/15              | 2/15\n  1/5               | 1/20                  3/20\n  3/10              | 3/40                  0                      9/40\n  14/25             | 86727015/196851553    -60129073/52624712     957436434/1378352377    83886832/147842441\n  19/25             | -86860849/45628967    111022885/25716487     108046682/101167669     -141756746/36005461\n  35226607/35688279 | 77759591/16096467     -49252809/6452555      -381680111/51572984     879269579/66788831\n  1                 | 237564263/39280295    -100523239/10677940    -265574846/27330247     317978411/18988713\n  1                 | 17572349/289262523    0                      57513011/201864250      15587306/354501571\n --------------------------------------------------------------------------------------------------------------\n                    | 17572349/289262523    0                      57513011/201864250      15587306/354501571\n                    | 15231665/510830334    0                      59452991/116050448      -28398517/122437738\n ...continued...\n  0                 |\n  2/15              |\n  1/5               |\n  3/10              |\n  14/25             |\n  19/25             | 73139862/60170633\n  35226607/35688279 | -90453121/33722162     111179552/157155827\n  1                 | -124494385/35453627    86822444/100138635     -12873523/724232625\n  1                 | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0\n -----------------------------------------------------------------------------------------------------------------------\n                    | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0\n                    | 56673824/137010559     68003849/426673583     7097631/37564021       -71226429/583093742    1/20 17 stages, 10th order This scheme is due to Feagin, see [4]. 0                        |  0\n  0.1                      |  0.1\n  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052\n  0.809036761204472681298  |  0.202259190301118170324  0                        0.606777570903354510974\n  0.309036761204472681298  |  0.184024714708643575149  0                        0.197966831227192369068\n  0.981074190219795268254  |  0.087900734020668133731  0                        0\n  0.833333333333333333333  |  0.085970050490246030218  0                        0\n  0.354017365856802376329  |  0.120930449125333720660  0                        0\n  0.882527661964732346425  |  0.110854379580391483508  0                        0\n  0.642615758240322548157  |  0.112054414752879004829  0                        0\n  0.357384241759677451842  |  0.113976783964185986138  0                        0\n  0.117472338035267653574  |  0.079831452828019604635  0                        0\n  0.833333333333333333333  |  0.985115610164857280120  0                        0\n  0.309036761204472681298  |  0.895080295771632891049  0                        0.197966831227192369068\n  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052  0\n  0.1                      |  0.1                      0                       -0.157178665799771163367\n  1                        |  0.181781300700095283888  0.675                    0.342758159847189839942\n ------------------------------------------------------------------------------------------------------\n                           |  0.033333333333333333333  0.025                    0.033333333333333333333\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  | -0.072954784731363262918\n  0.981074190219795268254  |  0.410459702520260645318  0.482713753678866489204\n  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -0.073185637507085073678\n  0.354017365856802376329  |  0                        0.260124675758295622809  0.032540262154909133015\n  0.882527661964732346425  |  0                        0                       -0.060576148825500558762\n  0.642615758240322548157  |  0                        0                       -0.144942775902865915672\n  0.357384241759677451842  |  0                        0                       -0.076881336420335693858\n  0.117472338035267653574  |  0                        0                       -0.052032968680060307651\n  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -1.378964865748435675821\n  0.309036761204472681298  | -0.072954784731363262918  0                       -0.851236239662007619739\n  0.539357840802981787532  |  0                       -0.777333643644968233538  0\n  0.1                      |  0                        0                        0\n  1                        |  0                        0.259111214548322744512 -0.358278966717952089048\n ------------------------------------------------------------------------------------------------------\n                           |  0                        0.05                     0\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  | -0.059578021181736100156\n  0.882527661964732346425  |  0.321763705601778390100  0.510485725608063031577\n  0.642615758240322548157  | -0.333269719096256706589  0.499269229556880061353  0.509504608929686104236\n  0.357384241759677451842  |  0.239527360324390649107  0.397774662368094639047  0.010755895687360745555\n  0.117472338035267653574  | -0.057695414616854888173  0.194781915712104164976  0.145384923188325069727\n  0.833333333333333333333  | -0.861164195027635666673  5.784288136375372200229  3.288077619851035668904\n  0.309036761204472681298  |  0.398320112318533301719  3.639372631810356060294  1.548228770398303223653\n  0.539357840802981787532  | -0.091089566215517606959  0                        0\n  0.1                      |  0                        0                        0\n  1                        | -1.045948959408833060950  0.930327845415626983292  1.779509594317081024461\n ------------------------------------------------------------------------------------------------------\n                           |  0.04                     0                        0.189237478148923490158\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  |\n  0.882527661964732346425  |\n  0.642615758240322548157  |\n  0.357384241759677451842  | -0.327769124164018874147\n  0.117472338035267653574  | -0.078294271035167077755 -0.114503299361098912184\n  0.833333333333333333333  | -2.386339050931363840134 -3.254793424836439186545 -2.163435416864229823539\n  0.309036761204472681298  | -2.122217147040537160260 -1.583503985453261727133 -1.715616082859362649220\n  0.539357840802981787532  |  0                        0                        0\n  0.1                      |  0                        0                        0\n  1                        |  0.1                     -0.282547569539044081612 -0.159327350119972549169\n ------------------------------------------------------------------------------------------------------\n                           |  0.277429188517743176508  0.277429188517743176508  0.189237478148923490158\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  |\n  0.882527661964732346425  |\n  0.642615758240322548157  |\n  0.357384241759677451842  |\n  0.117472338035267653574  |\n  0.833333333333333333333  |\n  0.309036761204472681298  | -0.024403640575012745213\n  0.539357840802981787532  |  0.091089566215517606959  0.777333643644968233538\n  0.1                      |  0                        0                        0.157178665799771163367\n  1                        | -0.145515894647001510860 -0.259111214548322744512 -0.342758159847189839942 -0.675\n -------------------------------------------------------------------------------------------------------------\n                           | -0.04                    -0.05                    -0.033333333333333333333 -0.025\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  |\n  0.882527661964732346425  |\n  0.642615758240322548157  |\n  0.357384241759677451842  |\n  0.117472338035267653574  |\n  0.833333333333333333333  |\n  0.309036761204472681298  |\n  0.539357840802981787532  |\n  0.1                      |\n  1                        |\n ---------------------------------------------------\n                           | 0.033333333333333333333 Bibliography [1] A family of embedded Runge-Kutta formulae , Dormand, J. R., Prince, P. J. (1980), Journal of Computational and\n Applied Mathematics 6 (1): 19–26, doi:10.1016/0771-050X(80)90013-3. [2] A New Embedded Pair of Runge-Kutta Formulas of orders 5 and 6 , M. Calvo, J.I. Montijano, L. Randez, Computers & Mathematics\n with Applications, Volume 20, Issue 1, 1990, Pages 15–24, ISSN 0898-1221, http://dx.doi.org/10.1016/0898-1221(90)90064-Q. [3] A variable order Runge-Kutta method for initial value problems with rapidly varying right-hand sides , J. R. Cash,\n A. H. Karp, ACM Transactions on Mathematical Software, vol. 16,  pp. 201–222, 1990, doi:10.1145/79505.79507. [4] A tenth-order Runge-Kutta method with error estimate , Feagin, T., Proceedings of the IAENG Conf. on Scientific\n Computing. 2007. Used By module~~foodie_integrator_emd_runge_kutta~~UsedByGraph module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie foodie module~foodie_integrator_emd_runge_kutta->module~foodie module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~oscillation_test_t oscillation_test_t module~foodie->module~oscillation_test_t module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_burgers type_burgers module~foodie->module~type_burgers module~oscillation_t oscillation_t module~foodie->module~oscillation_t module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~type_lorenz->program~integrate_lorenz program~integrate_oscillation integrate_oscillation module~oscillation_test_t->program~integrate_oscillation module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~oscillation_t->module~oscillation_test_t module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_emd_runge_kuttaUsedByGraph = svgPanZoom('#modulefoodie_integrator_emd_runge_kuttaUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: supported_stages = '6,7,9,17' List of supported stages number. Valid format is 1-2,4,9-23... . integer(kind=I_P), private, parameter :: min_ss = 6 Minimum number of stages supported. integer(kind=I_P), private, parameter :: max_ss = 17 Maximum number of stages supported. Derived Types type, public :: emd_runge_kutta_integrator Components Type Visibility Attributes Name Initial real(kind=R_P), private :: tolerance = 0._R_P Tolerance on the local truncation error. real(kind=R_P), private :: pp1_inv = 0._R_P 1/(p+1) where p is the accuracy order of the lower accurate scheme of the pair. integer(kind=I_P), private :: stages = 0 Number of stages. real(kind=R_P), private, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), private, allocatable :: beta (:,:) \\beta Butcher's coefficients. real(kind=R_P), private, allocatable :: gamm (:) \\gamma Butcher's coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_emd_runge_kutta.html","title":"foodie_integrator_emd_runge_kutta – FOODIE"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_utils module~~foodie_integrator_euler_explicit~~UsesGraph module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_euler_explicit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Forward Explicit Euler scheme implemented is:  U&#94;{n+1} = U&#94;n +\\Delta t R(t, U&#94;n)  Note The value of \\Delta t must be provided, it not being computed by the integrator. Used By module~~foodie_integrator_euler_explicit~~UsedByGraph module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie foodie module~foodie_integrator_euler_explicit->module~foodie module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~oscillation_test_t oscillation_test_t module~foodie->module~oscillation_test_t module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_burgers type_burgers module~foodie->module~type_burgers module~oscillation_t oscillation_t module~foodie->module~oscillation_t module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~type_lorenz->program~integrate_lorenz program~integrate_oscillation integrate_oscillation module~oscillation_test_t->program~integrate_oscillation module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~oscillation_t->module~oscillation_test_t module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_euler_explicitUsedByGraph = svgPanZoom('#modulefoodie_integrator_euler_explicitUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=1), private, parameter :: supported_stages_steps = '1' List of supported stages/steps number. Valid format is 1-2,4,9-23... . integer(kind=I_P), private, parameter :: min_ss = 1 Minimum number of stages/steps supported. integer(kind=I_P), private, parameter :: max_ss = 1 Maximum number of stages/steps supported. Derived Types type, public :: euler_explicit_integrator Type-Bound Procedures procedure, public, nopass :: integrate Integrate integrand field. procedure, public, nopass :: min_stages_steps Return the minimum number of stages/steps supported. procedure, public, nopass :: max_stages_steps Return the maximum number of stages/steps supported. procedure, public, nopass :: is_supported Check if the queried number of stages/steps is supported or not. Description FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. Functions private elemental function min_stages_steps () Arguments None Return Value integer(kind=I_P) Minimum number of stages/steps supported. Description Return the minimum number of stages/steps supported. private elemental function max_stages_steps () Arguments None Return Value integer(kind=I_P) Maximum number of stages/steps supported. Description Return the maximum number of stages/steps supported. private elemental function is_supported (stages_steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages_steps Number of stages/steps used. Return Value logical Is true is the stages number is in supported_stages_steps . Description Check if the queried number of stages/steps is supported or not. Subroutines private subroutine integrate (U, Dt, t) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. Description Integrate field with explicit Euler scheme, 1st order.","tags":"","loc":"module/foodie_integrator_euler_explicit.html","title":"foodie_integrator_euler_explicit – FOODIE"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_utils module~~foodie_integrator_leapfrog~~UsesGraph module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_leapfrog Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the leapfrog class scheme implemented (see [3]) is:  U&#94;{n+2} = U&#94;{n} + 2\\Delta t \\cdot R(t&#94;{n+1}, U&#94;{n+1})  Optionally, the Robert-Asselin-Williams (RAW) filter (see [3]) is applied to the computed integration steps:\n  \\Delta = \\frac{\\nu}{2}(U&#94;{n} - 2 U&#94;{n+1} + U&#94;{n+2}) \n  U&#94;{n+1} = U&#94;{n+1} + \\Delta * \\alpha \n  U&#94;{n+2} = U&#94;{n+2} + \\Delta * (\\alpha-1) \n Note that for \\alpha=1 the filter reverts back to the standard Robert-Asselin scheme.\n The filter coefficients should be taken as \\nu \\in (0,1] and \\alpha \\in (0.5,1]. The default values are \\nu=0.01 \\alpha=0.53 Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit. The filter coefficients \\nu,\\,\\alpha  define the actual scheme. Bibliography [1] The integration of a low order spectral form of the primitive meteorological equations , Robert, A. J., J. Meteor. Soc.\n Japan,vol. 44, pages 237–245, 1966. [2] Frequency filter for time integrations , Asselin, R., Monthly Weather Review, vol. 100, pages 487–490, 1972. [3] The RAW filter: An improvement to the Robert–Asselin filter in semi-implicit integrations , Williams, P.D., Monthly\n Weather Review, vol. 139(6), pages 1996–2007, June 2011. Used By module~~foodie_integrator_leapfrog~~UsedByGraph module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie foodie module~foodie_integrator_leapfrog->module~foodie module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~oscillation_test_t oscillation_test_t module~foodie->module~oscillation_test_t module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_burgers type_burgers module~foodie->module~type_burgers module~oscillation_t oscillation_t module~foodie->module~oscillation_t module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~type_lorenz->program~integrate_lorenz program~integrate_oscillation integrate_oscillation module~oscillation_test_t->program~integrate_oscillation module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~oscillation_t->module~oscillation_test_t module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_leapfrogUsedByGraph = svgPanZoom('#modulefoodie_integrator_leapfrogUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: supported_steps = '2' List of supported steps number. Valid format is 1-2,4,9-23... . integer(kind=I_P), private, parameter :: min_ss = 2 Minimum number of steps supported. integer(kind=I_P), private, parameter :: max_ss = 2 Maximum number of steps supported. Derived Types type, public :: leapfrog_integrator Components Type Visibility Attributes Name Initial real(kind=R_P), private :: nu = 0.01_R_P Robert-Asselin filter coefficient. real(kind=R_P), private :: alpha = 0.53_R_P Robert-Asselin-Williams filter coefficient. Type-Bound Procedures procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, nopass :: min_steps Return the minimum number of steps supported. procedure, public, nopass :: max_steps Return the maximum number of steps supported. procedure, public, nopass :: is_supported Check if the queried number of steps is supported or not. Description FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Functions private elemental function min_steps () Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Description Return the minimum number of steps supported. private elemental function max_steps () Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. Description Return the maximum number of steps supported. private elemental function is_supported (steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . Description Check if the queried number of steps is supported or not. Subroutines private elemental subroutine init (self, nu, alpha) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(inout) :: self LF integrator. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. Description Create the actual leapfrog integrator: initialize the filter coefficient. private subroutine integrate (self, U, previous, Dt, t, filter) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(in) :: self LF integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:2) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. class( integrand ), intent(inout), optional :: filter Filter field displacement. Description Integrate field with leapfrog class scheme.","tags":"","loc":"module/foodie_integrator_leapfrog.html","title":"foodie_integrator_leapfrog – FOODIE"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_utils module~~foodie_integrator_low_storage_runge_kutta~~UsesGraph module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. The integrators provided have the low storage property allowing for an efficient use of the memory.\n Following Williamson approach [1], the LSRK(5,4)2N (solution 3) scheme of Carpenter et al. [2] is implemented. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form: \\begin{matrix}\n K_1 = U&#94;n \\\\\n K_2 = 0 \\\\\n\\left.\\begin{matrix}\n K_2 = A_s K_2 + \\Delta t R(t&#94;n + C_s \\Delta t, K_1) \\\\\n K_1 = K_1 + B_s K_2\n\\end{matrix}\\right\\} s=1,2,...N_s\\\\\nU&#94;{n+1} = K_1\n\\end{matrix} where Ns is the number of stages used and K_1, K_2 are the 2 registers used for stages computation. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus A_1=C_1=0. The coefficients A_s, B_s, C_s are given in the Williamson low storage table\n form. The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: 1 stage, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. It is not a real low storage scheme, this being\n meaningless for a first order scheme. However it is added for safety reason. Stage A B C 1 0 1 0 5 stages, SSP, 4th order This scheme is a low storage RK(5, 4), based on the solution 3 proposed in [2]. Stage A B C 1 0 1432997174477/9575080441755 0 2 -567301805773 /1357537059087 5161836677717/13612068292357 1432997174477/9575080441755 3 -2404267990393/2016746695238 1720146321549/2090206949498 2526269341429/6820363962896 4 -3550918686646/2091501179385 3134564353537/4481467310338 2006345519317/3224310063776 5 -1275806237668/842570457699 2277821191437/14882151754819 2802321613138/2924317926251 6 stages, 4th order This scheme is a low storage RK(6, 4), by [3]. Stage A B C 1 0 0.122000000000 0 2 -0.691750960670 0.477263056358 0.122000000000 3 -1.727127405211 0.381941220320 0.269115878630 4 -0.694890150986 0.447757195744 0.447717183551 5 -1.039942756197 0.498614246822 0.749979795490 6 -1.531977447611 0.186648570846 0.898555413085 7 stages, 4th order This scheme is a low storage RK(7, 4), by [3]. Stage A B C 1 0 0.117322146869 0 2 -0.647900745934 0.503270262127 0.117322146869 3 -2.704760863204 0.233663281658 0.294523230758 4 -0.460080550118 0.283419634625 0.305658622131 5 -0.500581787785 0.540367414023 0.582864148403 6 -1.906532255913 0.371499414620 0.858664273599 7 -1.450000000000 0.136670099385 0.868664273599 12 stages, 4th order This scheme is a low storage RK(12, 4), by [4]. Stage A B C 1 0 0.0650008435125904 0 2 -0.0923311242368072 0.0161459902249842 0.0650008435125904 3 -0.9441056581158819 0.5758627178358159 0.0796560563081853 4 -4.3271273247576394 0.1649758848361671 0.1620416710085376 5 -2.1557771329026072 0.3934619494248182 0.2248877362907778 6 -0.9770727190189062 0.0443509641602719 0.2952293985641261 7 -0.7581835342571139 0.2074504268408778 0.3318332506149405 8 -1.7977525470825499 0.6914247433015102 0.4094724050198658 9 -2.6915667972700770 0.3766646883450449 0.6356954475753369 10 -4.6466798960268143 0.0757190350155483 0.6806551557645497 11 -0.1539613783825189 0.2027862031054088 0.7143773712418350 12 -0.5943293901830616 0.2167029365631842 0.9032588871651854 13 stages, 4th order This scheme is a low storage RK(13, 4), by [4]. Stage A B C 1 0 0.0271990297818803 0 2 -0.6160178650170565 0.1772488819905108 0.0271990297818803 3 -0.4449487060774118 0.0378528418949694 0.0952594339119365 4 -1.0952033345276178 0.6086431830142991 0.1266450286591127 5 -1.2256030785959187 0.2154313974316100 0.1825883045699772 6 -0.2740182222332805 0.2066152563885843 0.3737511439063931 7 -0.0411952089052647 0.0415864076069797 0.5301279418422206 8 -0.1797084899153560 0.0219891884310925 0.5704177433952291 9 -1.1771530652064288 0.9893081222650993 0.5885784947099155 10 -0.4078831463120878 0.0063199019859826 0.6160769826246714 11 -0.8295636426191777 0.3749640721105318 0.6223252334314046 12 -4.7895970584252288 1.6080235151003195 0.6897593128753419 13 -0.6606671432964504 0.0961209123818189 0.9126827615920843 14 stages, 4th order This scheme is a low storage RK(14, 4), by [4]. Stage A B C 1 0 0.0367762454319673 0 2 -0.7188012108672410 0.3136296607553959 0.0367762454319673 3 -0.7785331173421570 0.1531848691869027 0.1249685262725025 4 -0.0053282796654044 0.0030097086818182 0.2446177702277698 5 -0.8552979934029281 0.3326293790646110 0.2476149531070420 6 -3.9564138245774565 0.2440251405350864 0.2969311120382472 7 -1.5780575380587385 0.3718879239592277 0.3978149645802642 8 -2.0837094552574054 0.6204126221582444 0.5270854589440328 9 -0.7483334182761610 0.1524043173028741 0.6981269994175695 10 -0.7032861106563359 0.0760894927419266 0.8190890835352128 11 0.0013917096117681 0.0077604214040978 0.8527059887098624 12 -0.0932075369637460 0.0024647284755382 0.8604711817462826 13 -0.9514200470875948 0.0780348340049386 0.8627060376969976 14 -7.1151571693922548 5.5059777270269628 0.8734213127600976 Bibliography [1] Low-Storage Runge-Kutta Schemes , J. H. Williamson, Journal of Computational Physics, vol. 35, 1980, pp. 48–56. [2] Fourth-Order 2N-Storage Runge-Kutta Schemes , Mark H. Carpenter, Christopher A. Kennedy, NASA Technical Memorandum 109112,\n June 1994. [3] High-accuracy large-step explicit Runge–Kutta (HALE-RK) schemes for computational aeroacoustics , Vasanth Allampalli and\n Ray Hixon and M. Nallasamy and Scott D. Sawyer, Journal of Computational Physics, vol. 228, 2009, pp. 3837–3850. [4] Efficient low-storage Runge–Kutta schemes with optimized stability regions , Jens Niegemann and Richard Diehl and Kurt\n Busch, Journal of Computational Physics, vol. 231, 2012, pp. 364–372. Used By module~~foodie_integrator_low_storage_runge_kutta~~UsedByGraph module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~oscillation_test_t oscillation_test_t module~foodie->module~oscillation_test_t module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_burgers type_burgers module~foodie->module~type_burgers module~oscillation_t oscillation_t module~foodie->module~oscillation_t module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~type_lorenz->program~integrate_lorenz program~integrate_oscillation integrate_oscillation module~oscillation_test_t->program~integrate_oscillation module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~oscillation_t->module~oscillation_test_t module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_low_storage_runge_kuttaUsedByGraph = svgPanZoom('#modulefoodie_integrator_low_storage_runge_kuttaUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), private, parameter :: registers = 2 Registers used (2N schemes). character(len=99), private, parameter :: supported_stages = '1,5-7,12-14' List of supported stages number. Valid format is 1-2,4,9-23... . integer(kind=I_P), private, parameter :: min_ss = 1 Minimum number of stages supported. integer(kind=I_P), private, parameter :: max_ss = 14 Maximum number of stages supported. Derived Types type, public :: ls_runge_kutta_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: stages = 0 Number of stages. real(kind=R_P), private, allocatable :: A (:) Low storage A coefficients. real(kind=R_P), private, allocatable :: B (:) Low storage B coefficients. real(kind=R_P), private, allocatable :: C (:) Low storage C coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_low_storage_runge_kutta.html","title":"foodie_integrator_low_storage_runge_kutta – FOODIE"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_utils module~~foodie_integrator_tvd_runge_kutta~~UsesGraph module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_tvd_runge_kutta Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. The integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP)\n one. The schemes are explicit and defined through the Butcher's table syntax, see[1] . Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form:  U&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta&#94;s K&#94;s  where Ns is the number of stages used and K&#94;s is the s&#94;{th} stage computed as:  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are\n given in the Butcher table form: gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns}\n  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns}\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns}\n ------------|-------------------------------------------------------------\n             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: gamma&#94;1    | 0                 0                 ...        0\n  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0\n ------------|-------------------------------------------------------------\n             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} Moreover the following relation always holds:\n  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: 1 stage, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. 0 | 0\n ---|---\n    | 1 2 stages, SSP, 2nd order This scheme is an optmial SSP(2, 2) without low-storage algorithm, see [2]. 0 | 0     0\n  1 | 1     0\n ---|-----------\n    | 1/2   1/2 3 stages, SSP, 3rd order This scheme is an optmial SSP(3, 3) without low-storage algorithm, see [2]. 0   | 0     0     0\n  1   | 1     0     0\n  1/2 | 1/4   1/4   0\n -----|-----------------\n      | 1/6   1/6   1/3 5 stages, SSP, 4th order This scheme is an optmial SSP(5, 4) without low-storage algorithm, see [2]. 0                | 0                  0                  0                  0                  0\n  0.39175222700392 | 0.39175222700392   0                  0                  0                  0\n  0.58607968896780 | 0.21766909633821   0.36841059262959   0                  0                  0\n  0.47454236302687 | 0.08269208670950   0.13995850206999   0.25189177424738   0                  0\n  0.93501063100924 | 0.06796628370320   0.11503469844438   0.20703489864929   0.54497475021237   0\n ------------------|---------------------------------------------------------------------------------------------\n                   | 0.14681187618661   0.24848290924556   0.10425883036650   0.27443890091960   0.22600748319395 Bibliography [1] Coefficients for the study of Runge-Kutta integration processes , Butcher, J.C., J. Austral. Math. Soc., Vol. 3,\n pages: 185–201, 1963. [2] High Order Strong Stability Preserving Time Discretizations , Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of\n Scientific Computing, vol. 38, N. 3, 2009, pp. 251-289. Used By module~~foodie_integrator_tvd_runge_kutta~~UsedByGraph module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie foodie module~foodie_integrator_tvd_runge_kutta->module~foodie module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~oscillation_test_t oscillation_test_t module~foodie->module~oscillation_test_t module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_burgers type_burgers module~foodie->module~type_burgers module~oscillation_t oscillation_t module~foodie->module~oscillation_t module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~type_lorenz->program~integrate_lorenz program~integrate_oscillation integrate_oscillation module~oscillation_test_t->program~integrate_oscillation module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~oscillation_t->module~oscillation_test_t module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_tvd_runge_kuttaUsedByGraph = svgPanZoom('#modulefoodie_integrator_tvd_runge_kuttaUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: supported_stages = '1-3,5' List of supported stages number. Valid format is 1-2,4,9-23... . integer(kind=I_P), private, parameter :: min_ss = 1 Minimum number of stages supported. integer(kind=I_P), private, parameter :: max_ss = 5 Maximum number of stages supported. Derived Types type, public :: tvd_runge_kutta_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: stages = 0 Number of stages. real(kind=R_P), private, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), private, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), private, allocatable :: gamm (:) \\gamma Butcher's coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_tvd_runge_kutta.html","title":"foodie_integrator_tvd_runge_kutta – FOODIE"},{"text":"FOODIE kinds: definition of reals and integer kind parameters of FOODIE library. Used By module~~foodie_kinds~~UsedByGraph module~foodie_kinds foodie_kinds module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_adams_bashforth module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_emd_runge_kutta->module~foodie module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~oscillation_test_t oscillation_test_t module~foodie->module~oscillation_test_t module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_burgers type_burgers module~foodie->module~type_burgers module~oscillation_t oscillation_t module~foodie->module~oscillation_t module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~type_lorenz->program~integrate_lorenz program~integrate_oscillation integrate_oscillation module~oscillation_test_t->program~integrate_oscillation module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~oscillation_t->module~oscillation_test_t module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_kindsUsedByGraph = svgPanZoom('#modulefoodie_kindsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: R8P = selected_real_kind(15, 307) 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision.","tags":"","loc":"module/foodie_kinds.html","title":"foodie_kinds – FOODIE"},{"text":"Uses: foodie_kinds module~~foodie_utils~~UsesGraph module~foodie_utils foodie_utils module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE utils: module of (possible) unrelated utilities of FOODIE library. Used By module~~foodie_utils~~UsedByGraph module~foodie_utils foodie_utils module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_utils->module~foodie_integrator_adams_bashforth module~foodie foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth->module~foodie module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~oscillation_test_t oscillation_test_t module~foodie->module~oscillation_test_t module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_burgers type_burgers module~foodie->module~type_burgers module~oscillation_t oscillation_t module~foodie->module~oscillation_t module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~type_lorenz->program~integrate_lorenz program~integrate_oscillation integrate_oscillation module~oscillation_test_t->program~integrate_oscillation module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~oscillation_t->module~oscillation_test_t module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_utilsUsedByGraph = svgPanZoom('#modulefoodie_utilsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions public elemental function is_admissible (n, adm_range) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: n Number queried. character(len=*), intent(in) :: adm_range Admissible range string. Return Value logical Is true is the number is in adm_range . Description Check if the queried number n is admitted by the admissible range list adm_range . Subroutines private pure subroutine tokenize (string, delimiter, toks, Nt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be tokenized. character(len=*), intent(in) :: delimiter Delimiter of tokens. character(len=len(string)), intent(out), allocatable :: toks (:) Tokens. integer(kind=I_P), intent(out), optional :: Nt Number of tokens. Description Tokenize a string in order to parse it.","tags":"","loc":"module/foodie_utils.html","title":"foodie_utils – FOODIE"},{"text":"Uses: Data_Type_Command_Line_Interface foodie IR_Precision oscillation_t pyplot_module module~~oscillation_test_t~~UsesGraph module~oscillation_test_t oscillation_test_t IR_Precision IR_Precision IR_Precision->module~oscillation_test_t module~data_type_command_line_interface Data_Type_Command_Line_Interface IR_Precision->module~data_type_command_line_interface module~oscillation_t oscillation_t IR_Precision->module~oscillation_t module~data_type_command_line_interface->module~oscillation_test_t module~pyplot_module pyplot_module module~pyplot_module->module~oscillation_test_t module~oscillation_t->module~oscillation_test_t module~foodie foodie module~foodie->module~oscillation_test_t module~foodie->module~oscillation_t iso_fortran_env iso_fortran_env iso_fortran_env->module~data_type_command_line_interface iso_fortran_env->module~pyplot_module module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_adams_bashforth var panmoduleoscillation_test_tUsesGraph = svgPanZoom('#moduleoscillation_test_tUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Oscillation test handler definition. Used By module~~oscillation_test_t~~UsedByGraph module~oscillation_test_t oscillation_test_t program~integrate_oscillation integrate_oscillation module~oscillation_test_t->program~integrate_oscillation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, private, parameter :: space_dimension = 2 Space dimensions. real(kind=R_P), private, parameter :: initial_state (1:space_dimension) = [0._R_P, 1._R_P] Initial state. character(len=99), private, parameter :: solvers (1:10) = [\"adams-bashforth        \", \"adams-bashforth-moulton\", \"adams-moulton          \", \"backward-diff-formula  \", \"emd-runge-kutta        \", \"euler                  \", \"leapfrog               \", \"leapfrog-raw           \", \"ls-runge-kutta         \", \"tvd-runge-kutta        \"] List of available solvers. Derived Types type, public :: oscillation_test Components Type Visibility Attributes Name Initial type(Type_Command_Line_Interface), private :: cli Command line interface handler. integer(kind=I_P), private :: error = 0 Error handler. logical, private :: errors_analysis = .false. Flag for activating errors analysis. real(kind=R_P), private :: frequency = 0.0_R_P Oscillation frequency. real(kind=R_P), private :: final_time = 0.0_R_P Final integration time. integer(kind=I_P), private :: implicit_iterations = 0 Number of iterations (implicit solvers). character(len=99), private :: output_cli = 'unset' Output files basename. logical, private :: plots = .false. Flag for activating plots saving. logical, private :: results = .false. Flag for activating results saving. character(len=99), private :: solver = 'adams-bashforth' Solver used. integer(kind=I_P), private, allocatable :: stages_steps (:) Number of stages/steps used. real(kind=R_P), private, allocatable :: Dt (:) Time step(s) exercised. real(kind=R_P), private, allocatable :: tolerance (:) Tolerance(s) exercised on local truncation error. Type-Bound Procedures procedure, public, pass(self) :: execute Execute selected test(s). procedure, private, pass(self) :: init Initialize test: set Command Line Interface, parse it and check its validity. procedure, private, pass(self) :: test Perform the test. Description Class to handle oscillation test(s). Functions private pure function exact_solution_xy (frequency, t) result(ex_sol) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: frequency Oscillation frequency. real(kind=R_P), intent(in) :: t Time. Return Value real(kind=R_P)\n  (1:2) Exact solution. Description Compute the exact solution on X-Y domain. private pure function error_L2 (frequency, solution) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: frequency Oscillation frequency. real(kind=R_P), intent(in) :: solution (0:,0:) Solution at each time step. Return Value real(kind=R_P)\n  (1:space_dimension) L2 norm of the numerical error. Description Compute the L2 norm of numerical error with respect the exact solution. private pure function observed_order (error, Dt) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: error (1:space_dimension,1:2) Computed errors. real(kind=R_P), intent(in) :: Dt (1:2) Time steps used. Return Value real(kind=R_P)\n  (1:space_dimension) Estimation of the order of accuracy. Description Estimate the order of accuracy using 2 subsequent refined numerical solutions. Subroutines private subroutine execute (self) Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(inout) :: self Test. Description Execute test(s). private subroutine init (self) Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(inout) :: self Test. Description Initialize test: set Command Line Interface, parse it and check its validity. private subroutine test (self, solver) Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(in) :: self Test. character(len=*), intent(in) :: solver Selected solver. Description Perform the test. private subroutine solve (solver, frequency, final_time, stages_steps, iterations, solution, error, last_step, Dt, tolerance) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: solver Selected solver: must be defined into solvers . real(kind=R_P), intent(in) :: frequency Oscillation frequency. real(kind=R_P), intent(in) :: final_time Final integration time. integer(kind=I_P), intent(in) :: stages_steps Number of stages/steps used. integer(kind=I_P), intent(in) :: iterations Number of fixed point iterations. real(kind=R_P), intent(out), allocatable :: solution (:,:) Solution at each time step, X-Y. real(kind=R_P), intent(out) :: error (1:) Error (norm L2) with respect the exact solution. integer(kind=I_P), intent(out) :: last_step Last time step computed. real(kind=R_P), intent(in), optional :: Dt Time step. real(kind=R_P), intent(in), optional :: tolerance Local error tolerance. Description Rune the solver selected. private subroutine save_results (results, plots, output_cli, solver, frequency, solution) Arguments Type Intent Optional Attributes Name logical, intent(in) :: results Flag for activating results saving. logical, intent(in) :: plots Flag for activating plots saving. character(len=*), intent(in) :: output_cli Output files basename coming from CLI. character(len=*), intent(in) :: solver Selected solver: must be defined into solvers . real(kind=R_P), intent(in) :: frequency Oscillation frequency. real(kind=R_P), intent(in) :: solution (0:,0:) Solution at each time step. Description Save results (and plots).","tags":"","loc":"module/oscillation_test_t.html","title":"oscillation_test_t – FOODIE"},{"text":"Uses: IR_Precision foodie module~~oscillation_t~~UsesGraph module~oscillation_t oscillation_t IR_Precision IR_Precision IR_Precision->module~oscillation_t module~foodie foodie module~foodie->module~oscillation_t module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_adams_bashforth var panmoduleoscillation_tUsesGraph = svgPanZoom('#moduleoscillation_tUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Oscillation field that is a concrete extension of the abstract integrand type. Used By module~~oscillation_t~~UsedByGraph module~oscillation_t oscillation_t module~oscillation_test_t oscillation_test_t module~oscillation_t->module~oscillation_test_t program~integrate_oscillation integrate_oscillation module~oscillation_test_t->program~integrate_oscillation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: oscillation Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. real(kind=R_P), private :: f = 0._R_P Oscillation frequency (Hz). real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, [1:dims]. Type-Bound Procedures procedure, public, pass(self) :: init Init field. procedure, public, pass(self) :: output Extract Oscillation field. procedure, public, pass(self) :: t => dOscillation_dt Time derivative, residuals. procedure, public, pass(lhs) :: local_error => oscillation_local_error ||Oscillation-oscillation||. procedure, public, pass(lhs) :: integrand_multiply_integrand => oscillation_multiply_oscillation Oscillation * oscillation. procedure, public, pass(lhs) :: integrand_multiply_real => oscillation_multiply_real Oscillation * real. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_oscillation Real * Oscillation. procedure, public, pass(lhs) :: add => add_oscillation Oscillation + Oscillation. procedure, public, pass(lhs) :: sub => sub_oscillation Oscillation - Oscillation. procedure, public, pass(lhs) :: assign_integrand => oscillation_assign_oscillation Oscillation = Oscillation. Description Oscillation equations field. Functions private pure function output (self) result(state) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. Return Value real(kind=R_P),\n  dimension(:),allocatable Oscillation state vector. Description Output the Oscillation field state. private pure function dOscillation_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Oscillation field time derivative. Description Time derivative of Oscillation field. private pure function oscillation_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 oscillation approximations. private pure function oscillation_multiply_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a oscillation field by another one. private pure function oscillation_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Oscillation field by a real scalar. private pure function real_multiply_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( oscillation ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Oscillation field. private pure function add_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Oscillation fields. private pure function sub_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Oscillation fields. Subroutines private pure subroutine init (self, initial_state, frequency) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of the Oscillation field vector. real(kind=R_P), intent(in) :: frequency Frequency of oscillation. Description Construct an initialized Oscillation field. private pure subroutine oscillation_assign_oscillation (lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Oscillation field to another.","tags":"","loc":"module/oscillation_t.html","title":"oscillation_t – FOODIE"},{"text":"Uses: IR_Precision wenoof module~~type_euler_1d_caf_no_foodie~~UsesGraph module~type_euler_1d_caf_no_foodie type_euler_1D_caf_no_foodie IR_Precision IR_Precision IR_Precision->module~type_euler_1d_caf_no_foodie module~type_weno_interpolator_upwind type_weno_interpolator_upwind IR_Precision->module~type_weno_interpolator_upwind module~type_weno_interpolator type_weno_interpolator IR_Precision->module~type_weno_interpolator module~wenoof wenoof module~wenoof->module~type_euler_1d_caf_no_foodie module~type_weno_interpolator_upwind->module~wenoof module~type_weno_interpolator->module~wenoof module~type_weno_interpolator->module~type_weno_interpolator_upwind var panmoduletype_euler_1d_caf_no_foodieUsesGraph = svgPanZoom('#moduletype_euler_1d_caf_no_foodieUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Euler 1D (CAF enabled) field without extending FOODIE integrand. Used By module~~type_euler_1d_caf_no_foodie~~UsedByGraph module~type_euler_1d_caf_no_foodie type_euler_1D_caf_no_foodie program~integrate_euler_1d_caf integrate_euler_1D_caf module~type_euler_1d_caf_no_foodie->program~integrate_euler_1d_caf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: remote_U (:,:)[:] CAF buffer for sharing remote conservative variables. real(kind=R_P), private, allocatable :: remote_U (:,:) CAF buffer for sharing remote conservative variables. real(kind=R_P), private, allocatable :: U_L (:,:) Integrand (state) variables, left ghost cells [1:Nc,1:Ng]. real(kind=R_P), private, allocatable :: U_R (:,:) Integrand (state) variables, right ghost cells [1:Nc,Ni-Ng+1:Ni]. Derived Types type, public :: euler_1D_caf_nf Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type( weno_interpolator_upwind ), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. integer(kind=I_P), private :: me = 0 ID of this_image(). integer(kind=I_P), private :: we = 0 Number of CAF images used. Finalizations Procedures final :: finalize","tags":"","loc":"module/type_euler_1d_caf_no_foodie.html","title":"type_euler_1D_caf_no_foodie – FOODIE"},{"text":"Uses: IR_Precision foodie wenoof module~~type_euler_1d_caf~~UsesGraph module~type_euler_1d_caf type_euler_1D_caf IR_Precision IR_Precision IR_Precision->module~type_euler_1d_caf module~type_weno_interpolator_upwind type_weno_interpolator_upwind IR_Precision->module~type_weno_interpolator_upwind module~type_weno_interpolator type_weno_interpolator IR_Precision->module~type_weno_interpolator module~wenoof wenoof module~wenoof->module~type_euler_1d_caf module~foodie foodie module~foodie->module~type_euler_1d_caf module~type_weno_interpolator_upwind->module~wenoof module~type_weno_interpolator->module~wenoof module~type_weno_interpolator->module~type_weno_interpolator_upwind module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_adams_bashforth var panmoduletype_euler_1d_cafUsesGraph = svgPanZoom('#moduletype_euler_1d_cafUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Euler 1D (CAF enabled) field that is a concrete extension of the abstract integrand type. Used By module~~type_euler_1d_caf~~UsedByGraph module~type_euler_1d_caf type_euler_1D_caf program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: remote_U (:,:)[:] CAF buffer for sharing remote conservative variables. real(kind=R_P), private, allocatable :: remote_U (:,:) CAF buffer for sharing remote conservative variables. real(kind=R_P), private, allocatable :: U_L (:,:) Integrand (state) variables, left ghost cells [1:Nc,1:Ng]. real(kind=R_P), private, allocatable :: U_R (:,:) Integrand (state) variables, right ghost cells [1:Nc,Ni-Ng+1:Ni]. Derived Types type, public, extends(integrand) :: euler_1D_caf Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type( weno_interpolator_upwind ), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. integer(kind=I_P), private :: me = 0 ID of this_image(). integer(kind=I_P), private :: we = 0 Number of CAF images used. Finalizations Procedures final :: finalize","tags":"","loc":"module/type_euler_1d_caf.html","title":"type_euler_1D_caf – FOODIE"},{"text":"Uses: IR_Precision wenoof module~~type_euler_1d_openmp_no_foodie~~UsesGraph module~type_euler_1d_openmp_no_foodie type_euler_1D_openmp_no_foodie IR_Precision IR_Precision IR_Precision->module~type_euler_1d_openmp_no_foodie module~type_weno_interpolator_upwind type_weno_interpolator_upwind IR_Precision->module~type_weno_interpolator_upwind module~type_weno_interpolator type_weno_interpolator IR_Precision->module~type_weno_interpolator module~wenoof wenoof module~wenoof->module~type_euler_1d_openmp_no_foodie module~type_weno_interpolator_upwind->module~wenoof module~type_weno_interpolator->module~wenoof module~type_weno_interpolator->module~type_weno_interpolator_upwind var panmoduletype_euler_1d_openmp_no_foodieUsesGraph = svgPanZoom('#moduletype_euler_1d_openmp_no_foodieUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Euler 1D (OpenMP enabled) field without extending FOODIE integrand. Used By module~~type_euler_1d_openmp_no_foodie~~UsedByGraph module~type_euler_1d_openmp_no_foodie type_euler_1D_openmp_no_foodie program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie module~type_euler_1d_openmp_no_foodie->program~integrate_euler_1d_openmp_no_foodie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: euler_1D_omp_nf Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type( weno_interpolator_upwind ), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalizations Procedures final :: finalize","tags":"","loc":"module/type_euler_1d_openmp_no_foodie.html","title":"type_euler_1D_openmp_no_foodie – FOODIE"},{"text":"Uses: IR_Precision foodie wenoof module~~type_euler_1d_openmp~~UsesGraph module~type_euler_1d_openmp type_euler_1D_openmp IR_Precision IR_Precision IR_Precision->module~type_euler_1d_openmp module~type_weno_interpolator_upwind type_weno_interpolator_upwind IR_Precision->module~type_weno_interpolator_upwind module~type_weno_interpolator type_weno_interpolator IR_Precision->module~type_weno_interpolator module~wenoof wenoof module~wenoof->module~type_euler_1d_openmp module~foodie foodie module~foodie->module~type_euler_1d_openmp module~type_weno_interpolator_upwind->module~wenoof module~type_weno_interpolator->module~wenoof module~type_weno_interpolator->module~type_weno_interpolator_upwind module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_adams_bashforth var panmoduletype_euler_1d_openmpUsesGraph = svgPanZoom('#moduletype_euler_1d_openmpUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Euler 1D (OpenMP enabled) field that is a concrete extension of the abstract integrand type. Used By module~~type_euler_1d_openmp~~UsedByGraph module~type_euler_1d_openmp type_euler_1D_openmp program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~type_euler_1d_openmp->program~integrate_euler_1d_openmp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: euler_1D_openmp Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type( weno_interpolator_upwind ), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalizations Procedures final :: finalize","tags":"","loc":"module/type_euler_1d_openmp.html","title":"type_euler_1D_openmp – FOODIE"},{"text":"Uses: IR_Precision foodie module~~type_burgers~~UsesGraph module~type_burgers type_burgers IR_Precision IR_Precision IR_Precision->module~type_burgers module~foodie foodie module~foodie->module~type_burgers module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_adams_bashforth var panmoduletype_burgersUsesGraph = svgPanZoom('#moduletype_burgersUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Burgers field that is a concrete extension of the abstract integrand type. Used By module~~type_burgers~~UsedByGraph module~type_burgers type_burgers program~integrate_burgers integrate_burgers module~type_burgers->program~integrate_burgers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: burgers Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. integer(kind=I_P), private :: Ni = 0 Number of grid nodes. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private :: h = 0._R_P Space step discretization. real(kind=R_P), private :: nu = 0._R_P Viscosity. real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, whole physical domain, [1:Ni]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:Ni,1:steps]. Type-Bound Procedures procedure, public, pass(self) :: init Init field. procedure, public, pass(self) :: output Extract Burgers field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. procedure, public, pass(self) :: t => dBurgers_dt Time derivative, residuals func. procedure, public, pass(self) :: update_previous_steps Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. procedure, public, pass(lhs) :: local_error => burgers_local_error Local error. procedure, public, pass(lhs) :: integrand_multiply_integrand => burgers_multiply_burgers Burgers * burgers operator. procedure, public, pass(lhs) :: integrand_multiply_real => burgers_multiply_real Burgers * real operator. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_burgers Real * Burgers operator. procedure, public, pass(lhs) :: add => add_burgers Burgers + Burgers operator. procedure, public, pass(lhs) :: sub => sub_burgers Burgers - Burgers operator. procedure, public, pass(lhs) :: assign_integrand => burgers_assign_burgers Burgers = Burgers. procedure, public, pass(lhs) :: assign_real => burgers_assign_real Burgers = real. procedure, private, pass(self) :: x => dBurgers_dx 1st derivative. procedure, private, pass(self) :: xx => d2Burgers_dx2 2nd derivative. Description Burgers equations field. Functions private pure function output (self) result(state) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value real(kind=R_P),\n  dimension(:),allocatable Burgers state variable. Description Output the Burgers field state. private pure function compute_dt (self, CFL) result(dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in) :: CFL Courant-Friedricks-Lewi stability coefficient. Return Value real(kind=R_P) Current time step. Description Compute the current time step, by means of CFL condition. private function dBurgers_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Burgers field time derivative. Description Time derivative of Burgers field, residuals function. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Burgers field. Description Extract previous time solution of Burgers field. private function burgers_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 burgers approximations. private function burgers_multiply_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by another one. private function burgers_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by a real scalar. private function real_multiply_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( burgers ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Burgers field. private function add_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Burgers fields. private function sub_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Burgers fields. private function dBurgers_dx (self) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative. Description Compute the first order spatial derivative of Burgers field. private function d2Burgers_dx2 (self) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative. Description Compute the second order spatial derivative of Burgers field. Subroutines private subroutine init (self, initial_state, Ni, h, nu, steps) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. real(kind=R_P), intent(in), dimension(1:Ni) :: initial_state Initial state of Burgers field domain. integer(kind=I_P), intent(in) :: Ni Number of grid nodes. real(kind=R_P), intent(in) :: h Space step discretization. real(kind=R_P), intent(in) :: nu Viscosity. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Burgers field. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. private subroutine burgers_assign_burgers (lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Burgers field to another. private subroutine burgers_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Burgers field.","tags":"","loc":"module/type_burgers.html","title":"type_burgers – FOODIE"},{"text":"Uses: IR_Precision foodie wenoof module~~type_euler_1d~~UsesGraph module~type_euler_1d type_euler_1D IR_Precision IR_Precision IR_Precision->module~type_euler_1d module~type_weno_interpolator_upwind type_weno_interpolator_upwind IR_Precision->module~type_weno_interpolator_upwind module~type_weno_interpolator type_weno_interpolator IR_Precision->module~type_weno_interpolator module~wenoof wenoof module~wenoof->module~type_euler_1d module~foodie foodie module~foodie->module~type_euler_1d module~type_weno_interpolator_upwind->module~wenoof module~type_weno_interpolator->module~wenoof module~type_weno_interpolator->module~type_weno_interpolator_upwind module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_adams_bashforth var panmoduletype_euler_1dUsesGraph = svgPanZoom('#moduletype_euler_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Euler 1D field that is a concrete extension of the abstract integrand type. Used By module~~type_euler_1d~~UsedByGraph module~type_euler_1d type_euler_1D program~integrate_euler_1d integrate_euler_1D module~type_euler_1d->program~integrate_euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: euler_1D Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps stored. integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type( weno_interpolator_upwind ), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real(kind=R_P), private, allocatable :: previous (:,:,:) Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalizations Procedures final :: finalize","tags":"","loc":"module/type_euler_1d.html","title":"type_euler_1D – FOODIE"},{"text":"Uses: IR_Precision foodie module~~type_lorenz~~UsesGraph module~type_lorenz type_lorenz IR_Precision IR_Precision IR_Precision->module~type_lorenz module~foodie foodie module~foodie->module~type_lorenz module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_adams_bashforth var panmoduletype_lorenzUsesGraph = svgPanZoom('#moduletype_lorenzUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Lorenz field that is a concrete extension of the abstract integrand type. Used By module~~type_lorenz~~UsedByGraph module~type_lorenz type_lorenz program~integrate_lorenz integrate_lorenz module~type_lorenz->program~integrate_lorenz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: lorenz Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, [1:dims]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:dims,1:steps]. real(kind=R_P), private :: sigma = 0._R_P Lorenz \\sigma. real(kind=R_P), private :: rho = 0._R_P Lorenz \\rho. real(kind=R_P), private :: beta = 0._R_P Lorenz \\beta. Type-Bound Procedures procedure, public, pass(self) :: init Init field. procedure, public, pass(self) :: output Extract Lorenz field. procedure, public, pass(self) :: t => dLorenz_dt Time derivative, residuals function. procedure, public, pass(lhs) :: local_error => lorenz_local_error Local error. procedure, public, pass(self) :: update_previous_steps Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. procedure, public, pass(lhs) :: integrand_multiply_integrand => lorenz_multiply_lorenz Lorenz * Lorenz operator. procedure, public, pass(lhs) :: integrand_multiply_real => lorenz_multiply_real Lorenz * real operator. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_lorenz Real * Lorenz operator. procedure, public, pass(lhs) :: add => add_lorenz Lorenz + Lorenz operator. procedure, public, pass(lhs) :: sub => sub_lorenz Lorenz - Lorenz. procedure, public, pass(lhs) :: assign_integrand => lorenz_assign_lorenz Lorenz = Lorenz. procedure, public, pass(lhs) :: assign_real => lorenz_assign_real Lorenz = real. Description Lorenz equations field. Functions private pure function output (self) result(state) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value real(kind=R_P),\n  dimension(:),allocatable Lorenz state vector. Description Output the Lorenz field state. private function dLorenz_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Lorenz field time derivative. Description Time derivative of Lorenz field. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Lorenz field. Description Extract previous time solution of Lorenz field. private function lorenz_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 lorenz approximations. private function lorenz_multiply_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a lorenz field by another one. private function lorenz_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Lorenz field by a real scalar. private function real_multiply_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( lorenz ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Lorenz field. private function add_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Lorenz fields. private function sub_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Lorenz fields. Subroutines private subroutine init (self, initial_state, sigma, rho, beta, steps) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Lorenz field. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. private subroutine lorenz_assign_lorenz (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Lorenz field to another. private subroutine lorenz_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Lorenz field.","tags":"","loc":"module/type_lorenz.html","title":"type_lorenz – FOODIE"},{"text":"Uses: IR_Precision iso_fortran_env module~~data_type_command_line_interface~~UsesGraph module~data_type_command_line_interface Data_Type_Command_Line_Interface IR_Precision IR_Precision IR_Precision->module~data_type_command_line_interface iso_fortran_env iso_fortran_env iso_fortran_env->module~data_type_command_line_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FLAP, Fortran command Line Arguments Parser for poor people Used By module~~data_type_command_line_interface~~UsedByGraph module~data_type_command_line_interface Data_Type_Command_Line_Interface program~integrate_burgers integrate_burgers module~data_type_command_line_interface->program~integrate_burgers program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie module~data_type_command_line_interface->program~integrate_euler_1d_openmp_no_foodie module~oscillation_test_t oscillation_test_t module~data_type_command_line_interface->module~oscillation_test_t program~integrate_euler_1d integrate_euler_1D module~data_type_command_line_interface->program~integrate_euler_1d program~test_nested test_nested module~data_type_command_line_interface->program~test_nested program~test_string test_string module~data_type_command_line_interface->program~test_string program~integrate_euler_1d_caf integrate_euler_1D_caf module~data_type_command_line_interface->program~integrate_euler_1d_caf program~test_basic test_basic module~data_type_command_line_interface->program~test_basic program~test_choices_logical test_choices_logical module~data_type_command_line_interface->program~test_choices_logical program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~data_type_command_line_interface->program~integrate_euler_1d_caf~2 program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~data_type_command_line_interface->program~integrate_euler_1d_openmp program~integrate_lorenz integrate_lorenz module~data_type_command_line_interface->program~integrate_lorenz program~integrate_oscillation integrate_oscillation module~oscillation_test_t->program~integrate_oscillation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), private, parameter :: max_val_len = 1000 Maximum number of characters of CLA value. character(len=*), private, parameter :: action_store = 'STORE' CLA that stores value (if invoked a value must be passed). character(len=*), private, parameter :: action_store_star = 'STORE*' CLA that stores value or revert on default is invoked alone. character(len=*), private, parameter :: action_store_true = 'STORE_TRUE' CLA that stores .true. without the necessity of a value. character(len=*), private, parameter :: action_store_false = 'STORE_FALSE' CLA that stores .false. without the necessity of a value. character(len=*), private, parameter :: action_print_help = 'PRINT_HELP' CLA that print help message. character(len=*), private, parameter :: action_print_vers = 'PRINT_VERSION' CLA that print version. character(len=*), private, parameter :: args_sep = '||!||' Arguments separator for multiple valued (list) CLA. integer(kind=I4P), private, parameter :: error_cla_optional_no_def = 1 Optional CLA without default value. integer(kind=I4P), private, parameter :: error_cla_required_m_exclude = 2 Required CLA cannot exclude others. integer(kind=I4P), private, parameter :: error_cla_positional_m_exclude = 3 Positional CLA cannot exclude others. integer(kind=I4P), private, parameter :: error_cla_named_no_name = 4 Named CLA without switch name. integer(kind=I4P), private, parameter :: error_cla_positional_no_position = 5 Positional CLA without position. integer(kind=I4P), private, parameter :: error_cla_positional_no_store = 6 Positional CLA without action_store. integer(kind=I4P), private, parameter :: error_cla_not_in_choices = 7 CLA value out of a specified choices. integer(kind=I4P), private, parameter :: error_cla_missing_required = 8 Missing required CLA. integer(kind=I4P), private, parameter :: error_cla_m_exclude = 9 Two mutually exclusive CLAs have been passed. integer(kind=I4P), private, parameter :: error_cla_casting_logical = 10 Error casting CLA value to logical type. integer(kind=I4P), private, parameter :: error_cla_choices_logical = 11 Error adding choices check for CLA value of logical type. integer(kind=I4P), private, parameter :: error_cla_no_list = 12 Actual CLA is not list-values. integer(kind=I4P), private, parameter :: error_cla_nargs_insufficient = 13 Multi-valued CLA with insufficient arguments. integer(kind=I4P), private, parameter :: error_cla_value_missing = 14 Missing value of CLA. integer(kind=I4P), private, parameter :: error_cla_unknown = 15 Unknown CLA (switch name). integer(kind=I4P), private, parameter :: error_cla_envvar_positional = 16 Envvar not allowed for positional CLA. integer(kind=I4P), private, parameter :: error_cla_envvar_not_store = 17 Envvar not allowed action different from store; integer(kind=I4P), private, parameter :: error_cla_envvar_nargs = 18 Envvar not allowed for list-values CLA. integer(kind=I4P), private, parameter :: error_cla_store_star_positional = 19 Action store* not allowed for positional CLA. integer(kind=I4P), private, parameter :: error_cla_store_star_nargs = 20 Action store* not allowed for list-values CLA. integer(kind=I4P), private, parameter :: error_cla_store_star_envvar = 21 Action store* not allowed for environment variable CLA. integer(kind=I4P), private, parameter :: error_cla_action_unknown = 22 Unknown CLA (switch name). integer(kind=I4P), private, parameter :: error_clasg_consistency = 23 CLAs group consistency error. integer(kind=I4P), private, parameter :: error_clasg_m_exclude = 24 Two mutually exclusive CLAs group have been called. integer(kind=I4P), private, parameter :: error_cli_missing_cla = 25 CLA not found in CLI. integer(kind=I4P), private, parameter :: error_cli_missing_group = 26 Group not found in CLI. integer(kind=I4P), private, parameter :: error_cli_missing_selection_cla = 27 CLA selection in CLI failing. integer(kind=I4P), private, parameter :: error_cli_too_few_clas = 28 Insufficient arguments for CLI. integer(kind=I4P), private, parameter :: status_clasg_print_v = -1 Print version status. integer(kind=I4P), private, parameter :: status_clasg_print_h = -2 Print help status. Derived Types type, private, abstract :: Type_Object Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), private, allocatable :: help Help message. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilog message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). integer(kind=I4P), public :: error = 0_I4P Error traping flag. Type-Bound Procedures procedure, public :: free_object Free dynamic memory. procedure, public :: errored Trig error occurence and print meaningful message. procedure, public :: print_version Print version. procedure, public :: assign_object Assignment overloading. Description Abstract object defining data and methods that are common to CLA, CLAG and CLI. type, private, extends( Type_Object ) :: Type_Command_Line_Argument Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: switch Switch name. character(len=:), private, allocatable :: switch_ab Abbreviated switch name. logical, private :: required = .false. Flag for set required argument. logical, private :: positional = .false. Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), private :: position = 0_I4P Position of positional CLA. logical, private :: passed = .false. Flag for checking if CLA has been passed to CLI. logical, private :: hidden = .false. Flag for hiding CLA, thus it does not compare into help. character(len=:), private, allocatable :: act CLA value action. character(len=:), private, allocatable :: def Default value. character(len=:), private, allocatable :: nargs Number of arguments consumed by CLA. character(len=:), private, allocatable :: choices List (comma separated) of allowable values for the argument. character(len=:), private, allocatable :: val CLA value. character(len=:), private, allocatable :: envvar Environment variable from which take value. Finalizations Procedures final :: finalize_cla","tags":"","loc":"module/data_type_command_line_interface.html","title":"Data_Type_Command_Line_Interface – FOODIE"},{"text":"Uses: IR_Precision module~~type_weno_interpolator~~UsesGraph module~type_weno_interpolator type_weno_interpolator IR_Precision IR_Precision IR_Precision->module~type_weno_interpolator Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract WENO interpolator object, Used By module~~type_weno_interpolator~~UsedByGraph module~type_weno_interpolator type_weno_interpolator module~wenoof wenoof module~type_weno_interpolator->module~wenoof module~type_weno_interpolator_upwind type_weno_interpolator_upwind module~type_weno_interpolator->module~type_weno_interpolator_upwind module~type_euler_1d_openmp type_euler_1D_openmp module~wenoof->module~type_euler_1d_openmp module~type_euler_1d_openmp_no_foodie type_euler_1D_openmp_no_foodie module~wenoof->module~type_euler_1d_openmp_no_foodie module~type_euler_1d type_euler_1D module~wenoof->module~type_euler_1d module~type_euler_1d_caf_no_foodie type_euler_1D_caf_no_foodie module~wenoof->module~type_euler_1d_caf_no_foodie module~type_euler_1d_caf type_euler_1D_caf module~wenoof->module~type_euler_1d_caf module~type_weno_interpolator_upwind->module~wenoof program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~type_euler_1d_openmp->program~integrate_euler_1d_openmp program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie module~type_euler_1d_openmp_no_foodie->program~integrate_euler_1d_openmp_no_foodie program~integrate_euler_1d integrate_euler_1D module~type_euler_1d->program~integrate_euler_1d program~integrate_euler_1d_caf integrate_euler_1D_caf module~type_euler_1d_caf_no_foodie->program~integrate_euler_1d_caf program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 var panmoduletype_weno_interpolatorUsedByGraph = svgPanZoom('#moduletype_weno_interpolatorUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private elemental subroutine abstract_destructor (self) Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(inout) :: self WENO interpolator. Description Destoy a WENO interpolator. abstract interface private subroutine abstract_constructor (self, constructor) Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(inout) :: self WENO interpolator. class( weno_constructor ), intent(in) :: constructor WENO constructor. Description Create a WENO interpolator. abstract interface private pure subroutine abstract_description (self, string) Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(in) :: self WENO interpolator. character(len=:), intent(out), allocatable :: string String returned. Description Return a string describing a WENO interpolator. abstract interface private pure subroutine abstract_interpolate (self, S, stencil, location, interpolation) Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(in) :: self WENO interpolator. integer(kind=I_P), intent(in) :: S Number of stencils used. real(kind=R_P), intent(in) :: stencil (1:,1-S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. character(len=*), intent(in) :: location Location of interpolated value(s): central, left, right, both. real(kind=R_P), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Description Interpolate the stecil input values computing the actual interpolation. Derived Types type, public, abstract :: weno_constructor Description Abstract type used for create new concrete WENO interpolators. type, public, abstract :: weno_interpolator Type-Bound Procedures procedure(abstract_destructor), public, pass(self), deferred :: destroy procedure(abstract_constructor), public, pass(self), deferred :: create procedure(abstract_description), public, pass(self), deferred :: description procedure(abstract_interpolate), public, pass(self), deferred :: interpolate Description WENO interpolator object.","tags":"","loc":"module/type_weno_interpolator.html","title":"type_weno_interpolator – FOODIE"},{"text":"Uses: IR_Precision type_weno_interpolator module~~type_weno_interpolator_upwind~~UsesGraph module~type_weno_interpolator_upwind type_weno_interpolator_upwind IR_Precision IR_Precision IR_Precision->module~type_weno_interpolator_upwind module~type_weno_interpolator type_weno_interpolator IR_Precision->module~type_weno_interpolator module~type_weno_interpolator->module~type_weno_interpolator_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module providing upwind biased WENO interpolator object and constructor, Note The provided WENO interpolator implements the Efficient Implementation of Weighted ENO Schemes ,\n Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202–228, doi:10.1006/jcph.1996.0130. Used By module~~type_weno_interpolator_upwind~~UsedByGraph module~type_weno_interpolator_upwind type_weno_interpolator_upwind module~wenoof wenoof module~type_weno_interpolator_upwind->module~wenoof module~type_euler_1d_openmp type_euler_1D_openmp module~wenoof->module~type_euler_1d_openmp module~type_euler_1d_openmp_no_foodie type_euler_1D_openmp_no_foodie module~wenoof->module~type_euler_1d_openmp_no_foodie module~type_euler_1d type_euler_1D module~wenoof->module~type_euler_1d module~type_euler_1d_caf_no_foodie type_euler_1D_caf_no_foodie module~wenoof->module~type_euler_1d_caf_no_foodie module~type_euler_1d_caf type_euler_1D_caf module~wenoof->module~type_euler_1d_caf program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~type_euler_1d_openmp->program~integrate_euler_1d_openmp program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie module~type_euler_1d_openmp_no_foodie->program~integrate_euler_1d_openmp_no_foodie program~integrate_euler_1d integrate_euler_1D module~type_euler_1d->program~integrate_euler_1d program~integrate_euler_1d_caf integrate_euler_1D_caf module~type_euler_1d_caf_no_foodie->program~integrate_euler_1d_caf program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 var panmoduletype_weno_interpolator_upwindUsedByGraph = svgPanZoom('#moduletype_weno_interpolator_upwindUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface weno_constructor_upwind private elemental function weno_constructor_upwind_init (S, eps) result(constructor) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: S Maximum stencils dimension. real(kind=R_P), intent(in), optional :: eps Parameter for avoiding divided by zero when computing smoothness indicators. Return Value type( weno_constructor_upwind ) WENO constructor. Description Create (initialize) the WENO interpolator. Derived Types type, public, extends(weno_constructor) :: weno_constructor_upwind Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0 Stencils dimension. real(kind=R_P), public :: eps = 10._R_P**(-6) Parameter for avoiding divided by zero when computing smoothness indicators. Constructor private elemental function weno_constructor_upwind_init (S, eps) Create (initialize) the WENO interpolator. Description Upwind biased WENO interpolator constructor, type, public, extends(weno_interpolator) :: weno_interpolator_upwind Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: S = 0_I_P Stencil dimension. real(kind=R_P), private :: eps = 0._R_P Parameter for avoiding divided by zero when computing smoothness indicators. real(kind=R_P), private, allocatable :: weights_opt (:,:) Optimal weights                    [1:2,0:S-1]. real(kind=R_P), private, allocatable :: poly_coef (:,:,:) Polynomials coefficients           [1:2,0:S-1,0:S-1]. real(kind=R_P), private, allocatable :: smooth_coef (:,:,:) Smoothness indicators coefficients [0:S-1,0:S-1,0:S-1]. Finalizations Procedures final :: finalize","tags":"","loc":"module/type_weno_interpolator_upwind.html","title":"type_weno_interpolator_upwind – FOODIE"},{"text":"Uses: type_weno_interpolator type_weno_interpolator_upwind module~~wenoof~~UsesGraph module~wenoof wenoof module~type_weno_interpolator_upwind type_weno_interpolator_upwind module~type_weno_interpolator_upwind->module~wenoof module~type_weno_interpolator type_weno_interpolator module~type_weno_interpolator->module~wenoof module~type_weno_interpolator->module~type_weno_interpolator_upwind IR_Precision IR_Precision IR_Precision->module~type_weno_interpolator_upwind IR_Precision->module~type_weno_interpolator Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. WenOOF, WENO interpolation Object Oriented Fortran library Used By module~~wenoof~~UsedByGraph module~wenoof wenoof module~type_euler_1d_openmp type_euler_1D_openmp module~wenoof->module~type_euler_1d_openmp module~type_euler_1d_openmp_no_foodie type_euler_1D_openmp_no_foodie module~wenoof->module~type_euler_1d_openmp_no_foodie module~type_euler_1d type_euler_1D module~wenoof->module~type_euler_1d module~type_euler_1d_caf_no_foodie type_euler_1D_caf_no_foodie module~wenoof->module~type_euler_1d_caf_no_foodie module~type_euler_1d_caf type_euler_1D_caf module~wenoof->module~type_euler_1d_caf program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~type_euler_1d_openmp->program~integrate_euler_1d_openmp program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie module~type_euler_1d_openmp_no_foodie->program~integrate_euler_1d_openmp_no_foodie program~integrate_euler_1d integrate_euler_1D module~type_euler_1d->program~integrate_euler_1d program~integrate_euler_1d_caf integrate_euler_1D_caf module~type_euler_1d_caf_no_foodie->program~integrate_euler_1d_caf program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: weno_factory Type-Bound Procedures procedure, public, nopass :: create Description WENO factory aimed to create and return a concrete WENO interpolator to the client code without exposing the concrete\n interpolators classes. Subroutines private subroutine create (constructor, interpolator) Arguments Type Intent Optional Attributes Name class( weno_constructor ), intent(in) :: constructor The concrete WENO constructor selected by client code. class( weno_interpolator ), intent(out), allocatable :: interpolator The concrete WENO interpolator. Description Create and return a concrete WENO interpolator object being an extension of the abstract weno_interpolator type.","tags":"","loc":"module/wenoof.html","title":"wenoof – FOODIE"},{"text":"Uses: iso_fortran_env module~~pyplot_module~~UsesGraph module~pyplot_module pyplot_module iso_fortran_env iso_fortran_env iso_fortran_env->module~pyplot_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~pyplot_module~~UsedByGraph module~pyplot_module pyplot_module program~integrate_burgers integrate_burgers module~pyplot_module->program~integrate_burgers program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie module~pyplot_module->program~integrate_euler_1d_openmp_no_foodie program~test test module~pyplot_module->program~test module~oscillation_test_t oscillation_test_t module~pyplot_module->module~oscillation_test_t program~integrate_euler_1d integrate_euler_1D module~pyplot_module->program~integrate_euler_1d program~integrate_euler_1d_caf integrate_euler_1D_caf module~pyplot_module->program~integrate_euler_1d_caf program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~pyplot_module->program~integrate_euler_1d_caf~2 program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~pyplot_module->program~integrate_euler_1d_openmp program~integrate_lorenz integrate_lorenz module~pyplot_module->program~integrate_lorenz program~integrate_oscillation integrate_oscillation module~oscillation_test_t->program~integrate_oscillation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, private, parameter :: wp = real64 character(len=*), private, parameter :: tmp_file = 'pyplot_module_temp_1234567890.py' character(len=*), private, parameter :: python_exe = 'python' character(len=*), private, parameter :: int_fmt = '(I10)' integer, private, parameter :: max_int_len = 10 character(len=*), private, parameter :: real_fmt_default = '(E30.16)' integer, private, parameter :: max_real_len = 30 Derived Types type, public :: pyplot Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: str logical, private :: show_legend = .false. logical, private :: use_numpy = .true. logical, private :: mplot3d = .false. logical, private :: polar = .false. logical, private :: axis_equal = .false. character(len=:), private, allocatable :: real_fmt Type-Bound Procedures procedure, public :: initialize procedure, public :: add_plot procedure, public :: add_3d_plot procedure, public :: add_contour procedure, public :: add_bar procedure, public :: savefig procedure, public :: destroy procedure, public :: execute procedure, public :: add_str Subroutines private subroutine destroy (me) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me Description Author Jacob Williams private subroutine add_str (me, str) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in) :: str Description Author Jacob Williams private subroutine initialize (me, grid, xlabel, ylabel, zlabel, title, legend, use_numpy, figsize, font_size, axes_labelsize, xtick_labelsize, ytick_labelsize, ztick_labelsize, legend_fontsize, mplot3d, axis_equal, polar, real_fmt) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me logical, intent(in), optional :: grid character(len=*), intent(in), optional :: xlabel character(len=*), intent(in), optional :: ylabel character(len=*), intent(in), optional :: zlabel character(len=*), intent(in), optional :: title logical, intent(in), optional :: legend logical, intent(in), optional :: use_numpy integer, intent(in), optional dimension(2) :: figsize integer, intent(in), optional :: font_size integer, intent(in), optional :: axes_labelsize integer, intent(in), optional :: xtick_labelsize integer, intent(in), optional :: ytick_labelsize integer, intent(in), optional :: ztick_labelsize integer, intent(in), optional :: legend_fontsize logical, intent(in), optional :: mplot3d logical, intent(in), optional :: axis_equal logical, intent(in), optional :: polar character(len=*), intent(in), optional :: real_fmt Description Author Jacob Williams private subroutine add_plot (me, x, y, label, linestyle, markersize, linewidth, xlim, ylim, xscale, yscale) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y character(len=*), intent(in) :: label character(len=*), intent(in) :: linestyle integer, intent(in), optional :: markersize integer, intent(in), optional :: linewidth real(kind=wp), intent(in), optional dimension(2) :: xlim real(kind=wp), intent(in), optional dimension(2) :: ylim character(len=*), intent(in), optional :: xscale character(len=*), intent(in), optional :: yscale Description Author Jacob Williams private subroutine add_contour (me, x, y, z, label, linestyle, linewidth, levels, color, filled, cmap) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:,:) :: z character(len=*), intent(in) :: label character(len=*), intent(in) :: linestyle integer, intent(in), optional :: linewidth real(kind=wp), intent(in), optional dimension(:) :: levels character(len=*), intent(in), optional :: color logical, intent(in), optional :: filled character(len=*), intent(in), optional :: cmap Description Author Jacob Williams private subroutine add_3d_plot (me, x, y, z, label, linestyle, markersize, linewidth) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z character(len=*), intent(in) :: label character(len=*), intent(in) :: linestyle integer, intent(in), optional :: markersize integer, intent(in), optional :: linewidth Description Author Jacob Williams private subroutine add_bar (me, left, height, label, width, bottom, color, yerr, align, xlim, ylim, xscale, yscale) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: left real(kind=wp), intent(in), dimension(:) :: height character(len=*), intent(in) :: label real(kind=wp), intent(in), optional dimension(:) :: width real(kind=wp), intent(in), optional dimension(:) :: bottom character(len=*), intent(in), optional :: color real(kind=wp), intent(in), optional dimension(:) :: yerr character(len=*), intent(in), optional :: align real(kind=wp), intent(in), optional dimension(2) :: xlim real(kind=wp), intent(in), optional dimension(2) :: ylim character(len=*), intent(in), optional :: xscale character(len=*), intent(in), optional :: yscale Description Author Jacob Williams private subroutine optional_int_to_string (int_value, string_value, default_value) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: int_value character(len=*), intent(out) :: string_value character(len=*), intent(in) :: default_value Description Author Jacob Williams private subroutine integer_to_string (i, s) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: i character(len=*), intent(out) :: s Description Author Jacob Williams private subroutine vec_to_string (v, fmt, str, use_numpy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: v character(len=*), intent(in) :: fmt character(len=:), intent(out), allocatable :: str logical, intent(in) :: use_numpy Description Author Jacob Williams private subroutine matrix_to_string (v, fmt, str, use_numpy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: v character(len=*), intent(in) :: fmt character(len=:), intent(out), allocatable :: str logical, intent(in) :: use_numpy Description Author Jacob Williams private subroutine execute (me, pyfile) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in), optional :: pyfile Description Author Jacob Williams private subroutine savefig (me, figfile, pyfile) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in) :: figfile character(len=*), intent(in), optional :: pyfile Description Author Jacob Williams","tags":"","loc":"module/pyplot_module.html","title":"pyplot_module – FOODIE"},{"text":"Uses: oscillation_test_t program~~integrate_oscillation~~UsesGraph program~integrate_oscillation integrate_oscillation module~oscillation_test_t oscillation_test_t module~oscillation_test_t->program~integrate_oscillation IR_Precision IR_Precision IR_Precision->module~oscillation_test_t module~data_type_command_line_interface Data_Type_Command_Line_Interface IR_Precision->module~data_type_command_line_interface module~oscillation_t oscillation_t IR_Precision->module~oscillation_t module~data_type_command_line_interface->module~oscillation_test_t module~pyplot_module pyplot_module module~pyplot_module->module~oscillation_test_t module~oscillation_t->module~oscillation_test_t module~foodie foodie module~foodie->module~oscillation_test_t module~foodie->module~oscillation_t iso_fortran_env iso_fortran_env iso_fortran_env->module~data_type_command_line_interface iso_fortran_env->module~pyplot_module module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_adams_bashforth var panprogramintegrate_oscillationUsesGraph = svgPanZoom('#programintegrate_oscillationUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODIE with the integration of Oscillation equations. Variables Type Attributes Name Initial type( oscillation_test ) :: test Oscillation test. Source Code program integrate_oscillation !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Oscillation equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use oscillation_test_t , only : oscillation_test !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( oscillation_test ) :: test !< Oscillation test. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call test % execute stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram integrate_oscillation","tags":"","loc":"program/integrate_oscillation.html","title":"integrate_oscillation – FOODIE"},{"text":"Uses: IR_Precision type_euler_1D_caf_no_foodie Data_Type_Command_Line_Interface pyplot_module program~~integrate_euler_1d_caf~~UsesGraph program~integrate_euler_1d_caf integrate_euler_1D_caf IR_Precision IR_Precision IR_Precision->program~integrate_euler_1d_caf module~type_euler_1d_caf_no_foodie type_euler_1D_caf_no_foodie IR_Precision->module~type_euler_1d_caf_no_foodie module~data_type_command_line_interface Data_Type_Command_Line_Interface IR_Precision->module~data_type_command_line_interface module~type_weno_interpolator_upwind type_weno_interpolator_upwind IR_Precision->module~type_weno_interpolator_upwind module~type_weno_interpolator type_weno_interpolator IR_Precision->module~type_weno_interpolator module~pyplot_module pyplot_module module~pyplot_module->program~integrate_euler_1d_caf module~type_euler_1d_caf_no_foodie->program~integrate_euler_1d_caf module~data_type_command_line_interface->program~integrate_euler_1d_caf iso_fortran_env iso_fortran_env iso_fortran_env->module~pyplot_module iso_fortran_env->module~data_type_command_line_interface module~wenoof wenoof module~wenoof->module~type_euler_1d_caf_no_foodie module~type_weno_interpolator_upwind->module~wenoof module~type_weno_interpolator->module~wenoof module~type_weno_interpolator->module~type_weno_interpolator_upwind var panprogramintegrate_euler_1d_cafUsesGraph = svgPanZoom('#programintegrate_euler_1d_cafUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test without FOODIE with the integration of Euler 1D PDEs system by CAF paradigm. Calls program~~integrate_euler_1d_caf~~CallsGraph program~integrate_euler_1d_caf integrate_euler_1D_caf proc~init~11 init program~integrate_euler_1d_caf->proc~init~11 strz strz program~integrate_euler_1d_caf->strz proc~synchronize synchronize program~integrate_euler_1d_caf->proc~synchronize proc~save_time_serie save_time_serie program~integrate_euler_1d_caf->proc~save_time_serie proc~save_results~2 save_results program~integrate_euler_1d_caf->proc~save_results~2 str str program~integrate_euler_1d_caf->str proc~init~11->strz proc~init~11->proc~save_time_serie proc~init~11->str proc~save_time_serie->str proc~save_results~2->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( tvd_runge_kutta_integrator ) :: rk_integrator Runge-Kutta integrator. integer, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D_caf_nf) :: rk_stage (1:rk_stages) Runge-Kutta stages. integer, parameter :: ord = 7 Space reconstruciton order, real(kind=R_P) :: t Time. real(kind=R_P), parameter :: CFL = 0.7_R_P CFL value. integer(kind=I_P), parameter :: Ns = 1 Number of differnt initial gas species. integer(kind=I_P), parameter :: Nc = Ns+2 Number of conservative variables. integer(kind=I_P), parameter :: Np = Ns+4 Number of primitive variables. character(len=:), allocatable :: BC_L Left boundary condition type. character(len=:), allocatable :: BC_R Right boundary condition type. real(kind=R_P) :: Dx Space step discretization. real(kind=R_P) :: cp0 (1:Ns) Specific heat at constant pressure. real(kind=R_P) :: cv0 (1:Ns) Specific heat at constant volume. real(kind=R_P), allocatable :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), allocatable :: x (:) Cell center x-abscissa values. real(kind=R_P), allocatable :: final_state (:,:) Final state. integer(kind=I_P) :: error Error handler. integer(kind=I_P) :: profiling (1:2) Tic-toc profiling counters. integer(kind=I_P) :: count_rate Counting rate of system clock. real(kind=R_P) :: system_clocks Profiling result. integer(kind=I_P) :: steps Time steps counter. type(euler_1D_caf_nf) :: domain Domain of Euler equations. integer(kind=I_P) :: Ni_image Space dimension of local image. integer(kind=I_P) :: Ni [*] Number of grid cells. integer(kind=I_P) :: steps_max [*] Maximum number of time steps. logical :: results [*] Flag for activating results saving. logical :: plots [*] Flag for activating plots saving. logical :: time_serie [*] Flag for activating time serie-results saving. logical :: verbose [*] Flag for activating more verbose output. real(kind=R_P), allocatable :: Dt (:)[:] Time step. integer(kind=I_P) :: Ni Number of grid cells. integer(kind=I_P) :: steps_max Maximum number of time steps. logical :: results Flag for activating results saving. logical :: plots Flag for activating plots saving. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose Flag for activating more verbose output. real(kind=R_P), allocatable :: Dt (:) Time step. integer(kind=I_P) :: me ID of this_image() integer(kind=I_P) :: we Number of CAF images used. character(len=:), allocatable :: id My ID. Subroutines subroutine init () Arguments None Description Initialize the simulation. subroutine synchronize () Arguments None Description Synchronize CAF images. subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. subroutine save_time_serie (title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Source Code program integrate_euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !< Test without FOODIE with the integration of Euler 1D PDEs system by CAF paradigm. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str , strz use type_euler_1D_caf_no_foodie , only : euler_1D_caf_nf , tvd_runge_kutta_integrator use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_caf_nf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer , parameter :: ord = 7 !< Space reconstruciton order, real ( R_P ) :: t !< Time. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( len = :), allocatable :: BC_L !< Left boundary condition type. character ( len = :), allocatable :: BC_R !< Right boundary condition type. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. type ( euler_1D_caf_nf ) :: domain !< Domain of Euler equations. ! coarrays-related variables integer ( I_P ) :: Ni_image !< Space dimension of local image. #ifdef CAF integer ( I_P ) :: Ni [ * ] !< Number of grid cells. integer ( I_P ) :: steps_max [ * ] !< Maximum number of time steps. logical :: results [ * ] !< Flag for activating results saving. logical :: plots [ * ] !< Flag for activating plots saving. logical :: time_serie [ * ] !< Flag for activating time serie-results saving. logical :: verbose [ * ] !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:)[:] !< Time step. #else integer ( I_P ) :: Ni !< Number of grid cells. integer ( I_P ) :: steps_max !< Maximum number of time steps. logical :: results !< Flag for activating results saving. logical :: plots !< Flag for activating plots saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:) !< Time step. #endif integer ( I_P ) :: me !< ID of this_image() integer ( I_P ) :: we !< Number of CAF images used. character ( len = :), allocatable :: id !< My ID. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF me = this_image () we = num_images () #else me = 1 we = 1 #endif id = trim ( strz ( 3 , me )) // '> ' ! setting Command Line Interface call cli % init ( progname = 'euler-1D-caf-no-foodie' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test 1D Euler equations integration without FOODIE, CAF enabled' , & examples = [ \"euler-1D-caf-no-foodie --results  \" , & \"euler-1D-caf-no-foodie -r -t -v -p\" , & \"euler-1D-caf-no-foodie            \" , & \"euler-1D-caf-no-foodie --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) ! parsing Command Line Interface if ( me == 1 ) then ! only master image do CLI stuffs call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop endif call init () system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) Dt ( me ) = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call synchronize call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , Dt = Dt ( me ), t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + Dt ( me ) call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-image-' // trim ( strz ( 3 , me ))) print \"(A,I5,A,F23.15)\" , id , we , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_caf","tags":"","loc":"program/integrate_euler_1d_caf.html","title":"integrate_euler_1D_caf – FOODIE"},{"text":"Uses: IR_Precision type_euler_1D_caf Data_Type_Command_Line_Interface foodie pyplot_module program~~integrate_euler_1d_caf~2~~UsesGraph program~integrate_euler_1d_caf~2 integrate_euler_1D_caf IR_Precision IR_Precision IR_Precision->program~integrate_euler_1d_caf~2 module~type_euler_1d_caf type_euler_1D_caf IR_Precision->module~type_euler_1d_caf module~data_type_command_line_interface Data_Type_Command_Line_Interface IR_Precision->module~data_type_command_line_interface module~type_weno_interpolator_upwind type_weno_interpolator_upwind IR_Precision->module~type_weno_interpolator_upwind module~type_weno_interpolator type_weno_interpolator IR_Precision->module~type_weno_interpolator module~pyplot_module pyplot_module module~pyplot_module->program~integrate_euler_1d_caf~2 module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~foodie foodie module~foodie->program~integrate_euler_1d_caf~2 module~foodie->module~type_euler_1d_caf module~data_type_command_line_interface->program~integrate_euler_1d_caf~2 iso_fortran_env iso_fortran_env iso_fortran_env->module~pyplot_module iso_fortran_env->module~data_type_command_line_interface module~wenoof wenoof module~wenoof->module~type_euler_1d_caf module~type_weno_interpolator_upwind->module~wenoof module~type_weno_interpolator->module~wenoof module~type_weno_interpolator->module~type_weno_interpolator_upwind module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_adams_bashforth var panprogramintegrate_euler_1d_caf2UsesGraph = svgPanZoom('#programintegrate_euler_1d_caf2UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODIE with the integration of Euler 1D PDEs system. Calls program~~integrate_euler_1d_caf~2~~CallsGraph program~integrate_euler_1d_caf~2 integrate_euler_1D_caf strz strz program~integrate_euler_1d_caf~2->strz proc~save_results~3 save_results program~integrate_euler_1d_caf~2->proc~save_results~3 proc~save_time_serie~2 save_time_serie program~integrate_euler_1d_caf~2->proc~save_time_serie~2 proc~init~13 init program~integrate_euler_1d_caf~2->proc~init~13 proc~synchronize~3 synchronize program~integrate_euler_1d_caf~2->proc~synchronize~3 str str program~integrate_euler_1d_caf~2->str proc~save_results~3->str proc~save_time_serie~2->str proc~init~13->strz proc~init~13->proc~save_time_serie~2 proc~init~13->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( tvd_runge_kutta_integrator ) :: rk_integrator Runge-Kutta integrator. integer, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D_caf) :: rk_stage (1:rk_stages) Runge-Kutta stages. integer, parameter :: ord = 7 Space reconstruciton order, real(kind=R_P) :: t Time. real(kind=R_P), parameter :: CFL = 0.7_R_P CFL value. integer(kind=I_P), parameter :: Ns = 1 Number of differnt initial gas species. integer(kind=I_P), parameter :: Nc = Ns+2 Number of conservative variables. integer(kind=I_P), parameter :: Np = Ns+4 Number of primitive variables. character(len=:), allocatable :: BC_L Left boundary condition type. character(len=:), allocatable :: BC_R Right boundary condition type. real(kind=R_P) :: Dx Space step discretization. real(kind=R_P) :: cp0 (1:Ns) Specific heat at constant pressure. real(kind=R_P) :: cv0 (1:Ns) Specific heat at constant volume. real(kind=R_P), allocatable :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), allocatable :: x (:) Cell center x-abscissa values. real(kind=R_P), allocatable :: final_state (:,:) Final state. integer(kind=I_P) :: error Error handler. integer(kind=I_P) :: profiling (1:2) Tic-toc profiling counters. integer(kind=I_P) :: count_rate Counting rate of system clock. real(kind=R_P) :: system_clocks Profiling result. integer(kind=I_P) :: steps Time steps counter. type(euler_1D_caf) :: domain Domain of Euler equations. integer(kind=I_P) :: Ni_image Space dimension of local image. integer(kind=I_P) :: Ni [*] Number of grid cells. integer(kind=I_P) :: steps_max [*] Maximum number of time steps. logical :: results [*] Flag for activating results saving. logical :: plots [*] Flag for activating plots saving. logical :: time_serie [*] Flag for activating time serie-results saving. logical :: verbose [*] Flag for activating more verbose output. real(kind=R_P), allocatable :: Dt (:)[:] Time step. integer(kind=I_P) :: Ni Number of grid cells. integer(kind=I_P) :: steps_max Maximum number of time steps. logical :: results Flag for activating results saving. logical :: plots Flag for activating plots saving. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose Flag for activating more verbose output. real(kind=R_P), allocatable :: Dt (:) Time step. integer(kind=I_P) :: me ID of this_image() integer(kind=I_P) :: we Number of CAF images used. character(len=:), allocatable :: id My ID. Subroutines subroutine init () Arguments None Description Initialize the simulation. subroutine synchronize () Arguments None Description Synchronize CAF images. subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. subroutine save_time_serie (title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Source Code program integrate_euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str , strz use type_euler_1D_caf , only : euler_1D_caf use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_caf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer , parameter :: ord = 7 !< Space reconstruciton order, real ( R_P ) :: t !< Time. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( len = :), allocatable :: BC_L !< Left boundary condition type. character ( len = :), allocatable :: BC_R !< Right boundary condition type. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. type ( euler_1D_caf ) :: domain !< Domain of Euler equations. ! coarrays-related variables integer ( I_P ) :: Ni_image !< Space dimension of local image. #ifdef CAF integer ( I_P ) :: Ni [ * ] !< Number of grid cells. integer ( I_P ) :: steps_max [ * ] !< Maximum number of time steps. logical :: results [ * ] !< Flag for activating results saving. logical :: plots [ * ] !< Flag for activating plots saving. logical :: time_serie [ * ] !< Flag for activating time serie-results saving. logical :: verbose [ * ] !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:)[:] !< Time step. #else integer ( I_P ) :: Ni !< Number of grid cells. integer ( I_P ) :: steps_max !< Maximum number of time steps. logical :: results !< Flag for activating results saving. logical :: plots !< Flag for activating plots saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:) !< Time step. #endif integer ( I_P ) :: me !< ID of this_image() integer ( I_P ) :: we !< Number of CAF images used. character ( len = :), allocatable :: id !< My ID. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF me = this_image () we = num_images () #else me = 1 we = 1 #endif id = trim ( strz ( 3 , me )) // '> ' ! setting Command Line Interface call cli % init ( progname = 'euler-1D-caf' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration, CAF enabled' , & examples = [ \"euler-1D-caf --results  \" , & \"euler-1D-caf -r -t -v -p\" , & \"euler-1D-caf            \" , & \"euler-1D-caf --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) ! parsing Command Line Interface if ( me == 1 ) then ! only master image do CLI stuffs call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop endif call init () system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) Dt ( me ) = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call synchronize call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , Dt = Dt ( me ), t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + Dt ( me ) call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-image-' // trim ( strz ( 3 , me ))) print \"(A,I5,A,F23.15)\" , id , we , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_caf","tags":"","loc":"program/integrate_euler_1d_caf~2.html","title":"integrate_euler_1D_caf – FOODIE"},{"text":"Uses: IR_Precision type_euler_1D_openmp_no_foodie Data_Type_Command_Line_Interface pyplot_module omp_lib program~~integrate_euler_1d_openmp_no_foodie~~UsesGraph program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie IR_Precision IR_Precision IR_Precision->program~integrate_euler_1d_openmp_no_foodie module~type_euler_1d_openmp_no_foodie type_euler_1D_openmp_no_foodie IR_Precision->module~type_euler_1d_openmp_no_foodie module~data_type_command_line_interface Data_Type_Command_Line_Interface IR_Precision->module~data_type_command_line_interface module~type_weno_interpolator_upwind type_weno_interpolator_upwind IR_Precision->module~type_weno_interpolator_upwind module~type_weno_interpolator type_weno_interpolator IR_Precision->module~type_weno_interpolator module~pyplot_module pyplot_module module~pyplot_module->program~integrate_euler_1d_openmp_no_foodie omp_lib omp_lib omp_lib->program~integrate_euler_1d_openmp_no_foodie module~type_euler_1d_openmp_no_foodie->program~integrate_euler_1d_openmp_no_foodie module~data_type_command_line_interface->program~integrate_euler_1d_openmp_no_foodie iso_fortran_env iso_fortran_env iso_fortran_env->module~pyplot_module iso_fortran_env->module~data_type_command_line_interface module~wenoof wenoof module~wenoof->module~type_euler_1d_openmp_no_foodie module~type_weno_interpolator_upwind->module~wenoof module~type_weno_interpolator->module~wenoof module~type_weno_interpolator->module~type_weno_interpolator_upwind var panprogramintegrate_euler_1d_openmp_no_foodieUsesGraph = svgPanZoom('#programintegrate_euler_1d_openmp_no_foodieUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test without FOODIE with the integration of Euler 1D PDEs system by OpenMP paradigm. Calls program~~integrate_euler_1d_openmp_no_foodie~~CallsGraph program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie proc~init~15 init program~integrate_euler_1d_openmp_no_foodie->proc~init~15 proc~save_time_serie~3 save_time_serie program~integrate_euler_1d_openmp_no_foodie->proc~save_time_serie~3 proc~save_results~4 save_results program~integrate_euler_1d_openmp_no_foodie->proc~save_results~4 omp_set_dynamic omp_set_dynamic program~integrate_euler_1d_openmp_no_foodie->omp_set_dynamic omp_set_num_threads omp_set_num_threads program~integrate_euler_1d_openmp_no_foodie->omp_set_num_threads omp_get_num_threads omp_get_num_threads program~integrate_euler_1d_openmp_no_foodie->omp_get_num_threads str str program~integrate_euler_1d_openmp_no_foodie->str proc~save_time_serie~3->str proc~save_results~4->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( tvd_runge_kutta_integrator ) :: rk_integrator Runge-Kutta integrator. integer, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D_omp_nf) :: rk_stage (1:rk_stages) Runge-Kutta stages. real(kind=R_P) :: dt Time step. real(kind=R_P) :: t Time. type(euler_1D_omp_nf) :: domain Domain of Euler equations. real(kind=R_P), parameter :: CFL = 0.7_R_P CFL value. integer(kind=I_P), parameter :: Ns = 1 Number of differnt initial gas species. integer(kind=I_P), parameter :: Nc = Ns+2 Number of conservative variables. integer(kind=I_P), parameter :: Np = Ns+4 Number of primitive variables. character(len=3) :: BC_L Left boundary condition type. character(len=3) :: BC_R Right boundary condition type. integer(kind=I_P) :: Ni Number of grid cells. real(kind=R_P) :: Dx Space step discretization. real(kind=R_P) :: cp0 (1:Ns) Specific heat at constant pressure. real(kind=R_P) :: cv0 (1:Ns) Specific heat at constant volume. real(kind=R_P), allocatable :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), allocatable :: x (:) Cell center x-abscissa values. real(kind=R_P), allocatable :: final_state (:,:) Final state. integer(kind=I_P) :: error Error handler. integer(kind=I_P) :: steps_max Maximum number of time steps. integer(kind=I_P) :: omp_threads Number of OpenMP threads. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose Flag for activating more verbose output. integer(kind=I_P) :: profiling (1:2) Tic-toc profiling counters. integer(kind=I_P) :: count_rate Counting rate of system clock. real(kind=R_P) :: system_clocks Profiling result. integer(kind=I_P) :: steps Time steps counter. Subroutines subroutine init () Arguments None Description Initialize the field. subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. subroutine save_time_serie (title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Source Code program integrate_euler_1D_openmp_no_foodie !----------------------------------------------------------------------------------------------------------------------------------- !< Test without FOODIE with the integration of Euler 1D PDEs system by OpenMP paradigm. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D_openmp_no_foodie , only : euler_1D_omp_nf , tvd_runge_kutta_integrator use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use pyplot_module , only : pyplot #ifdef OPENMP use OMP_LIB #endif !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_omp_nf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. type ( euler_1D_omp_nf ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: steps_max !< Maximum number of time steps. integer ( I_P ) :: omp_threads !< Number of OpenMP threads. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D-openmp-no-foodie' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test 1D Euler equations integration without FOODIE, OpenMP enabled' , & examples = [ \"euler-1D-openmp-no-foodie --results  \" , & \"euler-1D-openmp-no-foodie -r -t -v -p\" , & \"euler-1D-openmp-no-foodie            \" , & \"euler-1D-openmp-no-foodie --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) call cli % add ( switch = '--omp_threads' , help = 'Number of OpenMP threads used' , required = . false ., act = 'store' , def = '1' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--omp_threads' , val = omp_threads , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop #ifdef OPENMP call omp_set_dynamic (. false .) call omp_set_num_threads ( omp_threads ) ! check OpenMP parallel environment correctness !$OMP PARALLEL      & !$OMP DEFAULT(none) & !$OMP SHARED(omp_threads) omp_threads = omp_get_num_threads () !$OMP END PARALLEL #endif call init () call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) t = 0._R_P call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_omp_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-time_serie.dat' , & t = t ) system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + dt call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_omp_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages ))) print \"(I5,A,F23.15)\" , omp_threads , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_openmp_no_foodie","tags":"","loc":"program/integrate_euler_1d_openmp_no_foodie.html","title":"integrate_euler_1D_openmp_no_foodie – FOODIE"},{"text":"Uses: IR_Precision type_euler_1D_openmp Data_Type_Command_Line_Interface foodie pyplot_module omp_lib program~~integrate_euler_1d_openmp~~UsesGraph program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie foodie module~foodie->program~integrate_euler_1d_openmp module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp module~pyplot_module pyplot_module module~pyplot_module->program~integrate_euler_1d_openmp module~type_euler_1d_openmp->program~integrate_euler_1d_openmp omp_lib omp_lib omp_lib->program~integrate_euler_1d_openmp module~data_type_command_line_interface Data_Type_Command_Line_Interface module~data_type_command_line_interface->program~integrate_euler_1d_openmp IR_Precision IR_Precision IR_Precision->program~integrate_euler_1d_openmp IR_Precision->module~type_euler_1d_openmp IR_Precision->module~data_type_command_line_interface module~type_weno_interpolator_upwind type_weno_interpolator_upwind IR_Precision->module~type_weno_interpolator_upwind module~type_weno_interpolator type_weno_interpolator IR_Precision->module~type_weno_interpolator module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_adams_bashforth iso_fortran_env iso_fortran_env iso_fortran_env->module~pyplot_module iso_fortran_env->module~data_type_command_line_interface module~wenoof wenoof module~wenoof->module~type_euler_1d_openmp module~type_weno_interpolator_upwind->module~wenoof module~type_weno_interpolator->module~wenoof module~type_weno_interpolator->module~type_weno_interpolator_upwind var panprogramintegrate_euler_1d_openmpUsesGraph = svgPanZoom('#programintegrate_euler_1d_openmpUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODIE with the integration of Euler 1D PDEs system. Calls program~~integrate_euler_1d_openmp~~CallsGraph program~integrate_euler_1d_openmp integrate_euler_1D_openmp omp_get_thread_num omp_get_thread_num program~integrate_euler_1d_openmp->omp_get_thread_num proc~save_time_serie~4 save_time_serie program~integrate_euler_1d_openmp->proc~save_time_serie~4 omp_set_dynamic omp_set_dynamic program~integrate_euler_1d_openmp->omp_set_dynamic omp_set_num_threads omp_set_num_threads program~integrate_euler_1d_openmp->omp_set_num_threads omp_get_num_threads omp_get_num_threads program~integrate_euler_1d_openmp->omp_get_num_threads proc~init~17 init program~integrate_euler_1d_openmp->proc~init~17 str str program~integrate_euler_1d_openmp->str proc~save_results~5 save_results program~integrate_euler_1d_openmp->proc~save_results~5 proc~save_time_serie~4->str proc~save_results~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( tvd_runge_kutta_integrator ) :: rk_integrator Runge-Kutta integrator. integer, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D_openmp) :: rk_stage (1:rk_stages) Runge-Kutta stages. real(kind=R_P) :: dt Time step. real(kind=R_P) :: t Time. type(euler_1D_openmp) :: domain Domain of Euler equations. real(kind=R_P), parameter :: CFL = 0.7_R_P CFL value. integer(kind=I_P), parameter :: Ns = 1 Number of differnt initial gas species. integer(kind=I_P), parameter :: Nc = Ns+2 Number of conservative variables. integer(kind=I_P), parameter :: Np = Ns+4 Number of primitive variables. character(len=3) :: BC_L Left boundary condition type. character(len=3) :: BC_R Right boundary condition type. integer(kind=I_P) :: Ni Number of grid cells. real(kind=R_P) :: Dx Space step discretization. real(kind=R_P) :: cp0 (1:Ns) Specific heat at constant pressure. real(kind=R_P) :: cv0 (1:Ns) Specific heat at constant volume. real(kind=R_P), allocatable :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), allocatable :: x (:) Cell center x-abscissa values. real(kind=R_P), allocatable :: final_state (:,:) Final state. integer(kind=I_P) :: error Error handler. integer(kind=I_P) :: steps_max Maximum number of time steps. integer(kind=I_P) :: omp_threads Number of OpenMP threads. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose Flag for activating more verbose output. integer(kind=I_P) :: profiling (1:2) Tic-toc profiling counters. integer(kind=I_P) :: count_rate Counting rate of system clock. real(kind=R_P) :: system_clocks Profiling result. integer(kind=I_P) :: steps Time steps counter. Subroutines subroutine init () Arguments None Description Initialize the field. subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. subroutine save_time_serie (title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Source Code program integrate_euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D_openmp , only : euler_1D_openmp use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot #ifdef OPENMP use OMP_LIB #endif !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_openmp ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. type ( euler_1D_openmp ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: steps_max !< Maximum number of time steps. integer ( I_P ) :: omp_threads !< Number of OpenMP threads. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D-openmp' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration, OpenMP enabled' , & examples = [ \"euler-1D-openmp --results  \" , & \"euler-1D-openmp -r -t -v -p\" , & \"euler-1D-openmp            \" , & \"euler-1D-openmp --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) call cli % add ( switch = '--omp_threads' , help = 'Number of OpenMP threads used' , required = . false ., act = 'store' , def = '1' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--omp_threads' , val = omp_threads , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop #ifdef OPENMP call omp_set_dynamic (. false .) call omp_set_num_threads ( omp_threads ) ! check OpenMP parallel environment correctness !$OMP PARALLEL      & !$OMP DEFAULT(none) & !$OMP SHARED(omp_threads, verbose) omp_threads = omp_get_num_threads () if ( verbose ) print \"(A)\" , ' Thread ' // trim ( str (. true ., omp_get_thread_num ())) // ' of: ' // trim ( str (. true ., omp_threads )) // ' is alive!' !$OMP END PARALLEL #endif call init () call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) t = 0._R_P call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_openmp_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-time_serie.dat' , & t = t ) system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + dt call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_openmp_integration-tvdrk-' // trim ( str (. true ., rk_stages ))) print \"(I5,A,F23.15)\" , omp_threads , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_openmp","tags":"","loc":"program/integrate_euler_1d_openmp.html","title":"integrate_euler_1D_openmp – FOODIE"},{"text":"Uses: IR_Precision type_burgers Data_Type_Command_Line_Interface foodie pyplot_module program~~integrate_burgers~~UsesGraph program~integrate_burgers integrate_burgers module~data_type_command_line_interface Data_Type_Command_Line_Interface module~data_type_command_line_interface->program~integrate_burgers IR_Precision IR_Precision IR_Precision->program~integrate_burgers IR_Precision->module~data_type_command_line_interface module~type_burgers type_burgers IR_Precision->module~type_burgers module~pyplot_module pyplot_module module~pyplot_module->program~integrate_burgers module~foodie foodie module~foodie->program~integrate_burgers module~foodie->module~type_burgers module~type_burgers->program~integrate_burgers iso_fortran_env iso_fortran_env iso_fortran_env->module~data_type_command_line_interface iso_fortran_env->module~pyplot_module module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_adams_bashforth var panprogramintegrate_burgersUsesGraph = svgPanZoom('#programintegrate_burgersUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODIE with the integration of Burgers equation. Calls program~~integrate_burgers~~CallsGraph program~integrate_burgers integrate_burgers proc~test_ls_rk test_ls_rk program~integrate_burgers->proc~test_ls_rk proc~test_ab test_ab program~integrate_burgers->proc~test_ab proc~test_tvd_rk test_tvd_rk program~integrate_burgers->proc~test_tvd_rk proc~test_euler test_euler program~integrate_burgers->proc~test_euler proc~test_leapfrog test_leapfrog program~integrate_burgers->proc~test_leapfrog proc~init~19 init program~integrate_burgers->proc~init~19 str str proc~test_ls_rk->str proc~save_results~6 save_results proc~test_ls_rk->proc~save_results~6 proc~test_ab->str proc~test_ab->proc~save_results~6 proc~test_tvd_rk->str proc~test_tvd_rk->proc~save_results~6 proc~test_euler->str proc~test_euler->proc~save_results~6 proc~test_leapfrog->str proc~test_leapfrog->proc~save_results~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( burgers ) :: domain Burgers field domain. real(kind=R_P), parameter :: CFL = 0.1_R_P CFL value. real(kind=R_P), parameter :: t_final = 0.6_R_P Final time. real(kind=R_P), parameter :: nu = 1._R_P Viscosity. integer(kind=I_P), parameter :: Ni = 100 Number of grid nodes. real(kind=R_P) :: h Space step discretization. real(kind=R_P) :: initial_state (1:Ni) Initial state. real(kind=R_P) :: x (1:Ni) Nodes values. real(kind=R_P), allocatable :: final_state (:) Final state. integer(kind=I_P) :: error Error handler. character(len=99) :: solver Solver used. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. Subroutines subroutine init () Arguments None Description Initialize the field. subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. subroutine test_ab () Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. subroutine test_euler () Arguments None Description Test explicit forward Euler ODE solver. subroutine test_leapfrog () Arguments None Description Test explicit leapfrog class of ODE solvers. subroutine test_ls_rk () Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. subroutine test_tvd_rk () Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Source Code program integrate_burgers !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Burgers equation. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_burgers , only : burgers use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( burgers ) :: domain !< Burgers field domain. real ( R_P ), parameter :: CFL = 0.1_R_P !< CFL value. real ( R_P ), parameter :: t_final = 0.6_R_P !< Final time. real ( R_P ), parameter :: nu = 1._R_P !< Viscosity. integer ( I_P ), parameter :: Ni = 100 !< Number of grid nodes. real ( R_P ) :: h !< Space step discretization. real ( R_P ) :: initial_state ( 1 : Ni ) !< Initial state. real ( R_P ) :: x ( 1 : Ni ) !< Nodes values. real ( R_P ), allocatable :: final_state (:) !< Final state. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'burgers' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Burgers equation integration' , & examples = [ \"burgers --solver euler --results  \" , & \"burgers --solver ls-runge-kutta -r\" , & \"burgers --solver adams-bashforth  \" , & \"burgers --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! create Burgers field initial state call init () ! integrate Burgers equation select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- h = 2._R_P * pi / Ni do i = 1 , Ni x ( i ) = h * ( i - 1 ) initial_state ( i ) = 1 0._R_P * sin ( x ( i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"U\"' do i = 1 , Ni write ( rawfile , '(2(' // FR_P // ',1X))' ) x ( i ), final_state ( i ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) call plt % add_plot ( x = x , y = final_state , label = 'U' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( burgers ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = s ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t ( s ) < t_final ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), Dt = Dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit ' // & 'Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'burgers_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of explicit Euler solver' call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit Euler' , & filename = 'burgers_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( burgers ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( burgers ) :: previous ( 1 : 2 ) !< Previous time steps solutions. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = 2 ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t < t_final ) if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit leapfrog scheme' ,& filename = 'burgers_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit low storage Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit TVD Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_burgers","tags":"","loc":"program/integrate_burgers.html","title":"integrate_burgers – FOODIE"},{"text":"Uses: IR_Precision type_euler_1D Data_Type_Command_Line_Interface foodie pyplot_module program~~integrate_euler_1d~~UsesGraph program~integrate_euler_1d integrate_euler_1D module~data_type_command_line_interface Data_Type_Command_Line_Interface module~data_type_command_line_interface->program~integrate_euler_1d IR_Precision IR_Precision IR_Precision->program~integrate_euler_1d IR_Precision->module~data_type_command_line_interface module~type_euler_1d type_euler_1D IR_Precision->module~type_euler_1d module~type_weno_interpolator_upwind type_weno_interpolator_upwind IR_Precision->module~type_weno_interpolator_upwind module~type_weno_interpolator type_weno_interpolator IR_Precision->module~type_weno_interpolator module~pyplot_module pyplot_module module~pyplot_module->program~integrate_euler_1d module~foodie foodie module~foodie->program~integrate_euler_1d module~foodie->module~type_euler_1d module~type_euler_1d->program~integrate_euler_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~data_type_command_line_interface iso_fortran_env->module~pyplot_module module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_adams_bashforth module~wenoof wenoof module~wenoof->module~type_euler_1d module~type_weno_interpolator_upwind->module~wenoof module~type_weno_interpolator->module~wenoof module~type_weno_interpolator->module~type_weno_interpolator_upwind var panprogramintegrate_euler_1dUsesGraph = svgPanZoom('#programintegrate_euler_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODIE with the integration of Euler 1D PDEs system. Calls program~~integrate_euler_1d~~CallsGraph program~integrate_euler_1d integrate_euler_1D proc~test_ab~2 test_ab program~integrate_euler_1d->proc~test_ab~2 proc~init~21 init program~integrate_euler_1d->proc~init~21 proc~test_tvd_rk~2 test_tvd_rk program~integrate_euler_1d->proc~test_tvd_rk~2 proc~test_euler~2 test_euler program~integrate_euler_1d->proc~test_euler~2 proc~test_leapfrog~2 test_leapfrog program~integrate_euler_1d->proc~test_leapfrog~2 proc~test_ls_rk~2 test_ls_rk program~integrate_euler_1d->proc~test_ls_rk~2 proc~save_time_serie~5 save_time_serie proc~test_ab~2->proc~save_time_serie~5 str str proc~test_ab~2->str proc~save_results~7 save_results proc~test_ab~2->proc~save_results~7 proc~init~21->str proc~test_tvd_rk~2->proc~save_time_serie~5 proc~test_tvd_rk~2->str proc~test_tvd_rk~2->proc~save_results~7 proc~test_euler~2->proc~save_time_serie~5 proc~test_euler~2->str proc~test_euler~2->proc~save_results~7 proc~test_leapfrog~2->proc~save_time_serie~5 proc~test_leapfrog~2->str proc~test_leapfrog~2->proc~save_results~7 proc~test_ls_rk~2->proc~save_time_serie~5 proc~test_ls_rk~2->str proc~test_ls_rk~2->proc~save_results~7 proc~save_time_serie~5->str proc~save_results~7->str proc~average_solution average_solution proc~save_results~7->proc~average_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type(euler_1D) :: domain Domain of Euler equations. integer(kind=I_P) :: Ns Number of differnt initial gas species. integer(kind=I_P) :: Nc Number of conservative variables, Nc=Ns+2. integer(kind=I_P) :: Np Number of primitive variables, Np=Ns+4. integer(kind=I_P) :: Ni Number of grid cells. real(kind=R_P) :: Dx Space step discretization. real(kind=R_P) :: CFL CFL value. real(kind=R_P) :: t_final Final time. character(len=3) :: BC_L Left boundary condition type. character(len=3) :: BC_R Right boundary condition type. real(kind=R_P), allocatable :: cp0 (:) Specific heat at constant pressure [1:Ns]. real(kind=R_P), allocatable :: cv0 (:) Specific heat at constant volume [1:Ns]. real(kind=R_P), allocatable :: initial_state (:,:) Initial state of primitive variables [1:Np,1:Ni]. real(kind=R_P), allocatable :: xcenter (:) Cell center x-abscissa values, [1:Ni]. real(kind=R_P), allocatable :: xnode (:) Cell node x-abscissa values, [0:Ni]. real(kind=R_P), allocatable :: av_xnode (:) Average-grid cell node x-abscissa values, [0:Ni]. real(kind=R_P), allocatable :: final_state (:,:) Final state. real(kind=R_P), allocatable :: av_state (:,:) Average-grid final state. character(len=:), allocatable :: variables Variables names list. character(len=:), allocatable :: output Output files basename. integer(kind=I_P) :: error Error handler. integer(kind=I_P) :: stages_steps Number of stages/steps used. character(len=99) :: solver Solver used. character(len=99) :: problem Problem solved. character(len=99) :: output_cli Output files basename. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose Flag for activating more verbose output. integer(kind=I_P) :: av_Ni Average the solution over an average-grid. Subroutines subroutine init () Arguments None Description Initialize the field. subroutine average_solution () Arguments None Description Average the solution over an average grid. subroutine save_results (title, basename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: basename Output basename. Description Save results. subroutine save_time_serie (title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. subroutine test_ab () Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. subroutine test_euler () Arguments None Description Test explicit forward Euler ODE solver. subroutine test_leapfrog () Arguments None Description Test explicit leapfrog class of ODE solvers. subroutine test_ls_rk () Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. subroutine test_tvd_rk () Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Source Code program integrate_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D , only : euler_1D use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( euler_1D ) :: domain !< Domain of Euler equations. integer ( I_P ) :: Ns !< Number of differnt initial gas species. integer ( I_P ) :: Nc !< Number of conservative variables, Nc=Ns+2. integer ( I_P ) :: Np !< Number of primitive variables, Np=Ns+4. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: CFL !< CFL value. real ( R_P ) :: t_final !< Final time. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. real ( R_P ), allocatable :: cp0 (:) !< Specific heat at constant pressure [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat at constant volume [1:Ns]. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables [1:Np,1:Ni]. real ( R_P ), allocatable :: xcenter (:) !< Cell center x-abscissa values, [1:Ni]. real ( R_P ), allocatable :: xnode (:) !< Cell node x-abscissa values, [0:Ni]. real ( R_P ), allocatable :: av_xnode (:) !< Average-grid cell node x-abscissa values, [0:Ni]. real ( R_P ), allocatable :: final_state (:,:) !< Final state. real ( R_P ), allocatable :: av_state (:,:) !< Average-grid final state. character ( len = :), allocatable :: variables !< Variables names list. character ( len = :), allocatable :: output !< Output files basename. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: stages_steps !< Number of stages/steps used. character ( 99 ) :: solver !< Solver used. character ( 99 ) :: problem !< Problem solved. character ( 99 ) :: output_cli !< Output files basename. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: av_Ni !< Average the solution over an average-grid. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration' , & examples = [ \"euler-1D --solver euler --results  \" , & \"euler-1D --solver ls-runge-kutta -r\" , & \"euler-1D --solver adams-bashforth  \" , & \"euler-1D --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver' , required = . true ., act = 'store' ) call cli % add ( switch = '--problem' , help = 'Problem solved' , required = . false ., def = 'sod' , act = 'store' , choices = 'sod,smooth' ) call cli % add ( switch = '--Ni' , help = 'Number finite volumes' , required = . false ., act = 'store' , def = '100' ) call cli % add ( switch = '--av_Ni' , help = 'Number finite volumes over average the solution' , required = . false ., act = 'store' , def = '-1' ) call cli % add ( switch = '--ss' , help = 'Stages/steps used' , required = . false ., act = 'store' , def = '-1' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--output' , help = 'Output files basename' , required = . false ., act = 'store' , def = 'unset' ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--solver' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--problem' , val = problem , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--av_Ni' , val = av_Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--ss' , val = stages_steps , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--results' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--plots' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--tserie' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--output' , val = output_cli , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop ! create Euler field initial state call init () ! integrate Euler equation select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Species counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( xcenter ( 1 : Ni )) allocate ( xnode ( 0 : Ni )) Dx = 1._R_P / Ni do i = 1 , Ni xcenter ( i ) = Dx * i - 0.5_R_P * Dx enddo do i = 0 , Ni xnode ( i ) = Dx * i enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then allocate ( av_xnode ( 0 : av_Ni )) do i = 0 , av_Ni av_xnode ( i ) = 1._R_P / av_Ni * i enddo endif select case ( trim ( adjustl ( problem ))) case ( 'sod' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.2_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str (. true ., s )) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case ( 'smooth' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.1_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str (. true ., s )) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni initial_state (:, i ) = [ 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! rho(s) 0.5_R_P * ( xcenter ( i ) - 0.5_R_P ) ** 4 , & ! u 1 0._R_P + 2._R_P * xcenter ( i ) ** 4 , & ! p 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case default print \"(A)\" , 'Error: unknown problem \"' // trim ( adjustl ( problem )) // '\"' print \"(A)\" , 'Valid problem names are:' print \"(A)\" , '  + sod' print \"(A)\" , '  + smooth' stop endselect if ( trim ( adjustl ( output_cli )) /= 'unset' ) then output = trim ( adjustl ( output_cli )) // '-' // trim ( adjustl ( solver )) else output = 'euler_1D_integration-' // trim ( adjustl ( solver )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine average_solution () !--------------------------------------------------------------------------------------------------------------------------------- !< Average the solution over an average grid. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i , ii , i1 , i2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then if ( allocated ( av_state )) deallocate ( av_state ) ; allocate ( av_state ( 1 : Np , 1 : av_Ni )) do i = 1 , av_Ni i1 = minloc ( array = xcenter , dim = 1 , mask = ( xcenter >= av_xnode ( i - 1 ))) i2 = maxloc ( array = xcenter , dim = 1 , mask = ( xcenter <= av_xnode ( i ))) av_state (:, i ) = 0._R_P do ii = i1 , i2 av_state (:, i ) = av_state (:, i ) + final_state (:, ii ) enddo av_state (:, i ) = av_state (:, i ) / ( i2 - i1 + 1 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine average_solution subroutine save_results ( title , basename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: basename !< Output basename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = basename // '-' // trim ( str (. true ., Ni )) // '_cells.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) variables write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str (. true ., Ni )) // ' cells\", I=' // trim ( str (. true ., Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 1 )) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str (. true ., Ni + 1 )) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( rawfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then print \"(A)\" , ' Average solution from Ni: ' // trim ( str (. true ., Ni )) // ' to av_Ni: ' // trim ( str (. true ., av_Ni )) call average_solution write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str (. true ., Ni )) // ' cells averaged over ' // trim ( str (. true ., av_Ni )) // & ' cells\", I=' // trim ( str (. true ., av_Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 1 )) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str (. true ., av_Ni + 1 )) // '(' // FR_P // ',1X))' ) av_xnode do v = 1 , Np write ( rawfile , '(' // trim ( str (. true ., av_Ni )) // '(' // FR_P // ',1X))' ) av_state ( v , :) enddo endif close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = xcenter , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = xcenter , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( basename // '-' // trim ( str (. true ., Ni )) // '_cells.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) 'TITLE=\"' // title // '\"' endif write ( tsfile , '(A)' ) variables // ' \"t\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\", I=' // trim ( str (. true ., Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 2 )) // ']=CELLCENTERED)' write ( tsfile , '(' // trim ( str (. true ., Ni + 1 )) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( tsfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo write ( tsfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' )( t , v = 1 , Ni ) if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( euler_1D ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of Adams-Bashforth class of solvers' steps_range = [ 1 , ab_steps ] ; if ( stages_steps > 0 ) steps_range = [ stages_steps , stages_steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' AB-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' steps' call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 1 ) call rk_integrator % init ( stages = s ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 3 ) call rk_integrator % init ( stages = s ) case ( 4 , 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 7 ) call rk_integrator % init ( stages = 5 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , t = t ( s )) step = 1 do while ( t ( s ) < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t ( s ), CFL = 0.1_R_P * CFL ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), dt = dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 call save_time_serie ( t = t ( s )) enddo call save_time_serie ( t = t ( s ), finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of explicit Euler solver' title = '1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '  Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( euler_1D ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( euler_1D ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of leapfrog (RAW filtered) class of solvers' title = '1D Euler equations integration, explicit leapfrog (RAW filtered), t=' // str ( n = t_final ) call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = 2 , ord = 3 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) step = 1 do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = 0.1_R_P * CFL ) if ( 2 >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of low storage (2N) Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of TVD/SSP Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit TVD/SSP Runge-Kutta, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_euler_1D","tags":"","loc":"program/integrate_euler_1d.html","title":"integrate_euler_1D – FOODIE"},{"text":"Uses: IR_Precision type_lorenz Data_Type_Command_Line_Interface foodie pyplot_module program~~integrate_lorenz~~UsesGraph program~integrate_lorenz integrate_lorenz module~data_type_command_line_interface Data_Type_Command_Line_Interface module~data_type_command_line_interface->program~integrate_lorenz IR_Precision IR_Precision IR_Precision->program~integrate_lorenz IR_Precision->module~data_type_command_line_interface module~type_lorenz type_lorenz IR_Precision->module~type_lorenz module~pyplot_module pyplot_module module~pyplot_module->program~integrate_lorenz module~foodie foodie module~foodie->program~integrate_lorenz module~foodie->module~type_lorenz module~type_lorenz->program~integrate_lorenz iso_fortran_env iso_fortran_env iso_fortran_env->module~data_type_command_line_interface iso_fortran_env->module~pyplot_module module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_adams_bashforth var panprogramintegrate_lorenzUsesGraph = svgPanZoom('#programintegrate_lorenzUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODIE with the integration of Lorenz equations. Calls program~~integrate_lorenz~~CallsGraph program~integrate_lorenz integrate_lorenz proc~test_tvd_rk~3 test_tvd_rk program~integrate_lorenz->proc~test_tvd_rk~3 proc~test_leapfrog~3 test_leapfrog program~integrate_lorenz->proc~test_leapfrog~3 proc~test_ls_rk~3 test_ls_rk program~integrate_lorenz->proc~test_ls_rk~3 proc~test_ab~3 test_ab program~integrate_lorenz->proc~test_ab~3 proc~test_euler~3 test_euler program~integrate_lorenz->proc~test_euler~3 proc~save_results~8 save_results proc~test_tvd_rk~3->proc~save_results~8 str str proc~test_tvd_rk~3->str proc~test_leapfrog~3->proc~save_results~8 proc~test_ls_rk~3->proc~save_results~8 proc~test_ls_rk~3->str proc~test_ab~3->proc~save_results~8 proc~test_ab~3->str proc~test_euler~3->proc~save_results~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( lorenz ) :: attractor Lorenz field. integer, parameter :: num_steps = 2000 Maximum time steps. integer, parameter :: space_dimension = 3 Space dimensions. real(kind=R_P), parameter :: sigma = 10._R_P Lorenz' \\sigma. real(kind=R_P), parameter :: rho = 28._R_P Lorenz' \\rho. real(kind=R_P), parameter :: beta = 8._R_P/3._R_P Lorenz' \\beta. real(kind=R_P), parameter :: dt = 0.01_R_P Time step. real(kind=R_P), parameter :: initial_state (1:space_dimension) = [1., 1., 1.] Initial state. real(kind=R_P) :: solution (0:space_dimension,0:num_steps) Solution at each time step. integer(kind=I_P) :: error Error handler. character(len=99) :: solver Solver used. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. Subroutines subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. subroutine test_ab () Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. subroutine test_euler () Arguments None Description Test explicit forward Euler ODE solver. subroutine test_leapfrog () Arguments None Description Test explicit leapfrog class of ODE solvers. subroutine test_ls_rk () Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. subroutine test_tvd_rk () Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Source Code program integrate_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Lorenz equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_lorenz , only : lorenz use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( lorenz ) :: attractor !< Lorenz field. integer , parameter :: num_steps = 2000 !< Maximum time steps. integer , parameter :: space_dimension = 3 !< Space dimensions. real ( R_P ), parameter :: sigma = 1 0._R_P !< Lorenz' \\sigma. real ( R_P ), parameter :: rho = 2 8._R_P !< Lorenz' \\rho. real ( R_P ), parameter :: beta = 8._R_P / 3._R_P !< Lorenz' \\beta. real ( R_P ), parameter :: dt = 0.01_R_P !< Time step. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 1. , 1. , 1. ] !< Initial state. real ( R_P ) :: solution ( 0 : space_dimension , 0 : num_steps ) !< Solution at each time step. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'lorenz' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Lorenz equations integration' , & examples = [ \"lorenz --solver euler --results  \" , & \"lorenz --solver ls-runge-kutta -r\" , & \"lorenz --solver adams-bashforth  \" , & \"lorenz --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! integrate Lorenz equations select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\" \"z\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 3 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'x' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'y' , linestyle = 'b-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 3 , :), label = 'z' , linestyle = 'g-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'x-y path' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 3 , :), label = 'x-z path' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 2 , :), y = solution ( 3 , :), label = 'y-z path' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( lorenz ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call ab_integrator % integrate ( U = attractor , previous = previous ( 1 : s ), dt = dt , t = solution ( 0 , step - s : step - 1 )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'lorenz_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of explicit Euler solver' call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call euler_integrator % integrate ( U = attractor , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Euler' , & filename = 'lorenz_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( lorenz ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( lorenz ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = 2 ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call lf_integrator % integrate ( U = attractor , previous = previous , dt = dt , t = solution ( 0 , step ), filter = filter ) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit leapfrog scheme' ,& filename = 'lorenz_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit low storage Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'lorenz_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit TVD Runge-Kutta ' // trim ( str (. true ., s )) // ' stages' ,& filename = 'lorenz_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_lorenz","tags":"","loc":"program/integrate_lorenz.html","title":"integrate_lorenz – FOODIE"},{"text":"Uses: IR_Precision iso_fortran_env program~~test_driver~~UsesGraph program~test_driver Test_Driver IR_Precision IR_Precision IR_Precision->program~test_driver iso_fortran_env iso_fortran_env iso_fortran_env->program~test_driver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Testing program for IR_Precision, Pure Fortran (2003+) library for ensuring codes portability Usage ./Test_Driver Calls program~~test_driver~~CallsGraph program~test_driver Test_Driver cton cton program~test_driver->cton strz strz program~test_driver->strz ir_print ir_print program~test_driver->ir_print bstr bstr program~test_driver->bstr bcton bcton program~test_driver->bcton ir_init ir_init program~test_driver->ir_init digit digit program~test_driver->digit str str program~test_driver->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code program Test_Driver !----------------------------------------------------------------------------------------------------------------------------------- !< Testing program for IR_Precision, Pure Fortran (2003+) library for ensuring codes portability !< !<### Usage !<```bash !< ./Test_Driver !<``` !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision USE , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! initialize IR_Precision call IR_Init ! print main IR_Precision values call IR_Print ( unit = stdout ) print \"(A)\" , '' print \"(A)\" , 'Testing IR_Precision tools' print \"(A)\" , 'Casting real-to-string: ' // str ( n = 1._R8P ) print \"(A)\" , 'Casting integer-to-string: ' // str ( n = 11_I8P ) print \"(A,\" // FR8P // \")\" , 'Casting string-to-real: ' , cton ( str = '2.2d0' , knd = 1._R8P ) print \"(A,\" // FI4P // \")\" , 'Casting integer-to-string: ' , cton ( str = '43' , knd = 1_I4P ) print \"(A)\" , 'Casting integer-to-string with zero padding: ' // trim ( strz ( nz_pad = 3 , n = 34_I8P )) ! print \"(A)\", 'Casting real-to-bit_string: '//bstr(n=1._R4P) print \"(A)\" , 'Casting integer-to-bit_string: ' // bstr ( n = 1_I4P ) ! print \"(A,\"//FR4P//\")\", 'Casting bit_string-to-real: ',bcton(bstr='00111111100000000000000000000000',knd=1._R4P) print \"(A,\" // FI4P // \")\" , 'Casting bit_string-to-integer: ' , bcton ( bstr = '00000000000000000000000000000001' , knd = 1_I4P ) print \"(A)\" , 'Number of digit of 1023: ' // str ( n = digit ( 1023_I4P )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram Test_Driver","tags":"","loc":"program/test_driver.html","title":"Test_Driver – FOODIE"},{"text":"Uses: IR_Precision Data_Type_Command_Line_Interface program~~test_basic~~UsesGraph program~test_basic test_basic IR_Precision IR_Precision IR_Precision->program~test_basic module~data_type_command_line_interface Data_Type_Command_Line_Interface IR_Precision->module~data_type_command_line_interface module~data_type_command_line_interface->program~test_basic iso_fortran_env iso_fortran_env iso_fortran_env->module~data_type_command_line_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Calls program~~test_basic~~CallsGraph program~test_basic test_basic str str program~test_basic->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command Line Interface (CLI). character(len=99) :: sval String value. real(kind=R8P) :: rval Real value. real(kind=R8P) :: prval Positional real value. integer(kind=I4P) :: ival Integer value. integer(kind=I4P) :: ieval Exclusive integer value. integer(kind=I4P) :: envi Environment set integer value. logical :: bval Boolean value. logical :: vbval Valued-boolean value. integer(kind=I8P) :: ilist (1:3) Integer list values. real(kind=R8P), allocatable :: vlistR8P (:) Varying size real list values. real(kind=R4P), allocatable :: vlistR4P (:) Varying size real list values. integer(kind=I8P), allocatable :: vlistI8P (:) Varying size integer list values. integer(kind=I4P), allocatable :: vlistI4P (:) Varying size integer list values. integer(kind=I2P), allocatable :: vlistI2P (:) Varying size integer list values. integer(kind=I1P), allocatable :: vlistI1P (:) Varying size integer list values. logical, allocatable :: vlistBool (:) Varying size boolean list values. character(len=10), allocatable :: vlistChar (:) Varying size character list values. character(len=99), allocatable :: garbage (:) Varying size character list for trailing garbage values. integer(kind=I4P) :: error Error trapping flag. integer(kind=I4P) :: l Counter. Source Code program test_basic !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface ! Definition of Type_Command_Line_Interface. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: sval !< String value. real ( R8P ) :: rval !< Real value. real ( R8P ) :: prval !< Positional real value. integer ( I4P ) :: ival !< Integer value. integer ( I4P ) :: ieval !< Exclusive integer value. integer ( I4P ) :: envi !< Environment set integer value. logical :: bval !< Boolean value. logical :: vbval !< Valued-boolean value. integer ( I8P ) :: ilist ( 1 : 3 ) !< Integer list values. real ( R8P ), allocatable :: vlistR8P (:) !< Varying size real list values. real ( R4P ), allocatable :: vlistR4P (:) !< Varying size real list values. integer ( I8P ), allocatable :: vlistI8P (:) !< Varying size integer list values. integer ( I4P ), allocatable :: vlistI4P (:) !< Varying size integer list values. integer ( I2P ), allocatable :: vlistI2P (:) !< Varying size integer list values. integer ( I1P ), allocatable :: vlistI1P (:) !< Varying size integer list values. logical , allocatable :: vlistBool (:) !< Varying size boolean list values. character ( 10 ), allocatable :: vlistChar (:) !< Varying size character list values. character ( 99 ), allocatable :: garbage (:) !< Varying size character list for trailing garbage values. integer ( I4P ) :: error !< Error trapping flag. integer ( I4P ) :: l !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! initializing Command Line Interface call cli % init ( progname = 'test_basic' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & help = 'Usage: ' , & description = 'Toy program for testing FLAP' , & examples = [ \"test_basic -s 'Hello FLAP'                               \" , & \"test_basic -s 'Hello FLAP' -i -2 # printing error...     \" , & \"test_basic -s 'Hello FLAP' -i 3 -ie 1 # printing error...\" , & \"test_basic -s 'Hello FLAP' -i 3 -r 33.d0                 \" , & \"test_basic -s 'Hello FLAP' --integer_list 10 -3 87       \" , & \"test_basic -s 'Hello FLAP' --man_file FLAP.1             \" , & \"test_basic 33.0 -s 'Hello FLAP' -i 5                     \" , & \"test_basic --string 'Hello FLAP' --boolean               \" ],& epilog = new_line ( 'a' ) // \"And that's how to FLAP your life\" ) ! setting Command Line Argumenst call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer_ex' , switch_ab = '-ie' , help = 'Exclusive integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , exclude = '-ie' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) if ( error /= 0 ) stop call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--env' , switch_ab = '-e' , help = 'Environment input' , required = . false ., act = 'store' , def = '-1' , envvar = 'FLAP_NUM_INT' ,& error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--man_file' , help = 'Save manual into man_file' , required = . false ., act = 'store' , def = 'test_basic.1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listR8P' , switch_ab = '-vlR8P' , help = 'Varying size real R8P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listR4P' , switch_ab = '-vlR4P' , help = 'Varying size real R4P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1.0 2.0 3.0 4.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI8P' , switch_ab = '-vlI8P' , help = 'Varying size integer I8P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2 3 4 5 6 7 8' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI4P' , switch_ab = '-vlI4P' , help = 'Varying size integer I4P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2 3 4' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI2P' , switch_ab = '-vlI2P' , help = 'Varying size integer I2P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI1P' , switch_ab = '-vlI1P' , help = 'Varying size integer I1P list input' , required = . false ., act = 'store' ,& nargs = '+' , def = '1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listBool' , switch_ab = '-vlBool' , help = 'Varying size boolean list input' , required = . false ., act = 'store' ,& nargs = '*' , def = 'T F T T F' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listChar' , switch_ab = '-vlChar' , help = 'Varying size character list input' , required = . false ., act = 'store' ,& nargs = '*' , def = 'foo bar baz' , error = error ) if ( error /= 0 ) stop ! parsing Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) stop ! using Command Line Interface data to set test_basic behaviour call cli % get ( switch = '-s' , val = sval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = rval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = ival , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-ie' , val = ieval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-b' , val = bval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-bv' , val = vbval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-il' , val = ilist , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-e' , val = envi , error = error ) ; if ( error /= 0 ) stop call cli % get ( position = 1_I4P , val = prval , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlR8P' , val = vlistR8P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlR4P' , val = vlistR4P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI8P' , val = vlistI8P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI4P' , val = vlistI4P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI2P' , val = vlistI2P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI1P' , val = vlistI1P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlBool' , val = vlistBool , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlChar' , val = vlistChar , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '--' , val = garbage , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'test_basic has been called with the following arguments values:' print '(A)' , 'String              input = ' // trim ( adjustl ( sval )) print '(A)' , 'Real                input = ' // str ( n = rval ) print '(A)' , 'Integer             input = ' // str ( n = ival ) print '(A)' , 'Exclusive   integer input = ' // str ( n = ieval ) print '(A)' , 'Environment integer input = ' // str ( n = envi ) print '(A,L1)' , 'Boolean             input = ' , bval print '(A,L1)' , 'Valued boolean      input = ' , vbval print '(A)' , 'Positional real     input = ' // str ( n = prval ) print '(A)' , 'Integer list inputs:' do l = 1 , 3 print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = ilist ( l ))) enddo if ( allocated ( vlistR8P )) then print '(A)' , 'Varying size real R8P list inputs:' do l = 1 , size ( vlistR8P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistR8P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size real R8P list!' endif if ( allocated ( vlistR4P )) then print '(A)' , 'Varying size real R4P list inputs:' do l = 1 , size ( vlistR4P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistR4P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size real R4P list!' endif if ( allocated ( vlistI8P )) then print '(A)' , 'Varying size integer I8P list inputs:' do l = 1 , size ( vlistI8P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistI8P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I8P list!' endif if ( allocated ( vlistI4P )) then print '(A)' , 'Varying size integer I4P list inputs:' do l = 1 , size ( vlistI4P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistI4P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I4P list!' endif if ( allocated ( vlistI2P )) then print '(A)' , 'Varying size integer I2P list inputs:' do l = 1 , size ( vlistI2P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistI2P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I2P list!' endif if ( allocated ( vlistI1P )) then print '(A)' , 'Varying size integer I1P list inputs:' do l = 1 , size ( vlistI1P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistI1P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I1P list!' endif if ( allocated ( vlistBool )) then print '(A)' , 'Varying size boolean list inputs:' do l = 1 , size ( vlistBool ) print '(A,L1)' , '  Input(' // trim ( str (. true ., l )) // ') = ' , vlistBool ( l ) enddo else print '(A)' , 'Problems occuour with varying size boolean list!' endif if ( allocated ( vlistChar )) then print '(A)' , 'Varying size character list inputs:' do l = 1 , size ( vlistChar ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // vlistChar ( l ) enddo else print '(A)' , 'Problems occuour with varying size character list!' endif if ( allocated ( garbage )) then print '(A)' , 'You have used implicit \"--\" option for collecting list of \"trailing garbage\" values that are:' do l = 1 , size ( garbage ) print '(A)' , '  Garbage(' // trim ( str (. true ., l )) // ') = ' // garbage ( l ) enddo endif if ( cli % passed ( switch = '--man_file' )) then call cli % get ( switch = '--man_file' , val = sval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Saving man page' call cli % save_man_page ( error = error , man_file = trim ( adjustl ( sval ))) endif stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_basic","tags":"","loc":"program/test_basic.html","title":"test_basic – FOODIE"},{"text":"Uses: IR_Precision Data_Type_Command_Line_Interface program~~test_choices_logical~~UsesGraph program~test_choices_logical test_choices_logical IR_Precision IR_Precision IR_Precision->program~test_choices_logical module~data_type_command_line_interface Data_Type_Command_Line_Interface IR_Precision->module~data_type_command_line_interface module~data_type_command_line_interface->program~test_choices_logical iso_fortran_env iso_fortran_env iso_fortran_env->module~data_type_command_line_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FLAP for bad usage of choices option with logical Calls program~~test_choices_logical~~CallsGraph program~test_choices_logical test_choices_logical str str program~test_choices_logical->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command Line Interface (CLI). logical :: vbval Valued-boolean value. integer(kind=I4P) :: error Error trapping flag. Source Code program test_choices_logical !----------------------------------------------------------------------------------------------------------------------------------- !< Test FLAP for bad usage of choices option with logical !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision USE Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command Line Interface (CLI). logical :: vbval !< Valued-boolean value. integer ( I4P ) :: error !< Error trapping flag. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call cli % init ( progname = 'test_choices_logical' ) call cli % add ( switch = '--boolean-value' , switch_ab = '-bv' , help = 'A help message' , & required = . false ., def = '.false.' , choices = '.True.,.False.' , act = 'store' , error = error ) call cli % parse ( error = error ) call cli % get ( switch = '-bv' , val = vbval , error = error ) print \"(A)\" , \"Error code: \" // trim ( str (. true ., error )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_choices_logical","tags":"","loc":"program/test_choices_logical.html","title":"test_choices_logical – FOODIE"},{"text":"Uses: IR_Precision Data_Type_Command_Line_Interface program~~test_nested~~UsesGraph program~test_nested test_nested IR_Precision IR_Precision IR_Precision->program~test_nested module~data_type_command_line_interface Data_Type_Command_Line_Interface IR_Precision->module~data_type_command_line_interface module~data_type_command_line_interface->program~test_nested iso_fortran_env iso_fortran_env iso_fortran_env->module~data_type_command_line_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Calls program~~test_nested~~CallsGraph program~test_nested test_nested str str program~test_nested->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command Line Interface (CLI). logical :: authors_print Boolean value. character(len=500) :: message Message value. integer(kind=I4P) :: error Error trapping flag. Source Code program test_nested !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface ! Definition of Type_Command_Line_Interface. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command Line Interface (CLI). logical :: authors_print !< Boolean value. character ( 500 ) :: message !< Message value. integer ( I4P ) :: error !< Error trapping flag. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- authors_print = . false . ! initializing Command Line Interface call cli % init ( progname = 'test_nested' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with nested commands' , & examples = [ 'test_nested                      ' , & 'test_nested -h                   ' , & 'test_nested init                 ' , & 'test_nested commit -m \"fix bug-1\"' , & 'test_nested tag -a \"v2.1.5\"      ' ]) ! set a Command Line Argument without a group to trigger authors names printing call cli % add ( switch = '--authors' , switch_ab = '-a' , help = 'Print authors names' , required = . false ., act = 'store_true' , def = '.false.' ) ! set Command Line Arguments Groups, i.e. commands call cli % add_group ( group = 'init' , description = 'fake init versioning' ) call cli % add_group ( group = 'commit' , description = 'fake commit changes to current branch' ) call cli % add_group ( group = 'tag' , description = 'fake tag current commit' ) call cli % set_mutually_exclusive_groups ( group1 = 'init' , group2 = 'commit' ) ! set Command Line Arguments of commit command call cli % add ( group = 'commit' , switch = '--message' , switch_ab = '-m' , help = 'Commit message' , required = . false ., act = 'store' , def = '' ) ! set Command Line Arguments of commit command call cli % add ( group = 'tag' , switch = '--annotate' , switch_ab = '-a' , help = 'Tag annotation' , required = . false ., act = 'store' , def = '' ) ! parsing Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) then print '(A)' , 'Error code: ' // trim ( str ( n = error )) stop endif ! using Command Line Interface data to trigger program behaviour call cli % get ( switch = '-a' , val = authors_print , error = error ) ; if ( error /= 0 ) stop if ( authors_print ) then print '(A)' , 'Authors: ' // cli % authors elseif ( cli % run_command ( 'init' )) then print '(A)' , 'init (fake) versioning' elseif ( cli % run_command ( 'commit' )) then call cli % get ( group = 'commit' , switch = '-m' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'commit changes to current branch with message \"' // trim ( message ) // '\"' elseif ( cli % run_command ( 'tag' )) then call cli % get ( group = 'tag' , switch = '-a' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'tag current branch with message \"' // trim ( message ) // '\"' else print '(A)' , 'cowardly you are doing nothing... try at least \"-h\" option!' endif stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_nested","tags":"","loc":"program/test_nested.html","title":"test_nested – FOODIE"},{"text":"Uses: IR_Precision Data_Type_Command_Line_Interface program~~test_string~~UsesGraph program~test_string test_string IR_Precision IR_Precision IR_Precision->program~test_string module~data_type_command_line_interface Data_Type_Command_Line_Interface IR_Precision->module~data_type_command_line_interface module~data_type_command_line_interface->program~test_string iso_fortran_env iso_fortran_env iso_fortran_env->module~data_type_command_line_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Calls program~~test_string~~CallsGraph program~test_string test_string str str program~test_string->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command Line Interface (CLI). character(len=99) :: sval String value. real(kind=R8P) :: rval Real value. real(kind=R8P) :: prval Positional real value. integer(kind=I4P) :: ival Integer value. integer(kind=I4P) :: ieval Exclusive integer value. logical :: bval Boolean value. logical :: vbval Valued-boolean value. integer(kind=I8P) :: ilist (1:3) Integer list values. integer(kind=I4P) :: error Error trapping flag. integer(kind=I4P) :: l Counter. Source Code program test_string !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface ! Definition of Type_Command_Line_Interface. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: sval !< String value. real ( R8P ) :: rval !< Real value. real ( R8P ) :: prval !< Positional real value. integer ( I4P ) :: ival !< Integer value. integer ( I4P ) :: ieval !< Exclusive integer value. logical :: bval !< Boolean value. logical :: vbval !< Valued-boolean value. integer ( I8P ) :: ilist ( 1 : 3 ) !< Integer list values. integer ( I4P ) :: error !< Error trapping flag. integer ( I4P ) :: l !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! initializing Command Line Interface call cli % init ( progname = 'test_sting' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with a fake string input' , & examples = [ \"test_sting -s 'Hello FLAP'                               \" , & \"test_sting -s 'Hello FLAP' -i -2 # printing error...     \" , & \"test_sting -s 'Hello FLAP' -i 3 -ie 1 # printing error...\" , & \"test_sting -s 'Hello FLAP' -i 3 -r 33.d0                 \" , & \"test_sting -s 'Hello FLAP' --integer_list 10 -3 87       \" , & \"test_sting 33.0 -s 'Hello FLAP' -i 5                     \" , & \"test_sting --string 'Hello FLAP' --boolean               \" ],& epilog = new_line ( 'a' ) // \"And that's how to FLAP your life\" ) ! setting Command Line Argumenst call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--integer_ex' , switch_ab = '-ie' , help = 'Exclusive integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , exclude = '-ie' , error = error ) call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) ! parsing Command Line Interface call cli % parse ( args = \"-s 'FAKE INVOCATION FROM STRING' --integer_list 10 -3 87\" , error = error ) if ( error /= 0 ) stop ! using Command Line Interface data to set test_string behaviour call cli % get ( switch = '-s' , val = sval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = rval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = ival , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-ie' , val = ieval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-b' , val = bval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-bv' , val = vbval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-il' , val = ilist , error = error ) ; if ( error /= 0 ) stop call cli % get ( position = 1_I4P , val = prval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'test_string has been called with the following arguments values:' print '(A)' , 'String            input = ' // trim ( adjustl ( sval )) print '(A)' , 'Real              input = ' // str ( n = rval ) print '(A)' , 'Integer           input = ' // str ( n = ival ) print '(A)' , 'Exclusive integer input = ' // str ( n = ieval ) print '(A,L1)' , 'Boolean           input = ' , bval print '(A,L1)' , 'Valued boolean    input = ' , vbval print '(A)' , 'Positional real   input = ' // str ( n = prval ) print '(A)' , 'Integer list inputs:' do l = 1 , 3 print '(A)' , 'Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = ilist ( l ))) enddo stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_string","tags":"","loc":"program/test_string.html","title":"test_string – FOODIE"},{"text":"Uses: IR_Precision iso_fortran_env program~~test_driver~2~~UsesGraph program~test_driver~2 Test_Driver IR_Precision IR_Precision IR_Precision->program~test_driver~2 iso_fortran_env iso_fortran_env iso_fortran_env->program~test_driver~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Testing program for IR_Precision, Pure Fortran (2003+) library for ensuring codes portability Usage ./Test_Driver Calls program~~test_driver~2~~CallsGraph program~test_driver~2 Test_Driver cton cton program~test_driver~2->cton strz strz program~test_driver~2->strz ir_print ir_print program~test_driver~2->ir_print bstr bstr program~test_driver~2->bstr bcton bcton program~test_driver~2->bcton ir_init ir_init program~test_driver~2->ir_init digit digit program~test_driver~2->digit str str program~test_driver~2->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code program Test_Driver !----------------------------------------------------------------------------------------------------------------------------------- !< Testing program for IR_Precision, Pure Fortran (2003+) library for ensuring codes portability !< !<### Usage !<```bash !< ./Test_Driver !<``` !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision USE , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! initialize IR_Precision call IR_Init ! print main IR_Precision values call IR_Print ( unit = stdout ) print \"(A)\" , '' print \"(A)\" , 'Testing IR_Precision tools' print \"(A)\" , 'Casting real-to-string: ' // str ( n = 1._R8P ) print \"(A)\" , 'Casting integer-to-string: ' // str ( n = 11_I8P ) print \"(A,\" // FR8P // \")\" , 'Casting string-to-real: ' , cton ( str = '2.2d0' , knd = 1._R8P ) print \"(A,\" // FI4P // \")\" , 'Casting integer-to-string: ' , cton ( str = '43' , knd = 1_I4P ) print \"(A)\" , 'Casting integer-to-string with zero padding: ' // trim ( strz ( nz_pad = 3 , n = 34_I8P )) ! print \"(A)\", 'Casting real-to-bit_string: '//bstr(n=1._R4P) print \"(A)\" , 'Casting integer-to-bit_string: ' // bstr ( n = 1_I4P ) ! print \"(A,\"//FR4P//\")\", 'Casting bit_string-to-real: ',bcton(bstr='00111111100000000000000000000000',knd=1._R4P) print \"(A,\" // FI4P // \")\" , 'Casting bit_string-to-integer: ' , bcton ( bstr = '00000000000000000000000000000001' , knd = 1_I4P ) print \"(A)\" , 'Number of digit of 1023: ' // str ( n = digit ( 1023_I4P )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram Test_Driver","tags":"","loc":"program/test_driver~2.html","title":"Test_Driver – FOODIE"},{"text":"Uses: iso_fortran_env pyplot_module program~~test~~UsesGraph program~test test iso_fortran_env iso_fortran_env iso_fortran_env->program~test module~pyplot_module pyplot_module iso_fortran_env->module~pyplot_module module~pyplot_module->program~test Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: n = 100 real(kind=wp), dimension(n) :: x real(kind=wp), dimension(n) :: y real(kind=wp), dimension(n) :: yerr real(kind=wp), dimension(n) :: sx real(kind=wp), dimension(n) :: cx real(kind=wp), dimension(n) :: tx real(kind=wp), dimension(n,n) :: z type( pyplot ) :: plt integer :: i integer :: j real(kind=wp) :: r2 Source Code program test use , intrinsic :: iso_fortran_env , only : wp => real64 use pyplot_module , only : pyplot implicit none integer , parameter :: n = 100 real ( wp ), dimension ( n ) :: x !! x values real ( wp ), dimension ( n ) :: y !! y values real ( wp ), dimension ( n ) :: yerr !! error values for bar chart real ( wp ), dimension ( n ) :: sx !! sin(x) values real ( wp ), dimension ( n ) :: cx !! cos(x) values real ( wp ), dimension ( n ) :: tx !! sin(x)*cos(x) values real ( wp ), dimension ( n , n ) :: z !! z matrix for contour plot type ( pyplot ) :: plt !! pytplot handler integer :: i !! counter integer :: j !! counter real ( wp ) :: r2 !! temp variable !generate some data: x = [( real ( i , wp ), i = 0 , size ( x ) - 1 )] / 5.0_wp sx = sin ( x ) cx = cos ( x ) tx = sx * cx yerr = abs ( sx * . 25_wp ) !2d line plot: call plt % initialize ( grid = . true ., xlabel = 'angle (rad)' , figsize = [ 20 , 10 ],& title = 'plot test' , legend = . true ., axis_equal = . true .) call plt % add_plot ( x , sx , label = '$\\sin (x)$' , linestyle = 'b-o' , markersize = 5 , linewidth = 2 ) call plt % add_plot ( x , cx , label = '$\\cos (x)$' , linestyle = 'r-o' , markersize = 5 , linewidth = 2 ) call plt % add_plot ( x , tx , label = '$\\sin (x) \\cos (x)$' , linestyle = 'g-o' , markersize = 2 , linewidth = 1 ) call plt % savefig ( 'plottest.png' , pyfile = 'plottest.py' ) !bar chart: tx = 0.1_wp !for bar width call plt % initialize ( grid = . true ., xlabel = 'angle (rad)' ,& title = 'bar test' , legend = . true ., figsize = [ 20 , 10 ],& font_size = 20 ,& axes_labelsize = 20 ,& xtick_labelsize = 20 ,& ytick_labelsize = 20 ,& legend_fontsize = 20 ) call plt % add_bar ( left = x , height = sx , width = tx , label = '$\\sin (x)$' ,& color = 'r' , yerr = yerr , xlim = [ 0.0_wp , 2 0.0_wp ], align = 'center' ) call plt % savefig ( 'bartest.png' , pyfile = 'bartest.py' ) !contour plot: x = [( real ( i , wp ), i = 0 , n - 1 )] / 10 0.0_wp y = [( real ( i , wp ), i = 0 , n - 1 )] / 10 0.0_wp do i = 1 , n do j = 1 , n r2 = x ( i ) ** 2 + y ( j ) ** 2 z ( i , j ) = sin ( x ( i )) * cos ( y ( j )) * sin ( r2 ) / ( 1.0_wp + log ( r2 + 1.0_wp )) end do end do call plt % initialize ( grid = . true ., xlabel = 'x angle (rad)' , ylabel = 'y angle (rad)' , figsize = [ 10 , 10 ],& title = 'Contour plot test' , real_fmt = '*' ) call plt % add_contour ( x , y , z , label = 'contour' , linestyle = '-' , linewidth = 2 , filled = . true ., cmap = 'bone' ) call plt % savefig ( 'contour.png' , pyfile = 'contour.py' ) end program test","tags":"","loc":"program/test.html","title":"test – FOODIE"}]}