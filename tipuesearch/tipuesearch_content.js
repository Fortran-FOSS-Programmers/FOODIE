var tipuesearch = {"pages":[{"text":"FOODIE FOODIE FOODIE, Fortran Object-Oriented Differential-equations Integration Environment FOODIE is a pure Fortran (KISS) library providing an awesome environment for the numerical integration of Differential-equations (ODE, PDE); FOODIE is Fortran 2008+ standard compliant; FOODIE is OOP designed; FOODIE is a Free, Open Source Project. Table of Contents What is FOODIE? Main features Status Copyrights Documentation What is FOODIE? Modern Fortran standards (2003+) have introduced support for Object-Oriented Programming (OOP). Exploiting new features like Abstract Data Type (ADT) is now possible to develop a KISS library providing an awesome environment for the numerical integration of Differential-equations such as Ordinary and Partial Differential Eqautions (ODE, PDE). FOODIE is tailored to the systems arising from the semi-discretization of PDEs, but it is not limited to them. The FOODIE environment allows the (numerical) solution of general, non linear differential equations system of the form: where: U_t = dU/dt ; U is the vector of state variables being a function of the time-like independent variable t ; R is the (vectorial) residual function, it could be a non linear function of the solution U itself; F is the (vectorial) initial conditions function. The FOODIE has two main purposes: for developers devising new schemes for the numerical integrations of differential equations (DE): provide a concise, clear, robust and comprehensive abstract environment by means of which: express the solvers formulae with a very high-level language, it being close as much as possible to their natual mathematical formulations; this ensures: clearness, conciseness and robustness; fast-developing; for clients that must solve a differential equations system: provide a simple, standard API for many built-in DE solvers out-of-the-box, thus allowing: fast-solution of new problems; robustness: the same DE solver is applied to different problems, i.e. cross-validation; Go to Top Main features FOODIE is aimed to be a KISS-pure-Fortran library for integrating Ordinary Differential Equations (ODE), it being: Pure Fortran implementation; KISS and user-friendly: simple API, presently based on the Rouson's Abstract Data Type Pattern [8]; easy building and porting on heterogeneous architectures; comprehensive solvers set out-of-the-box: explicit schemes: Adams-Bashforth schemes see [7]: 1 step, namely the forward explicit Euler scheme, 1st order accurate; 2 steps, 2nd accurate; 3 steps, 3rd accurate; Euler scheme, 1st order accurate; Leapfrog , 2nd order accurate: unfiltered leapfrog, 2nd order accurate, mostly unstable, see [4]; Robert-Asselin filtered leapfrog, 1st order accurate, see [4, 5, 6]; Robert-Asselin-Williams filtered leapfrog, 3rd order accurate, see [5, 6]; Runge-Kutta schemes: low-storage schemes, see [1, 2, 3]: 1 stage, namely the forward explicit Euler scheme, 1st order accurate; 2 stages; 3 stages; 4 stages; 5 stages, 4th order accurate, 2N registers, see [3]; 6 stages, 4th order accurate, 2N registers, see [9]; 7 stages, 4th order accurate, 2N registers, see [9]; 12 stages, 4th order accurate, 2N registers, see [10]; 13 stages, 4th order accurate, 2N registers, see [10]; 14 stages, 4th order accurate, 2N registers, see [10]; TVD/SSP schemes, see [1]: 1 stage, namely the forward explicit Euler scheme, 1st order accurate; 2 stages, 2nd order accurate; 3 stages, 3rd order accurate; 4 stages; 5 stages, 4th order accurate; embedded (adaptive) schemes: Runge-Kutta-Fehlberg, 5 stages, 4th order accurate; Runge-Kutta-Cash-Karp, 5 stages, 4th order accurate; Prince-Dormand, 7 stages, 4th order accurate, see [11]; implicit schemes: Runge-Kutta schemes; predictor-corrector schemes: Adams-Bashforth-Moulton schemes: 1 step, AB(1)-AM(0), 1st order accurate; 2 steps, AB(2)-AM(1), 2nd accurate; 3 steps, AB(3)-AM(2), 3rd accurate; 4 steps, AB(4)-AM(3), 4th accurate; efficient and non intrusive : FOODIE environment is unaware of any eventual parallel paradigms the clients used, but it is proved to preserve high scalability on parallel architectures such as: OpenMP directive-based codes on shared memory multi/many cores architectures; CoArray Fortran (CAF) based codes for Partitioned Global Address Space (PGAS) programming model; MPI based code on distributed memory clusters; GPGPU/accelerators device enabled codes; Tests-Driven Developed ( TDD ): well documented: clear documentation of schemes implementations, e.g. see Adams-Bashforth API documentation ; complete API reference; comprehensive wiki : collaborative developed on GitHub ; FOSS licensed ; Any feature request is welcome. Bibliography [1] High Order Strong Stability Preserving Time Discretizations , Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of Scientific Computing, vol. 38, N. 3, 2009, pp. 251–289. [2] Low-Storage Runge-Kutta Schemes , J. H. Williamson, Journal of Computational Physics, vol. 35, 1980, pp. 48–56. [3] Fourth-Order 2N-Storage Runge-Kutta Schemes , Mark H. Carpenter, Christopher A. Kennedy, NASA Technical Memorandum 109112, June 1994. [4] Numerical methods used in atmospheric models , Mesinger F. and A. Arakawa, Global Atmospheric Research Programme (GARP), Technical Report , 1976. [5] A Proposed Modification to the Robert-Asselin Time Filter , Williams, P. D., Mon. Wea. Rev., vol. 137, pp. 2538–2546, 2009, doi: http://dx.doi.org/10.1175/2009MWR2724.1. [6] The RAW filter: An improvement to the Robert-Asselin filter in semi-implicit integrations , Williams, P.D., Monthly Weather Review, vol. 139(6), pages 1996–2007, June 2011. [7] Linear multistep method , wikipedia article . [8] Scientific Software Design: The Object-Oriented Way , Rouson, Damian and Xia, Jim and Xu, Xiaofeng, 2011, ISBN 9780521888134, Cambridge University Press, New York, NY, USA. [9] High-accuracy large-step explicit Runge–Kutta (HALE-RK) schemes for computational aeroacoustics , Vasanth Allampalli and Ray Hixon and M. Nallasamy and Scott D. Sawyer, Journal of Computational Physics, vol. 228, 2009, pp. 3837–3850. [10] Efficient low-storage Runge–Kutta schemes with optimized stability regions , Jens Niegemann and Richard Diehl and Kurt Busch, Journal of Computational Physics, vol. 231, 2012, pp. 364–372. [11] A family of embedded Runge-Kutta formulae , Dormand, J. R.; Prince, P. J. (1980), , Journal of Computational and Applied Mathematics 6 (1): 19–26, doi:10.1016/0771-050X(80)90013-3. Go to Top Status FOODIE project is young, but developed with love. Many integrators have been implemented using the Rouson's Abstract Data Type Pattern and tested with complex problems, but the library API is still in beta testing status. Nevertheless, FOODIE is already proven to be able to integrate a wide range of different ODE problems, from pure ODEs (Lorenz and inertial oscillations equations) to complex PDEs (Burgers and Euler equations), see the documentation. We are searching for Fortraners enthusiast joining our team! Copyrights FOODIE is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to FOODIE is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the FOODIE documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . Go to Top Developer Info Fortran-FOSS-Programmers Group","tags":"","loc":"index.html","title":" FOODIE "},{"text":"FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. Source Code !< FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. module foodie !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. !< !< FOODIE is a KISS library for solving systems of Ordinary Differential Equation (ODE) into the Initial Values Problems (IVP) !< contest. The mathematical formulation of the problem is: !< !< U_t = R(t,U) !< U_0 = F(0) !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function and *F* is the (vectorial) initial conditions function. !< !< FOODIE is aimed to the time-like integration of the above system of ODE. To this aim, different numerical schemes are provided: !< !<+ *explicit Adams-Bashforth* class of schemes: !<    + 1 step, namely the explicit forward Euler scheme, 1st order accurate; !<    + 2 steps, 2nd order accurate; !<    + 3 steps, 3rd order accurate; !<    + 4 steps, 4th order accurate; !<+ *forward explicit Euler* scheme, a 1st order accurate; !<+ *explicit Leapfrog*: !<    + Unfiltered, 2nd order accurate, (mostly) unstable; !<    + Robert-Asselin filtered, 1st order accurate; !<    + Robert-Asselin-Williams filter, 2nd order accurate; !<+ *explicit low storage Runge-Kutta 2N* class schemes: !<    + LS(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; !<    + LS(5,4): 5 stages, 4th order accurate; !<+ *explicit TVD or SSP Runge-Kutta* class schemes: !<    + TVD(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; !<    + SSP(2,2): 2 stages, 2nd order accurate; !<    + SSP(3,3): 3 stages, 3rd order accurate; !<    + SSP(5,4): 5 stages, 4th order accurate; !<+ *explicit embedded Runge-Kutta* class schemes: !<    + DP(7,4): 7 stages, 4th order accurate, Dormand and Prince scheme; !<+ *implicit Adams-Moulton* class of schemes: !<    + 0 step, namely the implicit backward Euler scheme, 1st order accurate; !<    + 1 step, 2nd order accurate; !<    + 2 steps, 3rd order accurate; !<    + 3 steps, 4th order accurate; !<+ *predictor-corrector Adams-Bashforth-Moulton* class of schemes: !<    + P=AB(1)-C=AM(0) step, namely the explicit/implicit forward/backward Euler scheme, 1st order accurate; !<    + P=AB(2)-C=AM(1) step, 2nd order accurate; !<    + P=AB(3)-C=AM(2) steps, 3rd order accurate; !<    + P=AB(4)-C=AM(3) steps, 4th order accurate; !< !<### Usage !< !< FOODIE schemes must be applied to only subclass extensions of the abstract class *integrand*. !< !< To use FOODIE you must: !< !<#### extend integrand abstract class provided by FOODIE implementing your concrete integrand field !< !< For example for the Lorenz' ODE system !< !<```fortran !< type, extends(integrand) :: lorenz !<   !< Lorenz equations field. !<   !< !<   !< It is a FOODIE integrand class. !<   private !<   real(R_P), dimension(:), allocatable :: state        !< Solution vector. !<   real(R_P)                            :: sigma=0._R_P !< Lorenz \\sigma. !<   real(R_P)                            :: rho=0._R_P   !< Lorenz \\rho. !<   real(R_P)                            :: beta=0._R_P  !< Lorenz \\beta. !<   contains !<     procedure, pass(self), public :: t => dLorenz_dt                                 !< Time derivate, resiuduals function. !<     procedure, pass(lhs),  public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. !<     procedure, pass(rhs),  public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. !<     procedure, pass(lhs),  public :: add => add_lorenz                               !< Lorenz + Lorenz oprator. !<     procedure, pass(lhs),  public :: assign_integrand => lorenz_assign_lorenz        !< Lorenz = Lorenz. !<     procedure, pass(lhs),  public :: assign_real => lorenz_assign_real               !< Lorenz = real. !<     ... !< endtype lorenz !<``` !< !<#### use one of the provided FOODIE integrator !< !< For example using the forward explicit Euler scheme to the above Lorenz' ODE system !< !<```fortran !< use foodie, only : euler_explicit_integrator !< use type_lorenz, only : lorenz !< type(euler_explicit_integrator) :: euler_integrator !< type(lorenz)                    :: attractor !< real                            :: dt=0.01 !< do step = 1, num_steps !<   call euler_integrator%integrate(field=attractor, dt=dt) !< enddo !<``` !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_integrator_adams_bashforth , only : adams_bashforth_integrator use foodie_integrator_adams_bashforth_moulton , only : adams_bashforth_moulton_integrator use foodie_integrator_adams_moulton , only : adams_moulton_integrator use foodie_integrator_emd_runge_kutta , only : emd_runge_kutta_integrator use foodie_integrator_euler_explicit , only : euler_explicit_integrator use foodie_integrator_leapfrog , only : leapfrog_integrator use foodie_integrator_low_storage_runge_kutta , only : ls_runge_kutta_integrator use foodie_integrator_tvd_runge_kutta , only : tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: integrand public :: adams_bashforth_integrator public :: adams_bashforth_moulton_integrator public :: adams_moulton_integrator public :: emd_runge_kutta_integrator public :: euler_explicit_integrator public :: leapfrog_integrator public :: ls_runge_kutta_integrator public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- endmodule foodie","tags":"","loc":"sourcefile/foodie.f90.html","title":"foodie.f90 – FOODIE"},{"text":"Define the abstract type integrand for building FOODIE ODE integrators. Source Code !< Define the abstract type *integrand* for building FOODIE ODE integrators. module foodie_adt_integrand !----------------------------------------------------------------------------------------------------------------------------------- !< Define the abstract type *integrand* for building FOODIE ODE integrators. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , abstract :: integrand !< Abstract type for building FOODIE ODE integrators. #ifdef CAF class ( * ), allocatable :: dummy_to_allow_extensions [:] !< Dummy member to allow concrete extensions with coarray members. #endif contains ! public deferred procedures that concrete integrand-field must implement procedure ( time_derivative ), pass ( self ), deferred , public :: t !< Time derivative, residuals. ! operators procedure ( local_error_operator ), pass ( lhs ), deferred , public :: local_error !< ||integrand - integrand||. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_multiply_integrand !< Integrand * integrand operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_multiply_real !< Integrand * real operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_multiply_integrand !< Real * integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: add !< Integrand + integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: sub !< Integrand - integrand operator. procedure ( assignment_integrand ), pass ( lhs ), deferred , public :: assign_integrand !< Integrand = integrand. ! operators overloading generic , public :: operator (. lterror .) => local_error !< Estimate local truncation error. generic , public :: operator ( + ) => add !< Overloading + operator. generic , public :: operator ( - ) => sub !< Overloading - operator. generic , public :: operator ( * ) => integrand_multiply_integrand , & real_multiply_integrand , & integrand_multiply_real !< Overloading * operator. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. endtype integrand abstract interface !< Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). function time_derivative ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative function of integrand class, i.e. the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( IN ) :: self !< Integrand field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Result of the time derivative function of integrand field. !--------------------------------------------------------------------------------------------------------------------------------- endfunction time_derivative function local_error_operator ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 solution approximations. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. !--------------------------------------------------------------------------------------------------------------------------------- endfunction local_error_operator function integrand_op_real ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Asymmetric type operator integrand.op.real. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction integrand_op_real function real_op_integrand ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Asymmetric type operator real.op.integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_op_integrand function symmetric_operator ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Symmetric type operator integrand.op.integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand class ( integrand ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction symmetric_operator subroutine assignment_integrand ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Symmetric assignment integrand = integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand class ( integrand ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assignment_integrand endinterface !----------------------------------------------------------------------------------------------------------------------------------- endmodule foodie_adt_integrand","tags":"","loc":"sourcefile/foodie_adt_integrand.f90.html","title":"foodie_adt_integrand.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 4rd order accurate. Source Code !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 4rd order accurate. module foodie_integrator_adams_bashforth !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 4rd order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Adams-Bashforth class scheme implemented is: !< !<  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s}{ b_s \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  !< !<where N_s is the number of previous steps considered. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit. The coefficients b_s define the actual scheme, that is selected accordingly to the number of !< **steps** used. !< !< Currently, the following schemes are available: !<##### 1 step, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. !< The *b* coefficient is: !< b = \\left[b_1\\right] = \\left[1\\right] !< The scheme is: !<  U&#94;{n+1} = U&#94;n + \\Delta t R(t&#94;n,U&#94;n)  !< !<##### 2 steps !< This scheme is 2nd order. !< The *b* coefficients are: !< b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] = !<       \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+2} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right]  !< !<##### 3 steps !< This scheme is 3rd order. !< The *b* coefficients are: !< b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] = !<       \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+3} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1}) !< +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right]  !< !<##### 4 steps !< This scheme is 4th order. !< The *b* coefficients are: !< b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 & b_4 \\end{array}} \\right] = !<       \\left[ {\\begin{array}{*{20}{c}} -\\frac{9}{24} & \\frac{37}{24} & -\\frac{59}{24} & \\frac{55}{24} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+4} = U&#94;{n+3} +\\Delta t \\left[ \\frac{55}{24}R(t&#94;{n+3}, U&#94;{n+3}) - \\frac{59}{24}R(t&#94;{n+2}, U&#94;{n+2}) !< +\\frac{37}{24} R(t&#94;{n+1}, U&#94;{n+1}) - \\frac{9}{24} R(t&#94;{n}, U&#94;{n}) \\right]  !< !<#### Bibliography !< !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P , I_P use foodie_adt_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: adams_bashforth_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: adams_bashforth_integrator !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 4rd order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. private integer ( I_P ) :: steps = 0 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< b coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. final :: finalize !< Finalize object. endtype adams_bashforth_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 1 : steps )) ; self % b = 0._R_P select case ( steps ) case ( 1 ) ! AB(1) Forward-Euler self % b ( 1 ) = 1._R_P case ( 2 ) ! AB(2) self % b ( 1 ) = - 0.5_R_P self % b ( 2 ) = 1.5_R_P case ( 3 ) ! AB(3) self % b ( 1 ) = 5._R_P / 1 2._R_P self % b ( 2 ) = - 4._R_P / 3._R_P self % b ( 3 ) = 2 3._R_P / 1 2._R_P case ( 4 ) ! AB(4) self % b ( 1 ) = - 3._R_P / 8._R_P self % b ( 2 ) = 3 7._R_P / 2 4._R_P self % b ( 3 ) = - 5 9._R_P / 2 4._R_P self % b ( 4 ) = 5 5._R_P / 2 4._R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 if ( allocated ( self % b )) deallocate ( self % b ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , previous , Dt , t , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate do s = 1 , self % steps U = U + previous ( s )% t ( t = t ( s )) * ( Dt * self % b ( s )) enddo if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do s = 1 , self % steps - 1 previous ( s ) = previous ( s + 1 ) enddo previous ( self % steps ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_adams_bashforth","tags":"","loc":"sourcefile/foodie_integrator_adams_bashforth.f90.html","title":"foodie_integrator_adams_bashforth.f90 – FOODIE"},{"text":"FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order\n accurate. Source Code !< FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order !< accurate. module foodie_integrator_adams_bashforth_moulton !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order !< accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Adams-Bashforth-Moulton class scheme implemented is: !< !<##### predictor !<  U&#94;{n+N_s&#94;p} = U&#94;{n+N_s&#94;p-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s&#94;p}{ b_s&#94;p \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  !<##### corrector !<  U&#94;{n+N_s&#94;c} = U&#94;{n+N_s&#94;c-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s&#94;c}{ b_s&#94;c \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } \\right]  !< !<where N_s&#94;p is the number of previous steps considered for the predictor and N_s&#94;c is the number of previous steps !<considered for the corrector. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The coefficients b_s&#94;{p,c} define the actual scheme, that is selected accordingly to the number of !< **steps** used. The predictor and corrector schemes should have the same formal order of accuracy, thus N_s&#94;p=N_s&#94;c+1 !< should hold. !< !< Currently, the following schemes are available: !<##### P=AB(1)-C=AM(0) step, Explicit/Implicit Farward/Backward Euler, 1st order !< This scheme is TVD and reverts to Explicit/Implicit Farward/Backward Euler, it being 1st order. !< The *b* coefficient is: !< b&#94;p = \\left[b_1\\right] = \\left[1\\right] !< b&#94;c = \\left[b_0\\right] = \\left[1\\right] !< The scheme is: !<  U&#94;{n+1,p} = U&#94;{n} + \\Delta t R(t&#94;{n},U&#94;{n})  !<  U&#94;{n+1,c} = U&#94;{n} + \\Delta t R(t&#94;{n+1},U&#94;{n+1,p})  !< !<##### P=AB(2)-C=AM(1) steps !< This scheme is 2nd order. !< The *b* coefficients are: !< b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right] !< b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2} & \\frac{1}{2} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+2,p} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right]  !<  U&#94;{n+2,c} = U&#94;{n+1} +\\Delta t \\left[ \\frac{1}{2} R(t&#94;{n+2,p}, U&#94;{n+2})+\\frac{1}{2} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  !< !<##### P=AB(3)-C=AM(2) steps !< This scheme is 3rd order. !< The *b* coefficients are: !< b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right] !< b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{12} & \\frac{2}{3} & \\frac{5}{12} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+3,p} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1}) !< +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right]  !<  U&#94;{n+3,c} = U&#94;{n+2} +\\Delta t \\left[ \\frac{5}{12}R(t&#94;{n+3}, U&#94;{n+3,p}) + \\frac{2}{3}R(t&#94;{n+2}, U&#94;{n+2}) !< -\\frac{1}{12} R(t&#94;{n+1}, U&#94;{n+1})  \\right]  !< !<##### P=AB(4)-C=AM(3) steps !< This scheme is 4th order. !< The *b* coefficients are: !< b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 & b_4 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} -\\frac{9}{24} & \\frac{37}{24} & -\\frac{59}{24} & \\frac{55}{24} \\end{array}} \\right] !< b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 & b_3 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{24} & -\\frac{5}{24} & \\frac{19}{24} & \\frac{9}{24} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+4,p} = U&#94;{n+3} +\\Delta t \\left[ \\frac{55}{24}R(t&#94;{n+3}, U&#94;{n+3}) - \\frac{59}{24}R(t&#94;{n+2}, U&#94;{n+2}) !< +\\frac{37}{24} R(t&#94;{n+1}, U&#94;{n+1}) - \\frac{9}{24} R(t&#94;{n}, U&#94;{n}) \\right]  !<  U&#94;{n+4,c} = U&#94;{n+3} +\\Delta t \\left[ \\frac{9}{24}R(t&#94;{n+4}, U&#94;{n+4,p}) + \\frac{19}{24}R(t&#94;{n+3}, U&#94;{n+3}) !< -\\frac{5}{24} R(t&#94;{n+2}, U&#94;{n+2}) + \\frac{1}{24} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  !< !<#### Bibliography !< !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P , I_P use foodie_adt_integrand , only : integrand use foodie_integrator_adams_bashforth , only : adams_bashforth_integrator use foodie_integrator_adams_moulton , only : adams_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: adams_bashforth_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: adams_bashforth_moulton_integrator !< FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. !< !< @note The integrator must be created or initialized (predictor and corrector schemes selection) before used. private integer ( I_P ) :: steps =- 1 !< Number of time steps. type ( adams_bashforth_integrator ) :: predictor !< Predictor solver. type ( adams_moulton_integrator ) :: corrector !< Corrector solver. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype adams_bashforth_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth-Moulton integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps call self % predictor % init ( steps = steps ) call self % corrector % init ( steps = steps - 1 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = - 1 call self % predictor % destroy call self % corrector % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , previous , Dt , t , iterations ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth-Moulton class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( IN ) :: self !< Actual ABM integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations of AM scheme. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % predictor % integrate ( U = U , previous = previous , Dt = Dt , t = t , autoupdate = . false .) call self % corrector % integrate ( U = U , previous = previous ( 2 :), Dt = Dt , t = t , iterations = iterations , autoupdate = . false .) call self % predictor % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_adams_bashforth_moulton","tags":"","loc":"sourcefile/foodie_integrator_adams_bashforth_moulton.f90.html","title":"foodie_integrator_adams_bashforth_moulton.f90 – FOODIE"},{"text":"FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 4rd order accurate. Source Code !< FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 4rd order accurate. module foodie_integrator_adams_moulton !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 4rd order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Adams-Moulton class scheme implemented is: !< !<  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s-1}{ b_s \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } + !< b_{N_S}\\cdot R(t&#94;{n+N_s}, U&#94;{n+N_s}) \\right]  !< !<where N_s is the number of previous steps considered. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are implicit. The coefficients b_s define the actual scheme, that is selected accordingly to the number of !< **steps** used. !< !< Currently, the following schemes are available: !<##### 0 step, Implicit Backward Euler, 1st order !< This scheme is TVD and reverts to Implicit Backward Euler, it being 1st order. !< The *b* coefficient is: !< b = \\left[b_0\\right] = \\left[1\\right] !< The scheme is: !<  U&#94;{n} = U&#94;{n-1} + \\Delta t R(t&#94;{n},U&#94;{n})  !< !<##### 1 step !< This scheme is 2nd order. !< The *b* coefficients are: !< b = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 \\end{array}} \\right] = !<       \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2} & \\frac{1}{2} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+1} = U&#94;{n} +\\Delta t \\left[ \\frac{1}{2} R(t&#94;{n+1}, U&#94;{n+1})+\\frac{1}{2} R(t&#94;{n}, U&#94;{n}) \\right]  !< !<##### 2 steps !< This scheme is 3rd order. !< The *b* coefficients are: !< b = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 \\end{array}} \\right] = !<       \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{12} & \\frac{2}{3} & \\frac{5}{12} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+2} = U&#94;{n+1} +\\Delta t \\left[ \\frac{5}{12}R(t&#94;{n+2}, U&#94;{n+2}) + \\frac{2}{3}R(t&#94;{n+1}, U&#94;{n+1}) !< -\\frac{1}{12} R(t&#94;{n}, U&#94;{n})  \\right]  !< !<##### 3 steps !< This scheme is 4th order. !< The *b* coefficients are: !< b = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 & b_3 \\end{array}} \\right] = !<       \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{24} & -\\frac{5}{24} & \\frac{19}{24} & \\frac{9}{24} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+3} = U&#94;{n+2} +\\Delta t \\left[ \\frac{9}{24}R(t&#94;{n+3}, U&#94;{n+3}) + \\frac{19}{24}R(t&#94;{n+2}, U&#94;{n+2}) !< -\\frac{5}{24} R(t&#94;{n+1}, U&#94;{n+1}) + \\frac{1}{24} R(t&#94;{n}, U&#94;{n}) \\right]  !< !<#### Bibliography !< !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P , I_P use foodie_adt_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: adams_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: adams_moulton_integrator !< FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 3rd order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. private integer ( I_P ) :: steps =- 1 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< b coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. final :: finalize !< Finalize object. endtype adams_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Moulton integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 0 : steps )) ; self % b = 0._R_P select case ( steps ) case ( 0 ) ! AM(0) Bacward-Euler self % b ( 0 ) = 1._R_P case ( 1 ) ! AM(1) self % b ( 0 ) = 0.5_R_P self % b ( 1 ) = 0.5_R_P case ( 2 ) ! AM(2) self % b ( 0 ) = - 1._R_P / 1 2._R_P self % b ( 1 ) = 2._R_P / 3._R_P self % b ( 2 ) = 5._R_P / 1 2._R_P case ( 3 ) ! AM(3) self % b ( 0 ) = 1._R_P / 2 4._R_P self % b ( 1 ) = - 5._R_P / 2 4._R_P self % b ( 2 ) = 1 9._R_P / 2 4._R_P self % b ( 3 ) = 3._R_P / 8._R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = - 1 if ( allocated ( self % b )) deallocate ( self % b ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , previous , Dt , t , iterations , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Moulton class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. class ( integrand ), allocatable :: delta !< Delta RHS for fixex point iterations. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate if ( self % steps > 0 ) then if ( present ( iterations )) then ! perform fixed point iterations allocate ( delta , source = previous ( self % steps )) do s = 0 , self % steps - 1 delta = delta + previous ( s + 1 )% t ( t = t ( s + 1 )) * ( Dt * self % b ( s )) enddo do s = 1 , iterations U = delta + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps )) enddo else U = previous ( self % steps ) + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps )) do s = 0 , self % steps - 1 U = U + previous ( s + 1 )% t ( t = t ( s + 1 )) * ( Dt * self % b ( s )) enddo endif if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) else U = U + U % t ( t = t ( 1 )) * ( Dt * self % b ( 0 )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 0 , self % steps - 2 previous ( s + 1 ) = previous ( s + 2 ) enddo previous ( self % steps ) = U endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_adams_moulton","tags":"","loc":"sourcefile/foodie_integrator_adams_moulton.f90.html","title":"foodie_integrator_adams_moulton.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 6th order accurate. Source Code !< FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 6th order accurate. module foodie_integrator_emd_runge_kutta !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 6th order accurate. !< !< The integrators provided have the embedded pairs property allowing for automatic step size control. !< The schemes are explicit and defined through the extended Butcher's table syntax, see[1] . !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<  U_p&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_p&#94;s K&#94;s  !<  U_{p+1}&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_{p+1}&#94;s K&#94;s  !< !< *p* is the lower accuracy order scheme and *p+1* is the higher one; Ns is the number of stages used and K&#94;s is !< the s&#94;{th} stage computed as: !< !<  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are !< given in the extended Butcher table form: !< !<``` !<  gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns} !<  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns} !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns} !< ------------|------------------------------------------------------------- !<             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns} !<             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} !<``` !< !< Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: !< !<``` !<  gamma&#94;1    | 0                 0                 ...        0 !<  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0 !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0 !< ------------|------------------------------------------------------------- !<             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns} !<             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} !<``` !< !< Moreover the following relation always holds: !<  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !<##### 2 stages, 2th order !< This scheme is due to Heun-Euler. !<``` !<  0  | 0 !<  1  | 1     0 !< ---------------- !<     | 1/2   1/2 !<     | 1      0 !<``` !< !<##### 6 stages, 5th order !< This scheme is due to Cash and Karp, see [3]. !<``` !<  0    | 0 !<  1/5\t | 1/5 !<  3/10 | 3/40\t         9/40 !<  3/5\t | 3/10\t         -9/10\t      6/5 !<  1\t   | -11/54\t       5/2\t        -70/27\t    35/27 !<  7/8\t | 1631/55296    175/512      575/13824   44275/110592     253/4096     0 !< ---------------------------------------------------------------------------------------- !<       | 37/378        0           250/621      125/594          0            512/1771 !<       | 2825/27648    0           18575/48384  13525/55296      277/14336    1/4 !<``` !< !<##### 7 stages, 4th order !< This scheme is due to Dormand and Prince, see [1]. !<``` !<  0    | 0 !<  1/5  | 1/5 !<  3/10 | 3/40          9/40 !<  4/5  | 44/45        -56/15        32/9 !<  8/9  | 19372/6561   -25360/2187   64448/6561   -212/729 !<  1    | 9017/3168    -355/33       46732/5247    49/176      -5103/18656 !<  1    | 35/384        0            500/1113      125/192     -2187/6784      11/84      0 !< -------------------------------------------------------------------------------------------- !<       | 5179/57600    0            7571/16695    393/640     -92097/339200   187/2100   1/40 !<       | 35/384        0            500/1113      125/192     -2187/6784      11/84      0 !<``` !< !<##### 9 stages, 6th order !< This scheme is due to Calvo et al., see [2]. !<``` !<  0                 | 0 !<  2/15              | 2/15 !<  1/5               | 1/20                  3/20 !<  3/10              | 3/40                  0                      9/40 !<  14/25             | 86727015/196851553    -60129073/52624712     957436434/1378352377    83886832/147842441 !<  19/25             | -86860849/45628967    111022885/25716487     108046682/101167669     -141756746/36005461 !<  35226607/35688279 | 77759591/16096467     -49252809/6452555      -381680111/51572984     879269579/66788831 !<  1                 | 237564263/39280295    -100523239/10677940    -265574846/27330247     317978411/18988713 !<  1                 | 17572349/289262523    0                      57513011/201864250      15587306/354501571 !< -------------------------------------------------------------------------------------------------------------- !<                    | 17572349/289262523    0                      57513011/201864250      15587306/354501571 !<                    | 15231665/510830334    0                      59452991/116050448      -28398517/122437738 !< ...continued... !<  0                 | !<  2/15              | !<  1/5               | !<  3/10              | !<  14/25             | !<  19/25             | 73139862/60170633 !<  35226607/35688279 | -90453121/33722162     111179552/157155827 !<  1                 | -124494385/35453627    86822444/100138635     -12873523/724232625 !<  1                 | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0 !< ----------------------------------------------------------------------------------------------------------------------- !<                    | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0 !<                    | 56673824/137010559     68003849/426673583     7097631/37564021       -71226429/583093742    1/20 !<``` !< !<##### 17 stages, 10th order !< This scheme is due to Feagin, see [4]. !<``` !<  0                        |  0 !<  0.1                      |  0.1 !<  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052 !<  0.809036761204472681298  |  0.202259190301118170324  0                        0.606777570903354510974 !<  0.309036761204472681298  |  0.184024714708643575149  0                        0.197966831227192369068 !<  0.981074190219795268254  |  0.087900734020668133731  0                        0 !<  0.833333333333333333333  |  0.085970050490246030218  0                        0 !<  0.354017365856802376329  |  0.120930449125333720660  0                        0 !<  0.882527661964732346425  |  0.110854379580391483508  0                        0 !<  0.642615758240322548157  |  0.112054414752879004829  0                        0 !<  0.357384241759677451842  |  0.113976783964185986138  0                        0 !<  0.117472338035267653574  |  0.079831452828019604635  0                        0 !<  0.833333333333333333333  |  0.985115610164857280120  0                        0 !<  0.309036761204472681298  |  0.895080295771632891049  0                        0.197966831227192369068 !<  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052  0 !<  0.1                      |  0.1                      0                       -0.157178665799771163367 !<  1                        |  0.181781300700095283888  0.675                    0.342758159847189839942 !< ------------------------------------------------------------------------------------------------------ !<                           |  0.033333333333333333333  0.025                    0.033333333333333333333 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | -0.072954784731363262918 !<  0.981074190219795268254  |  0.410459702520260645318  0.482713753678866489204 !<  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -0.073185637507085073678 !<  0.354017365856802376329  |  0                        0.260124675758295622809  0.032540262154909133015 !<  0.882527661964732346425  |  0                        0                       -0.060576148825500558762 !<  0.642615758240322548157  |  0                        0                       -0.144942775902865915672 !<  0.357384241759677451842  |  0                        0                       -0.076881336420335693858 !<  0.117472338035267653574  |  0                        0                       -0.052032968680060307651 !<  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -1.378964865748435675821 !<  0.309036761204472681298  | -0.072954784731363262918  0                       -0.851236239662007619739 !<  0.539357840802981787532  |  0                       -0.777333643644968233538  0 !<  0.1                      |  0                        0                        0 !<  1                        |  0                        0.259111214548322744512 -0.358278966717952089048 !< ------------------------------------------------------------------------------------------------------ !<                           |  0                        0.05                     0 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | -0.059578021181736100156 !<  0.882527661964732346425  |  0.321763705601778390100  0.510485725608063031577 !<  0.642615758240322548157  | -0.333269719096256706589  0.499269229556880061353  0.509504608929686104236 !<  0.357384241759677451842  |  0.239527360324390649107  0.397774662368094639047  0.010755895687360745555 !<  0.117472338035267653574  | -0.057695414616854888173  0.194781915712104164976  0.145384923188325069727 !<  0.833333333333333333333  | -0.861164195027635666673  5.784288136375372200229  3.288077619851035668904 !<  0.309036761204472681298  |  0.398320112318533301719  3.639372631810356060294  1.548228770398303223653 !<  0.539357840802981787532  | -0.091089566215517606959  0                        0 !<  0.1                      |  0                        0                        0 !<  1                        | -1.045948959408833060950  0.930327845415626983292  1.779509594317081024461 !< ------------------------------------------------------------------------------------------------------ !<                           |  0.04                     0                        0.189237478148923490158 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | !<  0.882527661964732346425  | !<  0.642615758240322548157  | !<  0.357384241759677451842  | -0.327769124164018874147 !<  0.117472338035267653574  | -0.078294271035167077755 -0.114503299361098912184 !<  0.833333333333333333333  | -2.386339050931363840134 -3.254793424836439186545 -2.163435416864229823539 !<  0.309036761204472681298  | -2.122217147040537160260 -1.583503985453261727133 -1.715616082859362649220 !<  0.539357840802981787532  |  0                        0                        0 !<  0.1                      |  0                        0                        0 !<  1                        |  0.1                     -0.282547569539044081612 -0.159327350119972549169 !< ------------------------------------------------------------------------------------------------------ !<                           |  0.277429188517743176508  0.277429188517743176508  0.189237478148923490158 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | !<  0.882527661964732346425  | !<  0.642615758240322548157  | !<  0.357384241759677451842  | !<  0.117472338035267653574  | !<  0.833333333333333333333  | !<  0.309036761204472681298  | -0.024403640575012745213 !<  0.539357840802981787532  |  0.091089566215517606959  0.777333643644968233538 !<  0.1                      |  0                        0                        0.157178665799771163367 !<  1                        | -0.145515894647001510860 -0.259111214548322744512 -0.342758159847189839942 -0.675 !< ------------------------------------------------------------------------------------------------------------- !<                           | -0.04                    -0.05                    -0.033333333333333333333 -0.025 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | !<  0.882527661964732346425  | !<  0.642615758240322548157  | !<  0.357384241759677451842  | !<  0.117472338035267653574  | !<  0.833333333333333333333  | !<  0.309036761204472681298  | !<  0.539357840802981787532  | !<  0.1                      | !<  1                        | !< --------------------------------------------------- !<                           | 0.033333333333333333333 !<``` !< !<#### Bibliography !< !< [1] *A family of embedded Runge-Kutta formulae*, Dormand, J. R., Prince, P. J. (1980), Journal of Computational and !< Applied Mathematics 6 (1): 19--26, doi:10.1016/0771-050X(80)90013-3. !< !< [2] *A New Embedded Pair of Runge-Kutta Formulas of orders 5 and 6*, M. Calvo, J.I. Montijano, L. Randez, Computers & Mathematics !< with Applications, Volume 20, Issue 1, 1990, Pages 15--24, ISSN 0898-1221, http://dx.doi.org/10.1016/0898-1221(90)90064-Q. !< !< [3] *A variable order Runge-Kutta method for initial value problems with rapidly varying right-hand sides*, J. R. Cash, !< A. H. Karp, ACM Transactions on Mathematical Software, vol. 16,  pp. 201--222, 1990, doi:10.1145/79505.79507. !< !< [4] *A tenth-order Runge-Kutta method with error estimate*, Feagin, T., Proceedings of the IAENG Conf. on Scientific !< Computing. 2007. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P , I_P use foodie_adt_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: emd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: emd_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. real ( R_P ) :: tolerance = 0._R_P !< Tolerance on the local truncation error. real ( R_P ) :: pp1_inv = 0._R_P !< 1/(p+1) where p is the accuracy order of the lower accurate scheme of the pair. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:,:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), private :: new_Dt !< Compute new estimation of the time step Dt. final :: finalize !< Finalize object. endtype emd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , stages , tolerance ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. real ( R_P ), optional , intent ( IN ) :: tolerance !< Tolerance on the local truncation error (default 0.01). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added if ( present ( tolerance )) then self % tolerance = tolerance else self % tolerance = 0.01_R_P endif self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages , 1 : 2 )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 2 ) ! HERK(2,2) self % pp1_inv = 1._R_P / ( 2._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.5_R_P ; self % beta ( 1 , 2 ) = 5._R_P self % beta ( 2 , 1 ) = 1._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 6 ) ! CKRK(6,5) self % pp1_inv = 1._R_P / ( 5._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 7._R_P / 37 8._R_P ; self % beta ( 1 , 2 ) = 282 5._R_P / 2764 8._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 25 0._R_P / 62 1._R_P ; self % beta ( 3 , 2 ) = 1857 5._R_P / 4838 4._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 59 4._R_P ; self % beta ( 4 , 2 ) = 1352 5._R_P / 5529 6._R_P self % beta ( 5 , 1 ) = 0._R_P ; self % beta ( 5 , 2 ) = 27 7._R_P / 1433 6._R_P self % beta ( 6 , 1 ) = 51 2._R_P / 177 1._R_P ; self % beta ( 6 , 2 ) = 1._R_P / 4._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 1 0._R_P ; self % alph ( 4 , 2 ) = - 9._R_P / 1 0._R_P ; self % alph ( 4 , 3 ) = 6._R_P / 5._R_P self % alph ( 5 , 1 ) =- 1 1._R_P / 5 4._R_P ; self % alph ( 5 , 2 ) = 5._R_P / 2._R_P ; self % alph ( 5 , 3 ) =- 7 0._R_P / 2 7._R_P self % alph ( 6 , 1 ) = 163 1._R_P / 5529 6._R_P ; self % alph ( 6 , 2 ) = 17 5._R_P / 51 2._R_P ; self % alph ( 6 , 3 ) = 57 5._R_P / 1382 4._R_P self % alph ( 5 , 4 ) = 3 5._R_P / 2 7._R_P self % alph ( 6 , 4 ) = 4427 5._R_P / 11059 2._R_P ; self % alph ( 6 , 5 ) = 25 3._R_P / 409 6._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 3._R_P / 5._R_P self % gamm ( 5 ) = 1._R_P self % gamm ( 6 ) = 7._R_P / 8._R_P case ( 7 ) ! DPRK(7,4) self % pp1_inv = 1._R_P / ( 4._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 5._R_P / 38 4._R_P ; self % beta ( 1 , 2 ) = 517 9._R_P / 5760 0._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 50 0._R_P / 111 3._R_P ; self % beta ( 3 , 2 ) = 757 1._R_P / 1669 5._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 19 2._R_P ; self % beta ( 4 , 2 ) = 39 3._R_P / 64 0._R_P self % beta ( 5 , 1 ) = - 218 7._R_P / 678 4._R_P ; self % beta ( 5 , 2 ) = - 9209 7._R_P / 33920 0._R_P self % beta ( 6 , 1 ) = 1 1._R_P / 8 4._R_P ; self % beta ( 6 , 2 ) = 18 7._R_P / 210 0._R_P self % beta ( 7 , 1 ) = 0._R_P ; self % beta ( 7 , 2 ) = 1._R_P / 4 0._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 4 4._R_P / 4 5._R_P ; self % alph ( 4 , 2 ) =- 5 6._R_P / 1 5._R_P ; self % alph ( 4 , 3 ) = 3 2._R_P / 9._R_P self % alph ( 5 , 1 ) = 1937 2._R_P / 656 1._R_P ; self % alph ( 5 , 2 ) =- 2536 0._R_P / 218 7._R_P ; self % alph ( 5 , 3 ) = 6444 8._R_P / 656 1._R_P self % alph ( 6 , 1 ) = 901 7._R_P / 316 8._R_P ; self % alph ( 6 , 2 ) =- 35 5._R_P / 3 3._R_P ; self % alph ( 6 , 3 ) = 4673 2._R_P / 524 7._R_P self % alph ( 7 , 1 ) = 3 5._R_P / 38 4._R_P ; self % alph ( 7 , 2 ) = 0._R_P ; self % alph ( 7 , 3 ) = 50 0._R_P / 111 3._R_P self % alph ( 5 , 4 ) =- 21 2._R_P / 72 9._R_P self % alph ( 6 , 4 ) = 4 9._R_P / 17 6._R_P ; self % alph ( 6 , 5 ) =- 510 3._R_P / 1865 6._R_P self % alph ( 7 , 4 ) = 12 5._R_P / 19 2._R_P ; self % alph ( 7 , 5 ) =- 218 7._R_P / 678 4._R_P ; self % alph ( 7 , 6 ) = 1 1._R_P / 8 4._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 4._R_P / 5._R_P self % gamm ( 5 ) = 8._R_P / 9._R_P self % gamm ( 6 ) = 1._R_P self % gamm ( 7 ) = 1._R_P case ( 9 ) ! CMRK(9,6) self % pp1_inv = 1._R_P / ( 6._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % beta ( 1 , 2 ) = 1523166 5._R_P / 51083033 4._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 5751301 1._R_P / 20186425 0._R_P ; self % beta ( 3 , 2 ) = 5945299 1._R_P / 11605044 8._R_P self % beta ( 4 , 1 ) = 1558730 6._R_P / 35450157 1._R_P ; self % beta ( 4 , 2 ) = - 2839851 7._R_P / 12243773 8._R_P self % beta ( 5 , 1 ) = 7178302 1._R_P / 23498286 5._R_P ; self % beta ( 5 , 2 ) = 5667382 4._R_P / 13701055 9._R_P self % beta ( 6 , 1 ) = 2967200 0._R_P / 18048016 7._R_P ; self % beta ( 6 , 2 ) = 6800384 9._R_P / 42667358 3._R_P self % beta ( 7 , 1 ) = 6556762 1._R_P / 12706095 2._R_P ; self % beta ( 7 , 2 ) = 709763 1._R_P / 3756402 1._R_P self % beta ( 8 , 1 ) = - 7907457 0._R_P / 21055759 7._R_P ; self % beta ( 8 , 2 ) = - 7122642 9._R_P / 58309374 2._R_P self % beta ( 9 , 1 ) = 0._R_P ; self % beta ( 9 , 2 ) = 1._R_P / 2 0._R_P self % alph ( 2 , 1 ) = 2._R_P / 1 5._R_P self % alph ( 3 , 1 ) = 1._R_P / 2 0._R_P ; self % alph ( 3 , 2 ) = 3._R_P / 2 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 8672701 5._R_P / 19685155 3._R_P ; self % alph ( 5 , 2 ) =- 6012907 3._R_P / 5262471 2._R_P self % alph ( 6 , 1 ) =- 8686084 9._R_P / 4562896 7._R_P ; self % alph ( 6 , 2 ) = 11102288 5._R_P / 2571648 7._R_P self % alph ( 7 , 1 ) = 7775959 1._R_P / 1609646 7._R_P ; self % alph ( 7 , 2 ) =- 4925280 9._R_P / 645255 5._R_P self % alph ( 8 , 1 ) = 23756426 3._R_P / 3928029 5._R_P ; self % alph ( 8 , 2 ) =- 10052323 9._R_P / 1067794 0._R_P self % alph ( 9 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 4 , 3 ) = 9._R_P / 4 0._R_P self % alph ( 5 , 3 ) = 95743643 4._R_P / 137835237 7._R_P ; self % alph ( 5 , 4 ) = 8388683 2._R_P / 14784244 1._R_P self % alph ( 6 , 3 ) = 10804668 2._R_P / 10116766 9._R_P ; self % alph ( 6 , 4 ) =- 14175674 6._R_P / 3600546 1._R_P self % alph ( 7 , 3 ) =- 38168011 1._R_P / 5157298 4._R_P ; self % alph ( 7 , 4 ) = 87926957 9._R_P / 6678883 1._R_P self % alph ( 8 , 3 ) =- 26557484 6._R_P / 2733024 7._R_P ; self % alph ( 8 , 4 ) = 31797841 1._R_P / 1898871 3._R_P self % alph ( 9 , 3 ) = 5751301 1._R_P / 20186425 0._R_P ; self % alph ( 9 , 4 ) = 1558730 6._R_P / 35450157 1._R_P self % alph ( 6 , 5 ) = 7313986 2._R_P / 6017063 3._R_P self % alph ( 7 , 5 ) =- 9045312 1._R_P / 3372216 2._R_P ; self % alph ( 7 , 6 ) = 11117955 2._R_P / 15715582 7._R_P self % alph ( 8 , 5 ) =- 12449438 5._R_P / 3545362 7._R_P ; self % alph ( 8 , 6 ) = 8682244 4._R_P / 10013863 5._R_P self % alph ( 9 , 5 ) = 7178302 1._R_P / 23498286 5._R_P ; self % alph ( 9 , 6 ) = 2967200 0._R_P / 18048016 7._R_P self % alph ( 8 , 7 ) =- 1287352 3._R_P / 72423262 5._R_P self % alph ( 9 , 7 ) = 6556762 1._R_P / 12706095 2._R_P ; self % alph ( 9 , 8 ) =- 7907457 0._R_P / 21055759 7._R_P self % gamm ( 2 ) = 2._R_P / 1 5._R_P self % gamm ( 3 ) = 1._R_P / 5._R_P self % gamm ( 4 ) = 3._R_P / 1 0._R_P self % gamm ( 5 ) = 1 4._R_P / 2 5._R_P self % gamm ( 6 ) = 1 9._R_P / 2 5._R_P self % gamm ( 7 ) = 3522660 7._R_P / 3568827 9._R_P self % gamm ( 8 ) = 1._R_P self % gamm ( 9 ) = 1._R_P case ( 17 ) ! FRK(17,10) self % pp1_inv = 1._R_P / ( 1 0._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 1 , 2 ) = 0.033333333333333333333_R_P self % beta ( 2 , 1 ) = 0.025_R_P ; self % beta ( 2 , 2 ) = 1._R_P / 3 6._R_P self % beta ( 3 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 3 , 2 ) = 0.033333333333333333333_R_P self % beta ( 4 , 1 ) = 0._R_P ; self % beta ( 4 , 2 ) = 0._R_P self % beta ( 5 , 1 ) = 0.05_R_P ; self % beta ( 5 , 2 ) = 0.05_R_P self % beta ( 6 , 1 ) = 0._R_P ; self % beta ( 6 , 2 ) = 0._R_P self % beta ( 7 , 1 ) = 0.04_R_P ; self % beta ( 7 , 2 ) = 0.04_R_P self % beta ( 8 , 1 ) = 0._R_P ; self % beta ( 8 , 2 ) = 0._R_P self % beta ( 9 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 9 , 2 ) = 0.189237478148923490158_R_P self % beta ( 10 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 10 , 2 ) = 0.277429188517743176508_R_P self % beta ( 11 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 11 , 2 ) = 0.277429188517743176508_R_P self % beta ( 12 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 12 , 2 ) = 0.189237478148923490158_R_P self % beta ( 13 , 1 ) =- 0.04_R_P ; self % beta ( 13 , 2 ) =- 0.04_R_P self % beta ( 14 , 1 ) =- 0.05_R_P ; self % beta ( 14 , 2 ) =- 0.05_R_P self % beta ( 15 , 1 ) =- 0.033333333333333333333_R_P ; self % beta ( 15 , 2 ) =- 0.033333333333333333333_R_P self % beta ( 16 , 1 ) =- 0.025_R_P ; self % beta ( 16 , 2 ) =- 1._R_P / 3 6._R_P self % beta ( 17 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 17 , 2 ) = 0.033333333333333333333_R_P self % alph ( 2 , 1 ) = 0.1_R_P self % alph ( 3 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 3 , 2 ) = 1.454534402178273228052_R_P self % alph ( 4 , 1 ) = 0.202259190301118170324_R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 0.184024714708643575149_R_P ; self % alph ( 5 , 2 ) = 0._R_P self % alph ( 6 , 1 ) = 0.087900734020668133731_R_P ; self % alph ( 6 , 2 ) = 0._R_P self % alph ( 7 , 1 ) = 0.085970050490246030218_R_P ; self % alph ( 7 , 2 ) = 0._R_P self % alph ( 8 , 1 ) = 0.120930449125333720660_R_P ; self % alph ( 8 , 2 ) = 0._R_P self % alph ( 9 , 1 ) = 0.110854379580391483508_R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 10 , 1 ) = 0.112054414752879004829_R_P ; self % alph ( 10 , 2 ) = 0._R_P self % alph ( 11 , 1 ) = 0.113976783964185986138_R_P ; self % alph ( 11 , 2 ) = 0._R_P self % alph ( 12 , 1 ) = 0.079831452828019604635_R_P ; self % alph ( 12 , 2 ) = 0._R_P self % alph ( 13 , 1 ) = 0.985115610164857280120_R_P ; self % alph ( 13 , 2 ) = 0._R_P self % alph ( 14 , 1 ) = 0.895080295771632891049_R_P ; self % alph ( 14 , 2 ) = 0._R_P self % alph ( 15 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 15 , 2 ) = 1.454534402178273228052_R_P self % alph ( 16 , 1 ) = 0.1_R_P ; self % alph ( 16 , 2 ) = 0._R_P self % alph ( 17 , 1 ) = 0.181781300700095283888_R_P ; self % alph ( 17 , 2 ) = 0.675_R_P self % alph ( 4 , 3 ) = 0.606777570903354510974_R_P self % alph ( 5 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 5 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 6 , 3 ) = 0._R_P ; self % alph ( 6 , 4 ) = 0.410459702520260645318_R_P self % alph ( 7 , 3 ) = 0._R_P ; self % alph ( 7 , 4 ) = 0.330885963040722183948_R_P self % alph ( 8 , 3 ) = 0._R_P ; self % alph ( 8 , 4 ) = 0._R_P self % alph ( 9 , 3 ) = 0._R_P ; self % alph ( 9 , 4 ) = 0._R_P self % alph ( 10 , 3 ) = 0._R_P ; self % alph ( 10 , 4 ) = 0._R_P self % alph ( 11 , 3 ) = 0._R_P ; self % alph ( 11 , 4 ) = 0._R_P self % alph ( 12 , 3 ) = 0._R_P ; self % alph ( 12 , 4 ) = 0._R_P self % alph ( 13 , 3 ) = 0._R_P ; self % alph ( 13 , 4 ) = 0.330885963040722183948_R_P self % alph ( 14 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 14 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 15 , 3 ) = 0._R_P ; self % alph ( 15 , 4 ) = 0._R_P self % alph ( 16 , 3 ) =- 0.157178665799771163367_R_P ; self % alph ( 16 , 4 ) = 0._R_P self % alph ( 17 , 3 ) = 0.342758159847189839942_R_P ; self % alph ( 17 , 4 ) = 0._R_P self % alph ( 6 , 5 ) = 0.482713753678866489204_R_P self % alph ( 7 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 7 , 6 ) =- 0.073185637507085073678_R_P self % alph ( 8 , 5 ) = 0.260124675758295622809_R_P ; self % alph ( 8 , 6 ) = 0.032540262154909133015_R_P self % alph ( 9 , 5 ) = 0._R_P ; self % alph ( 9 , 6 ) =- 0.060576148825500558762_R_P self % alph ( 10 , 5 ) = 0._R_P ; self % alph ( 10 , 6 ) =- 0.144942775902865915672_R_P self % alph ( 11 , 5 ) = 0._R_P ; self % alph ( 11 , 6 ) =- 0.076881336420335693858_R_P self % alph ( 12 , 5 ) = 0._R_P ; self % alph ( 12 , 6 ) =- 0.052032968680060307651_R_P self % alph ( 13 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 13 , 6 ) =- 1.378964865748435675821_R_P self % alph ( 14 , 5 ) = 0._R_P ; self % alph ( 14 , 6 ) =- 0.851236239662007619739_R_P self % alph ( 15 , 5 ) =- 0.777333643644968233538_R_P ; self % alph ( 15 , 6 ) = 0._R_P self % alph ( 16 , 5 ) = 0._R_P ; self % alph ( 16 , 6 ) = 0._R_P self % alph ( 17 , 5 ) = 0.259111214548322744512_R_P ; self % alph ( 17 , 6 ) =- 0.358278966717952089048_R_P self % alph ( 8 , 7 ) =- 0.059578021181736100156_R_P self % alph ( 9 , 7 ) = 0.321763705601778390100_R_P ; self % alph ( 9 , 8 ) = 0.510485725608063031577_R_P self % alph ( 10 , 7 ) =- 0.333269719096256706589_R_P ; self % alph ( 10 , 8 ) = 0.499269229556880061353_R_P self % alph ( 11 , 7 ) = 0.239527360324390649107_R_P ; self % alph ( 11 , 8 ) = 0.397774662368094639047_R_P self % alph ( 12 , 7 ) =- 0.057695414616854888173_R_P ; self % alph ( 12 , 8 ) = 0.194781915712104164976_R_P self % alph ( 13 , 7 ) =- 0.861164195027635666673_R_P ; self % alph ( 13 , 8 ) = 5.784288136375372200229_R_P self % alph ( 14 , 7 ) = 0.398320112318533301719_R_P ; self % alph ( 14 , 8 ) = 3.639372631810356060294_R_P self % alph ( 15 , 7 ) =- 0.091089566215517606959_R_P ; self % alph ( 15 , 8 ) = 0._R_P self % alph ( 16 , 7 ) = 0._R_P ; self % alph ( 16 , 8 ) = 0._R_P self % alph ( 17 , 7 ) =- 1.045948959408833060950_R_P ; self % alph ( 17 , 8 ) = 0.930327845415626983292_R_P self % alph ( 10 , 9 ) = 0.509504608929686104236_R_P self % alph ( 11 , 9 ) = 0.010755895687360745555_R_P ; self % alph ( 11 , 10 ) =- 0.327769124164018874147_R_P self % alph ( 12 , 9 ) = 0.145384923188325069727_R_P ; self % alph ( 12 , 10 ) =- 0.078294271035167077755_R_P self % alph ( 13 , 9 ) = 3.288077619851035668904_R_P ; self % alph ( 13 , 10 ) =- 2.386339050931363840134_R_P self % alph ( 14 , 9 ) = 1.548228770398303223653_R_P ; self % alph ( 14 , 10 ) =- 2.122217147040537160260_R_P self % alph ( 15 , 9 ) = 0._R_P ; self % alph ( 15 , 10 ) = 0._R_P self % alph ( 16 , 9 ) = 0._R_P ; self % alph ( 16 , 10 ) = 0._R_P self % alph ( 17 , 9 ) = 1.779509594317081024461_R_P ; self % alph ( 17 , 10 ) = 0.1_R_P self % alph ( 12 , 11 ) =- 0.114503299361098912184_R_P self % alph ( 13 , 11 ) =- 3.254793424836439186545_R_P ; self % alph ( 13 , 12 ) =- 2.163435416864229823539_R_P self % alph ( 14 , 11 ) =- 1.583503985453261727133_R_P ; self % alph ( 14 , 12 ) =- 1.715616082859362649220_R_P self % alph ( 15 , 11 ) = 0._R_P ; self % alph ( 15 , 12 ) = 0._R_P self % alph ( 16 , 11 ) = 0._R_P ; self % alph ( 16 , 12 ) = 0._R_P self % alph ( 17 , 11 ) =- 0.282547569539044081612_R_P ; self % alph ( 17 , 12 ) =- 0.159327350119972549169_R_P self % alph ( 14 , 13 ) =- 0.024403640575012745213_R_P self % alph ( 15 , 13 ) = 0.091089566215517606959_R_P ; self % alph ( 15 , 14 ) = 0.777333643644968233538_R_P self % alph ( 16 , 13 ) = 0._R_P ; self % alph ( 16 , 14 ) = 0._R_P self % alph ( 17 , 13 ) =- 0.145515894647001510860_R_P ; self % alph ( 17 , 14 ) =- 0.259111214548322744512_R_P self % alph ( 16 , 15 ) = 0.157178665799771163367_R_P self % alph ( 17 , 15 ) =- 0.342758159847189839942_R_P ; self % alph ( 17 , 16 ) =- 0.675_R_P self % gamm ( 2 ) = 0.1_R_P self % gamm ( 3 ) = 0.539357840802981787532_R_P self % gamm ( 4 ) = 0.809036761204472681298_R_P self % gamm ( 5 ) = 0.309036761204472681298_R_P self % gamm ( 6 ) = 0.981074190219795268254_R_P self % gamm ( 7 ) = 0.833333333333333333333_R_P self % gamm ( 8 ) = 0.354017365856802376329_R_P self % gamm ( 9 ) = 0.882527661964732346425_R_P self % gamm ( 10 ) = 0.642615758240322548157_R_P self % gamm ( 11 ) = 0.357384241759677451842_R_P self % gamm ( 12 ) = 0.117472338035267653574_R_P self % gamm ( 13 ) = 0.833333333333333333333_R_P self % gamm ( 14 ) = 0.309036761204472681298_R_P self % gamm ( 15 ) = 0.539357840802981787532_R_P self % gamm ( 16 ) = 0.1_R_P self % gamm ( 17 ) = 1._R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % tolerance = 0._R_P self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit embedded Runge-Kutta scheme. !< !< The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( INOUT ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: U1 !< First U evaluation. class ( integrand ), allocatable :: U2 !< Second U evaluation. real ( R_P ) :: error !< Local truncation error estimation. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( U1 , source = U ) allocate ( U2 , source = U ) error = 1 e6 do while ( error > self % tolerance ) ! compute stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! compute new time step U1 = U U2 = U do s = 1 , self % stages U1 = U1 + stage ( s ) * ( Dt * self % beta ( s , 1 )) U2 = U2 + stage ( s ) * ( Dt * self % beta ( s , 2 )) enddo error = U2 . lterror . U1 call self % new_Dt ( error = error , Dt = Dt ) enddo U = U1 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate ! private methods elemental subroutine new_Dt ( self , error , Dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute new estimation of the time step Dt. !< !< The formula employed is: !< !<  Dt_{new} = 0.9 Dt_{old} \\left( \\frac{tolerance}{error} \\right)&#94;{\\frac{1}{p+1}}  !< !< @note 0.9 is a safety factor. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( IN ) :: self !< Integrator. real ( R_P ), intent ( IN ) :: error !< Local truncation error estimation. real ( R_P ), intent ( INOUT ) :: Dt !< Time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( error > self % tolerance ) Dt = 0.9_R_P * Dt * ( self % tolerance / error ) ** self % pp1_inv return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine new_Dt elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_emd_runge_kutta","tags":"","loc":"sourcefile/foodie_integrator_embedded_runge_kutta.f90.html","title":"foodie_integrator_embedded_runge_kutta.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. Source Code !< FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. module foodie_integrator_euler_explicit !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Forward Explicit Euler scheme implemented is: !< !<  U&#94;{n+1} = U&#94;n +\\Delta t R(t, U&#94;n)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P use foodie_adt_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_explicit_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: euler_explicit_integrator !< FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< @note The integrator can be used directly without any initialization. contains procedure , nopass , public :: integrate !< Integrate integrand field. endtype euler_explicit_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine integrate ( U , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit Euler scheme, 1st order. !--------------------------------------------------------------------------------------------------------------------------------- class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), optional , intent ( IN ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- U = U + U % t ( t = t ) * Dt return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate endmodule foodie_integrator_euler_explicit","tags":"","loc":"sourcefile/foodie_integrator_euler_explicit.f90.html","title":"foodie_integrator_euler_explicit.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Source Code !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. module foodie_integrator_leapfrog !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the leapfrog class scheme implemented (see [3]) is: !< !<  U&#94;{n+2} = U&#94;{n} + 2\\Delta t \\cdot R(t&#94;{n+1}, U&#94;{n+1})  !< !< Optionally, the Robert-Asselin-Williams (RAW) filter (see [3]) is applied to the computed integration steps: !<  \\Delta = \\frac{\\nu}{2}(U&#94;{n} - 2 U&#94;{n+1} + U&#94;{n+2})  !<  U&#94;{n+1} = U&#94;{n+1} + \\Delta * \\alpha  !<  U&#94;{n+2} = U&#94;{n+2} + \\Delta * (\\alpha-1)  !< Note that for \\alpha=1 the filter reverts back to the standard Robert-Asselin scheme. !< The filter coefficients should be taken as \\nu \\in (0,1] and \\alpha \\in (0.5,1]. The default values are !< !<  + \\nu=0.01 !<  + \\alpha=0.53 !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit. The filter coefficients \\nu,\\,\\alpha  define the actual scheme. !< !<#### Bibliography !< !< [1] *The integration of a low order spectral form of the primitive meteorological equations*, Robert, A. J., J. Meteor. Soc. !< Japan,vol. 44, pages 237--245, 1966. !< !< [2] *Frequency filter for time integrations*, Asselin, R., Monthly Weather Review, vol. 100, pages 487--490, 1972. !< !< [3] *The RAW filter: An improvement to the Robert–Asselin filter in semi-implicit integrations*, Williams, P.D., Monthly !< Weather Review, vol. 139(6), pages 1996--2007, June 2011. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P , I_P use foodie_adt_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: leapfrog_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: leapfrog_integrator !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. !< !< @note The integrator could be used without initialialization (initialize the time filter coefficients) if the defulat values !< are suitable for the problem. private real ( R_P ) :: nu = 0.01_R_P !< Robert-Asselin filter coefficient. real ( R_P ) :: alpha = 0.53_R_P !< Robert-Asselin-Williams filter coefficient. contains procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. endtype leapfrog_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , nu , alpha ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual leapfrog integrator: initialize the filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( INOUT ) :: self !< LF integrator. real ( R_P ), optional , intent ( IN ) :: nu !< Williams-Robert-Asselin filter coefficient. real ( R_P ), optional , intent ( IN ) :: alpha !< Robert-Asselin filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % nu = 0.01_R_P self % alpha = 0.53_R_P if ( present ( nu )) self % nu = nu if ( present ( alpha )) self % alpha = alpha return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine integrate ( self , U , previous , Dt , t , filter ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with leapfrog class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( IN ) :: self !< LF integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 : 2 ) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. class ( integrand ), optional , intent ( INOUT ) :: filter !< Filter field displacement. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- U = previous ( 1 ) + previous ( 2 )% t ( t = t ) * ( Dt * 2._R_P ) if ( present ( filter )) then filter = ( previous ( 1 ) - previous ( 2 ) * 2._R_P + U ) * self % nu * 0.5_R_P previous ( 2 ) = previous ( 2 ) + filter * self % alpha U = U + filter * ( self % alpha - 1._R_P ) endif previous ( 1 ) = previous ( 2 ) previous ( 2 ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate endmodule foodie_integrator_leapfrog","tags":"","loc":"sourcefile/foodie_integrator_leapfrog.f90.html","title":"foodie_integrator_leapfrog.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. Source Code !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. module foodie_integrator_low_storage_runge_kutta !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< The integrators provided have the low storage property allowing for an efficient use of the memory. !< Following Williamson approach [1], the LSRK(5,4)2N (solution 3) scheme of Carpenter et al. [2] is implemented. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<\\begin{matrix} !< K_1 = U&#94;n \\\\ !< K_2 = 0 \\\\ !<\\left.\\begin{matrix} !< K_2 = A_s K_2 + \\Delta t R(t&#94;n + C_s \\Delta t, K_1) \\\\ !< K_1 = K_1 + B_s K_2 !<\\end{matrix}\\right\\} s=1,2,...N_s\\\\ !<U&#94;{n+1} = K_1 !<\\end{matrix} !< !< where *Ns* is the number of stages used and K_1, K_2 are the 2 registers used for stages computation. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus A_1=C_1=0. The coefficients A_s, B_s, C_s are given in the Williamson low storage table !< form. !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !<#### 1 stage, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. It is not a real low storage scheme, this being !< meaningless for a first order scheme. However it is added for safety reason. !< !< | ` Stage ` | ` A ` | ` B ` | ` C ` | !< |-----------|-------|-------|-------| !< | ` 1 `     | ` 0 ` | ` 1 ` | ` 0 ` | !< !<#### 5 stages, SSP, 4th order !< This scheme is a low storage RK(5, 4), based on the *solution 3* proposed in [2]. !< !< | ` Stage ` | ` A `                            | ` B `                            | ` C `                           | !< |-----------|----------------------------------|----------------------------------|---------------------------------| !< | ` 1 `     | `  0                           ` | ` 1432997174477/9575080441755  ` | ` 0                           ` | !< | ` 2 `     | ` -567301805773 /1357537059087 ` | ` 5161836677717/13612068292357 ` | ` 1432997174477/9575080441755 ` | !< | ` 3 `     | ` -2404267990393/2016746695238 ` | ` 1720146321549/2090206949498  ` | ` 2526269341429/6820363962896 ` | !< | ` 4 `     | ` -3550918686646/2091501179385 ` | ` 3134564353537/4481467310338  ` | ` 2006345519317/3224310063776 ` | !< | ` 5 `     | ` -1275806237668/842570457699  ` | ` 2277821191437/14882151754819 ` | ` 2802321613138/2924317926251 ` | !< !< !<#### 6 stages, 4th order !< This scheme is a low storage RK(6, 4), by [3]. !< !< | ` Stage ` | ` A `               | ` B `              | ` C `              | !< |-----------|---------------------|--------------------|--------------------| !< | ` 1 `     | `  0              ` | ` 0.122000000000 ` | ` 0              ` | !< | ` 2 `     | ` -0.691750960670 ` | ` 0.477263056358 ` | ` 0.122000000000 ` | !< | ` 3 `     | ` -1.727127405211 ` | ` 0.381941220320 ` | ` 0.269115878630 ` | !< | ` 4 `     | ` -0.694890150986 ` | ` 0.447757195744 ` | ` 0.447717183551 ` | !< | ` 5 `     | ` -1.039942756197 ` | ` 0.498614246822 ` | ` 0.749979795490 ` | !< | ` 6 `     | ` -1.531977447611 ` | ` 0.186648570846 ` | ` 0.898555413085 ` | !< !<#### 7 stages, 4th order !< This scheme is a low storage RK(7, 4), by [3]. !< !< | ` Stage ` | ` A `               | ` B `              | ` C `              | !< |-----------|---------------------|--------------------|--------------------| !< | ` 1 `     | `  0              ` | ` 0.117322146869 ` | ` 0              ` | !< | ` 2 `     | ` -0.647900745934 ` | ` 0.503270262127 ` | ` 0.117322146869 ` | !< | ` 3 `     | ` -2.704760863204 ` | ` 0.233663281658 ` | ` 0.294523230758 ` | !< | ` 4 `     | ` -0.460080550118 ` | ` 0.283419634625 ` | ` 0.305658622131 ` | !< | ` 5 `     | ` -0.500581787785 ` | ` 0.540367414023 ` | ` 0.582864148403 ` | !< | ` 6 `     | ` -1.906532255913 ` | ` 0.371499414620 ` | ` 0.858664273599 ` | !< | ` 7 `     | ` -1.450000000000 ` | ` 0.136670099385 ` | ` 0.868664273599 ` | !< !<#### 12 stages, 4th order !< This scheme is a low storage RK(12, 4), by [4]. !< !< | ` Stage ` | ` A `                   | ` B `                  | ` C `                  | !< |-----------|-------------------------|------------------------|------------------------| !< | ` 1  `    | `  0                  ` | ` 0.0650008435125904 ` | ` 0                  ` | !< | ` 2  `    | ` -0.0923311242368072 ` | ` 0.0161459902249842 ` | ` 0.0650008435125904 ` | !< | ` 3  `    | ` -0.9441056581158819 ` | ` 0.5758627178358159 ` | ` 0.0796560563081853 ` | !< | ` 4  `    | ` -4.3271273247576394 ` | ` 0.1649758848361671 ` | ` 0.1620416710085376 ` | !< | ` 5  `    | ` -2.1557771329026072 ` | ` 0.3934619494248182 ` | ` 0.2248877362907778 ` | !< | ` 6  `    | ` -0.9770727190189062 ` | ` 0.0443509641602719 ` | ` 0.2952293985641261 ` | !< | ` 7  `    | ` -0.7581835342571139 ` | ` 0.2074504268408778 ` | ` 0.3318332506149405 ` | !< | ` 8  `    | ` -1.7977525470825499 ` | ` 0.6914247433015102 ` | ` 0.4094724050198658 ` | !< | ` 9  `    | ` -2.6915667972700770 ` | ` 0.3766646883450449 ` | ` 0.6356954475753369 ` | !< | ` 10 `    | ` -4.6466798960268143 ` | ` 0.0757190350155483 ` | ` 0.6806551557645497 ` | !< | ` 11 `    | ` -0.1539613783825189 ` | ` 0.2027862031054088 ` | ` 0.7143773712418350 ` | !< | ` 12 `    | ` -0.5943293901830616 ` | ` 0.2167029365631842 ` | ` 0.9032588871651854 ` | !< !<#### 13 stages, 4th order !< This scheme is a low storage RK(13, 4), by [4]. !< !< | ` Stage ` | ` A `                   | ` B `                  | ` C `                  | !< |-----------|-------------------------|------------------------|------------------------| !< | ` 1  `    | `  0                  ` | ` 0.0271990297818803 ` | ` 0                  ` | !< | ` 2  `    | ` -0.6160178650170565 ` | ` 0.1772488819905108 ` | ` 0.0271990297818803 ` | !< | ` 3  `    | ` -0.4449487060774118 ` | ` 0.0378528418949694 ` | ` 0.0952594339119365 ` | !< | ` 4  `    | ` -1.0952033345276178 ` | ` 0.6086431830142991 ` | ` 0.1266450286591127 ` | !< | ` 5  `    | ` -1.2256030785959187 ` | ` 0.2154313974316100 ` | ` 0.1825883045699772 ` | !< | ` 6  `    | ` -0.2740182222332805 ` | ` 0.2066152563885843 ` | ` 0.3737511439063931 ` | !< | ` 7  `    | ` -0.0411952089052647 ` | ` 0.0415864076069797 ` | ` 0.5301279418422206 ` | !< | ` 8  `    | ` -0.1797084899153560 ` | ` 0.0219891884310925 ` | ` 0.5704177433952291 ` | !< | ` 9  `    | ` -1.1771530652064288 ` | ` 0.9893081222650993 ` | ` 0.5885784947099155 ` | !< | ` 10 `    | ` -0.4078831463120878 ` | ` 0.0063199019859826 ` | ` 0.6160769826246714 ` | !< | ` 11 `    | ` -0.8295636426191777 ` | ` 0.3749640721105318 ` | ` 0.6223252334314046 ` | !< | ` 12 `    | ` -4.7895970584252288 ` | ` 1.6080235151003195 ` | ` 0.6897593128753419 ` | !< | ` 13 `    | ` -0.6606671432964504 ` | ` 0.0961209123818189 ` | ` 0.9126827615920843 ` | !< !<#### 14 stages, 4th order !< This scheme is a low storage RK(14, 4), by [4]. !< !< | ` Stage ` | ` A `                   | ` B `                  | ` C `                  | !< |-----------|-------------------------|------------------------|------------------------| !< | ` 1  `    | `  0                  ` | ` 0.0367762454319673 ` | ` 0                  ` | !< | ` 2  `    | ` -0.7188012108672410 ` | ` 0.3136296607553959 ` | ` 0.0367762454319673 ` | !< | ` 3  `    | ` -0.7785331173421570 ` | ` 0.1531848691869027 ` | ` 0.1249685262725025 ` | !< | ` 4  `    | ` -0.0053282796654044 ` | ` 0.0030097086818182 ` | ` 0.2446177702277698 ` | !< | ` 5  `    | ` -0.8552979934029281 ` | ` 0.3326293790646110 ` | ` 0.2476149531070420 ` | !< | ` 6  `    | ` -3.9564138245774565 ` | ` 0.2440251405350864 ` | ` 0.2969311120382472 ` | !< | ` 7  `    | ` -1.5780575380587385 ` | ` 0.3718879239592277 ` | ` 0.3978149645802642 ` | !< | ` 8  `    | ` -2.0837094552574054 ` | ` 0.6204126221582444 ` | ` 0.5270854589440328 ` | !< | ` 9  `    | ` -0.7483334182761610 ` | ` 0.1524043173028741 ` | ` 0.6981269994175695 ` | !< | ` 10 `    | ` -0.7032861106563359 ` | ` 0.0760894927419266 ` | ` 0.8190890835352128 ` | !< | ` 11 `    | `  0.0013917096117681 ` | ` 0.0077604214040978 ` | ` 0.8527059887098624 ` | !< | ` 12 `    | ` -0.0932075369637460 ` | ` 0.0024647284755382 ` | ` 0.8604711817462826 ` | !< | ` 13 `    | ` -0.9514200470875948 ` | ` 0.0780348340049386 ` | ` 0.8627060376969976 ` | !< | ` 14 `    | ` -7.1151571693922548 ` | ` 5.5059777270269628 ` | ` 0.8734213127600976 ` | !< !<#### Bibliography !< !< [1] *Low-Storage Runge-Kutta Schemes*, J. H. Williamson, Journal of Computational Physics, vol. 35, 1980, pp. 48--56. !< !< [2] *Fourth-Order 2N-Storage Runge-Kutta Schemes*, Mark H. Carpenter, Christopher A. Kennedy, NASA Technical Memorandum 109112, !< June 1994. !< !< [3] *High-accuracy large-step explicit Runge–Kutta (HALE-RK) schemes for computational aeroacoustics*, Vasanth Allampalli and !< Ray Hixon and M. Nallasamy and Scott D. Sawyer, Journal of Computational Physics, vol. 228, 2009, pp. 3837--3850. !< !< [4] *Efficient low-storage Runge–Kutta schemes with optimized stability regions*, Jens Niegemann and Richard Diehl and Kurt !< Busch, Journal of Computational Physics, vol. 231, 2012, pp. 364--372. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: ISO_FORTRAN_ENV , only : stderr => ERROR_UNIT use foodie_kinds , only : R_P , I_P , I8P use foodie_adt_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: ls_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: ls_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: A (:) !< Low storage *A* coefficients. real ( R_P ), allocatable :: B (:) !< Low storage *B* coefficients. real ( R_P ), allocatable :: C (:) !< Low storage *C* coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype ls_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' low storage table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % A )) deallocate ( self % A ) ; allocate ( self % A ( 1 : stages )) ; self % A = 0._R_P if ( allocated ( self % B )) deallocate ( self % B ) ; allocate ( self % B ( 1 : stages )) ; self % B = 0._R_P if ( allocated ( self % C )) deallocate ( self % C ) ; allocate ( self % C ( 1 : stages )) ; self % C = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % B ( 1 ) = 1._R_P case ( 5 ) ! LSRK(5,4) self % A ( 1 ) = 0._R_P self % A ( 2 ) = - real ( 567301805773_I8P , kind = R_P ) / real ( 1357537059087_I8P , kind = R_P ) self % A ( 3 ) = - real ( 2404267990393_I8P , kind = R_P ) / real ( 2016746695238_I8P , kind = R_P ) self % A ( 4 ) = - real ( 3550918686646_I8P , kind = R_P ) / real ( 2091501179385_I8P , kind = R_P ) self % A ( 5 ) = - real ( 1275806237668_I8P , kind = R_P ) / real ( 842570457699_I8P , kind = R_P ) self % B ( 1 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % B ( 2 ) = real ( 5161836677717_I8P , kind = R_P ) / real ( 13612068292357_I8P , kind = R_P ) self % B ( 3 ) = real ( 1720146321549_I8P , kind = R_P ) / real ( 2090206949498_I8P , kind = R_P ) self % B ( 4 ) = real ( 3134564353537_I8P , kind = R_P ) / real ( 4481467310338_I8P , kind = R_P ) self % B ( 5 ) = real ( 2277821191437_I8P , kind = R_P ) / real ( 14882151754819_I8P , kind = R_P ) self % C ( 1 ) = 0._R_P self % C ( 2 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % C ( 3 ) = real ( 2526269341429_I8P , kind = R_P ) / real ( 6820363962896_I8P , kind = R_P ) self % C ( 4 ) = real ( 2006345519317_I8P , kind = R_P ) / real ( 3224310063776_I8P , kind = R_P ) self % C ( 5 ) = real ( 2802321613138_I8P , kind = R_P ) / real ( 2924317926251_I8P , kind = R_P ) case ( 6 ) ! LSRK(6,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.122000000000_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.691750960670_R_P ; self % B ( 2 ) = 0.477263056358_R_P ; self % C ( 2 ) = 0.122000000000_R_P self % A ( 3 ) = - 1.727127405211_R_P ; self % B ( 3 ) = 0.381941220320_R_P ; self % C ( 3 ) = 0.269115878630_R_P self % A ( 4 ) = - 0.694890150986_R_P ; self % B ( 4 ) = 0.447757195744_R_P ; self % C ( 4 ) = 0.447717183551_R_P self % A ( 5 ) = - 1.039942756197_R_P ; self % B ( 5 ) = 0.498614246822_R_P ; self % C ( 5 ) = 0.749979795490_R_P self % A ( 6 ) = - 1.531977447611_R_P ; self % B ( 6 ) = 0.186648570846_R_P ; self % C ( 6 ) = 0.898555413085_R_P case ( 7 ) ! LSRK(7,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.117322146869_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.647900745934_R_P ; self % B ( 2 ) = 0.503270262127_R_P ; self % C ( 2 ) = 0.117322146869_R_P self % A ( 3 ) = - 2.704760863204_R_P ; self % B ( 3 ) = 0.233663281658_R_P ; self % C ( 3 ) = 0.294523230758_R_P self % A ( 4 ) = - 0.460080550118_R_P ; self % B ( 4 ) = 0.283419634625_R_P ; self % C ( 4 ) = 0.305658622131_R_P self % A ( 5 ) = - 0.500581787785_R_P ; self % B ( 5 ) = 0.540367414023_R_P ; self % C ( 5 ) = 0.582864148403_R_P self % A ( 6 ) = - 1.906532255913_R_P ; self % B ( 6 ) = 0.371499414620_R_P ; self % C ( 6 ) = 0.858664273599_R_P self % A ( 7 ) = - 1.450000000000_R_P ; self % B ( 7 ) = 0.136670099385_R_P ; self % C ( 7 ) = 0.868664273599_R_P case ( 12 ) ! LSRK(12,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0650008435125904_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.0923311242368072_R_P ; self % B ( 2 ) = 0.0161459902249842_R_P ; self % C ( 2 ) = 0.0650008435125904_R_P self % A ( 3 ) = - 0.9441056581158819_R_P ; self % B ( 3 ) = 0.5758627178358159_R_P ; self % C ( 3 ) = 0.0796560563081853_R_P self % A ( 4 ) = - 4.3271273247576394_R_P ; self % B ( 4 ) = 0.1649758848361671_R_P ; self % C ( 4 ) = 0.1620416710085376_R_P self % A ( 5 ) = - 2.1557771329026072_R_P ; self % B ( 5 ) = 0.3934619494248182_R_P ; self % C ( 5 ) = 0.2248877362907778_R_P self % A ( 6 ) = - 0.9770727190189062_R_P ; self % B ( 6 ) = 0.0443509641602719_R_P ; self % C ( 6 ) = 0.2952293985641261_R_P self % A ( 7 ) = - 0.7581835342571139_R_P ; self % B ( 7 ) = 0.2074504268408778_R_P ; self % C ( 7 ) = 0.3318332506149405_R_P self % A ( 8 ) = - 1.7977525470825499_R_P ; self % B ( 8 ) = 0.6914247433015102_R_P ; self % C ( 8 ) = 0.4094724050198658_R_P self % A ( 9 ) = - 2.6915667972700770_R_P ; self % B ( 9 ) = 0.3766646883450449_R_P ; self % C ( 9 ) = 0.6356954475753369_R_P self % A ( 10 ) = - 4.6466798960268143_R_P ; self % B ( 10 ) = 0.0757190350155483_R_P ; self % C ( 10 ) = 0.6806551557645497_R_P self % A ( 11 ) = - 0.1539613783825189_R_P ; self % B ( 11 ) = 0.2027862031054088_R_P ; self % C ( 11 ) = 0.7143773712418350_R_P self % A ( 12 ) = - 0.5943293901830616_R_P ; self % B ( 12 ) = 0.2167029365631842_R_P ; self % C ( 12 ) = 0.9032588871651854_R_P case ( 13 ) ! LSRK(13,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0271990297818803_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.6160178650170565_R_P ; self % B ( 2 ) = 0.1772488819905108_R_P ; self % C ( 2 ) = 0.0271990297818803_R_P self % A ( 3 ) = - 0.4449487060774118_R_P ; self % B ( 3 ) = 0.0378528418949694_R_P ; self % C ( 3 ) = 0.0952594339119365_R_P self % A ( 4 ) = - 1.0952033345276178_R_P ; self % B ( 4 ) = 0.6086431830142991_R_P ; self % C ( 4 ) = 0.1266450286591127_R_P self % A ( 5 ) = - 1.2256030785959187_R_P ; self % B ( 5 ) = 0.2154313974316100_R_P ; self % C ( 5 ) = 0.1825883045699772_R_P self % A ( 6 ) = - 0.2740182222332805_R_P ; self % B ( 6 ) = 0.2066152563885843_R_P ; self % C ( 6 ) = 0.3737511439063931_R_P self % A ( 7 ) = - 0.0411952089052647_R_P ; self % B ( 7 ) = 0.0415864076069797_R_P ; self % C ( 7 ) = 0.5301279418422206_R_P self % A ( 8 ) = - 0.1797084899153560_R_P ; self % B ( 8 ) = 0.0219891884310925_R_P ; self % C ( 8 ) = 0.5704177433952291_R_P self % A ( 9 ) = - 1.1771530652064288_R_P ; self % B ( 9 ) = 0.9893081222650993_R_P ; self % C ( 9 ) = 0.5885784947099155_R_P self % A ( 10 ) = - 0.4078831463120878_R_P ; self % B ( 10 ) = 0.0063199019859826_R_P ; self % C ( 10 ) = 0.6160769826246714_R_P self % A ( 11 ) = - 0.8295636426191777_R_P ; self % B ( 11 ) = 0.3749640721105318_R_P ; self % C ( 11 ) = 0.6223252334314046_R_P self % A ( 12 ) = - 4.7895970584252288_R_P ; self % B ( 12 ) = 1.6080235151003195_R_P ; self % C ( 12 ) = 0.6897593128753419_R_P self % A ( 13 ) = - 0.6606671432964504_R_P ; self % B ( 13 ) = 0.0961209123818189_R_P ; self % C ( 13 ) = 0.9126827615920843_R_P case ( 14 ) ! LSRK(14,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0367762454319673_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.7188012108672410_R_P ; self % B ( 2 ) = 0.3136296607553959_R_P ; self % C ( 2 ) = 0.0367762454319673_R_P self % A ( 3 ) = - 0.7785331173421570_R_P ; self % B ( 3 ) = 0.1531848691869027_R_P ; self % C ( 3 ) = 0.1249685262725025_R_P self % A ( 4 ) = - 0.0053282796654044_R_P ; self % B ( 4 ) = 0.0030097086818182_R_P ; self % C ( 4 ) = 0.2446177702277698_R_P self % A ( 5 ) = - 0.8552979934029281_R_P ; self % B ( 5 ) = 0.3326293790646110_R_P ; self % C ( 5 ) = 0.2476149531070420_R_P self % A ( 6 ) = - 3.9564138245774565_R_P ; self % B ( 6 ) = 0.2440251405350864_R_P ; self % C ( 6 ) = 0.2969311120382472_R_P self % A ( 7 ) = - 1.5780575380587385_R_P ; self % B ( 7 ) = 0.3718879239592277_R_P ; self % C ( 7 ) = 0.3978149645802642_R_P self % A ( 8 ) = - 2.0837094552574054_R_P ; self % B ( 8 ) = 0.6204126221582444_R_P ; self % C ( 8 ) = 0.5270854589440328_R_P self % A ( 9 ) = - 0.7483334182761610_R_P ; self % B ( 9 ) = 0.1524043173028741_R_P ; self % C ( 9 ) = 0.6981269994175695_R_P self % A ( 10 ) = - 0.7032861106563359_R_P ; self % B ( 10 ) = 0.0760894927419266_R_P ; self % C ( 10 ) = 0.8190890835352128_R_P self % A ( 11 ) = 0.0013917096117681_R_P ; self % B ( 11 ) = 0.0077604214040978_R_P ; self % C ( 11 ) = 0.8527059887098624_R_P self % A ( 12 ) = - 0.0932075369637460_R_P ; self % B ( 12 ) = 0.0024647284755382_R_P ; self % C ( 12 ) = 0.8604711817462826_R_P self % A ( 13 ) = - 0.9514200470875948_R_P ; self % B ( 13 ) = 0.0780348340049386_R_P ; self % C ( 13 ) = 0.8627060376969976_R_P self % A ( 14 ) = - 7.1151571693922548_R_P ; self % B ( 14 ) = 5.5059777270269628_R_P ; self % C ( 14 ) = 0.8734213127600976_R_P case default write ( stderr , '(A,I3,A)' ) ' Error: ls_runge_kutta_integrator%init: ' , stages , ' is an invalid number-of-stages!' write ( stderr , '(A)' ) ' Valid number of stages are:' write ( stderr , '(A)' ) '   1  => LSRK(1, 1)' write ( stderr , '(A)' ) '   5  => LSRK(5, 4)' write ( stderr , '(A)' ) '   6  => LSRK(6, 4)' write ( stderr , '(A)' ) '   7  => LSRK(7, 4)' write ( stderr , '(A)' ) '   12 => LSRK(12, 4)' write ( stderr , '(A)' ) '   13 => LSRK(13, 4)' write ( stderr , '(A)' ) '   14 => LSRK(14, 4)' endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % A )) deallocate ( self % A ) if ( allocated ( self % B )) deallocate ( self % B ) if ( allocated ( self % C )) deallocate ( self % C ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit low storage Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 : 2 ) !< Runge-Kutta registers [1:2]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages stage ( 1 ) = U stage ( 2 ) = U * 0._R_P do s = 1 , self % stages stage ( 2 ) = stage ( 2 ) * self % A ( s ) + stage ( 1 )% t ( t = t + self % C ( s ) * Dt ) * Dt stage ( 1 ) = stage ( 1 ) + stage ( 2 ) * self % B ( s ) enddo U = stage ( 1 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_low_storage_runge_kutta","tags":"","loc":"sourcefile/foodie_integrator_low_storage_runge_kutta.f90.html","title":"foodie_integrator_low_storage_runge_kutta.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. Source Code !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. module foodie_integrator_tvd_runge_kutta !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< The integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP) !< one. The schemes are explicit and defined through the Butcher's table syntax, see[1] . !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<  U&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta&#94;s K&#94;s  !< !< where Ns is the number of stages used and K&#94;s is the s&#94;{th} stage computed as: !< !<  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are !< given in the Butcher table form: !< !<``` !<  gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns} !<  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns} !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns} !< ------------|------------------------------------------------------------- !<             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} !<``` !< !< Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: !< !<``` !<  gamma&#94;1    | 0                 0                 ...        0 !<  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0 !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0 !< ------------|------------------------------------------------------------- !<             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} !<``` !< !< Moreover the following relation always holds: !<  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !<##### 1 stage, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. !<``` !<  0 | 0 !< ---|--- !<    | 1 !<``` !< !<##### 2 stages, SSP, 2nd order !< This scheme is an optmial SSP(2, 2) without low-storage algorithm, see [2]. !<``` !<  0 | 0     0 !<  1 | 1     0 !< ---|----------- !<    | 1/2   1/2 !<``` !< !<##### 3 stages, SSP, 3rd order !< This scheme is an optmial SSP(3, 3) without low-storage algorithm, see [2]. !<``` !<  0   | 0     0     0 !<  1   | 1     0     0 !<  1/2 | 1/4   1/4   0 !< -----|----------------- !<      | 1/6   1/6   1/3 !<``` !< !<##### 5 stages, SSP, 4th order !< This scheme is an optmial SSP(5, 4) without low-storage algorithm, see [2]. !<``` !<  0                | 0                  0                  0                  0                  0 !<  0.39175222700392 | 0.39175222700392   0                  0                  0                  0 !<  0.58607968896780 | 0.21766909633821   0.36841059262959   0                  0                  0 !<  0.47454236302687 | 0.08269208670950   0.13995850206999   0.25189177424738   0                  0 !<  0.93501063100924 | 0.06796628370320   0.11503469844438   0.20703489864929   0.54497475021237   0 !< ------------------|--------------------------------------------------------------------------------------------- !<                   | 0.14681187618661   0.24848290924556   0.10425883036650   0.27443890091960   0.22600748319395 !<``` !< !<#### Bibliography !< !< [1] *Coefficients for the study of Runge-Kutta integration processes*, Butcher, J.C., J. Austral. Math. Soc., Vol. 3, !< pages: 185--201, 1963. !< !< [2] *High Order Strong Stability Preserving Time Discretizations*, Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of !< Scientific Computing, vol. 38, N. 3, 2009, pp. 251-289. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P , I_P use foodie_adt_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: tvd_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! computing new time step do s = 1 , self % stages U = U + stage ( s ) * ( Dt * self % beta ( s )) enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_tvd_runge_kutta","tags":"","loc":"sourcefile/foodie_integrator_tvd_runge_kutta.f90.html","title":"foodie_integrator_tvd_runge_kutta.f90 – FOODIE"},{"text":"FOODIE kinds: definition of reals and integer kind parameters of FOODIE library. Source Code !< FOODIE kinds: definition of reals and integer kind parameters of FOODIE library. module foodie_kinds !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE kinds: definition of reals and integer kind parameters of FOODIE library. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: R8P public :: R4P public :: R_P public :: I8P public :: I4P public :: I2P public :: I1P public :: I_P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. !----------------------------------------------------------------------------------------------------------------------------------- endmodule foodie_kinds","tags":"","loc":"sourcefile/foodie_kinds.f90.html","title":"foodie_kinds.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Oscillation equations. Source Code !< Test FOODIE with the integration of Oscillation equations. program integrate_oscillation !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Oscillation equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str , strz use type_oscillation , only : oscillation use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & adams_bashforth_moulton_integrator , & adams_moulton_integrator , & emd_runge_kutta_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. integer , parameter :: space_dimension = 2 !< Space dimensions. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 0._R_P , 1._R_P ] !< Initial state. real ( R_P ) :: f !< Oscillation frequency. real ( R_P ) :: t_final !< Final time. real ( R_P ) :: Dt !< Time step. real ( R_P ) :: tolerance !< Tolerance on local truncation error. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: stages_steps !< Number of stages/steps used. integer ( I_P ) :: implicit_iterations !< Number of iterations for implicit solvers. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. character ( 99 ) :: output_cli !< Output files basename. logical :: errors_analysis !< Flag for activating errors analysis. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'oscillation' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Oscillation equations integration' , & examples = [ \"oscillation --solver euler --results  \" , & \"oscillation --solver ls-runge-kutta -r\" , & \"oscillation --solver adams-bashforth  \" , & \"oscillation --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . false ., def = 'all' , act = 'store' ) call cli % add ( switch = '--ss' , help = 'Stages/steps used' , required = . false ., act = 'store' , def = '-1' ) call cli % add ( switch = '--iterations' , help = 'Number of iterations for implicit solvers' , required = . false ., act = 'store' , def = '5' ) call cli % add ( switch = '--frequency' , switch_ab = '-f' , help = 'Oscillation frequency' , required = . false ., def = '1e-4' , act = 'store' ) call cli % add ( switch = '--time_step' , switch_ab = '-Dt' , help = 'Integration time step' , required = . false ., def = '100.d0' , act = 'store' ) call cli % add ( switch = '--tolerance' , switch_ab = '-tol' , help = 'Tolerance on local error' , required = . false ., def = '0.001d0' , act = 'store' ) call cli % add ( switch = '--t_final' , switch_ab = '-tf' , help = 'Final integration time' , required = . false ., def = '1e6' , act = 'store' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--output' , help = 'Output files basename' , required = . false ., act = 'store' , def = 'unset' ) call cli % add ( switch = '--errors_analysis' , help = 'Peform errors analysis' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--ss' , val = stages_steps , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--iterations' , val = implicit_iterations , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-f' , val = f , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-Dt' , val = Dt , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-tol' , val = tolerance , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-tf' , val = t_final , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--output' , val = output_cli , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--errors_analysis' , val = errors_analysis , error = error ) ; if ( error /= 0 ) stop if ( errors_analysis ) then call perform_errors_analysis else select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab ( steps = stages_steps ) case ( 'adams-bashforth-moulton' ) call test_abm ( steps = stages_steps ) case ( 'adams-moulton' ) call test_am ( steps = stages_steps ) case ( 'emd-runge-kutta' ) call test_emd_rk ( stages = stages_steps ) case ( 'euler' ) call test_euler case ( 'leapfrog' ) call test_leapfrog case ( 'leapfrog-raw' ) call test_leapfrog ( raw = . true .) case ( 'ls-runge-kutta' ) call test_ls_rk ( stages = stages_steps ) case ( 'tvd-runge-kutta' ) call test_tvd_rk ( stages = stages_steps ) case ( 'all' ) call test_ab ( steps = stages_steps ) call test_abm ( steps = stages_steps ) call test_am ( steps = stages_steps ) call test_emd_rk ( stages = stages_steps ) call test_euler call test_leapfrog call test_ls_rk ( stages = stages_steps ) call test_tvd_rk ( stages = stages_steps ) case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + adams-bashforth-moulton' print \"(A)\" , '  + adams-moulton' print \"(A)\" , '  + emd-runge-kutta' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + leapfrog-raw' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect endif stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init ( output , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize solver local variable from global variables. !--------------------------------------------------------------------------------------------------------------------------------- character ( len = :), allocatable , intent ( OUT ) :: output !< Output files basename. real ( R_P ), allocatable , intent ( OUT ) :: solution (:,:) !< Solution at each time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( mod ( t_final , Dt ) /= 0 ) then print \"(A)\" , 'Error: the final integration time must be an exact multiple of the time step used!' print \"(A)\" , 'Final integration time: ' // str (. true ., t_final ) print \"(A)\" , 'Time step: ' // str (. true ., Dt ) stop endif if ( trim ( adjustl ( output_cli )) /= 'unset' ) then if ( trim ( adjustl ( solver )) /= 'emd-runge-kutta' ) then output = trim ( adjustl ( output_cli )) // '-' // trim ( strz ( 10 , int ( t_final / Dt ))) // '-time_steps-' // trim ( adjustl ( solver )) else output = trim ( adjustl ( output_cli )) // '-' // trim ( str (. true ., n = tolerance )) // '-tolerance-' // trim ( adjustl ( solver )) endif else if ( trim ( adjustl ( solver )) /= 'emd-runge-kutta' ) then output = 'oscillation_integration-' // trim ( strz ( 10 , int ( t_final / Dt ))) // '-time_steps-' // trim ( adjustl ( solver )) else output = 'oscillation_integration-' // trim ( str (. true ., n = tolerance )) // '-tolerance-' // trim ( adjustl ( solver )) endif endif if ( allocated ( solution )) deallocate ( solution ) ; allocate ( solution ( 0 : space_dimension , 0 : int ( t_final / Dt ))) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init function exact_solution ( t ) result ( ex_sol ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the exact solution. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ) :: ex_sol ( 1 : space_dimension ) !< Exact solution. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ex_sol ( 1 ) = initial_state ( 1 ) * cos ( f * t ) - initial_state ( 2 ) * sin ( f * t ) ex_sol ( 2 ) = initial_state ( 1 ) * sin ( f * t ) + initial_state ( 2 ) * cos ( f * t ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction exact_solution subroutine save_results ( title , basename , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: basename !< Output files basename. real ( R_P ), intent ( IN ) :: solution ( 0 :, 0 :) !< Solution at each time step. integer ( I_P ) :: rawfile !< Raw file unit for saving results. real ( R_P ) :: ex_sol ( 1 : space_dimension ) !< Exact solution. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = basename // '.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) 'VARIABLES=\"t\" \"x\" \"y\"' write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE time serie\"' do s = 0 , ubound ( solution , dim = 2 ) write ( rawfile , '(3(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , space_dimension ) enddo write ( rawfile , '(A)' ) 'ZONE T=\"Exact solution\"' do s = 0 , ubound ( solution , dim = 2 ) ex_sol = exact_solution ( t = solution ( 0 , s )) write ( rawfile , '(3(' // FR_P // ',1X))' ) solution ( 0 , s ), ( ex_sol ( i ), i = 1 , space_dimension ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'v' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( basename // '.png' ) call plt % initialize ( grid = . true ., xlabel = 'v1' , ylabel = 'v2' , title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'path' , linestyle = 'r-' , linewidth = 1 ) call plt % savefig ( 'path-' // basename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all AB solvers are used. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'adams-bashforth' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of Adams-Bashforth class of solvers' steps_range = [ 1 , ab_steps ] ; if ( steps > 0 ) steps_range = [ steps , steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' AB-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // ' steps=' // trim ( str (. true ., s )) call ab_solver ( steps = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_abm ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test predictor-corrector Adams-Bashforth-Moulton class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all AB solvers are used. integer , parameter :: abm_steps = 4 !< Adams-Bashforth-Moulton steps number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< ABM steps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'adams-bashforth-moulton' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of Adams-Bashforth-Moulton class of solvers' steps_range = [ 1 , abm_steps ] ; if ( steps > 0 ) steps_range = [ steps , steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' ABM-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, predictor/corrector Adams-Bashforth-Moulton, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) call abm_solver ( steps = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_abm subroutine test_am ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test implicit Adams-Moulton class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all AB solvers are used. integer , parameter :: am_steps = 3 !< Adams-Moulton steps number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< AM steps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'adams-moulton' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of Adams-Moulton class of solvers' steps_range = [ 0 , am_steps ] ; if ( steps > 0 ) steps_range = [ steps , steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' AM-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, implicit Adams-Moulton, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) if ( implicit_iterations > 1 ) then call am_solver ( steps = s , solution = solution , iterations = implicit_iterations ) else call am_solver ( steps = s , solution = solution ) endif call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_am subroutine test_emd_rk ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit embedded Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. integer , parameter :: rk_stages = 17 !< Runge-Kutta stages number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. integer ( I_P ) :: last_step !< Last time step computed. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'emd-runge-kutta' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of embedded Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages > 0 ) stages_range = [ stages , stages ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 1 ) cycle ! 1 stages not allowed if ( s == 2 ) cycle ! 2 stages not suited for test if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 5 ) cycle ! 5 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented if ( s == 12 ) cycle ! 12 stages not yet implemented if ( s == 13 ) cycle ! 13 stages not yet implemented if ( s == 14 ) cycle ! 14 stages not yet implemented if ( s == 15 ) cycle ! 15 stages not yet implemented if ( s == 16 ) cycle ! 16 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, explicit embedded Runge-Kutta, t=' // str ( n = t_final ) // ' steps=' // trim ( str (. true ., s )) call emd_rk_solver ( stages = s , tol = tolerance , solution = solution , last_step = last_step ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution (:, 0 : last_step )) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_emd_rk subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'euler' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of explicit Euler solver' title = 'Oscillation equation integration, explicit Euler, t=' // str ( n = t_final ) call euler_solver ( solution = solution ) call save_results ( title = title , basename = output , solution = solution ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- logical , optional , intent ( IN ) :: raw !< Activate RAW filter. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'leapfrog' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of leapfrog (RAW filtered) class of solvers' title = 'Oscillation equation integration, leapfrog (RAW filtered), t=' // str ( n = t_final ) call leapfrog_solver ( solution = solution , raw = raw ) call save_results ( title = title , basename = output , solution = solution ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. integer , parameter :: rk_stages = 14 !< Runge-Kutta stages number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'ls-runge-kutta' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of low storage (2N) Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages > 0 ) stages_range = [ stages , stages ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 9 ) cycle ! 9 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) call ls_rk_solver ( stages = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'tvd-runge-kutta' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of TVD/SSP Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages > 0 ) stages_range = [ stages , stages ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, explicit TVD/SSP Runge-Kutta, t=' // str ( n = t_final ) // ' steps=' // trim ( str (. true ., s )) call tvd_rk_solver ( stages = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk subroutine ab_solver ( steps , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all AB solvers are used. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. type ( oscillation ) :: previous ( 1 : steps ) !< Previous time steps solutions. type ( oscillation ) :: oscillator !< Oscillation field. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call ab_integrator % init ( steps = steps ) select case ( steps ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = steps ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 if ( steps >= step ) then ! time steps from 1 to s - 1 must be computed with other scheme call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) previous ( step ) = oscillator else call ab_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step - steps : step - 1 )) endif solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine ab_solver subroutine abm_solver ( steps , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with predictor-corrector Adams-Bashforth-Moulton class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all ABM solvers are used. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_moulton_integrator ) :: abm_integrator !< Adams-Bashforth-Moulton integrator. type ( oscillation ) :: previous ( 1 : steps ) !< Previous time steps solutions. type ( oscillation ) :: oscillator !< Oscillation field. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call abm_integrator % init ( steps = steps ) select case ( steps ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = steps ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 if ( steps >= step ) then ! time steps from 1 to s - 1 must be computed with other scheme call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) previous ( step ) = oscillator else call abm_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step - steps : step - 1 )) endif solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine abm_solver subroutine am_solver ( steps , iterations , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with implicit Adams-Moulton class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all AM solvers are used. integer ( I_P ), optional , intent ( IN ) :: iterations !< Number of fixed point iterations. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_moulton_integrator ) :: am_integrator !< Adams-Moulton integrator. type ( oscillation ) :: previous ( 1 : steps ) !< Previous time steps solutions. type ( oscillation ) :: oscillator !< Oscillation field. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call am_integrator % init ( steps = steps ) select case ( steps ) case ( 0 , 1 , 2 ) call rk_integrator % init ( stages = steps + 1 ) case ( 3 ) call rk_integrator % init ( stages = 5 ) endselect call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 if ( steps >= step ) then ! time steps from 1 to s - 1 must be computed with other scheme call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) previous ( step ) = oscillator else if ( steps == 0 ) then call am_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step - 1 : step - 1 ), iterations = iterations ) else call am_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step - steps : step - 1 ), iterations = iterations ) endif endif solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine am_solver subroutine emd_rk_solver ( stages , tol , solution , last_step ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit embedded Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. real ( R_P ), intent ( IN ) :: tol !< Tolerance on local truncation error. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. integer ( I_P ), intent ( OUT ) :: last_step !< Last time step number. type ( emd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. type ( oscillation ) :: rk_stage ( 1 : stages ) !< Runge-Kutta stages. type ( oscillation ) :: oscillator !< Oscillation field. integer ( I_P ) :: step !< Time steps counter. real ( R_P ) :: Dt_a !< Adaptive time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Dt_a = 1000 0._R_P ! initial step very large to trigger adaptation call rk_integrator % init ( stages = stages , tolerance = tol ) call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt_a , t = solution ( 0 , step )) solution ( 0 , step ) = solution ( 0 , step - 1 ) + Dt_a solution ( 1 : space_dimension , step ) = oscillator % output () enddo last_step = step return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine emd_rk_solver subroutine euler_solver ( solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. type ( oscillation ) :: oscillator !< Oscillation field. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 call euler_integrator % integrate ( U = oscillator , Dt = Dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_solver subroutine leapfrog_solver ( solution , raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. logical , optional , intent ( IN ) :: raw !< Activate RAW filter. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( oscillation ) :: previous ( 1 : 2 ) !< Previous time steps solutions. type ( oscillation ) :: filter !< Filter displacement. type ( oscillation ) :: oscillator !< Oscillation field. integer :: step !< Time steps counter. logical :: filtered !< Activate RAW filter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- filtered = . false . ; if ( present ( raw )) filtered = raw call lf_integrator % init () call rk_integrator % init ( stages = rk_stages ) call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 if ( 2 >= step ) then ! time steps from 1 to 2 must be computed with other scheme call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) previous ( step ) = oscillator else if ( filtered ) then call lf_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step ), filter = filter ) else call lf_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine leapfrog_solver subroutine ls_rk_solver ( stages , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: registers = 2 !< Runge-Kutta stages registers number. type ( oscillation ) :: rk_stage ( 1 : registers ) !< Runge-Kutta registers. type ( oscillation ) :: oscillator !< Oscillation field. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call rk_integrator % init ( stages = stages ) call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine ls_rk_solver subroutine tvd_rk_solver ( stages , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. type ( oscillation ) :: rk_stage ( 1 : stages ) !< Runge-Kutta stages. type ( oscillation ) :: oscillator !< Oscillation field. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call rk_integrator % init ( stages = stages ) call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tvd_rk_solver subroutine perform_errors_analysis () !--------------------------------------------------------------------------------------------------------------------------------- !< Peform errors analysis. !< !< The analysis is based on the integration of the Oscillation equations with different, decreasing time steps in the range !< *[5000, 2500, 1250, 625, 320, 100]*. The error is estimated by the L2 norm of the difference between the exact (U_e) and !< the numerical (U_{\\Delta t}) solutions for each time step: !< !< !<\\varepsilon (\\Delta t) = || U_e - U_{\\Delta t} ||_2 = \\sqrt{ \\sum_{s=1}&#94;{N_s} { \\left(U_e(t_0 + s * \\Delta t) - !<U_{\\Delta t}(t_0 + s * \\Delta t) \\right)&#94;2 }} !< !< !< Using two pairs of subsequent-decreasing time steps solution is possible to estimate the order of accuracy of the solver !< employed computing the \\emph{observed order} of accuracy: !< !< !<p = \\frac{log10 \\left( \\frac{\\varepsilon (\\Delta t_1)}{\\varepsilon (\\Delta t_2)} \\right)} !<{log10 \\left( \\frac{\\Delta t_1}{\\Delta t_2} \\right)} !< !< !<where \\frac{\\Delta t_1}{\\Delta t_2}>1. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), parameter :: NDt = 6 !< Number of time steps exercised. real ( R_P ), parameter :: time_steps ( 1 : NDt ) = [ 500 0._R_P , & 250 0._R_P , & 125 0._R_P , & 62 5._R_P , & 32 0._R_P , & 10 0._R_P ] !< Time steps exercised. real ( R_P ), parameter :: tolerances ( 1 : NDt ) = [ 0.001_R_P , & 0.0001_R_P , & 0.00001_R_P , & 0.000001_R_P , & 0.0000001_R_P , & 0.00000001_R_P ] !< Tolerances for embedded RK solvers. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. integer , parameter :: emd_rk_stages = 17 !< Embedded Runge-Kutta stages number. integer , parameter :: tvd_rk_stages = 5 !< TVD/SSP Runge-Kutta stages number. integer , parameter :: ls_rk_stages = 14 !< Low storage Runge-Kutta stages number. integer ( I_P ) :: s !< Steps/stages counter. integer ( I_P ) :: d !< Time steps-exercised counter. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: last_step !< Last time step computed. real ( R_P ) :: emd_Dt_mean ( 1 : emd_rk_stages , 1 : NDt ) !< Mean time resolution for adaptive step methods. ! errors and orders real ( R_P ) :: ab_errors ( 1 : space_dimension , 1 : ab_steps , 1 : NDt ) !< Adams-Bashforth errors. real ( R_P ) :: abm_errors ( 1 : space_dimension , 1 : ab_steps , 1 : NDt ) !< Adams-Bashforth-Moulton errors. real ( R_P ) :: am_errors ( 1 : space_dimension , 1 : ab_steps , 1 : NDt ) !< Adams-Moulton errors. real ( R_P ) :: emd_rk_errors ( 1 : space_dimension , 1 : emd_rk_stages , 1 : NDt ) !< TVD/SSP Runge-Kutta errors. real ( R_P ) :: lf_errors ( 1 : space_dimension , 1 : 2 , 1 : NDt ) !< Leapfrog errors. real ( R_P ) :: ls_rk_errors ( 1 : space_dimension , 1 : ls_rk_stages , 1 : NDt ) !< Low storage Runge-Kutta errors. real ( R_P ) :: tvd_rk_errors ( 1 : space_dimension , 1 : tvd_rk_stages , 1 : NDt ) !< TVD/SSP Runge-Kutta errors. real ( R_P ) :: ab_orders ( 1 : space_dimension , 1 : ab_steps , 1 : NDt - 1 ) !< Adams-Bashforth orders. real ( R_P ) :: abm_orders ( 1 : space_dimension , 1 : ab_steps , 1 : NDt - 1 ) !< Adams-Bashforth-Moulton orders. real ( R_P ) :: am_orders ( 1 : space_dimension , 1 : ab_steps , 1 : NDt - 1 ) !< Adams-Moulton orders. real ( R_P ) :: emd_rk_orders ( 1 : space_dimension , 1 : emd_rk_stages , 1 : NDt - 1 ) !< Embedded Runge-Kutta orders. real ( R_P ) :: lf_orders ( 1 : space_dimension , 1 : 2 , 1 : NDt - 1 ) !< Leapfrog orders. real ( R_P ) :: ls_rk_orders ( 1 : space_dimension , 1 : ls_rk_stages , 1 : NDt - 1 ) !< Low storage Runge-Kutta orders. real ( R_P ) :: tvd_rk_orders ( 1 : space_dimension , 1 : tvd_rk_stages , 1 : NDt - 1 ) !< TVD/SSP Runge-Kutta orders. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ab_errors = - 1._R_P ; ab_orders = 0._R_P abm_errors = - 1._R_P ; abm_orders = 0._R_P am_errors = - 1._R_P ; am_orders = 0._R_P emd_rk_errors = - 1._R_P ; emd_rk_orders = 0._R_P lf_errors = - 1._R_P ; lf_orders = 0._R_P ls_rk_errors = - 1._R_P ; ls_rk_orders = 0._R_P tvd_rk_errors = - 1._R_P ; tvd_rk_orders = 0._R_P if ( allocated ( solution )) deallocate ( solution ) ; allocate ( solution ( 0 : space_dimension , 0 : int ( t_final / Dt ))) results = . true . ! activate results saving ! Analyze errors of Adams-Bashforth solvers do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'adams-bashforth' call init ( output = output , solution = solution ) do s = 1 , ab_steps title = 'Oscillation equation integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // ' steps=' // trim ( str (. true ., s )) call ab_solver ( steps = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) ab_errors (:, s , d ) = compute_errors ( solution = solution ) enddo enddo do s = 1 , ab_steps do d = 1 , NDt - 1 ab_orders (:, s , d ) = estimate_orders ( solver_error = ab_errors (:, s , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo enddo ! Analyze errors of Adams-Bashforth-Moulton solvers do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'adams-bashforth-moulton' call init ( output = output , solution = solution ) do s = 1 , ab_steps title = 'Oscillation equation integration, predictor-corrector Adams-Bashforth-Moulton, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) call abm_solver ( steps = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) abm_errors (:, s , d ) = compute_errors ( solution = solution ) enddo enddo do s = 1 , ab_steps do d = 1 , NDt - 1 abm_orders (:, s , d ) = estimate_orders ( solver_error = abm_errors (:, s , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo enddo ! Analyze errors of Adams-Moulton solvers do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'adams-moulton' call init ( output = output , solution = solution ) do s = 0 , ab_steps - 1 title = 'Oscillation equation integration, implicit Adams-Moulton, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) if ( implicit_iterations > 1 ) then call am_solver ( steps = s , solution = solution , iterations = implicit_iterations ) else call am_solver ( steps = s , solution = solution ) endif call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) am_errors (:, s + 1 , d ) = compute_errors ( solution = solution ) enddo enddo do s = 0 , ab_steps - 1 do d = 1 , NDt - 1 am_orders (:, s + 1 , d ) = estimate_orders ( solver_error = am_errors (:, s + 1 , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo enddo ! Analyze errors of embedded Runge-Kutta solvers emd_Dt_mean = 0._R_P do d = 1 , NDt ! loop over exercised tolerances Dt = time_steps ( NDt ) tolerance = tolerances ( d ) solver = 'emd-runge-kutta' call init ( output = output , solution = solution ) do s = 1 , emd_rk_stages if ( s == 1 ) cycle ! 1 stages not allowed if ( s == 2 ) cycle ! 2 stages not suited for test if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 5 ) cycle ! 5 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented if ( s == 12 ) cycle ! 12 stages not yet implemented if ( s == 13 ) cycle ! 13 stages not yet implemented if ( s == 14 ) cycle ! 14 stages not yet implemented if ( s == 15 ) cycle ! 15 stages not yet implemented if ( s == 16 ) cycle ! 16 stages not yet implemented title = 'Oscillation equation integration, explicit embedded Runge-Kutta t=' // str ( n = t_final ) // ' stages=' // trim ( str (. true ., s )) if ( s == 17 ) then call emd_rk_solver ( stages = s , tol = tolerances ( d ) / 100 0._R_P , solution = solution , last_step = last_step ) else call emd_rk_solver ( stages = s , tol = tolerances ( d ), solution = solution , last_step = last_step ) endif emd_Dt_mean ( s , d ) = t_final / real ( last_step , kind = R_P ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution (:, 0 : last_step )) emd_rk_errors (:, s , d ) = compute_errors ( solution = solution (:, 0 : last_step )) enddo enddo do s = 1 , emd_rk_stages if ( s == 1 ) cycle ! 1 stages not allowed if ( s == 2 ) cycle ! 2 stages not suited for test if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 5 ) cycle ! 5 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented if ( s == 12 ) cycle ! 12 stages not yet implemented if ( s == 13 ) cycle ! 13 stages not yet implemented if ( s == 14 ) cycle ! 14 stages not yet implemented if ( s == 15 ) cycle ! 15 stages not yet implemented if ( s == 16 ) cycle ! 16 stages not yet implemented do d = 1 , NDt - 1 emd_rk_orders (:, s , d ) = estimate_orders ( solver_error = emd_rk_errors (:, s , d : d + 1 ), Dt_used = emd_Dt_mean ( s , d : d + 1 )) enddo enddo ! Analyze errors of leapfrog solver do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'leapfrog' call init ( output = output , solution = solution ) title = 'Oscillation equation integration, leapfrog (unfiltered), t=' // str ( n = t_final ) call leapfrog_solver ( solution = solution ) call save_results ( title = title , basename = output , solution = solution ) lf_errors (:, 1 , d ) = compute_errors ( solution = solution ) Dt = time_steps ( d ) solver = 'leapfrog' call init ( output = output , solution = solution ) title = 'Oscillation equation integration, leapfrog (RAW filtered), t=' // str ( n = t_final ) call leapfrog_solver ( solution = solution , raw = . true .) call save_results ( title = title , basename = output // '-raw' , solution = solution ) lf_errors (:, 2 , d ) = compute_errors ( solution = solution ) enddo do d = 1 , NDt - 1 lf_orders (:, 1 , d ) = estimate_orders ( solver_error = lf_errors (:, 1 , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) lf_orders (:, 2 , d ) = estimate_orders ( solver_error = lf_errors (:, 2 , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo ! Analyze errors of low storage Runge-Kutta solvers do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'ls-runge-kutta' call init ( output = output , solution = solution ) do s = 1 , ls_rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 9 ) cycle ! 9 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented title = 'Oscillation equation integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) call ls_rk_solver ( stages = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) ls_rk_errors (:, s , d ) = compute_errors ( solution = solution ) enddo enddo do s = 1 , ls_rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 9 ) cycle ! 9 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented do d = 1 , NDt - 1 ls_rk_orders (:, s , d ) = estimate_orders ( solver_error = ls_rk_errors (:, s , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo enddo ! Analyze errors of TVD/SSP Runge-Kutta solvers do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'tvd-runge-kutta' call init ( output = output , solution = solution ) do s = 1 , tvd_rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented title = 'Oscillation equation integration, explicit TVD/SSP Runge-Kutta, t=' // str ( n = t_final ) // ' steps=' // trim ( str (. true ., s )) call tvd_rk_solver ( stages = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) tvd_rk_errors (:, s , d ) = compute_errors ( solution = solution ) enddo enddo do s = 1 , tvd_rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented do d = 1 , NDt - 1 tvd_rk_orders (:, s , d ) = estimate_orders ( solver_error = tvd_rk_errors (:, s , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo enddo print \"(A)\" , \"Solver & Time Step & f*Dt & Error X & Error Y & Observed Order of Accuracy X & Observed Order of Accuracy Y\" call print_analysis ( solver = 'adams-bashforth' , time_steps = time_steps , errors = ab_errors , orders = ab_orders ) call print_analysis ( solver = 'adams-bashforth-moulton' , time_steps = time_steps , errors = abm_errors , orders = abm_orders ) call print_analysis ( solver = 'adams-moulton' , time_steps = time_steps , errors = am_errors , orders = am_orders ) call print_analysis ( solver = 'emd-runge-kutta' , mean_time_steps = emd_Dt_mean , errors = emd_rk_errors , orders = emd_rk_orders ) call print_analysis ( solver = 'leapfrog' , time_steps = time_steps , errors = lf_errors , orders = lf_orders ) call print_analysis ( solver = 'ls-runge-kutta' , time_steps = time_steps , errors = ls_rk_errors , orders = ls_rk_orders ) call print_analysis ( solver = 'tvd-runge-kutta' , time_steps = time_steps , errors = tvd_rk_errors , orders = tvd_rk_orders ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine perform_errors_analysis function compute_errors ( solution ) result ( error_L2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the L2 norm of numerical error with respect the exact solution. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: solution ( 0 :, 0 :) !< Solution at each time step. real ( R_P ) :: error_L2 ( 1 : space_dimension ) !< L2 norm of the numerical error. real ( R_P ) :: ex_sol ( 1 : space_dimension ) !< Exact solution. integer ( I_P ) :: s !< Steps/stages counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- error_L2 = 0._R_P do s = 0 , ubound ( solution , dim = 2 ) ex_sol = exact_solution ( t = solution ( 0 , s )) do v = 1 , space_dimension error_L2 ( v ) = error_L2 ( v ) + ( solution ( v , s ) - ex_sol ( v )) ** 2 enddo enddo error_L2 = sqrt ( error_L2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction compute_errors function estimate_orders ( solver_error , Dt_used ) result ( order ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate the order of accuracy using 2 subsequent refined numerical solutions. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: solver_error ( 1 : space_dimension , 1 : 2 ) !< Computed errors. real ( R_P ), intent ( IN ) :: Dt_used ( 1 : 2 ) !< Time steps used. real ( R_P ) :: order ( 1 : space_dimension ) !< Estimation of the order of accuracy. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do v = 1 , space_dimension order ( v ) = log ( solver_error ( v , 1 ) / solver_error ( v , 2 )) / log ( Dt_used ( 1 ) / Dt_used ( 2 )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction estimate_orders subroutine print_analysis ( solver , time_steps , mean_time_steps , errors , orders ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print summary of the error analysis. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: solver !< Solver name. real ( R_P ), optional , intent ( IN ) :: time_steps (:) !< Time steps exercised. real ( R_P ), optional , intent ( IN ) :: mean_time_steps (:,:) !< Mean time steps exercised. real ( R_P ), intent ( IN ) :: errors (:,:,:) !< Errors of the solver. real ( R_P ), intent ( IN ) :: orders (:,:,:) !< Observed orders of the solver. integer ( I_P ) :: s !< Solver index. integer ( I_P ) :: d !< Time steps-exercised counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( time_steps )) then do s = 1 , size ( errors , dim = 2 ) if ( errors ( 1 , s , 1 ) < 0._R_P ) cycle print \"(A)\" , solver // '-' // trim ( str (. true ., s )) do d = 1 , size ( errors , dim = 3 ) if ( d == 1 ) then print \"(A,F8.1,A,F10.3,A,E10.3,A,E10.3,A)\" , & \"  & \" , time_steps ( d ), \" & \" , f * time_steps ( d ), \" & \" , & errors ( 1 , s , d ), \" & \" , errors ( 2 , s , d ), \" & / & /\" else print \"(A,F8.1,A,F10.3,A,E10.3,A,E10.3,A,F9.2,A,F9.2)\" , & \"  & \" , time_steps ( d ), \" & \" , f * time_steps ( d ), \" & \" , & errors ( 1 , s , d ), \" & \" , errors ( 2 , s , d ), \" & \" , & orders ( 1 , s , d - 1 ), \" & \" , orders ( 2 , s , d - 1 ) endif enddo enddo elseif ( present ( mean_time_steps )) then do s = 1 , size ( errors , dim = 2 ) if ( errors ( 1 , s , 1 ) < 0._R_P ) cycle print \"(A)\" , solver // '-' // trim ( str (. true ., s )) do d = 1 , size ( errors , dim = 3 ) if ( d == 1 ) then print \"(A,F8.1,A,F10.3,A,E10.3,A,E10.3,A)\" , & \"  & \" , mean_time_steps ( s , d ), \" & \" , f * mean_time_steps ( s , d ), \" & \" , & errors ( 1 , s , d ), \" & \" , errors ( 2 , s , d ), \" & / & /\" else print \"(A,F8.1,A,F10.3,A,E10.3,A,E10.3,A,F9.2,A,F9.2)\" , & \"  & \" , mean_time_steps ( s , d ), \" & \" , f * mean_time_steps ( s , d ), \" & \" , & errors ( 1 , s , d ), \" & \" , errors ( 2 , s , d ), \" & \" , & orders ( 1 , s , d - 1 ), \" & \" , orders ( 2 , s , d - 1 ) endif enddo enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_analysis endprogram integrate_oscillation","tags":"","loc":"sourcefile/oscillation.f90.html","title":"oscillation.f90 – FOODIE"},{"text":"Define Oscillation field that is a concrete extension of the abstract integrand type. Source Code !< Define Oscillation field that is a concrete extension of the abstract integrand type. module type_oscillation !----------------------------------------------------------------------------------------------------------------------------------- !< Define Oscillation field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: oscillation !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: oscillation !< Oscillation equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Oscillation ODEs system !<The (inertial) Oscillation equations system is a non linear system of pure ODEs and it can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< v_1 \\\\ !< v_2 !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< -f v_2 \\\\ !< f v_1 !< \\end{bmatrix} !<\\end{matrix} !< !<The frequency *f* is constant and it is here selected as *f=10&#94;-4*. !< !<In the space *v1-v2* the path of the oscillation must be a circle, but for the frequency selected some ODE solvers are not !<stable leading to a wrong path, see [1]. !< !<#### Bibliography !< !<[1] *Numerical Methods for Fluid Dynamics With Applications to Geophysics*, Dale R. Durran, Springer, 2010. !< !<#### State variables organization !< State variables are organized as an array (rank 1) of reals of *dims* elements, in this case 2 elements. private integer ( I_P ) :: dims = 0 !< Space dimensions. real ( R_P ) :: f = 0._R_P !< Oscillation frequency (Hz). real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, [1:dims]. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Oscillation field. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dOscillation_dt !< Time derivative, residuals. procedure , pass ( lhs ), public :: local_error => oscillation_local_error !<||Oscillation-oscillation||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => oscillation_multiply_oscillation !< Oscillation * oscillation. procedure , pass ( lhs ), public :: integrand_multiply_real => oscillation_multiply_real !< Oscillation * real. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_oscillation !< Real * Oscillation. procedure , pass ( lhs ), public :: add => add_oscillation !< Oscillation + Oscillation. procedure , pass ( lhs ), public :: sub => sub_oscillation !< Oscillation - Oscillation. procedure , pass ( lhs ), public :: assign_integrand => oscillation_assign_oscillation !< Oscillation = Oscillation. endtype oscillation !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , initial_state , f ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: self !< Oscillation field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Initial state of the Oscillation field vector. real ( R_P ), intent ( IN ) :: f !< Frequency. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % f = f if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % dims )) ; self % U = initial_state return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Oscillation field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. real ( R_P ), dimension (:), allocatable :: state !< Oscillation state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output ! ADT integrand deferred methods function dOscillation_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Oscillation field time derivative. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: dState_dt ) select type ( dState_dt ) class is ( oscillation ) dState_dt = self dState_dt % U ( 1 ) = - self % f * self % U ( 2 ) dState_dt % U ( 2 ) = self % f * self % U ( 1 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dOscillation_dt function oscillation_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 oscillation approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( oscillation ) error = 0._R_P do i = 1 , lhs % dims error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_local_error function oscillation_multiply_oscillation ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a oscillation field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_multiply_oscillation function oscillation_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Oscillation field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_multiply_real function real_multiply_oscillation ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( oscillation ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_oscillation function add_oscillation ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Oscillation fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Oscillation function sub_oscillation ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Oscillation fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_Oscillation subroutine oscillation_assign_oscillation ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Oscillation field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( oscillation ) lhs % dims = rhs % dims lhs % f = rhs % f if ( allocated ( rhs % U )) lhs % U = rhs % U endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine oscillation_assign_oscillation endmodule type_oscillation","tags":"","loc":"sourcefile/type_oscillation.f90.html","title":"type_oscillation.f90 – FOODIE"},{"text":"Test without FOODIE with the integration of Euler 1D PDEs system by CAF paradigm. Source Code !< Test without FOODIE with the integration of Euler 1D PDEs system by CAF paradigm. program integrate_euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !< Test without FOODIE with the integration of Euler 1D PDEs system by CAF paradigm. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str , strz use type_euler_1D_caf_no_foodie , only : euler_1D_caf_nf , tvd_runge_kutta_integrator use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_caf_nf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer , parameter :: ord = 7 !< Space reconstruciton order, real ( R_P ) :: t !< Time. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( len = :), allocatable :: BC_L !< Left boundary condition type. character ( len = :), allocatable :: BC_R !< Right boundary condition type. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. type ( euler_1D_caf_nf ) :: domain !< Domain of Euler equations. ! coarrays-related variables integer ( I_P ) :: Ni_image !< Space dimension of local image. #ifdef CAF integer ( I_P ) :: Ni [ * ] !< Number of grid cells. integer ( I_P ) :: steps_max [ * ] !< Maximum number of time steps. logical :: results [ * ] !< Flag for activating results saving. logical :: plots [ * ] !< Flag for activating plots saving. logical :: time_serie [ * ] !< Flag for activating time serie-results saving. logical :: verbose [ * ] !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:)[:] !< Time step. #else integer ( I_P ) :: Ni !< Number of grid cells. integer ( I_P ) :: steps_max !< Maximum number of time steps. logical :: results !< Flag for activating results saving. logical :: plots !< Flag for activating plots saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:) !< Time step. #endif integer ( I_P ) :: me !< ID of this_image() integer ( I_P ) :: we !< Number of CAF images used. character ( len = :), allocatable :: id !< My ID. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF me = this_image () we = num_images () #else me = 1 we = 1 #endif id = trim ( strz ( 3 , me )) // '> ' ! setting Command Line Interface call cli % init ( progname = 'euler-1D-caf-no-foodie' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test 1D Euler equations integration without FOODIE, CAF enabled' , & examples = [ \"euler-1D-caf-no-foodie --results  \" , & \"euler-1D-caf-no-foodie -r -t -v -p\" , & \"euler-1D-caf-no-foodie            \" , & \"euler-1D-caf-no-foodie --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) ! parsing Command Line Interface if ( me == 1 ) then ! only master image do CLI stuffs call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop endif call init () system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) Dt ( me ) = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call synchronize call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , Dt = Dt ( me ), t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + Dt ( me ) call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-image-' // trim ( strz ( 3 , me ))) print \"(A,I5,A,F23.15)\" , id , we , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_caf","tags":"","loc":"sourcefile/euler-1d-caf_no_foodie.f90.html","title":"euler-1D-caf_no_foodie.f90 – FOODIE"},{"text":"Define Euler 1D (CAF enabled) field without extending FOODIE integrand. Source Code !< Define Euler 1D (CAF enabled) field without extending FOODIE integrand. module type_euler_1D_caf_no_foodie !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D (CAF enabled) field without extending FOODIE integrand. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D_caf_nf public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: euler_1D_caf_nf !< Euler 1D (CAF enabled) PDEs system field. !< !< @note This object does not use FOODIE. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. integer ( I_P ) :: me = 0 !< ID of this_image(). integer ( I_P ) :: we = 0 !< Number of CAF images used. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. ! private methods procedure , pass ( self ), private :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), private :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: synchronize !< Synchronize CAF images. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_caf_nf type :: tvd_runge_kutta_integrator !< TVD RK integrator. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy => destroy_rk !< Destroy the integrator. procedure , pass ( self ), public :: init => init_rk !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate => integrate_rk !< Integrate integrand field. final :: finalize_rk !< Finalize object. endtype tvd_runge_kutta_integrator #ifdef CAF real ( R_P ), allocatable :: remote_U (:,:)[:] !< CAF buffer for sharing remote conservative variables. #else real ( R_P ), allocatable :: remote_U (:,:) !< CAF buffer for sharing remote conservative variables. #endif real ( R_P ), allocatable :: U_L (:,:) !< Integrand (state) variables, left ghost cells [1:Nc,1:Ng]. real ( R_P ), allocatable :: U_R (:,:) !< Integrand (state) variables, right ghost cells [1:Nc,Ni-Ng+1:Ni]. !----------------------------------------------------------------------------------------------------------------------------------- contains ! type bound procedures of tvd_runge_kutta_integrator ! public methods elemental subroutine init_rk ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init_rk elemental subroutine destroy_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy_rk subroutine integrate_rk ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( euler_1D_caf_nf ), intent ( INOUT ) :: U !< Field to be integrated. class ( euler_1D_caf_nf ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s )% U = stage ( s )% U + stage ( ss )% U * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t () enddo ! computing new time step do s = 1 , self % stages U % U = U % U + stage ( s )% U * ( Dt * self % beta ( s )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate_rk ! private methods elemental subroutine finalize_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_rk ! type bound procedures of euler_1D_caf_nf ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , me , we , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension (local image). integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), intent ( IN ) :: me !< ID of this_image(). integer ( I_P ), intent ( IN ) :: we !< Number of CAF images used. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo self % me = me self % we = we #ifdef CAF if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )[ * ]) #else if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )) #endif if ( allocated ( U_L )) deallocate ( U_L ) ; allocate ( U_L ( 1 : self % Nc , 1 : self % Ni )) if ( allocated ( U_R )) deallocate ( U_R ) ; allocate ( U_R ( 1 : self % Nc , 1 : self % Ni )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) self % me = 0 self % we = 0 if ( allocated ( remote_U )) deallocate ( remote_U ) if ( allocated ( U_L )) deallocate ( U_L ) if ( allocated ( U_R )) deallocate ( U_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self , conservative ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. logical , optional , intent ( IN ) :: conservative !< Output conservative variables instead of primitive. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( conservative )) then state = self % U else allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! ADT integrand deferred methods function dEuler_dt ( self ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. type ( euler_1D_caf_nf ) :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals dState_dt = self do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: lhs !< Left hand side. class ( euler_1D_caf_nf ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf_nf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R lhs % me = rhs % me lhs % we = rhs % we endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive subroutine synchronize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( self % we > 1 ) then remote_U = self % U if ( self % me == 1 ) then sync images ( self % me + 1 ) U_R (:,:) = remote_U (:,:)[ self % me + 1 ] else if ( self % me == self % we ) then sync images ( self % me - 1 ) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] else sync images ([ self % me - 1 , self % me + 1 ]) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] U_R (:,:) = remote_U (:,:)[ self % me + 1 ] endif endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. character ( len = :), allocatable :: bc_type !< String containing BC type. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- call self % synchronize bc_type = trim ( adjustl ( self % BC_L )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = 1 - self % Ng , 0 primitive (:, i ) = self % conservative2primitive ( U_L (:, self % Ni + i )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect endif bc_type = trim ( adjustl ( self % BC_R )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = self % conservative2primitive ( U_R (:, i - self % Ni )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect endif return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D_caf_no_foodie","tags":"","loc":"sourcefile/type_euler-1d-caf_no_foodie.f90.html","title":"type_euler-1D-caf_no_foodie.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Euler 1D PDEs system. Source Code !< Test FOODIE with the integration of Euler 1D PDEs system. program integrate_euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str , strz use type_euler_1D_caf , only : euler_1D_caf use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_caf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer , parameter :: ord = 7 !< Space reconstruciton order, real ( R_P ) :: t !< Time. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( len = :), allocatable :: BC_L !< Left boundary condition type. character ( len = :), allocatable :: BC_R !< Right boundary condition type. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. type ( euler_1D_caf ) :: domain !< Domain of Euler equations. ! coarrays-related variables integer ( I_P ) :: Ni_image !< Space dimension of local image. #ifdef CAF integer ( I_P ) :: Ni [ * ] !< Number of grid cells. integer ( I_P ) :: steps_max [ * ] !< Maximum number of time steps. logical :: results [ * ] !< Flag for activating results saving. logical :: plots [ * ] !< Flag for activating plots saving. logical :: time_serie [ * ] !< Flag for activating time serie-results saving. logical :: verbose [ * ] !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:)[:] !< Time step. #else integer ( I_P ) :: Ni !< Number of grid cells. integer ( I_P ) :: steps_max !< Maximum number of time steps. logical :: results !< Flag for activating results saving. logical :: plots !< Flag for activating plots saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:) !< Time step. #endif integer ( I_P ) :: me !< ID of this_image() integer ( I_P ) :: we !< Number of CAF images used. character ( len = :), allocatable :: id !< My ID. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF me = this_image () we = num_images () #else me = 1 we = 1 #endif id = trim ( strz ( 3 , me )) // '> ' ! setting Command Line Interface call cli % init ( progname = 'euler-1D-caf' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration, CAF enabled' , & examples = [ \"euler-1D-caf --results  \" , & \"euler-1D-caf -r -t -v -p\" , & \"euler-1D-caf            \" , & \"euler-1D-caf --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) ! parsing Command Line Interface if ( me == 1 ) then ! only master image do CLI stuffs call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop endif call init () system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) Dt ( me ) = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call synchronize call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , Dt = Dt ( me ), t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + Dt ( me ) call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-image-' // trim ( strz ( 3 , me ))) print \"(A,I5,A,F23.15)\" , id , we , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_caf","tags":"","loc":"sourcefile/euler-1d-caf.f90.html","title":"euler-1D-caf.f90 – FOODIE"},{"text":"Define Euler 1D (CAF enabled) field that is a concrete extension of the abstract integrand type. Source Code !< Define Euler 1D (CAF enabled) field that is a concrete extension of the abstract integrand type. module type_euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D (CAF enabled) field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: euler_1D_caf !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. integer ( I_P ) :: me = 0 !< ID of this_image(). integer ( I_P ) :: we = 0 !< Number of CAF images used. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !<||euler-euler||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: synchronize !< Synchronize CAF images. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_caf #ifdef CAF real ( R_P ), allocatable :: remote_U (:,:)[:] !< CAF buffer for sharing remote conservative variables. #else real ( R_P ), allocatable :: remote_U (:,:) !< CAF buffer for sharing remote conservative variables. #endif real ( R_P ), allocatable :: U_L (:,:) !< Integrand (state) variables, left ghost cells [1:Nc,1:Ng]. real ( R_P ), allocatable :: U_R (:,:) !< Integrand (state) variables, right ghost cells [1:Nc,Ni-Ng+1:Ni]. !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , me , we , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension (local image). integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), intent ( IN ) :: me !< ID of this_image(). integer ( I_P ), intent ( IN ) :: we !< Number of CAF images used. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo self % me = me self % we = we #ifdef CAF if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )[ * ]) #else if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )) #endif if ( allocated ( U_L )) deallocate ( U_L ) ; allocate ( U_L ( 1 : self % Nc , 1 : self % Ni )) if ( allocated ( U_R )) deallocate ( U_R ) ; allocate ( U_R ( 1 : self % Nc , 1 : self % Ni )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) self % me = 0 self % we = 0 if ( allocated ( remote_U )) deallocate ( remote_U ) if ( allocated ( U_L )) deallocate ( U_L ) if ( allocated ( U_R )) deallocate ( U_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self , conservative ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. logical , optional , intent ( IN ) :: conservative !< Output conservative variables instead of primitive. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( conservative )) then state = self % U else allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! ADT integrand deferred methods function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D_caf :: dState_dt ) select type ( dState_dt ) class is ( euler_1D_caf ) dState_dt = self endselect select type ( dState_dt ) class is ( euler_1D_caf ) do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf ) error = 0._R_P do i = 1 , lhs % Ni do v = 1 , lhs % Nc error = error + ( lhs % U ( v , i ) - rhs % U ( v , i )) ** 2 / lhs % U ( v , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D_caf ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = rhs endselect select type ( opr ) class is ( euler_1D_caf ) opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R lhs % me = rhs % me lhs % we = rhs % we endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real ! private methods pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive subroutine synchronize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( self % we > 1 ) then remote_U = self % U if ( self % me == 1 ) then sync images ( self % me + 1 ) U_R (:,:) = remote_U (:,:)[ self % me + 1 ] else if ( self % me == self % we ) then sync images ( self % me - 1 ) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] else sync images ([ self % me - 1 , self % me + 1 ]) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] U_R (:,:) = remote_U (:,:)[ self % me + 1 ] endif endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. character ( len = :), allocatable :: bc_type !< String containing BC type. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- call self % synchronize bc_type = trim ( adjustl ( self % BC_L )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = 1 - self % Ng , 0 primitive (:, i ) = self % conservative2primitive ( U_L (:, self % Ni + i )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect endif bc_type = trim ( adjustl ( self % BC_R )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = self % conservative2primitive ( U_R (:, i - self % Ni )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect endif return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D_caf","tags":"","loc":"sourcefile/type_euler-1d-caf.f90.html","title":"type_euler-1D-caf.f90 – FOODIE"},{"text":"Test without FOODIE with the integration of Euler 1D PDEs system by OpenMP paradigm. Source Code !< Test without FOODIE with the integration of Euler 1D PDEs system by OpenMP paradigm. program integrate_euler_1D_openmp_no_foodie !----------------------------------------------------------------------------------------------------------------------------------- !< Test without FOODIE with the integration of Euler 1D PDEs system by OpenMP paradigm. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D_openmp_no_foodie , only : euler_1D_omp_nf , tvd_runge_kutta_integrator use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use pyplot_module , only : pyplot #ifdef OPENMP use OMP_LIB #endif !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_omp_nf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. type ( euler_1D_omp_nf ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: steps_max !< Maximum number of time steps. integer ( I_P ) :: omp_threads !< Number of OpenMP threads. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D-openmp-no-foodie' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test 1D Euler equations integration without FOODIE, OpenMP enabled' , & examples = [ \"euler-1D-openmp-no-foodie --results  \" , & \"euler-1D-openmp-no-foodie -r -t -v -p\" , & \"euler-1D-openmp-no-foodie            \" , & \"euler-1D-openmp-no-foodie --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) call cli % add ( switch = '--omp_threads' , help = 'Number of OpenMP threads used' , required = . false ., act = 'store' , def = '1' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--omp_threads' , val = omp_threads , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop #ifdef OPENMP call omp_set_dynamic (. false .) call omp_set_num_threads ( omp_threads ) ! check OpenMP parallel environment correctness !$OMP PARALLEL      & !$OMP DEFAULT(none) & !$OMP SHARED(omp_threads) omp_threads = omp_get_num_threads () !$OMP END PARALLEL #endif call init () call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) t = 0._R_P call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_omp_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-time_serie.dat' , & t = t ) system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + dt call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_omp_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages ))) print \"(I5,A,F23.15)\" , omp_threads , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_openmp_no_foodie","tags":"","loc":"sourcefile/euler-1d-openmp_no_foodie.f90.html","title":"euler-1D-openmp_no_foodie.f90 – FOODIE"},{"text":"Define Euler 1D (OpenMP enabled) field without extending FOODIE integrand. Source Code !< Define Euler 1D (OpenMP enabled) field without extending FOODIE integrand. module type_euler_1D_openmp_no_foodie !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D (OpenMP enabled) field without extending FOODIE integrand. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D_omp_nf public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: euler_1D_omp_nf !< Euler 1D (OpenMP enabled) PDEs system field. !< !< @note This object does not use FOODIE. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. ! private methods procedure , pass ( self ), private :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), private :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_omp_nf type :: tvd_runge_kutta_integrator !< TVD RK integrator. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy => destroy_rk !< Destroy the integrator. procedure , pass ( self ), public :: init => init_rk !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate => integrate_rk !< Integrate integrand field. final :: finalize_rk !< Finalize object. endtype tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! type bound procedures of tvd_runge_kutta_integrator ! public methods elemental subroutine init_rk ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init_rk elemental subroutine destroy_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy_rk subroutine integrate_rk ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( euler_1D_omp_nf ), intent ( INOUT ) :: U !< Field to be integrated. class ( euler_1D_omp_nf ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s )% U = stage ( s )% U + stage ( ss )% U * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t () enddo ! computing new time step do s = 1 , self % stages U % U = U % U + stage ( s )% U * ( Dt * self % beta ( s )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate_rk ! private methods elemental subroutine finalize_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_rk ! type bound procedures of euler_1D_omp_nf ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! private methods function dEuler_dt ( self ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. type ( euler_1D_omp_nf ) :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F, PR) do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals dState_dt = self !$OMP PARALLEL PRIVATE(i) SHARED(self, dState_dt, F) !$OMP DO do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: lhs !< Left hand side. class ( euler_1D_omp_nf ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_omp_nf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Nc , 1 : lhs % Ni )) endif if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) if ( allocated ( rhs % U )) then !$OMP DO do i = 1 , lhs % Ni lhs % U (:, i ) = rhs % U (:, i ) enddo endif !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- !$OMP PARALLEL PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) SHARED(self, primitive, r_primitive) select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction !$OMP DO do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction !$OMP DO do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect !$OMP END PARALLEL return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D_openmp_no_foodie","tags":"","loc":"sourcefile/type_euler-1d-openmp_no_foodie.f90.html","title":"type_euler-1D-openmp_no_foodie.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Euler 1D PDEs system. Source Code !< Test FOODIE with the integration of Euler 1D PDEs system. program integrate_euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D_openmp , only : euler_1D_openmp use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot #ifdef OPENMP use OMP_LIB #endif !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_openmp ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. type ( euler_1D_openmp ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: steps_max !< Maximum number of time steps. integer ( I_P ) :: omp_threads !< Number of OpenMP threads. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D-openmp' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration, OpenMP enabled' , & examples = [ \"euler-1D-openmp --results  \" , & \"euler-1D-openmp -r -t -v -p\" , & \"euler-1D-openmp            \" , & \"euler-1D-openmp --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) call cli % add ( switch = '--omp_threads' , help = 'Number of OpenMP threads used' , required = . false ., act = 'store' , def = '1' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--omp_threads' , val = omp_threads , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop #ifdef OPENMP call omp_set_dynamic (. false .) call omp_set_num_threads ( omp_threads ) ! check OpenMP parallel environment correctness !$OMP PARALLEL      & !$OMP DEFAULT(none) & !$OMP SHARED(omp_threads, verbose) omp_threads = omp_get_num_threads () if ( verbose ) print \"(A)\" , ' Thread ' // trim ( str (. true ., omp_get_thread_num ())) // ' of: ' // trim ( str (. true ., omp_threads )) // ' is alive!' !$OMP END PARALLEL #endif call init () call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) t = 0._R_P call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_openmp_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-time_serie.dat' , & t = t ) system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + dt call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_openmp_integration-tvdrk-' // trim ( str (. true ., rk_stages ))) print \"(I5,A,F23.15)\" , omp_threads , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_openmp","tags":"","loc":"sourcefile/euler-1d-openmp.f90.html","title":"euler-1D-openmp.f90 – FOODIE"},{"text":"Define Euler 1D (OpenMP enabled) field that is a concrete extension of the abstract integrand type. Source Code !< Define Euler 1D (OpenMP enabled) field that is a concrete extension of the abstract integrand type. module type_euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D (OpenMP enabled) field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: euler_1D_openmp !< Euler 1D (OpenMP enabled) PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !<||euler-euler||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! ADT integrand deferred methods function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F, PR) do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D_openmp :: dState_dt ) select type ( dState_dt ) class is ( euler_1D_openmp ) dState_dt = self endselect !$OMP PARALLEL PRIVATE(i) SHARED(self, dState_dt, F) select type ( dState_dt ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_openmp ) error = 0._R_P do i = 1 , lhs % Ni do v = 1 , lhs % Nc error = error + ( lhs % U ( v , i ) - rhs % U ( v , i )) ** 2 / lhs % U ( v , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) * rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) * rhs enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D_openmp ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = rhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , rhs % Ni opr % U (:, i ) = rhs % U (:, i ) * lhs enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) + rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) - rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_openmp ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Nc , 1 : lhs % Ni )) endif if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) select type ( rhs ) class is ( euler_1D_openmp ) if ( allocated ( rhs % U )) then !$OMP DO do i = 1 , lhs % Ni lhs % U (:, i ) = rhs % U (:, i ) enddo endif endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) then !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) do i = 1 , lhs % Ni lhs % U (:, i ) = rhs enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real ! private methods pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- !$OMP PARALLEL PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) SHARED(self, primitive, r_primitive) select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction !$OMP DO do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction !$OMP DO do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect !$OMP END PARALLEL return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D_openmp","tags":"","loc":"sourcefile/type_euler-1d-openmp.f90.html","title":"type_euler-1D-openmp.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Burgers equation. Source Code !< Test FOODIE with the integration of Burgers equation. program integrate_burgers !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Burgers equation. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_burgers , only : burgers use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( burgers ) :: domain !< Burgers field domain. real ( R_P ), parameter :: CFL = 0.1_R_P !< CFL value. real ( R_P ), parameter :: t_final = 0.6_R_P !< Final time. real ( R_P ), parameter :: nu = 1._R_P !< Viscosity. integer ( I_P ), parameter :: Ni = 100 !< Number of grid nodes. real ( R_P ) :: h !< Space step discretization. real ( R_P ) :: initial_state ( 1 : Ni ) !< Initial state. real ( R_P ) :: x ( 1 : Ni ) !< Nodes values. real ( R_P ), allocatable :: final_state (:) !< Final state. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'burgers' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Burgers equation integration' , & examples = [ \"burgers --solver euler --results  \" , & \"burgers --solver ls-runge-kutta -r\" , & \"burgers --solver adams-bashforth  \" , & \"burgers --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! create Burgers field initial state call init () ! integrate Burgers equation select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- h = 2._R_P * pi / Ni do i = 1 , Ni x ( i ) = h * ( i - 1 ) initial_state ( i ) = 1 0._R_P * sin ( x ( i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"U\"' do i = 1 , Ni write ( rawfile , '(2(' // FR_P // ',1X))' ) x ( i ), final_state ( i ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) call plt % add_plot ( x = x , y = final_state , label = 'U' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( burgers ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = s ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t ( s ) < t_final ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), Dt = Dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit ' // & 'Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'burgers_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of explicit Euler solver' call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit Euler' , & filename = 'burgers_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( burgers ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( burgers ) :: previous ( 1 : 2 ) !< Previous time steps solutions. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = 2 ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t < t_final ) if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit leapfrog scheme' ,& filename = 'burgers_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit low storage Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit TVD Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_burgers","tags":"","loc":"sourcefile/burgers.f90.html","title":"burgers.f90 – FOODIE"},{"text":"Define Burgers field that is a concrete extension of the abstract integrand type. Source Code !< Define Burgers field that is a concrete extension of the abstract integrand type. module type_burgers !----------------------------------------------------------------------------------------------------------------------------------- !< Define Burgers field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: burgers !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: burgers !< Burgers equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Burgers PDE equation !<The Burgers PDE equation is a non linear PDE widely used as numerical benchmark that can be applied to describe !<a wide range of different problems, from fluid dynamics to traffic flows, see [1]. !< !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = [u]\\;\\;\\; !<F(U) = [-\\frac{1}{2}u&#94;2+\\nu u_x] !<\\end{matrix} !< !< !<This is the viscous Burgers' equation, \\nu being the viscosity. This equation is of paramount relevance because it retains !<complex aspects such as the hyperbolic nature of the convection term (allowing discontinuous solutions) and the diffusive nature !<of the viscous term. !< !<#### Bibliography !< !<[1] *The partial differential equation ut + uux = nuxx*, Hopf, Eberhard, Communications on Pure and Applied Mathematics, !< vol 3, issue 3, doi 10.1002/cpa.3160030302, pp. 201--230, 1950. !< !<#### State variables organization !< State variable is organized as an array (rank 1) for whole physical domain. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: Ni = 0 !< Number of grid nodes. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ) :: h = 0._R_P !< Space step discretization. real ( R_P ) :: nu = 0._R_P !< Viscosity. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, whole physical domain, [1:Ni]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:Ni,1:steps]. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Burgers field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dBurgers_dt !< Time derivative, residuals func. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: local_error => burgers_local_error !< Local error. procedure , pass ( lhs ), public :: integrand_multiply_integrand => burgers_multiply_burgers !< Burgers * burgers operator. procedure , pass ( lhs ), public :: integrand_multiply_real => burgers_multiply_real !< Burgers * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_burgers !< Real * Burgers operator. procedure , pass ( lhs ), public :: add => add_burgers !< Burgers + Burgers operator. procedure , pass ( lhs ), public :: sub => sub_burgers !< Burgers - Burgers operator. procedure , pass ( lhs ), public :: assign_integrand => burgers_assign_burgers !< Burgers = Burgers. procedure , pass ( lhs ), public :: assign_real => burgers_assign_real !< Burgers = real. ! private methods procedure , pass ( self ), private :: x => dBurgers_dx !< 1st derivative. procedure , pass ( self ), private :: xx => d2Burgers_dx2 !< 2nd derivative. endtype burgers !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , initial_state , Ni , h , nu , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: Ni !< Number of grid nodes. real ( R_P ), dimension ( 1 : Ni ), intent ( IN ) :: initial_state !< Initial state of Burgers field domain. real ( R_P ), intent ( IN ) :: h !< Space step discretization. real ( R_P ), intent ( IN ) :: nu !< Viscosity. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : Ni , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % Ni = Ni self % h = h self % nu = nu return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Burgers field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), dimension (:), allocatable :: state !< Burgers state variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , CFL ) result ( dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step, by means of CFL condition. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), intent ( IN ) :: CFL !< Courant-Friedricks-Lewi stability coefficient. real ( R_P ) :: dt !< Current time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dt = CFL * self % h ** 2 / self % nu return !--------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! ADT integrand deferred methods function dBurgers_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Burgers field, residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Burgers field time derivative. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: dState_dt ) select type ( dState_dt ) class is ( burgers ) dState_dt = self dState_dt = self % xx () * self % nu dState_dt = dState_dt - self * self % x () endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dBurgers_dt subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( burgers ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: previous ) select type ( previous ) class is ( burgers ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step function burgers_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 burgers approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( burgers ) error = 0._R_P do i = 1 , lhs % dims error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_local_error function burgers_multiply_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_burgers function burgers_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_real function real_multiply_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( burgers ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_burgers function add_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_burgers function sub_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_burgers subroutine burgers_assign_burgers ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Burgers field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( burgers ) lhs % Ni = rhs % Ni lhs % steps = rhs % steps lhs % h = rhs % h lhs % nu = rhs % nu if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_burgers subroutine burgers_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_real ! private methods function dBurgers_dx ( self ) result ( derivative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the first order spatial derivative of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. type ( burgers ) :: derivative !< Burgers field derivative. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- derivative = self do i = 2 , self % Ni - 1 derivative % U ( i ) = ( self % U ( i + 1 ) - self % U ( i - 1 )) / ( 2._R_P * self % h ) enddo derivative % U ( 1 ) = ( self % U ( 2 ) - self % U ( self % Ni )) / ( 2._R_P * self % h ) derivative % U ( self % Ni ) = ( self % U ( 1 ) - self % U ( self % Ni - 1 )) / ( 2._R_P * self % h ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction function d2Burgers_dx2 ( self ) result ( derivative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the second order spatial derivative of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. type ( burgers ) :: derivative !< Burgers field derivative. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- derivative = self do i = 2 , self % Ni - 1 derivative % U ( i ) = ( self % U ( i + 1 ) - 2._R_P * self % U ( i ) + self % U ( i - 1 )) / ( self % h ** 2 ) enddo derivative % U ( 1 ) = ( self % U ( 2 ) - 2._R_P * self % U ( 1 ) + self % U ( self % Ni )) / ( self % h ** 2 ) derivative % U ( self % Ni ) = ( self % U ( 1 ) - 2._R_P * self % U ( self % Ni ) + self % U ( self % Ni - 1 )) / ( self % h ** 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction endmodule type_burgers","tags":"","loc":"sourcefile/type_burgers.f90.html","title":"type_burgers.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Euler 1D PDEs system. Source Code !< Test FOODIE with the integration of Euler 1D PDEs system. program integrate_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D , only : euler_1D use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( euler_1D ) :: domain !< Domain of Euler equations. integer ( I_P ) :: Ns !< Number of differnt initial gas species. integer ( I_P ) :: Nc !< Number of conservative variables, Nc=Ns+2. integer ( I_P ) :: Np !< Number of primitive variables, Np=Ns+4. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: CFL !< CFL value. real ( R_P ) :: t_final !< Final time. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. real ( R_P ), allocatable :: cp0 (:) !< Specific heat at constant pressure [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat at constant volume [1:Ns]. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables [1:Np,1:Ni]. real ( R_P ), allocatable :: xcenter (:) !< Cell center x-abscissa values, [1:Ni]. real ( R_P ), allocatable :: xnode (:) !< Cell node x-abscissa values, [0:Ni]. real ( R_P ), allocatable :: av_xnode (:) !< Average-grid cell node x-abscissa values, [0:Ni]. real ( R_P ), allocatable :: final_state (:,:) !< Final state. real ( R_P ), allocatable :: av_state (:,:) !< Average-grid final state. character ( len = :), allocatable :: variables !< Variables names list. character ( len = :), allocatable :: output !< Output files basename. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: stages_steps !< Number of stages/steps used. character ( 99 ) :: solver !< Solver used. character ( 99 ) :: problem !< Problem solved. character ( 99 ) :: output_cli !< Output files basename. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: av_Ni !< Average the solution over an average-grid. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration' , & examples = [ \"euler-1D --solver euler --results  \" , & \"euler-1D --solver ls-runge-kutta -r\" , & \"euler-1D --solver adams-bashforth  \" , & \"euler-1D --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver' , required = . true ., act = 'store' ) call cli % add ( switch = '--problem' , help = 'Problem solved' , required = . false ., def = 'sod' , act = 'store' , choices = 'sod,smooth' ) call cli % add ( switch = '--Ni' , help = 'Number finite volumes' , required = . false ., act = 'store' , def = '100' ) call cli % add ( switch = '--av_Ni' , help = 'Number finite volumes over average the solution' , required = . false ., act = 'store' , def = '-1' ) call cli % add ( switch = '--ss' , help = 'Stages/steps used' , required = . false ., act = 'store' , def = '-1' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--output' , help = 'Output files basename' , required = . false ., act = 'store' , def = 'unset' ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--solver' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--problem' , val = problem , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--av_Ni' , val = av_Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--ss' , val = stages_steps , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--results' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--plots' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--tserie' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--output' , val = output_cli , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop ! create Euler field initial state call init () ! integrate Euler equation select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Species counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( xcenter ( 1 : Ni )) allocate ( xnode ( 0 : Ni )) Dx = 1._R_P / Ni do i = 1 , Ni xcenter ( i ) = Dx * i - 0.5_R_P * Dx enddo do i = 0 , Ni xnode ( i ) = Dx * i enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then allocate ( av_xnode ( 0 : av_Ni )) do i = 0 , av_Ni av_xnode ( i ) = 1._R_P / av_Ni * i enddo endif select case ( trim ( adjustl ( problem ))) case ( 'sod' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.2_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str (. true ., s )) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case ( 'smooth' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.1_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str (. true ., s )) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni initial_state (:, i ) = [ 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! rho(s) 0.5_R_P * ( xcenter ( i ) - 0.5_R_P ) ** 4 , & ! u 1 0._R_P + 2._R_P * xcenter ( i ) ** 4 , & ! p 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case default print \"(A)\" , 'Error: unknown problem \"' // trim ( adjustl ( problem )) // '\"' print \"(A)\" , 'Valid problem names are:' print \"(A)\" , '  + sod' print \"(A)\" , '  + smooth' stop endselect if ( trim ( adjustl ( output_cli )) /= 'unset' ) then output = trim ( adjustl ( output_cli )) // '-' // trim ( adjustl ( solver )) else output = 'euler_1D_integration-' // trim ( adjustl ( solver )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine average_solution () !--------------------------------------------------------------------------------------------------------------------------------- !< Average the solution over an average grid. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i , ii , i1 , i2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then if ( allocated ( av_state )) deallocate ( av_state ) ; allocate ( av_state ( 1 : Np , 1 : av_Ni )) do i = 1 , av_Ni i1 = minloc ( array = xcenter , dim = 1 , mask = ( xcenter >= av_xnode ( i - 1 ))) i2 = maxloc ( array = xcenter , dim = 1 , mask = ( xcenter <= av_xnode ( i ))) av_state (:, i ) = 0._R_P do ii = i1 , i2 av_state (:, i ) = av_state (:, i ) + final_state (:, ii ) enddo av_state (:, i ) = av_state (:, i ) / ( i2 - i1 + 1 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine average_solution subroutine save_results ( title , basename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: basename !< Output basename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = basename // '-' // trim ( str (. true ., Ni )) // '_cells.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) variables write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str (. true ., Ni )) // ' cells\", I=' // trim ( str (. true ., Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 1 )) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str (. true ., Ni + 1 )) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( rawfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then print \"(A)\" , ' Average solution from Ni: ' // trim ( str (. true ., Ni )) // ' to av_Ni: ' // trim ( str (. true ., av_Ni )) call average_solution write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str (. true ., Ni )) // ' cells averaged over ' // trim ( str (. true ., av_Ni )) // & ' cells\", I=' // trim ( str (. true ., av_Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 1 )) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str (. true ., av_Ni + 1 )) // '(' // FR_P // ',1X))' ) av_xnode do v = 1 , Np write ( rawfile , '(' // trim ( str (. true ., av_Ni )) // '(' // FR_P // ',1X))' ) av_state ( v , :) enddo endif close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = xcenter , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = xcenter , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( basename // '-' // trim ( str (. true ., Ni )) // '_cells.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) 'TITLE=\"' // title // '\"' endif write ( tsfile , '(A)' ) variables // ' \"t\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\", I=' // trim ( str (. true ., Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 2 )) // ']=CELLCENTERED)' write ( tsfile , '(' // trim ( str (. true ., Ni + 1 )) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( tsfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo write ( tsfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' )( t , v = 1 , Ni ) if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( euler_1D ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of Adams-Bashforth class of solvers' steps_range = [ 1 , ab_steps ] ; if ( stages_steps > 0 ) steps_range = [ stages_steps , stages_steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' AB-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' steps' call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 1 ) call rk_integrator % init ( stages = s ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 3 ) call rk_integrator % init ( stages = s ) case ( 4 , 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 7 ) call rk_integrator % init ( stages = 5 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , t = t ( s )) step = 1 do while ( t ( s ) < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t ( s ), CFL = 0.1_R_P * CFL ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), dt = dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 call save_time_serie ( t = t ( s )) enddo call save_time_serie ( t = t ( s ), finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of explicit Euler solver' title = '1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '  Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( euler_1D ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( euler_1D ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of leapfrog (RAW filtered) class of solvers' title = '1D Euler equations integration, explicit leapfrog (RAW filtered), t=' // str ( n = t_final ) call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = 2 , ord = 3 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) step = 1 do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = 0.1_R_P * CFL ) if ( 2 >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of low storage (2N) Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of TVD/SSP Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit TVD/SSP Runge-Kutta, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_euler_1D","tags":"","loc":"sourcefile/euler-1d.f90.html","title":"euler-1D.f90 – FOODIE"},{"text":"Define Euler 1D field that is a concrete extension of the abstract integrand type. Source Code !< Define Euler 1D field that is a concrete extension of the abstract integrand type. module type_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: euler_1D !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: steps = 0 !< Number of time steps stored. integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real ( R_P ), allocatable :: previous (:,:,:) !< Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , steps , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 ; if ( present ( steps )) self % steps = steps self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % Nc , 1 : Ni , 1 : self % steps )) endif self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo if ( self % steps > 0 ) then do s = 1 , self % steps do i = 1 , Ni self % previous (:, i , s ) = self % primitive2conservative ( initial_state (:, i )) enddo enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % previous )) deallocate ( self % previous ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! ADT integrand deferred methods function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Nc => self % Nc , Np => self % Np , Ns => self % Ns , U => self % U , previous => self % previous ) ! allocate temporary arrays allocate ( F ( 1 : Nc , 0 : Ni )) ; F = 0._R_P allocate ( P ( 1 : Np , 1 - Ng : Ni + Ng )) ; P = 0._R_P allocate ( PR ( 1 : Np , 1 : 2 , 0 : Ni + 1 )) ; PR = 0._R_P ! compute primitive variables do i = 1 , Ni P (:, i ) = self % conservative2primitive ( U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , Ni call self % riemann_solver ( r1 = PR ( Ns + 3 , 2 , i ), u1 = PR ( Ns + 1 , 2 , i ), p1 = PR ( Ns + 2 , 2 , i ), g1 = PR ( Ns + 4 , 2 , i ), & r4 = PR ( Ns + 3 , 1 , i + 1 ), u4 = PR ( Ns + 1 , 1 , i + 1 ), p4 = PR ( Ns + 2 , 1 , i + 1 ), g4 = PR ( Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : Ns , 2 , i ) / PR ( Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : Ns , 1 , i + 1 ) / PR ( Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D :: dState_dt ) select type ( dState_dt ) class is ( euler_1D ) dState_dt = self do i = 1 , Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, :, s ) = self % previous (:, :, s + 1 ) enddo self % previous (:, :, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( euler_1D ) do s = 1 , self % steps self % previous (:, :, s ) = self % previous (:, :, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: previous ) select type ( previous ) class is ( euler_1D ) previous = self previous % U = self % previous (:, :, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) lhs % steps = rhs % steps lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real ! private methods pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions pure subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Ns => self % Ns , Np => self % Np , ord => self % ord , cv0 => self % cv0 , cp0 => self % cp0 , weno => self % weno ) select case ( ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = Ns , Np = Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = Ns , Np = Np , primitive = Pm (:, f )) enddo do j = i + 1 - Ng , i - 1 + Ng do f = 1 , 2 do v = 1 , Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : Ns + 2 , f ), primitive ( 1 : Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , Ns + 2 call weno % interpolate ( S = Ng , & stencil = C ( 1 : 2 , 1 - Ng : - 1 + Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : Ns + 2 , f ), CR ( 1 : Ns + 2 , f )) enddo r_primitive ( Ns + 3 , f , i ) = sum ( r_primitive ( 1 : Ns , f , i )) r_primitive ( Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cp0 ) / & dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cv0 ) enddo enddo endselect endassociate return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D","tags":"","loc":"sourcefile/type_euler-1d.f90.html","title":"type_euler-1D.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Lorenz equations. Source Code !< Test FOODIE with the integration of Lorenz equations. program integrate_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Lorenz equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_lorenz , only : lorenz use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( lorenz ) :: attractor !< Lorenz field. integer , parameter :: num_steps = 2000 !< Maximum time steps. integer , parameter :: space_dimension = 3 !< Space dimensions. real ( R_P ), parameter :: sigma = 1 0._R_P !< Lorenz' \\sigma. real ( R_P ), parameter :: rho = 2 8._R_P !< Lorenz' \\rho. real ( R_P ), parameter :: beta = 8._R_P / 3._R_P !< Lorenz' \\beta. real ( R_P ), parameter :: dt = 0.01_R_P !< Time step. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 1. , 1. , 1. ] !< Initial state. real ( R_P ) :: solution ( 0 : space_dimension , 0 : num_steps ) !< Solution at each time step. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'lorenz' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Lorenz equations integration' , & examples = [ \"lorenz --solver euler --results  \" , & \"lorenz --solver ls-runge-kutta -r\" , & \"lorenz --solver adams-bashforth  \" , & \"lorenz --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! integrate Lorenz equations select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\" \"z\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 3 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'x' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'y' , linestyle = 'b-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 3 , :), label = 'z' , linestyle = 'g-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'x-y path' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 3 , :), label = 'x-z path' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 2 , :), y = solution ( 3 , :), label = 'y-z path' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( lorenz ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call ab_integrator % integrate ( U = attractor , previous = previous ( 1 : s ), dt = dt , t = solution ( 0 , step - s : step - 1 )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'lorenz_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of explicit Euler solver' call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call euler_integrator % integrate ( U = attractor , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Euler' , & filename = 'lorenz_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( lorenz ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( lorenz ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = 2 ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call lf_integrator % integrate ( U = attractor , previous = previous , dt = dt , t = solution ( 0 , step ), filter = filter ) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit leapfrog scheme' ,& filename = 'lorenz_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit low storage Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'lorenz_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit TVD Runge-Kutta ' // trim ( str (. true ., s )) // ' stages' ,& filename = 'lorenz_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_lorenz","tags":"","loc":"sourcefile/lorenz.f90.html","title":"lorenz.f90 – FOODIE"},{"text":"Define Lorenz field that is a concrete extension of the abstract integrand type. Source Code !< Define Lorenz field that is a concrete extension of the abstract integrand type. module type_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Define Lorenz field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: lorenz !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Lorenz ODEs system !<The Lorenz' equations system [1] is a non linear system of pure ODEs that retains a reasonable-complex behaviour: such a !<system, for a certain parameters-region exhibits a chaotic dynamics useful for testing FOODIE solvers. !< !<The Lorenz' ODEs system can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< v_1 \\\\ !< v_2 \\\\ !< v_3 !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< \\sigma (v_2-v_1) \\\\ !< v_1(\\rho - v_3) -v_2 \\\\ !< v_1 v_2 - \\beta v_3 !< \\end{bmatrix} !<\\end{matrix} !< !<The parameters set is constant and it is here selected as: !< !<\\begin{matrix} !< \\sigma = 10 \\\\ !< \\rho = 28 \\\\ !< \\beta = \\frac{8}{3} !<\\end{matrix} !< !<These values are chaos-inducing thus they magnify the eventual numerical inaccuracies of FOODIE solvers, see [2]. !< !<#### Bibliography !< !<[1] *Deterministic Nonperiodic Flow*, Lorenz E.N., Journal of the Atmospheric Sciences, 1963, vol. 20, pp. 130--141, !<doi: http://dx.doi.org/10.1175/1520-0469(1963)020<0130:DNF>2.0.CO;2 !< !<[2] *Scientific software design: the object-oriented way*, Rouson, Damian, Jim Xia, and Xiaofeng Xu, !<Cambridge University Press, 2011 !< !<#### State variables organization !< State variables are organized as an array (rank 1) of reals of *dims* elements, in this case 3 elements. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, [1:dims]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:dims,1:steps]. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Lorenz field. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => lorenz_local_error !< Local error. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => lorenz_multiply_lorenz !< Lorenz * Lorenz operator. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< Lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz operator. procedure , pass ( lhs ), public :: sub => sub_lorenz !< Lorenz - Lorenz. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. endtype lorenz !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , initial_state , sigma , rho , beta , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Initial state of Lorenz field vector. real ( R_P ), intent ( IN ) :: sigma !< Lorenz  \\sigma. real ( R_P ), intent ( IN ) :: rho !< Lorenz  \\rho. real ( R_P ), intent ( IN ) :: beta !< Lorenz  \\beta. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % dims )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % dims , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % sigma = sigma self % rho = rho self % beta = beta return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Lorenz field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), dimension (:), allocatable :: state !< Lorenz state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output ! ADT integrand deferred methods function dLorenz_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Lorenz field time derivative. integer ( I_P ) :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: dState_dt ) select type ( dState_dt ) class is ( lorenz ) dState_dt = self dState_dt % U ( 1 ) = self % sigma * ( self % U ( 2 ) - self % U ( 1 )) dState_dt % U ( 2 ) = self % U ( 1 ) * ( self % rho - self % U ( 3 )) - self % U ( 2 ) dState_dt % U ( 3 ) = self % U ( 1 ) * self % U ( 2 ) - self % beta * self % U ( 3 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dLorenz_dt subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( lorenz ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: previous ) select type ( previous ) class is ( lorenz ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step function lorenz_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 lorenz approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) error = 0._R_P do i = 1 , lhs % dims error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_local_error function lorenz_multiply_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a lorenz field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_lorenz function lorenz_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Lorenz field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_real function real_multiply_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( lorenz ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_lorenz function add_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Lorenz function sub_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_lorenz subroutine lorenz_assign_lorenz ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Lorenz field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) lhs % dims = rhs % dims lhs % steps = rhs % steps if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous lhs % sigma = rhs % sigma lhs % rho = rhs % rho lhs % beta = rhs % beta endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_lorenz subroutine lorenz_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_real endmodule type_lorenz","tags":"","loc":"sourcefile/type_lorenz.f90.html","title":"type_lorenz.f90 – FOODIE"},{"text":"type, public, abstract :: integrand Abstract type for building FOODIE ODE integrators. Components Type Visibility Attributes Name Initial class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. Type-Bound Procedures procedure( time_derivative ), public, pass(self), deferred :: t Time derivative, residuals. function time_derivative (self, t) result(dState_dt) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function. procedure( local_error_operator ), public, pass(lhs), deferred :: local_error ||integrand - integrand||. function local_error_operator (lhs, rhs) result(error) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 solution approximations. procedure( symmetric_operator ), public, pass(lhs), deferred :: integrand_multiply_integrand Integrand * integrand operator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. procedure( integrand_op_real ), public, pass(lhs), deferred :: integrand_multiply_real Integrand * real operator. function integrand_op_real (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real. procedure( real_op_integrand ), public, pass(rhs), deferred :: real_multiply_integrand Real * integrand operator. function real_op_integrand (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand. procedure( symmetric_operator ), public, pass(lhs), deferred :: add Integrand + integrand operator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. procedure( symmetric_operator ), public, pass(lhs), deferred :: sub Integrand - integrand operator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. procedure( assignment_integrand ), public, pass(lhs), deferred :: assign_integrand Integrand = integrand. subroutine assignment_integrand (lhs, rhs) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. pass(lhs) deferred local_error () Arguments None Description ||integrand - integrand||. generic, public :: operator(+) => add Overloading + operator. pass(lhs) deferred add () Arguments None Description Integrand + integrand operator. generic, public :: operator(-) => sub Overloading - operator. pass(lhs) deferred sub () Arguments None Description Integrand - integrand operator. generic, public :: operator(*) => integrand_multiply_integrand , real_multiply_integrand , integrand_multiply_real Overloading * operator. pass(lhs) deferred integrand_multiply_integrand () Arguments None Description Integrand * integrand operator. pass(rhs) deferred real_multiply_integrand () Arguments None Description Real * integrand operator. pass(lhs) deferred integrand_multiply_real () Arguments None Description Integrand * real operator. generic, public :: assignment(=) => assign_integrand Overloading = assignament. pass(lhs) deferred assign_integrand () Arguments None Description Integrand = integrand. Source Code type , abstract :: integrand !< Abstract type for building FOODIE ODE integrators. #ifdef CAF class ( * ), allocatable :: dummy_to_allow_extensions [:] !< Dummy member to allow concrete extensions with coarray members. #endif contains ! public deferred procedures that concrete integrand-field must implement procedure ( time_derivative ), pass ( self ), deferred , public :: t !< Time derivative, residuals. ! operators procedure ( local_error_operator ), pass ( lhs ), deferred , public :: local_error !< ||integrand - integrand||. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_multiply_integrand !< Integrand * integrand operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_multiply_real !< Integrand * real operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_multiply_integrand !< Real * integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: add !< Integrand + integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: sub !< Integrand - integrand operator. procedure ( assignment_integrand ), pass ( lhs ), deferred , public :: assign_integrand !< Integrand = integrand. ! operators overloading generic , public :: operator (. lterror .) => local_error !< Estimate local truncation error. generic , public :: operator ( + ) => add !< Overloading + operator. generic , public :: operator ( - ) => sub !< Overloading - operator. generic , public :: operator ( * ) => integrand_multiply_integrand , & real_multiply_integrand , & integrand_multiply_real !< Overloading * operator. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. endtype integrand","tags":"","loc":"type/integrand.html","title":"integrand – FOODIE "},{"text":"type, public :: adams_bashforth_integrator FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 4rd order accurate. Note The integrator must be created or initialized (initialize the b coefficients) before used.\n Finalize object. Inherited By type~~adams_bashforth_integrator~~InheritedByGraph type~adams_bashforth_integrator adams_bashforth_integrator type~adams_bashforth_moulton_integrator adams_bashforth_moulton_integrator type~adams_bashforth_integrator->type~adams_bashforth_moulton_integrator predictor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps. real(kind=R_P), private, allocatable :: b (:) b coefficients. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth integrator: initialize the b coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, autoupdate) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Description Integrate field with Adams-Bashforth class scheme. procedure, public, pass(self) :: update_previous Cyclic update previous time steps. private subroutine update_previous (self, U, previous) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Description Cyclic update previous time steps. Source Code type :: adams_bashforth_integrator !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 4rd order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. private integer ( I_P ) :: steps = 0 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< b coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. final :: finalize !< Finalize object. endtype adams_bashforth_integrator","tags":"","loc":"type/adams_bashforth_integrator.html","title":"adams_bashforth_integrator – FOODIE "},{"text":"type, public :: adams_bashforth_moulton_integrator type~~adams_bashforth_moulton_integrator~~InheritsGraph type~adams_bashforth_moulton_integrator adams_bashforth_moulton_integrator type~adams_bashforth_integrator adams_bashforth_integrator type~adams_bashforth_integrator->type~adams_bashforth_moulton_integrator predictor type~adams_moulton_integrator adams_moulton_integrator type~adams_moulton_integrator->type~adams_bashforth_moulton_integrator corrector Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. Note The integrator must be created or initialized (predictor and corrector schemes selection) before used.\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = -1 Number of time steps. type( adams_bashforth_integrator ), private :: predictor Predictor solver. type( adams_moulton_integrator ), private :: corrector Corrector solver. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. Description Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth-Moulton integrator: initialize the b coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, iterations) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(in) :: self Actual ABM integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations of AM scheme. Description Integrate field with Adams-Bashforth-Moulton class scheme. Source Code type :: adams_bashforth_moulton_integrator !< FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. !< !< @note The integrator must be created or initialized (predictor and corrector schemes selection) before used. private integer ( I_P ) :: steps =- 1 !< Number of time steps. type ( adams_bashforth_integrator ) :: predictor !< Predictor solver. type ( adams_moulton_integrator ) :: corrector !< Corrector solver. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype adams_bashforth_moulton_integrator","tags":"","loc":"type/adams_bashforth_moulton_integrator.html","title":"adams_bashforth_moulton_integrator – FOODIE "},{"text":"type, public :: adams_moulton_integrator FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 3rd order accurate. Note The integrator must be created or initialized (initialize the b coefficients) before used.\n Finalize object. Inherited By type~~adams_moulton_integrator~~InheritedByGraph type~adams_moulton_integrator adams_moulton_integrator type~adams_bashforth_moulton_integrator adams_bashforth_moulton_integrator type~adams_moulton_integrator->type~adams_bashforth_moulton_integrator corrector Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = -1 Number of time steps. real(kind=R_P), private, allocatable :: b (:) b coefficients. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( adams_moulton_integrator ), intent(inout) :: self AB integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. Description Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, steps) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Moulton integrator: initialize the b coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, iterations, autoupdate) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Description Integrate field with Adams-Moulton class scheme. procedure, public, pass(self) :: update_previous Cyclic update previous time steps. private subroutine update_previous (self, U, previous) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Description Cyclic update previous time steps. Source Code type :: adams_moulton_integrator !< FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 3rd order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. private integer ( I_P ) :: steps =- 1 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< b coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. final :: finalize !< Finalize object. endtype adams_moulton_integrator","tags":"","loc":"type/adams_moulton_integrator.html","title":"adams_moulton_integrator – FOODIE "},{"text":"type, public :: emd_runge_kutta_integrator FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. Note The integrator must be created or initialized (initialize the RK coefficients) before used.\n Finalize object. Components Type Visibility Attributes Name Initial real(kind=R_P), public :: tolerance = 0._R_P Tolerance on the local truncation error. real(kind=R_P), public :: pp1_inv = 0._R_P 1/(p+1) where p is the accuracy order of the lower accurate scheme of the pair. integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:,:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( emd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, stages, tolerance) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. real(kind=R_P), intent(in), optional :: tolerance Tolerance on the local truncation error (default 0.01). Description Create the actual RK integrator: initialize the Butcher' table coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(inout) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit embedded Runge-Kutta scheme. procedure, private, pass(self) :: new_Dt Compute new estimation of the time step Dt. private elementalsubroutine new_Dt (self, error, Dt) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Integrator. real(kind=R_P), intent(in) :: error Local truncation error estimation. real(kind=R_P), intent(inout) :: Dt Time step. Description Compute new estimation of the time step Dt. Source Code type :: emd_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. real ( R_P ) :: tolerance = 0._R_P !< Tolerance on the local truncation error. real ( R_P ) :: pp1_inv = 0._R_P !< 1/(p+1) where p is the accuracy order of the lower accurate scheme of the pair. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:,:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), private :: new_Dt !< Compute new estimation of the time step Dt. final :: finalize !< Finalize object. endtype emd_runge_kutta_integrator","tags":"","loc":"type/emd_runge_kutta_integrator.html","title":"emd_runge_kutta_integrator – FOODIE "},{"text":"type, public :: euler_explicit_integrator FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. Note The integrator can be used directly without any initialization. Type-Bound Procedures procedure, public, nopass :: integrate Integrate integrand field. private subroutine integrate (U, Dt, t) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. Description Integrate field with explicit Euler scheme, 1st order. Source Code type :: euler_explicit_integrator !< FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< @note The integrator can be used directly without any initialization. contains procedure , nopass , public :: integrate !< Integrate integrand field. endtype euler_explicit_integrator","tags":"","loc":"type/euler_explicit_integrator.html","title":"euler_explicit_integrator – FOODIE "},{"text":"type, public :: leapfrog_integrator FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Note The integrator could be used without initialialization (initialize the time filter coefficients) if the defulat values\n are suitable for the problem. Components Type Visibility Attributes Name Initial real(kind=R_P), private :: nu = 0.01_R_P Robert-Asselin filter coefficient. real(kind=R_P), private :: alpha = 0.53_R_P Robert-Asselin-Williams filter coefficient. Type-Bound Procedures procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, nu, alpha) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(inout) :: self LF integrator. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. Description Create the actual leapfrog integrator: initialize the filter coefficient. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, filter) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(in) :: self LF integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:2) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. class( integrand ), intent(inout), optional :: filter Filter field displacement. Description Integrate field with leapfrog class scheme. Source Code type :: leapfrog_integrator !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. !< !< @note The integrator could be used without initialialization (initialize the time filter coefficients) if the defulat values !< are suitable for the problem. private real ( R_P ) :: nu = 0.01_R_P !< Robert-Asselin filter coefficient. real ( R_P ) :: alpha = 0.53_R_P !< Robert-Asselin-Williams filter coefficient. contains procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. endtype leapfrog_integrator","tags":"","loc":"type/leapfrog_integrator.html","title":"leapfrog_integrator – FOODIE "},{"text":"type, public :: ls_runge_kutta_integrator FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. Note The integrator must be created or initialized (initialize the RK coefficients) before used.\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: A (:) Low storage A coefficients. real(kind=R_P), public, allocatable :: B (:) Low storage B coefficients. real(kind=R_P), public, allocatable :: C (:) Low storage C coefficients. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private subroutine init (self, stages) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' low storage table coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:2) Runge-Kutta registers [1:2]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit low storage Runge-Kutta scheme. Source Code type :: ls_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: A (:) !< Low storage *A* coefficients. real ( R_P ), allocatable :: B (:) !< Low storage *B* coefficients. real ( R_P ), allocatable :: C (:) !< Low storage *C* coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype ls_runge_kutta_integrator","tags":"","loc":"type/ls_runge_kutta_integrator.html","title":"ls_runge_kutta_integrator – FOODIE "},{"text":"type, public :: tvd_runge_kutta_integrator FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. Note The integrator must be created or initialized (initialize the RK coefficients) before used.\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Source Code type :: tvd_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype tvd_runge_kutta_integrator","tags":"","loc":"type/tvd_runge_kutta_integrator~3.html","title":"tvd_runge_kutta_integrator – FOODIE "},{"text":"type, public, extends(integrand) :: oscillation type~~oscillation~~InheritsGraph type~oscillation oscillation integrand integrand integrand->type~oscillation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Oscillation equations field. It is a FOODIE integrand class concrete extension. Oscillation ODEs system The (inertial) Oscillation equations system is a non linear system of pure ODEs and it can be written as: \\begin{matrix}\n U_t = R(U)  \\\\\n U = \\begin{bmatrix}\n v_1 \\\\\n v_2\n \\end{bmatrix}\\;\\;\\;\n R(U) = \\begin{bmatrix}\n -f v_2 \\\\\n f v_1\n \\end{bmatrix}\n\\end{matrix} The frequency f is constant and it is here selected as f=10&#94;-4 . In the space v1-v2 the path of the oscillation must be a circle, but for the frequency selected some ODE solvers are not\nstable leading to a wrong path, see [1]. Bibliography [1] Numerical Methods for Fluid Dynamics With Applications to Geophysics , Dale R. Durran, Springer, 2010. State variables organization State variables are organized as an array (rank 1) of reals of dims elements, in this case 2 elements. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. real(kind=R_P), private :: f = 0._R_P Oscillation frequency (Hz). real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, [1:dims]. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, initial_state, f) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of the Oscillation field vector. real(kind=R_P), intent(in) :: f Frequency. Description Construct an initialized Oscillation field. procedure, public, pass(self) :: output Extract Oscillation field. private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. Return Value real(kind=R_P),\n  dimension(:),allocatable Oscillation state vector. Description Output the Oscillation field state. procedure, public, pass(self) :: t => dOscillation_dt Time derivative, residuals. private function dOscillation_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Oscillation field time derivative. Description Time derivative of Oscillation field. procedure, public, pass(lhs) :: local_error => oscillation_local_error ||Oscillation-oscillation||. private function oscillation_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 oscillation approximations. procedure, public, pass(lhs) :: integrand_multiply_integrand => oscillation_multiply_oscillation Oscillation * oscillation. private function oscillation_multiply_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a oscillation field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => oscillation_multiply_real Oscillation * real. private function oscillation_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Oscillation field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_oscillation Real * Oscillation. private function real_multiply_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( oscillation ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Oscillation field. procedure, public, pass(lhs) :: add => add_oscillation Oscillation + Oscillation. private function add_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Oscillation fields. procedure, public, pass(lhs) :: sub => sub_oscillation Oscillation - Oscillation. private function sub_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Oscillation fields. procedure, public, pass(lhs) :: assign_integrand => oscillation_assign_oscillation Oscillation = Oscillation. private subroutine oscillation_assign_oscillation (lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Oscillation field to another. Source Code type , extends ( integrand ) :: oscillation !< Oscillation equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Oscillation ODEs system !<The (inertial) Oscillation equations system is a non linear system of pure ODEs and it can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< v_1 \\\\ !< v_2 !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< -f v_2 \\\\ !< f v_1 !< \\end{bmatrix} !<\\end{matrix} !< !<The frequency *f* is constant and it is here selected as *f=10&#94;-4*. !< !<In the space *v1-v2* the path of the oscillation must be a circle, but for the frequency selected some ODE solvers are not !<stable leading to a wrong path, see [1]. !< !<#### Bibliography !< !<[1] *Numerical Methods for Fluid Dynamics With Applications to Geophysics*, Dale R. Durran, Springer, 2010. !< !<#### State variables organization !< State variables are organized as an array (rank 1) of reals of *dims* elements, in this case 2 elements. private integer ( I_P ) :: dims = 0 !< Space dimensions. real ( R_P ) :: f = 0._R_P !< Oscillation frequency (Hz). real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, [1:dims]. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Oscillation field. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dOscillation_dt !< Time derivative, residuals. procedure , pass ( lhs ), public :: local_error => oscillation_local_error !<||Oscillation-oscillation||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => oscillation_multiply_oscillation !< Oscillation * oscillation. procedure , pass ( lhs ), public :: integrand_multiply_real => oscillation_multiply_real !< Oscillation * real. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_oscillation !< Real * Oscillation. procedure , pass ( lhs ), public :: add => add_oscillation !< Oscillation + Oscillation. procedure , pass ( lhs ), public :: sub => sub_oscillation !< Oscillation - Oscillation. procedure , pass ( lhs ), public :: assign_integrand => oscillation_assign_oscillation !< Oscillation = Oscillation. endtype oscillation","tags":"","loc":"type/oscillation.html","title":"oscillation – FOODIE "},{"text":"type, public :: euler_1D_caf_nf type~~euler_1d_caf_nf~~InheritsGraph type~euler_1d_caf_nf euler_1D_caf_nf weno_interpolator_upwind weno_interpolator_upwind weno_interpolator_upwind->type~euler_1d_caf_nf weno Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Euler 1D (CAF enabled) PDEs system field. Note This object does not use FOODIE. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E)\n Finalize field. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type(weno_interpolator_upwind), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. integer(kind=I_P), private :: me = 0 ID of this_image(). integer(kind=I_P), private :: we = 0 Number of CAF images used. Finalization Procedures final :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( euler_1D_caf_nf ), intent(inout) :: self Euler field. Description Destroy field. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, me, we, ord) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension (local image). integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in) :: me ID of this_image(). integer(kind=I_P), intent(in) :: we Number of CAF images used. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. procedure, public, pass(self) :: destroy Destroy field. private subroutine destroy (self) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: self Euler field. Description Destroy field. procedure, public, pass(self) :: output Extract Euler field. private purefunction output (self, conservative) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. logical, intent(in), optional :: conservative Output conservative variables instead of primitive. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private purefunction compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. generic, public :: assignment(=) => assign_integrand Overloading = assignament. pass(lhs) assign_integrand () Arguments None Description Euler = Euler. procedure, private, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. Return Value type( euler_1D_caf_nf ) Euler field time derivative. Description Time derivative of Euler field, the residuals function. procedure, private, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_caf_nf ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private purefunction primitive2conservative (self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private purefunction conservative2primitive (self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. procedure, private, pass(self) :: synchronize Synchronize CAF images. private subroutine synchronize (self) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. Description Synchronize CAF images. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private subroutine impose_boundary_conditions (self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private puresubroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Source Code type :: euler_1D_caf_nf !< Euler 1D (CAF enabled) PDEs system field. !< !< @note This object does not use FOODIE. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. integer ( I_P ) :: me = 0 !< ID of this_image(). integer ( I_P ) :: we = 0 !< Number of CAF images used. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. ! private methods procedure , pass ( self ), private :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), private :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: synchronize !< Synchronize CAF images. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_caf_nf","tags":"","loc":"type/euler_1d_caf_nf.html","title":"euler_1D_caf_nf – FOODIE "},{"text":"type, public :: tvd_runge_kutta_integrator TVD RK integrator. Note The integrator must be created or initialized (initialize the RK coeficients) before used.\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. Finalization Procedures final :: finalize_rk private elementalsubroutine finalize_rk (self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy => destroy_rk Destroy the integrator. private elementalsubroutine destroy_rk (self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destoy the integrator. procedure, public, pass(self) :: init => init_rk Initialize (create) the integrator. private elementalsubroutine init_rk (self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. procedure, public, pass(self) :: integrate => integrate_rk Integrate integrand field. private subroutine integrate_rk (self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( euler_1D_caf_nf ), intent(inout) :: U Field to be integrated. class( euler_1D_caf_nf ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Source Code type :: tvd_runge_kutta_integrator !< TVD RK integrator. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy => destroy_rk !< Destroy the integrator. procedure , pass ( self ), public :: init => init_rk !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate => integrate_rk !< Integrate integrand field. final :: finalize_rk !< Finalize object. endtype tvd_runge_kutta_integrator","tags":"","loc":"type/tvd_runge_kutta_integrator.html","title":"tvd_runge_kutta_integrator – FOODIE "},{"text":"type, public, extends(integrand) :: euler_1D_caf type~~euler_1d_caf~~InheritsGraph type~euler_1d_caf euler_1D_caf weno_interpolator_upwind weno_interpolator_upwind weno_interpolator_upwind->type~euler_1d_caf weno integrand integrand integrand->type~euler_1d_caf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Euler 1D PDEs system field. It is a FOODIE integrand class concrete extension. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E)\n Finalize field. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type(weno_interpolator_upwind), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. integer(kind=I_P), private :: me = 0 ID of this_image(). integer(kind=I_P), private :: we = 0 Number of CAF images used. Finalization Procedures final :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( euler_1D_caf ), intent(inout) :: self Euler field. Description Destroy field. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, me, we, ord) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension (local image). integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in) :: me ID of this_image(). integer(kind=I_P), intent(in) :: we Number of CAF images used. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. procedure, public, pass(self) :: destroy Destroy field. private subroutine destroy (self) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: self Euler field. Description Destroy field. procedure, public, pass(self) :: output Extract Euler field. private purefunction output (self, conservative) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. logical, intent(in), optional :: conservative Output conservative variables instead of primitive. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private purefunction compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. procedure, public, pass(lhs) :: local_error => euler_local_error ||euler-euler||. private function euler_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 euler approximations. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Euler * Euler operator. private function euler_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Euler * real operator. private function euler_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Real * Euler operator. private function real_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D_caf ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. procedure, public, pass(lhs) :: add => add_euler Euler + Euler operator. private function add_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. procedure, public, pass(lhs) :: sub => sub_euler Euler - Euler. private function sub_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. procedure, public, pass(lhs) :: assign_real => euler_assign_real Euler = real. private subroutine euler_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private purefunction primitive2conservative (self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private purefunction conservative2primitive (self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. procedure, private, pass(self) :: synchronize Synchronize CAF images. private subroutine synchronize (self) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. Description Synchronize CAF images. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private subroutine impose_boundary_conditions (self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private puresubroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Source Code type , extends ( integrand ) :: euler_1D_caf !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. integer ( I_P ) :: me = 0 !< ID of this_image(). integer ( I_P ) :: we = 0 !< Number of CAF images used. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !<||euler-euler||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: synchronize !< Synchronize CAF images. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_caf","tags":"","loc":"type/euler_1d_caf.html","title":"euler_1D_caf – FOODIE "},{"text":"type, public :: euler_1D_omp_nf type~~euler_1d_omp_nf~~InheritsGraph type~euler_1d_omp_nf euler_1D_omp_nf weno_interpolator_upwind weno_interpolator_upwind weno_interpolator_upwind->type~euler_1d_omp_nf weno Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Euler 1D (OpenMP enabled) PDEs system field. Note This object does not use FOODIE. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E)\n Finalize field. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type(weno_interpolator_upwind), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalization Procedures final :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( euler_1D_omp_nf ), intent(inout) :: self Euler field. Description Destroy field. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, ord) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. procedure, public, pass(self) :: destroy Destroy field. private puresubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: self Euler field. Description Destroy field. procedure, public, pass(self) :: output Extract Euler field. private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private purefunction compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. generic, public :: assignment(=) => assign_integrand Overloading = assignament. pass(lhs) assign_integrand () Arguments None Description Euler = Euler. procedure, private, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. Return Value type( euler_1D_omp_nf ) Euler field time derivative. Description Time derivative of Euler field, the residuals function. procedure, private, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_omp_nf ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private purefunction primitive2conservative (self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private purefunction conservative2primitive (self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private puresubroutine impose_boundary_conditions (self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private puresubroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Source Code type :: euler_1D_omp_nf !< Euler 1D (OpenMP enabled) PDEs system field. !< !< @note This object does not use FOODIE. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. ! private methods procedure , pass ( self ), private :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), private :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_omp_nf","tags":"","loc":"type/euler_1d_omp_nf.html","title":"euler_1D_omp_nf – FOODIE "},{"text":"type, public :: tvd_runge_kutta_integrator TVD RK integrator. Note The integrator must be created or initialized (initialize the RK coeficients) before used.\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. Finalization Procedures final :: finalize_rk private elementalsubroutine finalize_rk (self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy => destroy_rk Destroy the integrator. private elementalsubroutine destroy_rk (self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destoy the integrator. procedure, public, pass(self) :: init => init_rk Initialize (create) the integrator. private elementalsubroutine init_rk (self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. procedure, public, pass(self) :: integrate => integrate_rk Integrate integrand field. private subroutine integrate_rk (self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( euler_1D_omp_nf ), intent(inout) :: U Field to be integrated. class( euler_1D_omp_nf ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Source Code type :: tvd_runge_kutta_integrator !< TVD RK integrator. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy => destroy_rk !< Destroy the integrator. procedure , pass ( self ), public :: init => init_rk !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate => integrate_rk !< Integrate integrand field. final :: finalize_rk !< Finalize object. endtype tvd_runge_kutta_integrator","tags":"","loc":"type/tvd_runge_kutta_integrator~2.html","title":"tvd_runge_kutta_integrator – FOODIE "},{"text":"type, public, extends(integrand) :: euler_1D_openmp type~~euler_1d_openmp~~InheritsGraph type~euler_1d_openmp euler_1D_openmp weno_interpolator_upwind weno_interpolator_upwind weno_interpolator_upwind->type~euler_1d_openmp weno integrand integrand integrand->type~euler_1d_openmp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Euler 1D (OpenMP enabled) PDEs system field. It is a FOODIE integrand class concrete extension. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E)\n Finalize field. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type(weno_interpolator_upwind), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalization Procedures final :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( euler_1D_openmp ), intent(inout) :: self Euler field. Description Destroy field. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, ord) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. procedure, public, pass(self) :: destroy Destroy field. private puresubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: self Euler field. Description Destroy field. procedure, public, pass(self) :: output Extract Euler field. private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private purefunction compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. procedure, public, pass(lhs) :: local_error => euler_local_error ||euler-euler||. private function euler_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 euler approximations. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Euler * Euler operator. private function euler_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Euler * real operator. private function euler_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Real * Euler operator. private function real_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D_openmp ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. procedure, public, pass(lhs) :: add => add_euler Euler + Euler operator. private function add_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. procedure, public, pass(lhs) :: sub => sub_euler Euler - Euler. private function sub_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. procedure, public, pass(lhs) :: assign_real => euler_assign_real Euler = real. private subroutine euler_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private purefunction primitive2conservative (self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private purefunction conservative2primitive (self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private puresubroutine impose_boundary_conditions (self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private puresubroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Source Code type , extends ( integrand ) :: euler_1D_openmp !< Euler 1D (OpenMP enabled) PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !<||euler-euler||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_openmp","tags":"","loc":"type/euler_1d_openmp.html","title":"euler_1D_openmp – FOODIE "},{"text":"type, public, extends(integrand) :: burgers type~~burgers~~InheritsGraph type~burgers burgers integrand integrand integrand->type~burgers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Burgers equations field. It is a FOODIE integrand class concrete extension. Burgers PDE equation The Burgers PDE equation is a non linear PDE widely used as numerical benchmark that can be applied to describe\na wide range of different problems, from fluid dynamics to traffic flows, see [1]. \n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = [u]\\;\\;\\;\nF(U) = [-\\frac{1}{2}u&#94;2+\\nu u_x]\n\\end{matrix}\n This is the viscous Burgers' equation, \\nu being the viscosity. This equation is of paramount relevance because it retains\ncomplex aspects such as the hyperbolic nature of the convection term (allowing discontinuous solutions) and the diffusive nature\nof the viscous term. Bibliography [1] The partial differential equation ut + uux = nuxx , Hopf, Eberhard, Communications on Pure and Applied Mathematics,\n vol 3, issue 3, doi 10.1002/cpa.3160030302, pp. 201–230, 1950. State variables organization State variable is organized as an array (rank 1) for whole physical domain. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. integer(kind=I_P), private :: Ni = 0 Number of grid nodes. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private :: h = 0._R_P Space step discretization. real(kind=R_P), private :: nu = 0._R_P Viscosity. real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, whole physical domain, [1:Ni]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:Ni,1:steps]. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, initial_state, Ni, h, nu, steps) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. real(kind=R_P), intent(in), dimension(1:Ni) :: initial_state Initial state of Burgers field domain. integer(kind=I_P), intent(in) :: Ni Number of grid nodes. real(kind=R_P), intent(in) :: h Space step discretization. real(kind=R_P), intent(in) :: nu Viscosity. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Burgers field. procedure, public, pass(self) :: output Extract Burgers field. private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value real(kind=R_P),\n  dimension(:),allocatable Burgers state variable. Description Output the Burgers field state. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private purefunction compute_dt (self, CFL) result(dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in) :: CFL Courant-Friedricks-Lewi stability coefficient. Return Value real(kind=R_P) Current time step. Description Compute the current time step, by means of CFL condition. procedure, public, pass(self) :: t => dBurgers_dt Time derivative, residuals func. private function dBurgers_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Burgers field time derivative. Description Time derivative of Burgers field, residuals function. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Burgers field. Description Extract previous time solution of Burgers field. procedure, public, pass(lhs) :: local_error => burgers_local_error Local error. private function burgers_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 burgers approximations. procedure, public, pass(lhs) :: integrand_multiply_integrand => burgers_multiply_burgers Burgers * burgers operator. private function burgers_multiply_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => burgers_multiply_real Burgers * real operator. private function burgers_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_burgers Real * Burgers operator. private function real_multiply_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( burgers ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Burgers field. procedure, public, pass(lhs) :: add => add_burgers Burgers + Burgers operator. private function add_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Burgers fields. procedure, public, pass(lhs) :: sub => sub_burgers Burgers - Burgers operator. private function sub_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Burgers fields. procedure, public, pass(lhs) :: assign_integrand => burgers_assign_burgers Burgers = Burgers. private subroutine burgers_assign_burgers (lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Burgers field to another. procedure, public, pass(lhs) :: assign_real => burgers_assign_real Burgers = real. private subroutine burgers_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Burgers field. procedure, private, pass(self) :: x => dBurgers_dx 1st derivative. private function dBurgers_dx (self) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative. Description Compute the first order spatial derivative of Burgers field. procedure, private, pass(self) :: xx => d2Burgers_dx2 2nd derivative. private function d2Burgers_dx2 (self) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative. Description Compute the second order spatial derivative of Burgers field. Source Code type , extends ( integrand ) :: burgers !< Burgers equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Burgers PDE equation !<The Burgers PDE equation is a non linear PDE widely used as numerical benchmark that can be applied to describe !<a wide range of different problems, from fluid dynamics to traffic flows, see [1]. !< !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = [u]\\;\\;\\; !<F(U) = [-\\frac{1}{2}u&#94;2+\\nu u_x] !<\\end{matrix} !< !< !<This is the viscous Burgers' equation, \\nu being the viscosity. This equation is of paramount relevance because it retains !<complex aspects such as the hyperbolic nature of the convection term (allowing discontinuous solutions) and the diffusive nature !<of the viscous term. !< !<#### Bibliography !< !<[1] *The partial differential equation ut + uux = nuxx*, Hopf, Eberhard, Communications on Pure and Applied Mathematics, !< vol 3, issue 3, doi 10.1002/cpa.3160030302, pp. 201--230, 1950. !< !<#### State variables organization !< State variable is organized as an array (rank 1) for whole physical domain. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: Ni = 0 !< Number of grid nodes. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ) :: h = 0._R_P !< Space step discretization. real ( R_P ) :: nu = 0._R_P !< Viscosity. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, whole physical domain, [1:Ni]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:Ni,1:steps]. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Burgers field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dBurgers_dt !< Time derivative, residuals func. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: local_error => burgers_local_error !< Local error. procedure , pass ( lhs ), public :: integrand_multiply_integrand => burgers_multiply_burgers !< Burgers * burgers operator. procedure , pass ( lhs ), public :: integrand_multiply_real => burgers_multiply_real !< Burgers * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_burgers !< Real * Burgers operator. procedure , pass ( lhs ), public :: add => add_burgers !< Burgers + Burgers operator. procedure , pass ( lhs ), public :: sub => sub_burgers !< Burgers - Burgers operator. procedure , pass ( lhs ), public :: assign_integrand => burgers_assign_burgers !< Burgers = Burgers. procedure , pass ( lhs ), public :: assign_real => burgers_assign_real !< Burgers = real. ! private methods procedure , pass ( self ), private :: x => dBurgers_dx !< 1st derivative. procedure , pass ( self ), private :: xx => d2Burgers_dx2 !< 2nd derivative. endtype burgers","tags":"","loc":"type/burgers.html","title":"burgers – FOODIE "},{"text":"type, public, extends(integrand) :: euler_1D type~~euler_1d~~InheritsGraph type~euler_1d euler_1D weno_interpolator_upwind weno_interpolator_upwind weno_interpolator_upwind->type~euler_1d weno integrand integrand integrand->type~euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Euler 1D PDEs system field. It is a FOODIE integrand class concrete extension. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E)\n Finalize field. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps stored. integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type(weno_interpolator_upwind), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real(kind=R_P), private, allocatable :: previous (:,:,:) Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalization Procedures final :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( euler_1D ), intent(inout) :: self Euler field. Description Destroy field. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, steps, ord) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: steps Time steps stored. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. procedure, public, pass(self) :: destroy Destroy field. private puresubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. Description Destroy field. procedure, public, pass(self) :: output Extract Euler field. private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private purefunction compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Euler field. Description Extract previous time solution of Euler field. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Euler * Euler operator. private function euler_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Euler * real operator. private function euler_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Real * Euler operator. private function real_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. procedure, public, pass(lhs) :: add => add_euler Euler + Euler operator. private function add_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. procedure, public, pass(lhs) :: sub => sub_euler Euler - Euler. private function sub_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. procedure, public, pass(lhs) :: assign_real => euler_assign_real Euler = real. private subroutine euler_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private purefunction primitive2conservative (self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private purefunction conservative2primitive (self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private puresubroutine impose_boundary_conditions (self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private puresubroutine reconstruct_interfaces_states (self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private puresubroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Source Code type , extends ( integrand ) :: euler_1D !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: steps = 0 !< Number of time steps stored. integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real ( R_P ), allocatable :: previous (:,:,:) !< Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D","tags":"","loc":"type/euler_1d.html","title":"euler_1D – FOODIE "},{"text":"type, public, extends(integrand) :: lorenz type~~lorenz~~InheritsGraph type~lorenz lorenz integrand integrand integrand->type~lorenz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Lorenz equations field. It is a FOODIE integrand class concrete extension. Lorenz ODEs system The Lorenz' equations system [1] is a non linear system of pure ODEs that retains a reasonable-complex behaviour: such a\nsystem, for a certain parameters-region exhibits a chaotic dynamics useful for testing FOODIE solvers. The Lorenz' ODEs system can be written as: \\begin{matrix}\n U_t = R(U)  \\\\\n U = \\begin{bmatrix}\n v_1 \\\\\n v_2 \\\\\n v_3\n \\end{bmatrix}\\;\\;\\;\n R(U) = \\begin{bmatrix}\n \\sigma (v_2-v_1) \\\\\n v_1(\\rho - v_3) -v_2 \\\\\n v_1 v_2 - \\beta v_3\n \\end{bmatrix}\n\\end{matrix} The parameters set is constant and it is here selected as: \\begin{matrix}\n \\sigma = 10 \\\\\n \\rho = 28 \\\\\n \\beta = \\frac{8}{3}\n\\end{matrix} These values are chaos-inducing thus they magnify the eventual numerical inaccuracies of FOODIE solvers, see [2]. Bibliography [1] Deterministic Nonperiodic Flow , Lorenz E.N., Journal of the Atmospheric Sciences, 1963, vol. 20, pp. 130–141,\ndoi: http://dx.doi.org/10.1175/1520-0469(1963)020<0130:DNF>2.0.CO;2 [2] Scientific software design: the object-oriented way , Rouson, Damian, Jim Xia, and Xiaofeng Xu,\nCambridge University Press, 2011 State variables organization State variables are organized as an array (rank 1) of reals of dims elements, in this case 3 elements. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, [1:dims]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:dims,1:steps]. real(kind=R_P), private :: sigma = 0._R_P Lorenz \\sigma. real(kind=R_P), private :: rho = 0._R_P Lorenz \\rho. real(kind=R_P), private :: beta = 0._R_P Lorenz \\beta. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, initial_state, sigma, rho, beta, steps) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Lorenz field. procedure, public, pass(self) :: output Extract Lorenz field. private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value real(kind=R_P),\n  dimension(:),allocatable Lorenz state vector. Description Output the Lorenz field state. procedure, public, pass(self) :: t => dLorenz_dt Time derivative, residuals function. private function dLorenz_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Lorenz field time derivative. Description Time derivative of Lorenz field. procedure, public, pass(lhs) :: local_error => lorenz_local_error Local error. private function lorenz_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 lorenz approximations. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Lorenz field. Description Extract previous time solution of Lorenz field. procedure, public, pass(lhs) :: integrand_multiply_integrand => lorenz_multiply_lorenz Lorenz * Lorenz operator. private function lorenz_multiply_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a lorenz field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => lorenz_multiply_real Lorenz * real operator. private function lorenz_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Lorenz field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_lorenz Real * Lorenz operator. private function real_multiply_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( lorenz ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Lorenz field. procedure, public, pass(lhs) :: add => add_lorenz Lorenz + Lorenz operator. private function add_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Lorenz fields. procedure, public, pass(lhs) :: sub => sub_lorenz Lorenz - Lorenz. private function sub_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Lorenz fields. procedure, public, pass(lhs) :: assign_integrand => lorenz_assign_lorenz Lorenz = Lorenz. private subroutine lorenz_assign_lorenz (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Lorenz field to another. procedure, public, pass(lhs) :: assign_real => lorenz_assign_real Lorenz = real. private subroutine lorenz_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Lorenz field. Source Code type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Lorenz ODEs system !<The Lorenz' equations system [1] is a non linear system of pure ODEs that retains a reasonable-complex behaviour: such a !<system, for a certain parameters-region exhibits a chaotic dynamics useful for testing FOODIE solvers. !< !<The Lorenz' ODEs system can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< v_1 \\\\ !< v_2 \\\\ !< v_3 !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< \\sigma (v_2-v_1) \\\\ !< v_1(\\rho - v_3) -v_2 \\\\ !< v_1 v_2 - \\beta v_3 !< \\end{bmatrix} !<\\end{matrix} !< !<The parameters set is constant and it is here selected as: !< !<\\begin{matrix} !< \\sigma = 10 \\\\ !< \\rho = 28 \\\\ !< \\beta = \\frac{8}{3} !<\\end{matrix} !< !<These values are chaos-inducing thus they magnify the eventual numerical inaccuracies of FOODIE solvers, see [2]. !< !<#### Bibliography !< !<[1] *Deterministic Nonperiodic Flow*, Lorenz E.N., Journal of the Atmospheric Sciences, 1963, vol. 20, pp. 130--141, !<doi: http://dx.doi.org/10.1175/1520-0469(1963)020<0130:DNF>2.0.CO;2 !< !<[2] *Scientific software design: the object-oriented way*, Rouson, Damian, Jim Xia, and Xiaofeng Xu, !<Cambridge University Press, 2011 !< !<#### State variables organization !< State variables are organized as an array (rank 1) of reals of *dims* elements, in this case 3 elements. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, [1:dims]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:dims,1:steps]. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Lorenz field. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => lorenz_local_error !< Local error. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => lorenz_multiply_lorenz !< Lorenz * Lorenz operator. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< Lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz operator. procedure , pass ( lhs ), public :: sub => sub_lorenz !< Lorenz - Lorenz. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. endtype lorenz","tags":"","loc":"type/lorenz.html","title":"lorenz – FOODIE "},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private subroutine assignment_integrand(lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand.","tags":"","loc":"interface/assignment_integrand.html","title":"assignment_integrand – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function time_derivative(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function.","tags":"","loc":"interface/time_derivative.html","title":"time_derivative – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function local_error_operator(lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 solution approximations.","tags":"","loc":"interface/local_error_operator.html","title":"local_error_operator – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function integrand_op_real(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real.","tags":"","loc":"interface/integrand_op_real.html","title":"integrand_op_real – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function real_op_integrand(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand.","tags":"","loc":"interface/real_op_integrand.html","title":"real_op_integrand – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function symmetric_operator(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand.","tags":"","loc":"interface/symmetric_operator.html","title":"symmetric_operator – FOODIE"},{"text":"private elementalsubroutine init(self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth integrator: initialize the b coefficients. Source Code elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 1 : steps )) ; self % b = 0._R_P select case ( steps ) case ( 1 ) ! AB(1) Forward-Euler self % b ( 1 ) = 1._R_P case ( 2 ) ! AB(2) self % b ( 1 ) = - 0.5_R_P self % b ( 2 ) = 1.5_R_P case ( 3 ) ! AB(3) self % b ( 1 ) = 5._R_P / 1 2._R_P self % b ( 2 ) = - 4._R_P / 3._R_P self % b ( 3 ) = 2 3._R_P / 1 2._R_P case ( 4 ) ! AB(4) self % b ( 1 ) = - 3._R_P / 8._R_P self % b ( 2 ) = 3 7._R_P / 2 4._R_P self % b ( 3 ) = - 5 9._R_P / 2 4._R_P self % b ( 4 ) = 5 5._R_P / 2 4._R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init.html","title":"init – FOODIE"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 if ( allocated ( self % b )) deallocate ( self % b ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy.html","title":"destroy – FOODIE"},{"text":"private subroutine integrate(self, U, previous, Dt, t, autoupdate) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Description Integrate field with Adams-Bashforth class scheme. Variables Type Visibility Attributes Name Initial logical, public :: autoupdate_ Perform cyclic autoupdate of previous time steps, dummy var. integer(kind=I_P), public :: s Steps counter. Source Code subroutine integrate ( self , U , previous , Dt , t , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate do s = 1 , self % steps U = U + previous ( s )% t ( t = t ( s )) * ( Dt * self % b ( s )) enddo if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate.html","title":"integrate – FOODIE"},{"text":"private subroutine update_previous(self, U, previous) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Description Cyclic update previous time steps. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Steps counter. Source Code subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do s = 1 , self % steps - 1 previous ( s ) = previous ( s + 1 ) enddo previous ( self % steps ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous","tags":"","loc":"proc/update_previous.html","title":"update_previous – FOODIE"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize.html","title":"finalize – FOODIE"},{"text":"private elementalsubroutine init(self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth-Moulton integrator: initialize the b coefficients. Source Code elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth-Moulton integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps call self % predictor % init ( steps = steps ) call self % corrector % init ( steps = steps - 1 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~2.html","title":"init – FOODIE"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = - 1 call self % predictor % destroy call self % corrector % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~2.html","title":"destroy – FOODIE"},{"text":"private subroutine integrate(self, U, previous, Dt, t, iterations) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(in) :: self Actual ABM integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations of AM scheme. Description Integrate field with Adams-Bashforth-Moulton class scheme. Source Code subroutine integrate ( self , U , previous , Dt , t , iterations ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth-Moulton class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( IN ) :: self !< Actual ABM integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations of AM scheme. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % predictor % integrate ( U = U , previous = previous , Dt = Dt , t = t , autoupdate = . false .) call self % corrector % integrate ( U = U , previous = previous ( 2 :), Dt = Dt , t = t , iterations = iterations , autoupdate = . false .) call self % predictor % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~2.html","title":"integrate – FOODIE"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~2.html","title":"finalize – FOODIE"},{"text":"private elementalsubroutine init(self, steps) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Moulton integrator: initialize the b coefficients. Source Code elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Moulton integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 0 : steps )) ; self % b = 0._R_P select case ( steps ) case ( 0 ) ! AM(0) Bacward-Euler self % b ( 0 ) = 1._R_P case ( 1 ) ! AM(1) self % b ( 0 ) = 0.5_R_P self % b ( 1 ) = 0.5_R_P case ( 2 ) ! AM(2) self % b ( 0 ) = - 1._R_P / 1 2._R_P self % b ( 1 ) = 2._R_P / 3._R_P self % b ( 2 ) = 5._R_P / 1 2._R_P case ( 3 ) ! AM(3) self % b ( 0 ) = 1._R_P / 2 4._R_P self % b ( 1 ) = - 5._R_P / 2 4._R_P self % b ( 2 ) = 1 9._R_P / 2 4._R_P self % b ( 3 ) = 3._R_P / 8._R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~3.html","title":"init – FOODIE"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = - 1 if ( allocated ( self % b )) deallocate ( self % b ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~3.html","title":"destroy – FOODIE"},{"text":"private subroutine integrate(self, U, previous, Dt, t, iterations, autoupdate) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Description Integrate field with Adams-Moulton class scheme. Variables Type Visibility Attributes Name Initial logical, public :: autoupdate_ Perform cyclic autoupdate of previous time steps, dummy var. class( integrand ), public, allocatable :: delta Delta RHS for fixex point iterations. integer(kind=I_P), public :: s Steps counter. Source Code subroutine integrate ( self , U , previous , Dt , t , iterations , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Moulton class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. class ( integrand ), allocatable :: delta !< Delta RHS for fixex point iterations. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate if ( self % steps > 0 ) then if ( present ( iterations )) then ! perform fixed point iterations allocate ( delta , source = previous ( self % steps )) do s = 0 , self % steps - 1 delta = delta + previous ( s + 1 )% t ( t = t ( s + 1 )) * ( Dt * self % b ( s )) enddo do s = 1 , iterations U = delta + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps )) enddo else U = previous ( self % steps ) + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps )) do s = 0 , self % steps - 1 U = U + previous ( s + 1 )% t ( t = t ( s + 1 )) * ( Dt * self % b ( s )) enddo endif if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) else U = U + U % t ( t = t ( 1 )) * ( Dt * self % b ( 0 )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~3.html","title":"integrate – FOODIE"},{"text":"private subroutine update_previous(self, U, previous) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Description Cyclic update previous time steps. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Steps counter. Source Code subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 0 , self % steps - 2 previous ( s + 1 ) = previous ( s + 2 ) enddo previous ( self % steps ) = U endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous","tags":"","loc":"proc/update_previous~2.html","title":"update_previous – FOODIE"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( adams_moulton_integrator ), intent(inout) :: self AB integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~3.html","title":"finalize – FOODIE"},{"text":"private elementalsubroutine init(self, stages, tolerance) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. real(kind=R_P), intent(in), optional :: tolerance Tolerance on the local truncation error (default 0.01). Description Create the actual RK integrator: initialize the Butcher' table coefficients. Source Code elemental subroutine init ( self , stages , tolerance ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. real ( R_P ), optional , intent ( IN ) :: tolerance !< Tolerance on the local truncation error (default 0.01). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added if ( present ( tolerance )) then self % tolerance = tolerance else self % tolerance = 0.01_R_P endif self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages , 1 : 2 )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 2 ) ! HERK(2,2) self % pp1_inv = 1._R_P / ( 2._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.5_R_P ; self % beta ( 1 , 2 ) = 5._R_P self % beta ( 2 , 1 ) = 1._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 6 ) ! CKRK(6,5) self % pp1_inv = 1._R_P / ( 5._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 7._R_P / 37 8._R_P ; self % beta ( 1 , 2 ) = 282 5._R_P / 2764 8._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 25 0._R_P / 62 1._R_P ; self % beta ( 3 , 2 ) = 1857 5._R_P / 4838 4._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 59 4._R_P ; self % beta ( 4 , 2 ) = 1352 5._R_P / 5529 6._R_P self % beta ( 5 , 1 ) = 0._R_P ; self % beta ( 5 , 2 ) = 27 7._R_P / 1433 6._R_P self % beta ( 6 , 1 ) = 51 2._R_P / 177 1._R_P ; self % beta ( 6 , 2 ) = 1._R_P / 4._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 1 0._R_P ; self % alph ( 4 , 2 ) = - 9._R_P / 1 0._R_P ; self % alph ( 4 , 3 ) = 6._R_P / 5._R_P self % alph ( 5 , 1 ) =- 1 1._R_P / 5 4._R_P ; self % alph ( 5 , 2 ) = 5._R_P / 2._R_P ; self % alph ( 5 , 3 ) =- 7 0._R_P / 2 7._R_P self % alph ( 6 , 1 ) = 163 1._R_P / 5529 6._R_P ; self % alph ( 6 , 2 ) = 17 5._R_P / 51 2._R_P ; self % alph ( 6 , 3 ) = 57 5._R_P / 1382 4._R_P self % alph ( 5 , 4 ) = 3 5._R_P / 2 7._R_P self % alph ( 6 , 4 ) = 4427 5._R_P / 11059 2._R_P ; self % alph ( 6 , 5 ) = 25 3._R_P / 409 6._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 3._R_P / 5._R_P self % gamm ( 5 ) = 1._R_P self % gamm ( 6 ) = 7._R_P / 8._R_P case ( 7 ) ! DPRK(7,4) self % pp1_inv = 1._R_P / ( 4._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 5._R_P / 38 4._R_P ; self % beta ( 1 , 2 ) = 517 9._R_P / 5760 0._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 50 0._R_P / 111 3._R_P ; self % beta ( 3 , 2 ) = 757 1._R_P / 1669 5._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 19 2._R_P ; self % beta ( 4 , 2 ) = 39 3._R_P / 64 0._R_P self % beta ( 5 , 1 ) = - 218 7._R_P / 678 4._R_P ; self % beta ( 5 , 2 ) = - 9209 7._R_P / 33920 0._R_P self % beta ( 6 , 1 ) = 1 1._R_P / 8 4._R_P ; self % beta ( 6 , 2 ) = 18 7._R_P / 210 0._R_P self % beta ( 7 , 1 ) = 0._R_P ; self % beta ( 7 , 2 ) = 1._R_P / 4 0._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 4 4._R_P / 4 5._R_P ; self % alph ( 4 , 2 ) =- 5 6._R_P / 1 5._R_P ; self % alph ( 4 , 3 ) = 3 2._R_P / 9._R_P self % alph ( 5 , 1 ) = 1937 2._R_P / 656 1._R_P ; self % alph ( 5 , 2 ) =- 2536 0._R_P / 218 7._R_P ; self % alph ( 5 , 3 ) = 6444 8._R_P / 656 1._R_P self % alph ( 6 , 1 ) = 901 7._R_P / 316 8._R_P ; self % alph ( 6 , 2 ) =- 35 5._R_P / 3 3._R_P ; self % alph ( 6 , 3 ) = 4673 2._R_P / 524 7._R_P self % alph ( 7 , 1 ) = 3 5._R_P / 38 4._R_P ; self % alph ( 7 , 2 ) = 0._R_P ; self % alph ( 7 , 3 ) = 50 0._R_P / 111 3._R_P self % alph ( 5 , 4 ) =- 21 2._R_P / 72 9._R_P self % alph ( 6 , 4 ) = 4 9._R_P / 17 6._R_P ; self % alph ( 6 , 5 ) =- 510 3._R_P / 1865 6._R_P self % alph ( 7 , 4 ) = 12 5._R_P / 19 2._R_P ; self % alph ( 7 , 5 ) =- 218 7._R_P / 678 4._R_P ; self % alph ( 7 , 6 ) = 1 1._R_P / 8 4._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 4._R_P / 5._R_P self % gamm ( 5 ) = 8._R_P / 9._R_P self % gamm ( 6 ) = 1._R_P self % gamm ( 7 ) = 1._R_P case ( 9 ) ! CMRK(9,6) self % pp1_inv = 1._R_P / ( 6._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % beta ( 1 , 2 ) = 1523166 5._R_P / 51083033 4._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 5751301 1._R_P / 20186425 0._R_P ; self % beta ( 3 , 2 ) = 5945299 1._R_P / 11605044 8._R_P self % beta ( 4 , 1 ) = 1558730 6._R_P / 35450157 1._R_P ; self % beta ( 4 , 2 ) = - 2839851 7._R_P / 12243773 8._R_P self % beta ( 5 , 1 ) = 7178302 1._R_P / 23498286 5._R_P ; self % beta ( 5 , 2 ) = 5667382 4._R_P / 13701055 9._R_P self % beta ( 6 , 1 ) = 2967200 0._R_P / 18048016 7._R_P ; self % beta ( 6 , 2 ) = 6800384 9._R_P / 42667358 3._R_P self % beta ( 7 , 1 ) = 6556762 1._R_P / 12706095 2._R_P ; self % beta ( 7 , 2 ) = 709763 1._R_P / 3756402 1._R_P self % beta ( 8 , 1 ) = - 7907457 0._R_P / 21055759 7._R_P ; self % beta ( 8 , 2 ) = - 7122642 9._R_P / 58309374 2._R_P self % beta ( 9 , 1 ) = 0._R_P ; self % beta ( 9 , 2 ) = 1._R_P / 2 0._R_P self % alph ( 2 , 1 ) = 2._R_P / 1 5._R_P self % alph ( 3 , 1 ) = 1._R_P / 2 0._R_P ; self % alph ( 3 , 2 ) = 3._R_P / 2 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 8672701 5._R_P / 19685155 3._R_P ; self % alph ( 5 , 2 ) =- 6012907 3._R_P / 5262471 2._R_P self % alph ( 6 , 1 ) =- 8686084 9._R_P / 4562896 7._R_P ; self % alph ( 6 , 2 ) = 11102288 5._R_P / 2571648 7._R_P self % alph ( 7 , 1 ) = 7775959 1._R_P / 1609646 7._R_P ; self % alph ( 7 , 2 ) =- 4925280 9._R_P / 645255 5._R_P self % alph ( 8 , 1 ) = 23756426 3._R_P / 3928029 5._R_P ; self % alph ( 8 , 2 ) =- 10052323 9._R_P / 1067794 0._R_P self % alph ( 9 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 4 , 3 ) = 9._R_P / 4 0._R_P self % alph ( 5 , 3 ) = 95743643 4._R_P / 137835237 7._R_P ; self % alph ( 5 , 4 ) = 8388683 2._R_P / 14784244 1._R_P self % alph ( 6 , 3 ) = 10804668 2._R_P / 10116766 9._R_P ; self % alph ( 6 , 4 ) =- 14175674 6._R_P / 3600546 1._R_P self % alph ( 7 , 3 ) =- 38168011 1._R_P / 5157298 4._R_P ; self % alph ( 7 , 4 ) = 87926957 9._R_P / 6678883 1._R_P self % alph ( 8 , 3 ) =- 26557484 6._R_P / 2733024 7._R_P ; self % alph ( 8 , 4 ) = 31797841 1._R_P / 1898871 3._R_P self % alph ( 9 , 3 ) = 5751301 1._R_P / 20186425 0._R_P ; self % alph ( 9 , 4 ) = 1558730 6._R_P / 35450157 1._R_P self % alph ( 6 , 5 ) = 7313986 2._R_P / 6017063 3._R_P self % alph ( 7 , 5 ) =- 9045312 1._R_P / 3372216 2._R_P ; self % alph ( 7 , 6 ) = 11117955 2._R_P / 15715582 7._R_P self % alph ( 8 , 5 ) =- 12449438 5._R_P / 3545362 7._R_P ; self % alph ( 8 , 6 ) = 8682244 4._R_P / 10013863 5._R_P self % alph ( 9 , 5 ) = 7178302 1._R_P / 23498286 5._R_P ; self % alph ( 9 , 6 ) = 2967200 0._R_P / 18048016 7._R_P self % alph ( 8 , 7 ) =- 1287352 3._R_P / 72423262 5._R_P self % alph ( 9 , 7 ) = 6556762 1._R_P / 12706095 2._R_P ; self % alph ( 9 , 8 ) =- 7907457 0._R_P / 21055759 7._R_P self % gamm ( 2 ) = 2._R_P / 1 5._R_P self % gamm ( 3 ) = 1._R_P / 5._R_P self % gamm ( 4 ) = 3._R_P / 1 0._R_P self % gamm ( 5 ) = 1 4._R_P / 2 5._R_P self % gamm ( 6 ) = 1 9._R_P / 2 5._R_P self % gamm ( 7 ) = 3522660 7._R_P / 3568827 9._R_P self % gamm ( 8 ) = 1._R_P self % gamm ( 9 ) = 1._R_P case ( 17 ) ! FRK(17,10) self % pp1_inv = 1._R_P / ( 1 0._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 1 , 2 ) = 0.033333333333333333333_R_P self % beta ( 2 , 1 ) = 0.025_R_P ; self % beta ( 2 , 2 ) = 1._R_P / 3 6._R_P self % beta ( 3 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 3 , 2 ) = 0.033333333333333333333_R_P self % beta ( 4 , 1 ) = 0._R_P ; self % beta ( 4 , 2 ) = 0._R_P self % beta ( 5 , 1 ) = 0.05_R_P ; self % beta ( 5 , 2 ) = 0.05_R_P self % beta ( 6 , 1 ) = 0._R_P ; self % beta ( 6 , 2 ) = 0._R_P self % beta ( 7 , 1 ) = 0.04_R_P ; self % beta ( 7 , 2 ) = 0.04_R_P self % beta ( 8 , 1 ) = 0._R_P ; self % beta ( 8 , 2 ) = 0._R_P self % beta ( 9 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 9 , 2 ) = 0.189237478148923490158_R_P self % beta ( 10 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 10 , 2 ) = 0.277429188517743176508_R_P self % beta ( 11 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 11 , 2 ) = 0.277429188517743176508_R_P self % beta ( 12 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 12 , 2 ) = 0.189237478148923490158_R_P self % beta ( 13 , 1 ) =- 0.04_R_P ; self % beta ( 13 , 2 ) =- 0.04_R_P self % beta ( 14 , 1 ) =- 0.05_R_P ; self % beta ( 14 , 2 ) =- 0.05_R_P self % beta ( 15 , 1 ) =- 0.033333333333333333333_R_P ; self % beta ( 15 , 2 ) =- 0.033333333333333333333_R_P self % beta ( 16 , 1 ) =- 0.025_R_P ; self % beta ( 16 , 2 ) =- 1._R_P / 3 6._R_P self % beta ( 17 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 17 , 2 ) = 0.033333333333333333333_R_P self % alph ( 2 , 1 ) = 0.1_R_P self % alph ( 3 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 3 , 2 ) = 1.454534402178273228052_R_P self % alph ( 4 , 1 ) = 0.202259190301118170324_R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 0.184024714708643575149_R_P ; self % alph ( 5 , 2 ) = 0._R_P self % alph ( 6 , 1 ) = 0.087900734020668133731_R_P ; self % alph ( 6 , 2 ) = 0._R_P self % alph ( 7 , 1 ) = 0.085970050490246030218_R_P ; self % alph ( 7 , 2 ) = 0._R_P self % alph ( 8 , 1 ) = 0.120930449125333720660_R_P ; self % alph ( 8 , 2 ) = 0._R_P self % alph ( 9 , 1 ) = 0.110854379580391483508_R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 10 , 1 ) = 0.112054414752879004829_R_P ; self % alph ( 10 , 2 ) = 0._R_P self % alph ( 11 , 1 ) = 0.113976783964185986138_R_P ; self % alph ( 11 , 2 ) = 0._R_P self % alph ( 12 , 1 ) = 0.079831452828019604635_R_P ; self % alph ( 12 , 2 ) = 0._R_P self % alph ( 13 , 1 ) = 0.985115610164857280120_R_P ; self % alph ( 13 , 2 ) = 0._R_P self % alph ( 14 , 1 ) = 0.895080295771632891049_R_P ; self % alph ( 14 , 2 ) = 0._R_P self % alph ( 15 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 15 , 2 ) = 1.454534402178273228052_R_P self % alph ( 16 , 1 ) = 0.1_R_P ; self % alph ( 16 , 2 ) = 0._R_P self % alph ( 17 , 1 ) = 0.181781300700095283888_R_P ; self % alph ( 17 , 2 ) = 0.675_R_P self % alph ( 4 , 3 ) = 0.606777570903354510974_R_P self % alph ( 5 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 5 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 6 , 3 ) = 0._R_P ; self % alph ( 6 , 4 ) = 0.410459702520260645318_R_P self % alph ( 7 , 3 ) = 0._R_P ; self % alph ( 7 , 4 ) = 0.330885963040722183948_R_P self % alph ( 8 , 3 ) = 0._R_P ; self % alph ( 8 , 4 ) = 0._R_P self % alph ( 9 , 3 ) = 0._R_P ; self % alph ( 9 , 4 ) = 0._R_P self % alph ( 10 , 3 ) = 0._R_P ; self % alph ( 10 , 4 ) = 0._R_P self % alph ( 11 , 3 ) = 0._R_P ; self % alph ( 11 , 4 ) = 0._R_P self % alph ( 12 , 3 ) = 0._R_P ; self % alph ( 12 , 4 ) = 0._R_P self % alph ( 13 , 3 ) = 0._R_P ; self % alph ( 13 , 4 ) = 0.330885963040722183948_R_P self % alph ( 14 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 14 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 15 , 3 ) = 0._R_P ; self % alph ( 15 , 4 ) = 0._R_P self % alph ( 16 , 3 ) =- 0.157178665799771163367_R_P ; self % alph ( 16 , 4 ) = 0._R_P self % alph ( 17 , 3 ) = 0.342758159847189839942_R_P ; self % alph ( 17 , 4 ) = 0._R_P self % alph ( 6 , 5 ) = 0.482713753678866489204_R_P self % alph ( 7 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 7 , 6 ) =- 0.073185637507085073678_R_P self % alph ( 8 , 5 ) = 0.260124675758295622809_R_P ; self % alph ( 8 , 6 ) = 0.032540262154909133015_R_P self % alph ( 9 , 5 ) = 0._R_P ; self % alph ( 9 , 6 ) =- 0.060576148825500558762_R_P self % alph ( 10 , 5 ) = 0._R_P ; self % alph ( 10 , 6 ) =- 0.144942775902865915672_R_P self % alph ( 11 , 5 ) = 0._R_P ; self % alph ( 11 , 6 ) =- 0.076881336420335693858_R_P self % alph ( 12 , 5 ) = 0._R_P ; self % alph ( 12 , 6 ) =- 0.052032968680060307651_R_P self % alph ( 13 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 13 , 6 ) =- 1.378964865748435675821_R_P self % alph ( 14 , 5 ) = 0._R_P ; self % alph ( 14 , 6 ) =- 0.851236239662007619739_R_P self % alph ( 15 , 5 ) =- 0.777333643644968233538_R_P ; self % alph ( 15 , 6 ) = 0._R_P self % alph ( 16 , 5 ) = 0._R_P ; self % alph ( 16 , 6 ) = 0._R_P self % alph ( 17 , 5 ) = 0.259111214548322744512_R_P ; self % alph ( 17 , 6 ) =- 0.358278966717952089048_R_P self % alph ( 8 , 7 ) =- 0.059578021181736100156_R_P self % alph ( 9 , 7 ) = 0.321763705601778390100_R_P ; self % alph ( 9 , 8 ) = 0.510485725608063031577_R_P self % alph ( 10 , 7 ) =- 0.333269719096256706589_R_P ; self % alph ( 10 , 8 ) = 0.499269229556880061353_R_P self % alph ( 11 , 7 ) = 0.239527360324390649107_R_P ; self % alph ( 11 , 8 ) = 0.397774662368094639047_R_P self % alph ( 12 , 7 ) =- 0.057695414616854888173_R_P ; self % alph ( 12 , 8 ) = 0.194781915712104164976_R_P self % alph ( 13 , 7 ) =- 0.861164195027635666673_R_P ; self % alph ( 13 , 8 ) = 5.784288136375372200229_R_P self % alph ( 14 , 7 ) = 0.398320112318533301719_R_P ; self % alph ( 14 , 8 ) = 3.639372631810356060294_R_P self % alph ( 15 , 7 ) =- 0.091089566215517606959_R_P ; self % alph ( 15 , 8 ) = 0._R_P self % alph ( 16 , 7 ) = 0._R_P ; self % alph ( 16 , 8 ) = 0._R_P self % alph ( 17 , 7 ) =- 1.045948959408833060950_R_P ; self % alph ( 17 , 8 ) = 0.930327845415626983292_R_P self % alph ( 10 , 9 ) = 0.509504608929686104236_R_P self % alph ( 11 , 9 ) = 0.010755895687360745555_R_P ; self % alph ( 11 , 10 ) =- 0.327769124164018874147_R_P self % alph ( 12 , 9 ) = 0.145384923188325069727_R_P ; self % alph ( 12 , 10 ) =- 0.078294271035167077755_R_P self % alph ( 13 , 9 ) = 3.288077619851035668904_R_P ; self % alph ( 13 , 10 ) =- 2.386339050931363840134_R_P self % alph ( 14 , 9 ) = 1.548228770398303223653_R_P ; self % alph ( 14 , 10 ) =- 2.122217147040537160260_R_P self % alph ( 15 , 9 ) = 0._R_P ; self % alph ( 15 , 10 ) = 0._R_P self % alph ( 16 , 9 ) = 0._R_P ; self % alph ( 16 , 10 ) = 0._R_P self % alph ( 17 , 9 ) = 1.779509594317081024461_R_P ; self % alph ( 17 , 10 ) = 0.1_R_P self % alph ( 12 , 11 ) =- 0.114503299361098912184_R_P self % alph ( 13 , 11 ) =- 3.254793424836439186545_R_P ; self % alph ( 13 , 12 ) =- 2.163435416864229823539_R_P self % alph ( 14 , 11 ) =- 1.583503985453261727133_R_P ; self % alph ( 14 , 12 ) =- 1.715616082859362649220_R_P self % alph ( 15 , 11 ) = 0._R_P ; self % alph ( 15 , 12 ) = 0._R_P self % alph ( 16 , 11 ) = 0._R_P ; self % alph ( 16 , 12 ) = 0._R_P self % alph ( 17 , 11 ) =- 0.282547569539044081612_R_P ; self % alph ( 17 , 12 ) =- 0.159327350119972549169_R_P self % alph ( 14 , 13 ) =- 0.024403640575012745213_R_P self % alph ( 15 , 13 ) = 0.091089566215517606959_R_P ; self % alph ( 15 , 14 ) = 0.777333643644968233538_R_P self % alph ( 16 , 13 ) = 0._R_P ; self % alph ( 16 , 14 ) = 0._R_P self % alph ( 17 , 13 ) =- 0.145515894647001510860_R_P ; self % alph ( 17 , 14 ) =- 0.259111214548322744512_R_P self % alph ( 16 , 15 ) = 0.157178665799771163367_R_P self % alph ( 17 , 15 ) =- 0.342758159847189839942_R_P ; self % alph ( 17 , 16 ) =- 0.675_R_P self % gamm ( 2 ) = 0.1_R_P self % gamm ( 3 ) = 0.539357840802981787532_R_P self % gamm ( 4 ) = 0.809036761204472681298_R_P self % gamm ( 5 ) = 0.309036761204472681298_R_P self % gamm ( 6 ) = 0.981074190219795268254_R_P self % gamm ( 7 ) = 0.833333333333333333333_R_P self % gamm ( 8 ) = 0.354017365856802376329_R_P self % gamm ( 9 ) = 0.882527661964732346425_R_P self % gamm ( 10 ) = 0.642615758240322548157_R_P self % gamm ( 11 ) = 0.357384241759677451842_R_P self % gamm ( 12 ) = 0.117472338035267653574_R_P self % gamm ( 13 ) = 0.833333333333333333333_R_P self % gamm ( 14 ) = 0.309036761204472681298_R_P self % gamm ( 15 ) = 0.539357840802981787532_R_P self % gamm ( 16 ) = 0.1_R_P self % gamm ( 17 ) = 1._R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~4.html","title":"init – FOODIE"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % tolerance = 0._R_P self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~4.html","title":"destroy – FOODIE"},{"text":"private subroutine integrate(self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(inout) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit embedded Runge-Kutta scheme. The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. Note This method can be used after the integrator is created (i.e. the RK coefficients are initialized). Variables Type Visibility Attributes Name Initial class( integrand ), public, allocatable :: U1 First U evaluation. class( integrand ), public, allocatable :: U2 Second U evaluation. real(kind=R_P), public :: error Local truncation error estimation. integer(kind=I_P), public :: s First stages counter. integer(kind=I_P), public :: ss Second stages counter. Source Code subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit embedded Runge-Kutta scheme. !< !< The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( INOUT ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: U1 !< First U evaluation. class ( integrand ), allocatable :: U2 !< Second U evaluation. real ( R_P ) :: error !< Local truncation error estimation. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( U1 , source = U ) allocate ( U2 , source = U ) error = 1 e6 do while ( error > self % tolerance ) ! compute stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! compute new time step U1 = U U2 = U do s = 1 , self % stages U1 = U1 + stage ( s ) * ( Dt * self % beta ( s , 1 )) U2 = U2 + stage ( s ) * ( Dt * self % beta ( s , 2 )) enddo error = U2 . lterror . U1 call self % new_Dt ( error = error , Dt = Dt ) enddo U = U1 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~4.html","title":"integrate – FOODIE"},{"text":"private elementalsubroutine new_Dt(self, error, Dt) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Integrator. real(kind=R_P), intent(in) :: error Local truncation error estimation. real(kind=R_P), intent(inout) :: Dt Time step. Description Compute new estimation of the time step Dt. The formula employed is:  Dt_{new} = 0.9 Dt_{old} \\left( \\frac{tolerance}{error} \\right)&#94;{\\frac{1}{p+1}}  Note 0.9 is a safety factor. Source Code elemental subroutine new_Dt ( self , error , Dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute new estimation of the time step Dt. !< !< The formula employed is: !< !<  Dt_{new} = 0.9 Dt_{old} \\left( \\frac{tolerance}{error} \\right)&#94;{\\frac{1}{p+1}}  !< !< @note 0.9 is a safety factor. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( IN ) :: self !< Integrator. real ( R_P ), intent ( IN ) :: error !< Local truncation error estimation. real ( R_P ), intent ( INOUT ) :: Dt !< Time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( error > self % tolerance ) Dt = 0.9_R_P * Dt * ( self % tolerance / error ) ** self % pp1_inv return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine new_Dt","tags":"","loc":"proc/new_dt.html","title":"new_Dt – FOODIE"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( emd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~4.html","title":"finalize – FOODIE"},{"text":"private subroutine integrate(U, Dt, t) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. Description Integrate field with explicit Euler scheme, 1st order. Source Code subroutine integrate ( U , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit Euler scheme, 1st order. !--------------------------------------------------------------------------------------------------------------------------------- class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), optional , intent ( IN ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- U = U + U % t ( t = t ) * Dt return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~5.html","title":"integrate – FOODIE"},{"text":"private elementalsubroutine init(self, nu, alpha) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(inout) :: self LF integrator. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. Description Create the actual leapfrog integrator: initialize the filter coefficient. Source Code elemental subroutine init ( self , nu , alpha ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual leapfrog integrator: initialize the filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( INOUT ) :: self !< LF integrator. real ( R_P ), optional , intent ( IN ) :: nu !< Williams-Robert-Asselin filter coefficient. real ( R_P ), optional , intent ( IN ) :: alpha !< Robert-Asselin filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % nu = 0.01_R_P self % alpha = 0.53_R_P if ( present ( nu )) self % nu = nu if ( present ( alpha )) self % alpha = alpha return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~5.html","title":"init – FOODIE"},{"text":"private subroutine integrate(self, U, previous, Dt, t, filter) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(in) :: self LF integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:2) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. class( integrand ), intent(inout), optional :: filter Filter field displacement. Description Integrate field with leapfrog class scheme. Source Code subroutine integrate ( self , U , previous , Dt , t , filter ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with leapfrog class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( IN ) :: self !< LF integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 : 2 ) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. class ( integrand ), optional , intent ( INOUT ) :: filter !< Filter field displacement. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- U = previous ( 1 ) + previous ( 2 )% t ( t = t ) * ( Dt * 2._R_P ) if ( present ( filter )) then filter = ( previous ( 1 ) - previous ( 2 ) * 2._R_P + U ) * self % nu * 0.5_R_P previous ( 2 ) = previous ( 2 ) + filter * self % alpha U = U + filter * ( self % alpha - 1._R_P ) endif previous ( 1 ) = previous ( 2 ) previous ( 2 ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~6.html","title":"integrate – FOODIE"},{"text":"private subroutine init(self, stages) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' low storage table coefficients. Source Code subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' low storage table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % A )) deallocate ( self % A ) ; allocate ( self % A ( 1 : stages )) ; self % A = 0._R_P if ( allocated ( self % B )) deallocate ( self % B ) ; allocate ( self % B ( 1 : stages )) ; self % B = 0._R_P if ( allocated ( self % C )) deallocate ( self % C ) ; allocate ( self % C ( 1 : stages )) ; self % C = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % B ( 1 ) = 1._R_P case ( 5 ) ! LSRK(5,4) self % A ( 1 ) = 0._R_P self % A ( 2 ) = - real ( 567301805773_I8P , kind = R_P ) / real ( 1357537059087_I8P , kind = R_P ) self % A ( 3 ) = - real ( 2404267990393_I8P , kind = R_P ) / real ( 2016746695238_I8P , kind = R_P ) self % A ( 4 ) = - real ( 3550918686646_I8P , kind = R_P ) / real ( 2091501179385_I8P , kind = R_P ) self % A ( 5 ) = - real ( 1275806237668_I8P , kind = R_P ) / real ( 842570457699_I8P , kind = R_P ) self % B ( 1 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % B ( 2 ) = real ( 5161836677717_I8P , kind = R_P ) / real ( 13612068292357_I8P , kind = R_P ) self % B ( 3 ) = real ( 1720146321549_I8P , kind = R_P ) / real ( 2090206949498_I8P , kind = R_P ) self % B ( 4 ) = real ( 3134564353537_I8P , kind = R_P ) / real ( 4481467310338_I8P , kind = R_P ) self % B ( 5 ) = real ( 2277821191437_I8P , kind = R_P ) / real ( 14882151754819_I8P , kind = R_P ) self % C ( 1 ) = 0._R_P self % C ( 2 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % C ( 3 ) = real ( 2526269341429_I8P , kind = R_P ) / real ( 6820363962896_I8P , kind = R_P ) self % C ( 4 ) = real ( 2006345519317_I8P , kind = R_P ) / real ( 3224310063776_I8P , kind = R_P ) self % C ( 5 ) = real ( 2802321613138_I8P , kind = R_P ) / real ( 2924317926251_I8P , kind = R_P ) case ( 6 ) ! LSRK(6,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.122000000000_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.691750960670_R_P ; self % B ( 2 ) = 0.477263056358_R_P ; self % C ( 2 ) = 0.122000000000_R_P self % A ( 3 ) = - 1.727127405211_R_P ; self % B ( 3 ) = 0.381941220320_R_P ; self % C ( 3 ) = 0.269115878630_R_P self % A ( 4 ) = - 0.694890150986_R_P ; self % B ( 4 ) = 0.447757195744_R_P ; self % C ( 4 ) = 0.447717183551_R_P self % A ( 5 ) = - 1.039942756197_R_P ; self % B ( 5 ) = 0.498614246822_R_P ; self % C ( 5 ) = 0.749979795490_R_P self % A ( 6 ) = - 1.531977447611_R_P ; self % B ( 6 ) = 0.186648570846_R_P ; self % C ( 6 ) = 0.898555413085_R_P case ( 7 ) ! LSRK(7,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.117322146869_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.647900745934_R_P ; self % B ( 2 ) = 0.503270262127_R_P ; self % C ( 2 ) = 0.117322146869_R_P self % A ( 3 ) = - 2.704760863204_R_P ; self % B ( 3 ) = 0.233663281658_R_P ; self % C ( 3 ) = 0.294523230758_R_P self % A ( 4 ) = - 0.460080550118_R_P ; self % B ( 4 ) = 0.283419634625_R_P ; self % C ( 4 ) = 0.305658622131_R_P self % A ( 5 ) = - 0.500581787785_R_P ; self % B ( 5 ) = 0.540367414023_R_P ; self % C ( 5 ) = 0.582864148403_R_P self % A ( 6 ) = - 1.906532255913_R_P ; self % B ( 6 ) = 0.371499414620_R_P ; self % C ( 6 ) = 0.858664273599_R_P self % A ( 7 ) = - 1.450000000000_R_P ; self % B ( 7 ) = 0.136670099385_R_P ; self % C ( 7 ) = 0.868664273599_R_P case ( 12 ) ! LSRK(12,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0650008435125904_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.0923311242368072_R_P ; self % B ( 2 ) = 0.0161459902249842_R_P ; self % C ( 2 ) = 0.0650008435125904_R_P self % A ( 3 ) = - 0.9441056581158819_R_P ; self % B ( 3 ) = 0.5758627178358159_R_P ; self % C ( 3 ) = 0.0796560563081853_R_P self % A ( 4 ) = - 4.3271273247576394_R_P ; self % B ( 4 ) = 0.1649758848361671_R_P ; self % C ( 4 ) = 0.1620416710085376_R_P self % A ( 5 ) = - 2.1557771329026072_R_P ; self % B ( 5 ) = 0.3934619494248182_R_P ; self % C ( 5 ) = 0.2248877362907778_R_P self % A ( 6 ) = - 0.9770727190189062_R_P ; self % B ( 6 ) = 0.0443509641602719_R_P ; self % C ( 6 ) = 0.2952293985641261_R_P self % A ( 7 ) = - 0.7581835342571139_R_P ; self % B ( 7 ) = 0.2074504268408778_R_P ; self % C ( 7 ) = 0.3318332506149405_R_P self % A ( 8 ) = - 1.7977525470825499_R_P ; self % B ( 8 ) = 0.6914247433015102_R_P ; self % C ( 8 ) = 0.4094724050198658_R_P self % A ( 9 ) = - 2.6915667972700770_R_P ; self % B ( 9 ) = 0.3766646883450449_R_P ; self % C ( 9 ) = 0.6356954475753369_R_P self % A ( 10 ) = - 4.6466798960268143_R_P ; self % B ( 10 ) = 0.0757190350155483_R_P ; self % C ( 10 ) = 0.6806551557645497_R_P self % A ( 11 ) = - 0.1539613783825189_R_P ; self % B ( 11 ) = 0.2027862031054088_R_P ; self % C ( 11 ) = 0.7143773712418350_R_P self % A ( 12 ) = - 0.5943293901830616_R_P ; self % B ( 12 ) = 0.2167029365631842_R_P ; self % C ( 12 ) = 0.9032588871651854_R_P case ( 13 ) ! LSRK(13,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0271990297818803_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.6160178650170565_R_P ; self % B ( 2 ) = 0.1772488819905108_R_P ; self % C ( 2 ) = 0.0271990297818803_R_P self % A ( 3 ) = - 0.4449487060774118_R_P ; self % B ( 3 ) = 0.0378528418949694_R_P ; self % C ( 3 ) = 0.0952594339119365_R_P self % A ( 4 ) = - 1.0952033345276178_R_P ; self % B ( 4 ) = 0.6086431830142991_R_P ; self % C ( 4 ) = 0.1266450286591127_R_P self % A ( 5 ) = - 1.2256030785959187_R_P ; self % B ( 5 ) = 0.2154313974316100_R_P ; self % C ( 5 ) = 0.1825883045699772_R_P self % A ( 6 ) = - 0.2740182222332805_R_P ; self % B ( 6 ) = 0.2066152563885843_R_P ; self % C ( 6 ) = 0.3737511439063931_R_P self % A ( 7 ) = - 0.0411952089052647_R_P ; self % B ( 7 ) = 0.0415864076069797_R_P ; self % C ( 7 ) = 0.5301279418422206_R_P self % A ( 8 ) = - 0.1797084899153560_R_P ; self % B ( 8 ) = 0.0219891884310925_R_P ; self % C ( 8 ) = 0.5704177433952291_R_P self % A ( 9 ) = - 1.1771530652064288_R_P ; self % B ( 9 ) = 0.9893081222650993_R_P ; self % C ( 9 ) = 0.5885784947099155_R_P self % A ( 10 ) = - 0.4078831463120878_R_P ; self % B ( 10 ) = 0.0063199019859826_R_P ; self % C ( 10 ) = 0.6160769826246714_R_P self % A ( 11 ) = - 0.8295636426191777_R_P ; self % B ( 11 ) = 0.3749640721105318_R_P ; self % C ( 11 ) = 0.6223252334314046_R_P self % A ( 12 ) = - 4.7895970584252288_R_P ; self % B ( 12 ) = 1.6080235151003195_R_P ; self % C ( 12 ) = 0.6897593128753419_R_P self % A ( 13 ) = - 0.6606671432964504_R_P ; self % B ( 13 ) = 0.0961209123818189_R_P ; self % C ( 13 ) = 0.9126827615920843_R_P case ( 14 ) ! LSRK(14,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0367762454319673_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.7188012108672410_R_P ; self % B ( 2 ) = 0.3136296607553959_R_P ; self % C ( 2 ) = 0.0367762454319673_R_P self % A ( 3 ) = - 0.7785331173421570_R_P ; self % B ( 3 ) = 0.1531848691869027_R_P ; self % C ( 3 ) = 0.1249685262725025_R_P self % A ( 4 ) = - 0.0053282796654044_R_P ; self % B ( 4 ) = 0.0030097086818182_R_P ; self % C ( 4 ) = 0.2446177702277698_R_P self % A ( 5 ) = - 0.8552979934029281_R_P ; self % B ( 5 ) = 0.3326293790646110_R_P ; self % C ( 5 ) = 0.2476149531070420_R_P self % A ( 6 ) = - 3.9564138245774565_R_P ; self % B ( 6 ) = 0.2440251405350864_R_P ; self % C ( 6 ) = 0.2969311120382472_R_P self % A ( 7 ) = - 1.5780575380587385_R_P ; self % B ( 7 ) = 0.3718879239592277_R_P ; self % C ( 7 ) = 0.3978149645802642_R_P self % A ( 8 ) = - 2.0837094552574054_R_P ; self % B ( 8 ) = 0.6204126221582444_R_P ; self % C ( 8 ) = 0.5270854589440328_R_P self % A ( 9 ) = - 0.7483334182761610_R_P ; self % B ( 9 ) = 0.1524043173028741_R_P ; self % C ( 9 ) = 0.6981269994175695_R_P self % A ( 10 ) = - 0.7032861106563359_R_P ; self % B ( 10 ) = 0.0760894927419266_R_P ; self % C ( 10 ) = 0.8190890835352128_R_P self % A ( 11 ) = 0.0013917096117681_R_P ; self % B ( 11 ) = 0.0077604214040978_R_P ; self % C ( 11 ) = 0.8527059887098624_R_P self % A ( 12 ) = - 0.0932075369637460_R_P ; self % B ( 12 ) = 0.0024647284755382_R_P ; self % C ( 12 ) = 0.8604711817462826_R_P self % A ( 13 ) = - 0.9514200470875948_R_P ; self % B ( 13 ) = 0.0780348340049386_R_P ; self % C ( 13 ) = 0.8627060376969976_R_P self % A ( 14 ) = - 7.1151571693922548_R_P ; self % B ( 14 ) = 5.5059777270269628_R_P ; self % C ( 14 ) = 0.8734213127600976_R_P case default write ( stderr , '(A,I3,A)' ) ' Error: ls_runge_kutta_integrator%init: ' , stages , ' is an invalid number-of-stages!' write ( stderr , '(A)' ) ' Valid number of stages are:' write ( stderr , '(A)' ) '   1  => LSRK(1, 1)' write ( stderr , '(A)' ) '   5  => LSRK(5, 4)' write ( stderr , '(A)' ) '   6  => LSRK(6, 4)' write ( stderr , '(A)' ) '   7  => LSRK(7, 4)' write ( stderr , '(A)' ) '   12 => LSRK(12, 4)' write ( stderr , '(A)' ) '   13 => LSRK(13, 4)' write ( stderr , '(A)' ) '   14 => LSRK(14, 4)' endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~6.html","title":"init – FOODIE"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % A )) deallocate ( self % A ) if ( allocated ( self % B )) deallocate ( self % B ) if ( allocated ( self % C )) deallocate ( self % C ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~5.html","title":"destroy – FOODIE"},{"text":"private subroutine integrate(self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:2) Runge-Kutta registers [1:2]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit low storage Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coefficients are initialized). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s First stages counter. Source Code subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit low storage Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 : 2 ) !< Runge-Kutta registers [1:2]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages stage ( 1 ) = U stage ( 2 ) = U * 0._R_P do s = 1 , self % stages stage ( 2 ) = stage ( 2 ) * self % A ( s ) + stage ( 1 )% t ( t = t + self % C ( s ) * Dt ) * Dt stage ( 1 ) = stage ( 1 ) + stage ( 2 ) * self % B ( s ) enddo U = stage ( 1 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~7.html","title":"integrate – FOODIE"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~5.html","title":"finalize – FOODIE"},{"text":"private elementalsubroutine init(self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. Source Code elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~7.html","title":"init – FOODIE"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~6.html","title":"destroy – FOODIE"},{"text":"private subroutine integrate(self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coefficients are initialized). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s First stages counter. integer(kind=I_P), public :: ss Second stages counter. Source Code subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! computing new time step do s = 1 , self % stages U = U + stage ( s ) * ( Dt * self % beta ( s )) enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~8.html","title":"integrate – FOODIE"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~6.html","title":"finalize – FOODIE"},{"text":"function exact_solution(t) result(ex_sol) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: t Time. Return Value real(kind=R_P)\n  (1:space_dimension) Exact solution. Description Compute the exact solution. Called By proc~~exact_solution~~CalledByGraph proc~exact_solution exact_solution proc~compute_errors compute_errors proc~compute_errors->proc~exact_solution proc~save_results save_results proc~save_results->proc~exact_solution proc~perform_errors_analysis perform_errors_analysis proc~perform_errors_analysis->proc~compute_errors proc~perform_errors_analysis->proc~save_results program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~perform_errors_analysis proc~test_euler test_euler program~integrate_oscillation->proc~test_euler proc~test_ls_rk test_ls_rk program~integrate_oscillation->proc~test_ls_rk proc~test_leapfrog test_leapfrog program~integrate_oscillation->proc~test_leapfrog proc~test_emd_rk test_emd_rk program~integrate_oscillation->proc~test_emd_rk proc~test_ab test_ab program~integrate_oscillation->proc~test_ab proc~test_abm test_abm program~integrate_oscillation->proc~test_abm proc~test_tvd_rk test_tvd_rk program~integrate_oscillation->proc~test_tvd_rk proc~test_am test_am program~integrate_oscillation->proc~test_am proc~test_euler->proc~save_results proc~test_ls_rk->proc~save_results proc~test_leapfrog->proc~save_results proc~test_emd_rk->proc~save_results proc~test_ab->proc~save_results proc~test_abm->proc~save_results proc~test_tvd_rk->proc~save_results proc~test_am->proc~save_results Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function exact_solution ( t ) result ( ex_sol ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the exact solution. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ) :: ex_sol ( 1 : space_dimension ) !< Exact solution. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ex_sol ( 1 ) = initial_state ( 1 ) * cos ( f * t ) - initial_state ( 2 ) * sin ( f * t ) ex_sol ( 2 ) = initial_state ( 1 ) * sin ( f * t ) + initial_state ( 2 ) * cos ( f * t ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction exact_solution","tags":"","loc":"proc/exact_solution.html","title":"exact_solution – FOODIE"},{"text":"function compute_errors(solution) result(error_L2) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: solution (0:,0:) Solution at each time step. Return Value real(kind=R_P)\n  (1:space_dimension) L2 norm of the numerical error. Description Compute the L2 norm of numerical error with respect the exact solution. Calls proc~~compute_errors~~CallsGraph proc~compute_errors compute_errors proc~exact_solution exact_solution proc~compute_errors->proc~exact_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~compute_errors~~CalledByGraph proc~compute_errors compute_errors proc~perform_errors_analysis perform_errors_analysis proc~perform_errors_analysis->proc~compute_errors program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~perform_errors_analysis Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: ex_sol (1:space_dimension) Exact solution. integer(kind=I_P), public :: s Steps/stages counter. integer(kind=I_P), public :: v Variables counter. Source Code function compute_errors ( solution ) result ( error_L2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the L2 norm of numerical error with respect the exact solution. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: solution ( 0 :, 0 :) !< Solution at each time step. real ( R_P ) :: error_L2 ( 1 : space_dimension ) !< L2 norm of the numerical error. real ( R_P ) :: ex_sol ( 1 : space_dimension ) !< Exact solution. integer ( I_P ) :: s !< Steps/stages counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- error_L2 = 0._R_P do s = 0 , ubound ( solution , dim = 2 ) ex_sol = exact_solution ( t = solution ( 0 , s )) do v = 1 , space_dimension error_L2 ( v ) = error_L2 ( v ) + ( solution ( v , s ) - ex_sol ( v )) ** 2 enddo enddo error_L2 = sqrt ( error_L2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction compute_errors","tags":"","loc":"proc/compute_errors.html","title":"compute_errors – FOODIE"},{"text":"function estimate_orders(solver_error, Dt_used) result(order) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: solver_error (1:space_dimension,1:2) Computed errors. real(kind=R_P), intent(in) :: Dt_used (1:2) Time steps used. Return Value real(kind=R_P)\n  (1:space_dimension) Estimation of the order of accuracy. Description Estimate the order of accuracy using 2 subsequent refined numerical solutions. Called By proc~~estimate_orders~~CalledByGraph proc~estimate_orders estimate_orders proc~perform_errors_analysis perform_errors_analysis proc~perform_errors_analysis->proc~estimate_orders program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~perform_errors_analysis Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: v Variables counter. Source Code function estimate_orders ( solver_error , Dt_used ) result ( order ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate the order of accuracy using 2 subsequent refined numerical solutions. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: solver_error ( 1 : space_dimension , 1 : 2 ) !< Computed errors. real ( R_P ), intent ( IN ) :: Dt_used ( 1 : 2 ) !< Time steps used. real ( R_P ) :: order ( 1 : space_dimension ) !< Estimation of the order of accuracy. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do v = 1 , space_dimension order ( v ) = log ( solver_error ( v , 1 ) / solver_error ( v , 2 )) / log ( Dt_used ( 1 ) / Dt_used ( 2 )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction estimate_orders","tags":"","loc":"proc/estimate_orders.html","title":"estimate_orders – FOODIE"},{"text":"subroutine init(output, solution) Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: output Output files basename. real(kind=R_P), intent(out), allocatable :: solution (:,:) Solution at each time step. Description Initialize solver local variable from global variables. Calls proc~~init~8~~CallsGraph proc~init~8 init str str proc~init~8->str strz strz proc~init~8->strz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~init~8~~CalledByGraph proc~init~8 init proc~test_euler test_euler proc~test_euler->proc~init~8 proc~test_ls_rk test_ls_rk proc~test_ls_rk->proc~init~8 proc~test_leapfrog test_leapfrog proc~test_leapfrog->proc~init~8 proc~test_emd_rk test_emd_rk proc~test_emd_rk->proc~init~8 proc~test_ab test_ab proc~test_ab->proc~init~8 proc~test_abm test_abm proc~test_abm->proc~init~8 proc~perform_errors_analysis perform_errors_analysis proc~perform_errors_analysis->proc~init~8 proc~test_tvd_rk test_tvd_rk proc~test_tvd_rk->proc~init~8 proc~test_am test_am proc~test_am->proc~init~8 program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~test_euler program~integrate_oscillation->proc~test_ls_rk program~integrate_oscillation->proc~test_leapfrog program~integrate_oscillation->proc~test_emd_rk program~integrate_oscillation->proc~test_ab program~integrate_oscillation->proc~test_abm program~integrate_oscillation->proc~perform_errors_analysis program~integrate_oscillation->proc~test_tvd_rk program~integrate_oscillation->proc~test_am Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine init ( output , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize solver local variable from global variables. !--------------------------------------------------------------------------------------------------------------------------------- character ( len = :), allocatable , intent ( OUT ) :: output !< Output files basename. real ( R_P ), allocatable , intent ( OUT ) :: solution (:,:) !< Solution at each time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( mod ( t_final , Dt ) /= 0 ) then print \"(A)\" , 'Error: the final integration time must be an exact multiple of the time step used!' print \"(A)\" , 'Final integration time: ' // str (. true ., t_final ) print \"(A)\" , 'Time step: ' // str (. true ., Dt ) stop endif if ( trim ( adjustl ( output_cli )) /= 'unset' ) then if ( trim ( adjustl ( solver )) /= 'emd-runge-kutta' ) then output = trim ( adjustl ( output_cli )) // '-' // trim ( strz ( 10 , int ( t_final / Dt ))) // '-time_steps-' // trim ( adjustl ( solver )) else output = trim ( adjustl ( output_cli )) // '-' // trim ( str (. true ., n = tolerance )) // '-tolerance-' // trim ( adjustl ( solver )) endif else if ( trim ( adjustl ( solver )) /= 'emd-runge-kutta' ) then output = 'oscillation_integration-' // trim ( strz ( 10 , int ( t_final / Dt ))) // '-time_steps-' // trim ( adjustl ( solver )) else output = 'oscillation_integration-' // trim ( str (. true ., n = tolerance )) // '-tolerance-' // trim ( adjustl ( solver )) endif endif if ( allocated ( solution )) deallocate ( solution ) ; allocate ( solution ( 0 : space_dimension , 0 : int ( t_final / Dt ))) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~8.html","title":"init – FOODIE"},{"text":"subroutine save_results(title, basename, solution) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: basename Output files basename. real(kind=R_P), intent(in) :: solution (0:,0:) Solution at each time step. Description Save plots of results. Calls proc~~save_results~~CallsGraph proc~save_results save_results proc~exact_solution exact_solution proc~save_results->proc~exact_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_results~~CalledByGraph proc~save_results save_results proc~test_euler test_euler proc~test_euler->proc~save_results proc~test_ls_rk test_ls_rk proc~test_ls_rk->proc~save_results proc~test_leapfrog test_leapfrog proc~test_leapfrog->proc~save_results proc~test_emd_rk test_emd_rk proc~test_emd_rk->proc~save_results proc~test_ab test_ab proc~test_ab->proc~save_results proc~test_abm test_abm proc~test_abm->proc~save_results proc~perform_errors_analysis perform_errors_analysis proc~perform_errors_analysis->proc~save_results proc~test_tvd_rk test_tvd_rk proc~test_tvd_rk->proc~save_results proc~test_am test_am proc~test_am->proc~save_results program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~test_euler program~integrate_oscillation->proc~test_ls_rk program~integrate_oscillation->proc~test_leapfrog program~integrate_oscillation->proc~test_emd_rk program~integrate_oscillation->proc~test_ab program~integrate_oscillation->proc~test_abm program~integrate_oscillation->proc~perform_errors_analysis program~integrate_oscillation->proc~test_tvd_rk program~integrate_oscillation->proc~test_am Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. real(kind=R_P), public :: ex_sol (1:space_dimension) Exact solution. type(pyplot), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: s Counter. Source Code subroutine save_results ( title , basename , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: basename !< Output files basename. real ( R_P ), intent ( IN ) :: solution ( 0 :, 0 :) !< Solution at each time step. integer ( I_P ) :: rawfile !< Raw file unit for saving results. real ( R_P ) :: ex_sol ( 1 : space_dimension ) !< Exact solution. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = basename // '.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) 'VARIABLES=\"t\" \"x\" \"y\"' write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE time serie\"' do s = 0 , ubound ( solution , dim = 2 ) write ( rawfile , '(3(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , space_dimension ) enddo write ( rawfile , '(A)' ) 'ZONE T=\"Exact solution\"' do s = 0 , ubound ( solution , dim = 2 ) ex_sol = exact_solution ( t = solution ( 0 , s )) write ( rawfile , '(3(' // FR_P // ',1X))' ) solution ( 0 , s ), ( ex_sol ( i ), i = 1 , space_dimension ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'v' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( basename // '.png' ) call plt % initialize ( grid = . true ., xlabel = 'v1' , ylabel = 'v2' , title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'path' , linestyle = 'r-' , linewidth = 1 ) call plt % savefig ( 'path-' // basename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results.html","title":"save_results – FOODIE"},{"text":"subroutine test_ab(steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of steps used: if negative all AB solvers are used. Description Test explicit Adams-Bashforth class of ODE solvers. Calls proc~~test_ab~~CallsGraph proc~test_ab test_ab proc~ab_solver ab_solver proc~test_ab->proc~ab_solver proc~init~8 init proc~test_ab->proc~init~8 proc~save_results save_results proc~test_ab->proc~save_results str str proc~test_ab->str proc~init~8->str strz strz proc~init~8->strz proc~exact_solution exact_solution proc~save_results->proc~exact_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_ab~~CalledByGraph proc~test_ab test_ab program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~test_ab Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: ab_steps = 4 Adams-Bashforth steps number. real(kind=R_P), public, allocatable :: solution (:,:) Solution at each time step. integer(kind=I_P), public :: s AB steps counter. integer(kind=I_P), public :: steps_range (1:2) Steps used. character(len=:), public, allocatable :: output Output files basename. character(len=:), public, allocatable :: title Output files title. Source Code subroutine test_ab ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all AB solvers are used. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'adams-bashforth' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of Adams-Bashforth class of solvers' steps_range = [ 1 , ab_steps ] ; if ( steps > 0 ) steps_range = [ steps , steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' AB-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // ' steps=' // trim ( str (. true ., s )) call ab_solver ( steps = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab.html","title":"test_ab – FOODIE"},{"text":"subroutine test_abm(steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of steps used: if negative all AB solvers are used. Description Test predictor-corrector Adams-Bashforth-Moulton class of ODE solvers. Calls proc~~test_abm~~CallsGraph proc~test_abm test_abm proc~abm_solver abm_solver proc~test_abm->proc~abm_solver proc~init~8 init proc~test_abm->proc~init~8 proc~save_results save_results proc~test_abm->proc~save_results str str proc~test_abm->str proc~init~8->str strz strz proc~init~8->strz proc~exact_solution exact_solution proc~save_results->proc~exact_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_abm~~CalledByGraph proc~test_abm test_abm program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~test_abm Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: abm_steps = 4 Adams-Bashforth-Moulton steps number. real(kind=R_P), public, allocatable :: solution (:,:) Solution at each time step. integer(kind=I_P), public :: s ABM steps counter. integer(kind=I_P), public :: steps_range (1:2) Steps used. character(len=:), public, allocatable :: output Output files basename. character(len=:), public, allocatable :: title Output files title. Source Code subroutine test_abm ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test predictor-corrector Adams-Bashforth-Moulton class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all AB solvers are used. integer , parameter :: abm_steps = 4 !< Adams-Bashforth-Moulton steps number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< ABM steps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'adams-bashforth-moulton' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of Adams-Bashforth-Moulton class of solvers' steps_range = [ 1 , abm_steps ] ; if ( steps > 0 ) steps_range = [ steps , steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' ABM-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, predictor/corrector Adams-Bashforth-Moulton, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) call abm_solver ( steps = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_abm","tags":"","loc":"proc/test_abm.html","title":"test_abm – FOODIE"},{"text":"subroutine test_am(steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of steps used: if negative all AB solvers are used. Description Test implicit Adams-Moulton class of ODE solvers. Calls proc~~test_am~~CallsGraph proc~test_am test_am proc~save_results save_results proc~test_am->proc~save_results proc~am_solver am_solver proc~test_am->proc~am_solver proc~init~8 init proc~test_am->proc~init~8 str str proc~test_am->str proc~exact_solution exact_solution proc~save_results->proc~exact_solution proc~init~8->str strz strz proc~init~8->strz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_am~~CalledByGraph proc~test_am test_am program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~test_am Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: am_steps = 3 Adams-Moulton steps number. real(kind=R_P), public, allocatable :: solution (:,:) Solution at each time step. integer(kind=I_P), public :: s AM steps counter. integer(kind=I_P), public :: steps_range (1:2) Steps used. character(len=:), public, allocatable :: output Output files basename. character(len=:), public, allocatable :: title Output files title. Source Code subroutine test_am ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test implicit Adams-Moulton class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all AB solvers are used. integer , parameter :: am_steps = 3 !< Adams-Moulton steps number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< AM steps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'adams-moulton' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of Adams-Moulton class of solvers' steps_range = [ 0 , am_steps ] ; if ( steps > 0 ) steps_range = [ steps , steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' AM-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, implicit Adams-Moulton, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) if ( implicit_iterations > 1 ) then call am_solver ( steps = s , solution = solution , iterations = implicit_iterations ) else call am_solver ( steps = s , solution = solution ) endif call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_am","tags":"","loc":"proc/test_am.html","title":"test_am – FOODIE"},{"text":"subroutine test_emd_rk(stages) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used: if negative all RK solvers are used. Description Test explicit embedded Runge-Kutta class of ODE solvers. Calls proc~~test_emd_rk~~CallsGraph proc~test_emd_rk test_emd_rk proc~emd_rk_solver emd_rk_solver proc~test_emd_rk->proc~emd_rk_solver proc~init~8 init proc~test_emd_rk->proc~init~8 proc~save_results save_results proc~test_emd_rk->proc~save_results str str proc~test_emd_rk->str proc~init~8->str strz strz proc~init~8->strz proc~exact_solution exact_solution proc~save_results->proc~exact_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_emd_rk~~CalledByGraph proc~test_emd_rk test_emd_rk program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~test_emd_rk Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: rk_stages = 17 Runge-Kutta stages number. real(kind=R_P), public, allocatable :: solution (:,:) Solution at each time step. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: stages_range (1:2) Stages used. character(len=:), public, allocatable :: output Output files basename. character(len=:), public, allocatable :: title Output files title. integer(kind=I_P), public :: last_step Last time step computed. Source Code subroutine test_emd_rk ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit embedded Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. integer , parameter :: rk_stages = 17 !< Runge-Kutta stages number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. integer ( I_P ) :: last_step !< Last time step computed. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'emd-runge-kutta' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of embedded Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages > 0 ) stages_range = [ stages , stages ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 1 ) cycle ! 1 stages not allowed if ( s == 2 ) cycle ! 2 stages not suited for test if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 5 ) cycle ! 5 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented if ( s == 12 ) cycle ! 12 stages not yet implemented if ( s == 13 ) cycle ! 13 stages not yet implemented if ( s == 14 ) cycle ! 14 stages not yet implemented if ( s == 15 ) cycle ! 15 stages not yet implemented if ( s == 16 ) cycle ! 16 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, explicit embedded Runge-Kutta, t=' // str ( n = t_final ) // ' steps=' // trim ( str (. true ., s )) call emd_rk_solver ( stages = s , tol = tolerance , solution = solution , last_step = last_step ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution (:, 0 : last_step )) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_emd_rk","tags":"","loc":"proc/test_emd_rk.html","title":"test_emd_rk – FOODIE"},{"text":"subroutine test_euler() Arguments None Description Test explicit forward Euler ODE solver. Calls proc~~test_euler~~CallsGraph proc~test_euler test_euler proc~euler_solver euler_solver proc~test_euler->proc~euler_solver proc~init~8 init proc~test_euler->proc~init~8 proc~save_results save_results proc~test_euler->proc~save_results str str proc~test_euler->str proc~init~8->str strz strz proc~init~8->strz proc~exact_solution exact_solution proc~save_results->proc~exact_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_euler~~CalledByGraph proc~test_euler test_euler program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~test_euler Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: solution (:,:) Solution at each time step. character(len=:), public, allocatable :: output Output files basename. character(len=:), public, allocatable :: title Output files title. Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'euler' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of explicit Euler solver' title = 'Oscillation equation integration, explicit Euler, t=' // str ( n = t_final ) call euler_solver ( solution = solution ) call save_results ( title = title , basename = output , solution = solution ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler.html","title":"test_euler – FOODIE"},{"text":"subroutine test_leapfrog(raw) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: raw Activate RAW filter. Description Test explicit leapfrog class of ODE solvers. Calls proc~~test_leapfrog~~CallsGraph proc~test_leapfrog test_leapfrog proc~leapfrog_solver leapfrog_solver proc~test_leapfrog->proc~leapfrog_solver proc~init~8 init proc~test_leapfrog->proc~init~8 proc~save_results save_results proc~test_leapfrog->proc~save_results str str proc~test_leapfrog->str proc~init~8->str strz strz proc~init~8->strz proc~exact_solution exact_solution proc~save_results->proc~exact_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_leapfrog~~CalledByGraph proc~test_leapfrog test_leapfrog program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~test_leapfrog Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: solution (:,:) Solution at each time step. character(len=:), public, allocatable :: output Output files basename. character(len=:), public, allocatable :: title Output files title. Source Code subroutine test_leapfrog ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- logical , optional , intent ( IN ) :: raw !< Activate RAW filter. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'leapfrog' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of leapfrog (RAW filtered) class of solvers' title = 'Oscillation equation integration, leapfrog (RAW filtered), t=' // str ( n = t_final ) call leapfrog_solver ( solution = solution , raw = raw ) call save_results ( title = title , basename = output , solution = solution ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog","tags":"","loc":"proc/test_leapfrog.html","title":"test_leapfrog – FOODIE"},{"text":"subroutine test_ls_rk(stages) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used: if negative all RK solvers are used. Description Test explicit low storage Runge-Kutta class of ODE solvers. Calls proc~~test_ls_rk~~CallsGraph proc~test_ls_rk test_ls_rk proc~save_results save_results proc~test_ls_rk->proc~save_results proc~ls_rk_solver ls_rk_solver proc~test_ls_rk->proc~ls_rk_solver proc~init~8 init proc~test_ls_rk->proc~init~8 str str proc~test_ls_rk->str proc~exact_solution exact_solution proc~save_results->proc~exact_solution proc~init~8->str strz strz proc~init~8->strz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_ls_rk~~CalledByGraph proc~test_ls_rk test_ls_rk program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~test_ls_rk Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: rk_stages = 14 Runge-Kutta stages number. real(kind=R_P), public, allocatable :: solution (:,:) Solution at each time step. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: stages_range (1:2) Stages used. character(len=:), public, allocatable :: output Output files basename. character(len=:), public, allocatable :: title Output files title. Source Code subroutine test_ls_rk ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. integer , parameter :: rk_stages = 14 !< Runge-Kutta stages number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'ls-runge-kutta' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of low storage (2N) Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages > 0 ) stages_range = [ stages , stages ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 9 ) cycle ! 9 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) call ls_rk_solver ( stages = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk","tags":"","loc":"proc/test_ls_rk.html","title":"test_ls_rk – FOODIE"},{"text":"subroutine test_tvd_rk(stages) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used: if negative all RK solvers are used. Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Calls proc~~test_tvd_rk~~CallsGraph proc~test_tvd_rk test_tvd_rk proc~tvd_rk_solver tvd_rk_solver proc~test_tvd_rk->proc~tvd_rk_solver proc~init~8 init proc~test_tvd_rk->proc~init~8 proc~save_results save_results proc~test_tvd_rk->proc~save_results str str proc~test_tvd_rk->str proc~init~8->str strz strz proc~init~8->strz proc~exact_solution exact_solution proc~save_results->proc~exact_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_tvd_rk~~CalledByGraph proc~test_tvd_rk test_tvd_rk program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~test_tvd_rk Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. real(kind=R_P), public, allocatable :: solution (:,:) Solution at each time step. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: stages_range (1:2) Stages used. character(len=:), public, allocatable :: output Output files basename. character(len=:), public, allocatable :: title Output files title. Source Code subroutine test_tvd_rk ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'tvd-runge-kutta' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of TVD/SSP Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages > 0 ) stages_range = [ stages , stages ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, explicit TVD/SSP Runge-Kutta, t=' // str ( n = t_final ) // ' steps=' // trim ( str (. true ., s )) call tvd_rk_solver ( stages = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk","tags":"","loc":"proc/test_tvd_rk.html","title":"test_tvd_rk – FOODIE"},{"text":"subroutine ab_solver(steps, solution) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of steps used: if negative all AB solvers are used. real(kind=R_P), intent(out) :: solution (0:,0:) Solution at each time step. Description Solve problem with explicit Adams-Bashforth class of ODE solvers. Called By proc~~ab_solver~~CalledByGraph proc~ab_solver ab_solver proc~perform_errors_analysis perform_errors_analysis proc~perform_errors_analysis->proc~ab_solver proc~test_ab test_ab proc~test_ab->proc~ab_solver program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~perform_errors_analysis program~integrate_oscillation->proc~test_ab Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( oscillation ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( adams_bashforth_integrator ), public :: ab_integrator Adams-Bashforth integrator. type( oscillation ), public :: previous (1:steps) Previous time steps solutions. type( oscillation ), public :: oscillator Oscillation field. integer, public :: step Time steps counter. Source Code subroutine ab_solver ( steps , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all AB solvers are used. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. type ( oscillation ) :: previous ( 1 : steps ) !< Previous time steps solutions. type ( oscillation ) :: oscillator !< Oscillation field. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call ab_integrator % init ( steps = steps ) select case ( steps ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = steps ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 if ( steps >= step ) then ! time steps from 1 to s - 1 must be computed with other scheme call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) previous ( step ) = oscillator else call ab_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step - steps : step - 1 )) endif solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine ab_solver","tags":"","loc":"proc/ab_solver.html","title":"ab_solver – FOODIE"},{"text":"subroutine abm_solver(steps, solution) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of steps used: if negative all ABM solvers are used. real(kind=R_P), intent(out) :: solution (0:,0:) Solution at each time step. Description Solve problem with predictor-corrector Adams-Bashforth-Moulton class of ODE solvers. Called By proc~~abm_solver~~CalledByGraph proc~abm_solver abm_solver proc~perform_errors_analysis perform_errors_analysis proc~perform_errors_analysis->proc~abm_solver proc~test_abm test_abm proc~test_abm->proc~abm_solver program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~perform_errors_analysis program~integrate_oscillation->proc~test_abm Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( oscillation ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( adams_bashforth_moulton_integrator ), public :: abm_integrator Adams-Bashforth-Moulton integrator. type( oscillation ), public :: previous (1:steps) Previous time steps solutions. type( oscillation ), public :: oscillator Oscillation field. integer, public :: step Time steps counter. Source Code subroutine abm_solver ( steps , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with predictor-corrector Adams-Bashforth-Moulton class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all ABM solvers are used. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_moulton_integrator ) :: abm_integrator !< Adams-Bashforth-Moulton integrator. type ( oscillation ) :: previous ( 1 : steps ) !< Previous time steps solutions. type ( oscillation ) :: oscillator !< Oscillation field. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call abm_integrator % init ( steps = steps ) select case ( steps ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = steps ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 if ( steps >= step ) then ! time steps from 1 to s - 1 must be computed with other scheme call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) previous ( step ) = oscillator else call abm_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step - steps : step - 1 )) endif solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine abm_solver","tags":"","loc":"proc/abm_solver.html","title":"abm_solver – FOODIE"},{"text":"subroutine am_solver(steps, iterations, solution) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of steps used: if negative all AM solvers are used. integer(kind=I_P), intent(in), optional :: iterations Number of fixed point iterations. real(kind=R_P), intent(out) :: solution (0:,0:) Solution at each time step. Description Solve problem with implicit Adams-Moulton class of ODE solvers. Called By proc~~am_solver~~CalledByGraph proc~am_solver am_solver proc~perform_errors_analysis perform_errors_analysis proc~perform_errors_analysis->proc~am_solver proc~test_am test_am proc~test_am->proc~am_solver program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~perform_errors_analysis program~integrate_oscillation->proc~test_am Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( oscillation ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( adams_moulton_integrator ), public :: am_integrator Adams-Moulton integrator. type( oscillation ), public :: previous (1:steps) Previous time steps solutions. type( oscillation ), public :: oscillator Oscillation field. integer, public :: step Time steps counter. Source Code subroutine am_solver ( steps , iterations , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with implicit Adams-Moulton class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all AM solvers are used. integer ( I_P ), optional , intent ( IN ) :: iterations !< Number of fixed point iterations. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_moulton_integrator ) :: am_integrator !< Adams-Moulton integrator. type ( oscillation ) :: previous ( 1 : steps ) !< Previous time steps solutions. type ( oscillation ) :: oscillator !< Oscillation field. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call am_integrator % init ( steps = steps ) select case ( steps ) case ( 0 , 1 , 2 ) call rk_integrator % init ( stages = steps + 1 ) case ( 3 ) call rk_integrator % init ( stages = 5 ) endselect call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 if ( steps >= step ) then ! time steps from 1 to s - 1 must be computed with other scheme call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) previous ( step ) = oscillator else if ( steps == 0 ) then call am_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step - 1 : step - 1 ), iterations = iterations ) else call am_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step - steps : step - 1 ), iterations = iterations ) endif endif solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine am_solver","tags":"","loc":"proc/am_solver.html","title":"am_solver – FOODIE"},{"text":"subroutine emd_rk_solver(stages, tol, solution, last_step) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used: if negative all RK solvers are used. real(kind=R_P), intent(in) :: tol Tolerance on local truncation error. real(kind=R_P), intent(out) :: solution (0:,0:) Solution at each time step. integer(kind=I_P), intent(out) :: last_step Last time step number. Description Solve problem with explicit embedded Runge-Kutta class of ODE solvers. Called By proc~~emd_rk_solver~~CalledByGraph proc~emd_rk_solver emd_rk_solver proc~perform_errors_analysis perform_errors_analysis proc~perform_errors_analysis->proc~emd_rk_solver proc~test_emd_rk test_emd_rk proc~test_emd_rk->proc~emd_rk_solver program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~perform_errors_analysis program~integrate_oscillation->proc~test_emd_rk Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( emd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. type( oscillation ), public :: rk_stage (1:stages) Runge-Kutta stages. type( oscillation ), public :: oscillator Oscillation field. integer(kind=I_P), public :: step Time steps counter. real(kind=R_P), public :: Dt_a Adaptive time step. Source Code subroutine emd_rk_solver ( stages , tol , solution , last_step ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit embedded Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. real ( R_P ), intent ( IN ) :: tol !< Tolerance on local truncation error. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. integer ( I_P ), intent ( OUT ) :: last_step !< Last time step number. type ( emd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. type ( oscillation ) :: rk_stage ( 1 : stages ) !< Runge-Kutta stages. type ( oscillation ) :: oscillator !< Oscillation field. integer ( I_P ) :: step !< Time steps counter. real ( R_P ) :: Dt_a !< Adaptive time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Dt_a = 1000 0._R_P ! initial step very large to trigger adaptation call rk_integrator % init ( stages = stages , tolerance = tol ) call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt_a , t = solution ( 0 , step )) solution ( 0 , step ) = solution ( 0 , step - 1 ) + Dt_a solution ( 1 : space_dimension , step ) = oscillator % output () enddo last_step = step return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine emd_rk_solver","tags":"","loc":"proc/emd_rk_solver.html","title":"emd_rk_solver – FOODIE"},{"text":"subroutine euler_solver(solution) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(out) :: solution (0:,0:) Solution at each time step. Description Solve problem with explicit forward Euler ODE solver. Called By proc~~euler_solver~~CalledByGraph proc~euler_solver euler_solver proc~test_euler test_euler proc~test_euler->proc~euler_solver program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~test_euler Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( euler_explicit_integrator ), public :: euler_integrator Euler integrator. type( oscillation ), public :: oscillator Oscillation field. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine euler_solver ( solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. type ( oscillation ) :: oscillator !< Oscillation field. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 call euler_integrator % integrate ( U = oscillator , Dt = Dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_solver","tags":"","loc":"proc/euler_solver.html","title":"euler_solver – FOODIE"},{"text":"subroutine leapfrog_solver(solution, raw) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(out) :: solution (0:,0:) Solution at each time step. logical, intent(in), optional :: raw Activate RAW filter. Description Solve problem with explicit leapfrog class of ODE solvers. Called By proc~~leapfrog_solver~~CalledByGraph proc~leapfrog_solver leapfrog_solver proc~test_leapfrog test_leapfrog proc~test_leapfrog->proc~leapfrog_solver proc~perform_errors_analysis perform_errors_analysis proc~perform_errors_analysis->proc~leapfrog_solver program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~test_leapfrog program~integrate_oscillation->proc~perform_errors_analysis Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( oscillation ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( leapfrog_integrator ), public :: lf_integrator Leapfrog integrator. type( oscillation ), public :: previous (1:2) Previous time steps solutions. type( oscillation ), public :: filter Filter displacement. type( oscillation ), public :: oscillator Oscillation field. integer, public :: step Time steps counter. logical, public :: filtered Activate RAW filter. Source Code subroutine leapfrog_solver ( solution , raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. logical , optional , intent ( IN ) :: raw !< Activate RAW filter. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( oscillation ) :: previous ( 1 : 2 ) !< Previous time steps solutions. type ( oscillation ) :: filter !< Filter displacement. type ( oscillation ) :: oscillator !< Oscillation field. integer :: step !< Time steps counter. logical :: filtered !< Activate RAW filter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- filtered = . false . ; if ( present ( raw )) filtered = raw call lf_integrator % init () call rk_integrator % init ( stages = rk_stages ) call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 if ( 2 >= step ) then ! time steps from 1 to 2 must be computed with other scheme call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) previous ( step ) = oscillator else if ( filtered ) then call lf_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step ), filter = filter ) else call lf_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine leapfrog_solver","tags":"","loc":"proc/leapfrog_solver.html","title":"leapfrog_solver – FOODIE"},{"text":"subroutine ls_rk_solver(stages, solution) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used: if negative all RK solvers are used. real(kind=R_P), intent(out) :: solution (0:,0:) Solution at each time step. Description Solve problem with explicit low storage Runge-Kutta class of ODE solvers. Called By proc~~ls_rk_solver~~CalledByGraph proc~ls_rk_solver ls_rk_solver proc~test_ls_rk test_ls_rk proc~test_ls_rk->proc~ls_rk_solver proc~perform_errors_analysis perform_errors_analysis proc~perform_errors_analysis->proc~ls_rk_solver program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~test_ls_rk program~integrate_oscillation->proc~perform_errors_analysis Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( ls_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: registers = 2 Runge-Kutta stages registers number. type( oscillation ), public :: rk_stage (1:registers) Runge-Kutta registers. type( oscillation ), public :: oscillator Oscillation field. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine ls_rk_solver ( stages , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: registers = 2 !< Runge-Kutta stages registers number. type ( oscillation ) :: rk_stage ( 1 : registers ) !< Runge-Kutta registers. type ( oscillation ) :: oscillator !< Oscillation field. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call rk_integrator % init ( stages = stages ) call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine ls_rk_solver","tags":"","loc":"proc/ls_rk_solver.html","title":"ls_rk_solver – FOODIE"},{"text":"subroutine tvd_rk_solver(stages, solution) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used: if negative all RK solvers are used. real(kind=R_P), intent(out) :: solution (0:,0:) Solution at each time step. Description Solve problem with explicit TVD/SSP Runge-Kutta class of ODE solvers. Called By proc~~tvd_rk_solver~~CalledByGraph proc~tvd_rk_solver tvd_rk_solver proc~test_tvd_rk test_tvd_rk proc~test_tvd_rk->proc~tvd_rk_solver proc~perform_errors_analysis perform_errors_analysis proc~perform_errors_analysis->proc~tvd_rk_solver program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~test_tvd_rk program~integrate_oscillation->proc~perform_errors_analysis Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. type( oscillation ), public :: rk_stage (1:stages) Runge-Kutta stages. type( oscillation ), public :: oscillator Oscillation field. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine tvd_rk_solver ( stages , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. type ( oscillation ) :: rk_stage ( 1 : stages ) !< Runge-Kutta stages. type ( oscillation ) :: oscillator !< Oscillation field. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call rk_integrator % init ( stages = stages ) call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tvd_rk_solver","tags":"","loc":"proc/tvd_rk_solver.html","title":"tvd_rk_solver – FOODIE"},{"text":"subroutine perform_errors_analysis() Arguments None Description Peform errors analysis. The analysis is based on the integration of the Oscillation equations with different, decreasing time steps in the range [5000, 2500, 1250, 625, 320, 100] . The error is estimated by the L2 norm of the difference between the exact (U_e) and\n the numerical (U_{\\Delta t}) solutions for each time step: \n\\varepsilon (\\Delta t) = || U_e - U_{\\Delta t} ||_2 = \\sqrt{ \\sum_{s=1}&#94;{N_s} { \\left(U_e(t_0 + s * \\Delta t) -\nU_{\\Delta t}(t_0 + s * \\Delta t) \\right)&#94;2 }}\n Using two pairs of subsequent-decreasing time steps solution is possible to estimate the order of accuracy of the solver\n employed computing the \\emph{observed order} of accuracy: \np = \\frac{log10 \\left( \\frac{\\varepsilon (\\Delta t_1)}{\\varepsilon (\\Delta t_2)} \\right)}\n{log10 \\left( \\frac{\\Delta t_1}{\\Delta t_2} \\right)}\n where \\frac{\\Delta t_1}{\\Delta t_2}>1. Calls proc~~perform_errors_analysis~~CallsGraph proc~perform_errors_analysis perform_errors_analysis proc~tvd_rk_solver tvd_rk_solver proc~perform_errors_analysis->proc~tvd_rk_solver proc~init~8 init proc~perform_errors_analysis->proc~init~8 proc~leapfrog_solver leapfrog_solver proc~perform_errors_analysis->proc~leapfrog_solver proc~ab_solver ab_solver proc~perform_errors_analysis->proc~ab_solver proc~ls_rk_solver ls_rk_solver proc~perform_errors_analysis->proc~ls_rk_solver proc~estimate_orders estimate_orders proc~perform_errors_analysis->proc~estimate_orders str str proc~perform_errors_analysis->str proc~abm_solver abm_solver proc~perform_errors_analysis->proc~abm_solver proc~save_results save_results proc~perform_errors_analysis->proc~save_results proc~print_analysis print_analysis proc~perform_errors_analysis->proc~print_analysis proc~compute_errors compute_errors proc~perform_errors_analysis->proc~compute_errors proc~emd_rk_solver emd_rk_solver proc~perform_errors_analysis->proc~emd_rk_solver proc~am_solver am_solver proc~perform_errors_analysis->proc~am_solver proc~init~8->str strz strz proc~init~8->strz proc~exact_solution exact_solution proc~save_results->proc~exact_solution proc~print_analysis->str proc~compute_errors->proc~exact_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~perform_errors_analysis~~CalledByGraph proc~perform_errors_analysis perform_errors_analysis program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~perform_errors_analysis Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public, parameter :: NDt = 6 Number of time steps exercised. real(kind=R_P), public, parameter :: time_steps (1:NDt) = [5000._R_P,2500._R_P,1250._R_P,625._R_P,320._R_P,100._R_P] Time steps exercised. real(kind=R_P), public, parameter :: tolerances (1:NDt) = [0.001_R_P,0.0001_R_P,0.00001_R_P,0.000001_R_P,0.0000001_R_P,0.00000001_R_P] Tolerances for embedded RK solvers. integer, public, parameter :: ab_steps = 4 Adams-Bashforth steps number. integer, public, parameter :: emd_rk_stages = 17 Embedded Runge-Kutta stages number. integer, public, parameter :: tvd_rk_stages = 5 TVD/SSP Runge-Kutta stages number. integer, public, parameter :: ls_rk_stages = 14 Low storage Runge-Kutta stages number. integer(kind=I_P), public :: s Steps/stages counter. integer(kind=I_P), public :: d Time steps-exercised counter. character(len=:), public, allocatable :: output Output files basename. character(len=:), public, allocatable :: title Output files title. real(kind=R_P), public, allocatable :: solution (:,:) Solution at each time step. integer(kind=I_P), public :: last_step Last time step computed. real(kind=R_P), public :: emd_Dt_mean (1:emd_rk_stages,1:NDt) Mean time resolution for adaptive step methods. real(kind=R_P), public :: ab_errors (1:space_dimension,1:ab_steps,1:NDt) Adams-Bashforth errors. real(kind=R_P), public :: abm_errors (1:space_dimension,1:ab_steps,1:NDt) Adams-Bashforth-Moulton errors. real(kind=R_P), public :: am_errors (1:space_dimension,1:ab_steps,1:NDt) Adams-Moulton errors. real(kind=R_P), public :: emd_rk_errors (1:space_dimension,1:emd_rk_stages,1:NDt) TVD/SSP Runge-Kutta errors. real(kind=R_P), public :: lf_errors (1:space_dimension,1:2,1:NDt) Leapfrog errors. real(kind=R_P), public :: ls_rk_errors (1:space_dimension,1:ls_rk_stages,1:NDt) Low storage Runge-Kutta errors. real(kind=R_P), public :: tvd_rk_errors (1:space_dimension,1:tvd_rk_stages,1:NDt) TVD/SSP Runge-Kutta errors. real(kind=R_P), public :: ab_orders (1:space_dimension,1:ab_steps,1:NDt-1) Adams-Bashforth orders. real(kind=R_P), public :: abm_orders (1:space_dimension,1:ab_steps,1:NDt-1) Adams-Bashforth-Moulton orders. real(kind=R_P), public :: am_orders (1:space_dimension,1:ab_steps,1:NDt-1) Adams-Moulton orders. real(kind=R_P), public :: emd_rk_orders (1:space_dimension,1:emd_rk_stages,1:NDt-1) Embedded Runge-Kutta orders. real(kind=R_P), public :: lf_orders (1:space_dimension,1:2,1:NDt-1) Leapfrog orders. real(kind=R_P), public :: ls_rk_orders (1:space_dimension,1:ls_rk_stages,1:NDt-1) Low storage Runge-Kutta orders. real(kind=R_P), public :: tvd_rk_orders (1:space_dimension,1:tvd_rk_stages,1:NDt-1) TVD/SSP Runge-Kutta orders. Source Code subroutine perform_errors_analysis () !--------------------------------------------------------------------------------------------------------------------------------- !< Peform errors analysis. !< !< The analysis is based on the integration of the Oscillation equations with different, decreasing time steps in the range !< *[5000, 2500, 1250, 625, 320, 100]*. The error is estimated by the L2 norm of the difference between the exact (U_e) and !< the numerical (U_{\\Delta t}) solutions for each time step: !< !< !<\\varepsilon (\\Delta t) = || U_e - U_{\\Delta t} ||_2 = \\sqrt{ \\sum_{s=1}&#94;{N_s} { \\left(U_e(t_0 + s * \\Delta t) - !<U_{\\Delta t}(t_0 + s * \\Delta t) \\right)&#94;2 }} !< !< !< Using two pairs of subsequent-decreasing time steps solution is possible to estimate the order of accuracy of the solver !< employed computing the \\emph{observed order} of accuracy: !< !< !<p = \\frac{log10 \\left( \\frac{\\varepsilon (\\Delta t_1)}{\\varepsilon (\\Delta t_2)} \\right)} !<{log10 \\left( \\frac{\\Delta t_1}{\\Delta t_2} \\right)} !< !< !<where \\frac{\\Delta t_1}{\\Delta t_2}>1. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), parameter :: NDt = 6 !< Number of time steps exercised. real ( R_P ), parameter :: time_steps ( 1 : NDt ) = [ 500 0._R_P , & 250 0._R_P , & 125 0._R_P , & 62 5._R_P , & 32 0._R_P , & 10 0._R_P ] !< Time steps exercised. real ( R_P ), parameter :: tolerances ( 1 : NDt ) = [ 0.001_R_P , & 0.0001_R_P , & 0.00001_R_P , & 0.000001_R_P , & 0.0000001_R_P , & 0.00000001_R_P ] !< Tolerances for embedded RK solvers. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. integer , parameter :: emd_rk_stages = 17 !< Embedded Runge-Kutta stages number. integer , parameter :: tvd_rk_stages = 5 !< TVD/SSP Runge-Kutta stages number. integer , parameter :: ls_rk_stages = 14 !< Low storage Runge-Kutta stages number. integer ( I_P ) :: s !< Steps/stages counter. integer ( I_P ) :: d !< Time steps-exercised counter. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: last_step !< Last time step computed. real ( R_P ) :: emd_Dt_mean ( 1 : emd_rk_stages , 1 : NDt ) !< Mean time resolution for adaptive step methods. ! errors and orders real ( R_P ) :: ab_errors ( 1 : space_dimension , 1 : ab_steps , 1 : NDt ) !< Adams-Bashforth errors. real ( R_P ) :: abm_errors ( 1 : space_dimension , 1 : ab_steps , 1 : NDt ) !< Adams-Bashforth-Moulton errors. real ( R_P ) :: am_errors ( 1 : space_dimension , 1 : ab_steps , 1 : NDt ) !< Adams-Moulton errors. real ( R_P ) :: emd_rk_errors ( 1 : space_dimension , 1 : emd_rk_stages , 1 : NDt ) !< TVD/SSP Runge-Kutta errors. real ( R_P ) :: lf_errors ( 1 : space_dimension , 1 : 2 , 1 : NDt ) !< Leapfrog errors. real ( R_P ) :: ls_rk_errors ( 1 : space_dimension , 1 : ls_rk_stages , 1 : NDt ) !< Low storage Runge-Kutta errors. real ( R_P ) :: tvd_rk_errors ( 1 : space_dimension , 1 : tvd_rk_stages , 1 : NDt ) !< TVD/SSP Runge-Kutta errors. real ( R_P ) :: ab_orders ( 1 : space_dimension , 1 : ab_steps , 1 : NDt - 1 ) !< Adams-Bashforth orders. real ( R_P ) :: abm_orders ( 1 : space_dimension , 1 : ab_steps , 1 : NDt - 1 ) !< Adams-Bashforth-Moulton orders. real ( R_P ) :: am_orders ( 1 : space_dimension , 1 : ab_steps , 1 : NDt - 1 ) !< Adams-Moulton orders. real ( R_P ) :: emd_rk_orders ( 1 : space_dimension , 1 : emd_rk_stages , 1 : NDt - 1 ) !< Embedded Runge-Kutta orders. real ( R_P ) :: lf_orders ( 1 : space_dimension , 1 : 2 , 1 : NDt - 1 ) !< Leapfrog orders. real ( R_P ) :: ls_rk_orders ( 1 : space_dimension , 1 : ls_rk_stages , 1 : NDt - 1 ) !< Low storage Runge-Kutta orders. real ( R_P ) :: tvd_rk_orders ( 1 : space_dimension , 1 : tvd_rk_stages , 1 : NDt - 1 ) !< TVD/SSP Runge-Kutta orders. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ab_errors = - 1._R_P ; ab_orders = 0._R_P abm_errors = - 1._R_P ; abm_orders = 0._R_P am_errors = - 1._R_P ; am_orders = 0._R_P emd_rk_errors = - 1._R_P ; emd_rk_orders = 0._R_P lf_errors = - 1._R_P ; lf_orders = 0._R_P ls_rk_errors = - 1._R_P ; ls_rk_orders = 0._R_P tvd_rk_errors = - 1._R_P ; tvd_rk_orders = 0._R_P if ( allocated ( solution )) deallocate ( solution ) ; allocate ( solution ( 0 : space_dimension , 0 : int ( t_final / Dt ))) results = . true . ! activate results saving ! Analyze errors of Adams-Bashforth solvers do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'adams-bashforth' call init ( output = output , solution = solution ) do s = 1 , ab_steps title = 'Oscillation equation integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // ' steps=' // trim ( str (. true ., s )) call ab_solver ( steps = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) ab_errors (:, s , d ) = compute_errors ( solution = solution ) enddo enddo do s = 1 , ab_steps do d = 1 , NDt - 1 ab_orders (:, s , d ) = estimate_orders ( solver_error = ab_errors (:, s , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo enddo ! Analyze errors of Adams-Bashforth-Moulton solvers do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'adams-bashforth-moulton' call init ( output = output , solution = solution ) do s = 1 , ab_steps title = 'Oscillation equation integration, predictor-corrector Adams-Bashforth-Moulton, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) call abm_solver ( steps = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) abm_errors (:, s , d ) = compute_errors ( solution = solution ) enddo enddo do s = 1 , ab_steps do d = 1 , NDt - 1 abm_orders (:, s , d ) = estimate_orders ( solver_error = abm_errors (:, s , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo enddo ! Analyze errors of Adams-Moulton solvers do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'adams-moulton' call init ( output = output , solution = solution ) do s = 0 , ab_steps - 1 title = 'Oscillation equation integration, implicit Adams-Moulton, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) if ( implicit_iterations > 1 ) then call am_solver ( steps = s , solution = solution , iterations = implicit_iterations ) else call am_solver ( steps = s , solution = solution ) endif call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) am_errors (:, s + 1 , d ) = compute_errors ( solution = solution ) enddo enddo do s = 0 , ab_steps - 1 do d = 1 , NDt - 1 am_orders (:, s + 1 , d ) = estimate_orders ( solver_error = am_errors (:, s + 1 , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo enddo ! Analyze errors of embedded Runge-Kutta solvers emd_Dt_mean = 0._R_P do d = 1 , NDt ! loop over exercised tolerances Dt = time_steps ( NDt ) tolerance = tolerances ( d ) solver = 'emd-runge-kutta' call init ( output = output , solution = solution ) do s = 1 , emd_rk_stages if ( s == 1 ) cycle ! 1 stages not allowed if ( s == 2 ) cycle ! 2 stages not suited for test if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 5 ) cycle ! 5 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented if ( s == 12 ) cycle ! 12 stages not yet implemented if ( s == 13 ) cycle ! 13 stages not yet implemented if ( s == 14 ) cycle ! 14 stages not yet implemented if ( s == 15 ) cycle ! 15 stages not yet implemented if ( s == 16 ) cycle ! 16 stages not yet implemented title = 'Oscillation equation integration, explicit embedded Runge-Kutta t=' // str ( n = t_final ) // ' stages=' // trim ( str (. true ., s )) if ( s == 17 ) then call emd_rk_solver ( stages = s , tol = tolerances ( d ) / 100 0._R_P , solution = solution , last_step = last_step ) else call emd_rk_solver ( stages = s , tol = tolerances ( d ), solution = solution , last_step = last_step ) endif emd_Dt_mean ( s , d ) = t_final / real ( last_step , kind = R_P ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution (:, 0 : last_step )) emd_rk_errors (:, s , d ) = compute_errors ( solution = solution (:, 0 : last_step )) enddo enddo do s = 1 , emd_rk_stages if ( s == 1 ) cycle ! 1 stages not allowed if ( s == 2 ) cycle ! 2 stages not suited for test if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 5 ) cycle ! 5 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented if ( s == 12 ) cycle ! 12 stages not yet implemented if ( s == 13 ) cycle ! 13 stages not yet implemented if ( s == 14 ) cycle ! 14 stages not yet implemented if ( s == 15 ) cycle ! 15 stages not yet implemented if ( s == 16 ) cycle ! 16 stages not yet implemented do d = 1 , NDt - 1 emd_rk_orders (:, s , d ) = estimate_orders ( solver_error = emd_rk_errors (:, s , d : d + 1 ), Dt_used = emd_Dt_mean ( s , d : d + 1 )) enddo enddo ! Analyze errors of leapfrog solver do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'leapfrog' call init ( output = output , solution = solution ) title = 'Oscillation equation integration, leapfrog (unfiltered), t=' // str ( n = t_final ) call leapfrog_solver ( solution = solution ) call save_results ( title = title , basename = output , solution = solution ) lf_errors (:, 1 , d ) = compute_errors ( solution = solution ) Dt = time_steps ( d ) solver = 'leapfrog' call init ( output = output , solution = solution ) title = 'Oscillation equation integration, leapfrog (RAW filtered), t=' // str ( n = t_final ) call leapfrog_solver ( solution = solution , raw = . true .) call save_results ( title = title , basename = output // '-raw' , solution = solution ) lf_errors (:, 2 , d ) = compute_errors ( solution = solution ) enddo do d = 1 , NDt - 1 lf_orders (:, 1 , d ) = estimate_orders ( solver_error = lf_errors (:, 1 , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) lf_orders (:, 2 , d ) = estimate_orders ( solver_error = lf_errors (:, 2 , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo ! Analyze errors of low storage Runge-Kutta solvers do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'ls-runge-kutta' call init ( output = output , solution = solution ) do s = 1 , ls_rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 9 ) cycle ! 9 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented title = 'Oscillation equation integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) call ls_rk_solver ( stages = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) ls_rk_errors (:, s , d ) = compute_errors ( solution = solution ) enddo enddo do s = 1 , ls_rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 9 ) cycle ! 9 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented do d = 1 , NDt - 1 ls_rk_orders (:, s , d ) = estimate_orders ( solver_error = ls_rk_errors (:, s , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo enddo ! Analyze errors of TVD/SSP Runge-Kutta solvers do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'tvd-runge-kutta' call init ( output = output , solution = solution ) do s = 1 , tvd_rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented title = 'Oscillation equation integration, explicit TVD/SSP Runge-Kutta, t=' // str ( n = t_final ) // ' steps=' // trim ( str (. true ., s )) call tvd_rk_solver ( stages = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) tvd_rk_errors (:, s , d ) = compute_errors ( solution = solution ) enddo enddo do s = 1 , tvd_rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented do d = 1 , NDt - 1 tvd_rk_orders (:, s , d ) = estimate_orders ( solver_error = tvd_rk_errors (:, s , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo enddo print \"(A)\" , \"Solver & Time Step & f*Dt & Error X & Error Y & Observed Order of Accuracy X & Observed Order of Accuracy Y\" call print_analysis ( solver = 'adams-bashforth' , time_steps = time_steps , errors = ab_errors , orders = ab_orders ) call print_analysis ( solver = 'adams-bashforth-moulton' , time_steps = time_steps , errors = abm_errors , orders = abm_orders ) call print_analysis ( solver = 'adams-moulton' , time_steps = time_steps , errors = am_errors , orders = am_orders ) call print_analysis ( solver = 'emd-runge-kutta' , mean_time_steps = emd_Dt_mean , errors = emd_rk_errors , orders = emd_rk_orders ) call print_analysis ( solver = 'leapfrog' , time_steps = time_steps , errors = lf_errors , orders = lf_orders ) call print_analysis ( solver = 'ls-runge-kutta' , time_steps = time_steps , errors = ls_rk_errors , orders = ls_rk_orders ) call print_analysis ( solver = 'tvd-runge-kutta' , time_steps = time_steps , errors = tvd_rk_errors , orders = tvd_rk_orders ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine perform_errors_analysis","tags":"","loc":"proc/perform_errors_analysis.html","title":"perform_errors_analysis – FOODIE"},{"text":"subroutine print_analysis(solver, time_steps, mean_time_steps, errors, orders) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: solver Solver name. real(kind=R_P), intent(in), optional :: time_steps (:) Time steps exercised. real(kind=R_P), intent(in), optional :: mean_time_steps (:,:) Mean time steps exercised. real(kind=R_P), intent(in) :: errors (:,:,:) Errors of the solver. real(kind=R_P), intent(in) :: orders (:,:,:) Observed orders of the solver. Description Print summary of the error analysis. Calls proc~~print_analysis~~CallsGraph proc~print_analysis print_analysis str str proc~print_analysis->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~print_analysis~~CalledByGraph proc~print_analysis print_analysis proc~perform_errors_analysis perform_errors_analysis proc~perform_errors_analysis->proc~print_analysis program~integrate_oscillation integrate_oscillation program~integrate_oscillation->proc~perform_errors_analysis Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Solver index. integer(kind=I_P), public :: d Time steps-exercised counter. Source Code subroutine print_analysis ( solver , time_steps , mean_time_steps , errors , orders ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print summary of the error analysis. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: solver !< Solver name. real ( R_P ), optional , intent ( IN ) :: time_steps (:) !< Time steps exercised. real ( R_P ), optional , intent ( IN ) :: mean_time_steps (:,:) !< Mean time steps exercised. real ( R_P ), intent ( IN ) :: errors (:,:,:) !< Errors of the solver. real ( R_P ), intent ( IN ) :: orders (:,:,:) !< Observed orders of the solver. integer ( I_P ) :: s !< Solver index. integer ( I_P ) :: d !< Time steps-exercised counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( time_steps )) then do s = 1 , size ( errors , dim = 2 ) if ( errors ( 1 , s , 1 ) < 0._R_P ) cycle print \"(A)\" , solver // '-' // trim ( str (. true ., s )) do d = 1 , size ( errors , dim = 3 ) if ( d == 1 ) then print \"(A,F8.1,A,F10.3,A,E10.3,A,E10.3,A)\" , & \"  & \" , time_steps ( d ), \" & \" , f * time_steps ( d ), \" & \" , & errors ( 1 , s , d ), \" & \" , errors ( 2 , s , d ), \" & / & /\" else print \"(A,F8.1,A,F10.3,A,E10.3,A,E10.3,A,F9.2,A,F9.2)\" , & \"  & \" , time_steps ( d ), \" & \" , f * time_steps ( d ), \" & \" , & errors ( 1 , s , d ), \" & \" , errors ( 2 , s , d ), \" & \" , & orders ( 1 , s , d - 1 ), \" & \" , orders ( 2 , s , d - 1 ) endif enddo enddo elseif ( present ( mean_time_steps )) then do s = 1 , size ( errors , dim = 2 ) if ( errors ( 1 , s , 1 ) < 0._R_P ) cycle print \"(A)\" , solver // '-' // trim ( str (. true ., s )) do d = 1 , size ( errors , dim = 3 ) if ( d == 1 ) then print \"(A,F8.1,A,F10.3,A,E10.3,A,E10.3,A)\" , & \"  & \" , mean_time_steps ( s , d ), \" & \" , f * mean_time_steps ( s , d ), \" & \" , & errors ( 1 , s , d ), \" & \" , errors ( 2 , s , d ), \" & / & /\" else print \"(A,F8.1,A,F10.3,A,E10.3,A,E10.3,A,F9.2,A,F9.2)\" , & \"  & \" , mean_time_steps ( s , d ), \" & \" , f * mean_time_steps ( s , d ), \" & \" , & errors ( 1 , s , d ), \" & \" , errors ( 2 , s , d ), \" & \" , & orders ( 1 , s , d - 1 ), \" & \" , orders ( 2 , s , d - 1 ) endif enddo enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_analysis","tags":"","loc":"proc/print_analysis.html","title":"print_analysis – FOODIE"},{"text":"private purefunction output(self) result(state) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. Return Value real(kind=R_P),\n  dimension(:),allocatable Oscillation state vector. Description Output the Oscillation field state. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Oscillation field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. real ( R_P ), dimension (:), allocatable :: state !< Oscillation state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output.html","title":"output – FOODIE"},{"text":"private function dOscillation_dt(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Oscillation field time derivative. Description Time derivative of Oscillation field. Source Code function dOscillation_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Oscillation field time derivative. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: dState_dt ) select type ( dState_dt ) class is ( oscillation ) dState_dt = self dState_dt % U ( 1 ) = - self % f * self % U ( 2 ) dState_dt % U ( 2 ) = self % f * self % U ( 1 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dOscillation_dt","tags":"","loc":"proc/doscillation_dt.html","title":"dOscillation_dt – FOODIE"},{"text":"private function oscillation_local_error(lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 oscillation approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code function oscillation_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 oscillation approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( oscillation ) error = 0._R_P do i = 1 , lhs % dims error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_local_error","tags":"","loc":"proc/oscillation_local_error.html","title":"oscillation_local_error – FOODIE"},{"text":"private function oscillation_multiply_oscillation(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a oscillation field by another one. Source Code function oscillation_multiply_oscillation ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a oscillation field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_multiply_oscillation","tags":"","loc":"proc/oscillation_multiply_oscillation.html","title":"oscillation_multiply_oscillation – FOODIE"},{"text":"private function oscillation_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Oscillation field by a real scalar. Source Code function oscillation_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Oscillation field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_multiply_real","tags":"","loc":"proc/oscillation_multiply_real.html","title":"oscillation_multiply_real – FOODIE"},{"text":"private function real_multiply_oscillation(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( oscillation ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Oscillation field. Source Code function real_multiply_oscillation ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( oscillation ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_oscillation","tags":"","loc":"proc/real_multiply_oscillation.html","title":"real_multiply_oscillation – FOODIE"},{"text":"private function add_oscillation(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Oscillation fields. Source Code function add_oscillation ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Oscillation fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Oscillation","tags":"","loc":"proc/add_oscillation.html","title":"add_oscillation – FOODIE"},{"text":"private function sub_oscillation(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Oscillation fields. Source Code function sub_oscillation ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Oscillation fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_Oscillation","tags":"","loc":"proc/sub_oscillation.html","title":"sub_oscillation – FOODIE"},{"text":"private subroutine init(self, initial_state, f) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of the Oscillation field vector. real(kind=R_P), intent(in) :: f Frequency. Description Construct an initialized Oscillation field. Source Code subroutine init ( self , initial_state , f ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: self !< Oscillation field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Initial state of the Oscillation field vector. real ( R_P ), intent ( IN ) :: f !< Frequency. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % f = f if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % dims )) ; self % U = initial_state return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~9.html","title":"init – FOODIE"},{"text":"private subroutine oscillation_assign_oscillation(lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Oscillation field to another. Source Code subroutine oscillation_assign_oscillation ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Oscillation field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( oscillation ) lhs % dims = rhs % dims lhs % f = rhs % f if ( allocated ( rhs % U )) lhs % U = rhs % U endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine oscillation_assign_oscillation","tags":"","loc":"proc/oscillation_assign_oscillation.html","title":"oscillation_assign_oscillation – FOODIE"},{"text":"subroutine init() Arguments None Description Initialize the simulation. Calls proc~~init~10~~CallsGraph proc~init~10 init proc~save_time_serie save_time_serie proc~init~10->proc~save_time_serie strz strz proc~init~10->strz str str proc~init~10->str proc~save_time_serie->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~init~10~~CalledByGraph proc~init~10 init program~integrate_euler_1d_caf integrate_euler_1D_caf program~integrate_euler_1d_caf->proc~init~10 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. real(kind=R_P), public :: x_L Left abscissa of local image. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~10.html","title":"init – FOODIE"},{"text":"subroutine synchronize() Arguments None Description Synchronize CAF images. Called By proc~~synchronize~~CalledByGraph proc~synchronize synchronize program~integrate_euler_1d_caf integrate_euler_1D_caf program~integrate_euler_1d_caf->proc~synchronize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Images counter. Source Code subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize","tags":"","loc":"proc/synchronize.html","title":"synchronize – FOODIE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. Calls proc~~save_results~2~~CallsGraph proc~save_results~2 save_results str str proc~save_results~2->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_results~2~~CalledByGraph proc~save_results~2 save_results program~integrate_euler_1d_caf integrate_euler_1D_caf program~integrate_euler_1d_caf->proc~save_results~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type(pyplot), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~2.html","title":"save_results – FOODIE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Calls proc~~save_time_serie~~CallsGraph proc~save_time_serie save_time_serie str str proc~save_time_serie->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~~CalledByGraph proc~save_time_serie save_time_serie proc~init~10 init proc~init~10->proc~save_time_serie program~integrate_euler_1d_caf integrate_euler_1D_caf program~integrate_euler_1d_caf->proc~save_time_serie program~integrate_euler_1d_caf->proc~init~10 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public, save :: tsfile File unit for saving time serie results. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie.html","title":"save_time_serie – FOODIE"},{"text":"private purefunction output(self, conservative) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. logical, intent(in), optional :: conservative Output conservative variables instead of primitive. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code pure function output ( self , conservative ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. logical , optional , intent ( IN ) :: conservative !< Output conservative variables instead of primitive. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( conservative )) then state = self % U else allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~2.html","title":"output – FOODIE"},{"text":"private purefunction compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. Calls proc~~compute_dt~~CallsGraph proc~compute_dt compute_dt proc~a a proc~compute_dt->proc~a Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: P (:) Primitive variables. real(kind=R_P), public :: vmax Maximum propagation speed of signals. integer(kind=I_P), public :: i Counter. Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt.html","title":"compute_dt – FOODIE"},{"text":"private function dEuler_dt(self) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. Return Value type( euler_1D_caf_nf ) Euler field time derivative. Description Time derivative of Euler field, the residuals function. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: F (:,:) Fluxes of conservative variables. real(kind=R_P), public, allocatable :: P (:,:) Primitive variables. real(kind=R_P), public, allocatable :: PR (:,:,:) Left (1) and right (2) (reconstructed) interface values of primitive variables. integer(kind=I_P), public :: i Counter. Source Code function dEuler_dt ( self ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. type ( euler_1D_caf_nf ) :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals dState_dt = self do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt.html","title":"dEuler_dt – FOODIE"},{"text":"private purefunction primitive2conservative(self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative.html","title":"primitive2conservative – FOODIE"},{"text":"private purefunction conservative2primitive(self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: c (:) Species concentration. Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive.html","title":"conservative2primitive – FOODIE"},{"text":"private elementalfunction p(r, a, g) result(pressure) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Description Compute the pressure for an ideal calorically perfect gas. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p.html","title":"p – FOODIE"},{"text":"private elementalfunction r(p, a, g) result(density) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Description Compute the density for an ideal calorically perfect gas. Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r.html","title":"r – FOODIE"},{"text":"private elementalfunction a(p, r, g) result(ss) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Description Compute the speed of sound for an ideal calorically perfect gas. Called By proc~~a~~CalledByGraph proc~a a proc~compute_dt compute_dt proc~compute_dt->proc~a none~eigen_vect_l eigen_vect_L none~eigen_vect_l->proc~a none~eigen_vect_r eigen_vect_R none~eigen_vect_r->proc~a proc~reconstruct_interfaces_states reconstruct_interfaces_states proc~reconstruct_interfaces_states->none~eigen_vect_l proc~reconstruct_interfaces_states->none~eigen_vect_r Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a.html","title":"a – FOODIE"},{"text":"private elementalfunction E(p, r, u, g) result(energy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Description Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~e~~CalledByGraph proc~e E proc~riemann_solver riemann_solver proc~riemann_solver->proc~e Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e.html","title":"E – FOODIE"},{"text":"private elementalfunction H(p, r, u, g) result(entalpy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Description Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~h~~CalledByGraph proc~h H none~fluxes fluxes none~fluxes->proc~h proc~riemann_solver riemann_solver proc~riemann_solver->none~fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h.html","title":"H – FOODIE"},{"text":"private elementalsubroutine init_rk(self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. Source Code elemental subroutine init_rk ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init_rk","tags":"","loc":"proc/init_rk.html","title":"init_rk – FOODIE"},{"text":"private elementalsubroutine destroy_rk(self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destoy the integrator. Source Code elemental subroutine destroy_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy_rk","tags":"","loc":"proc/destroy_rk.html","title":"destroy_rk – FOODIE"},{"text":"private subroutine integrate_rk(self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( euler_1D_caf_nf ), intent(inout) :: U Field to be integrated. class( euler_1D_caf_nf ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coeficients are initialized). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s First stages counter. integer(kind=I_P), public :: ss Second stages counter. Source Code subroutine integrate_rk ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( euler_1D_caf_nf ), intent ( INOUT ) :: U !< Field to be integrated. class ( euler_1D_caf_nf ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s )% U = stage ( s )% U + stage ( ss )% U * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t () enddo ! computing new time step do s = 1 , self % stages U % U = U % U + stage ( s )% U * ( Dt * self % beta ( s )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate_rk","tags":"","loc":"proc/integrate_rk.html","title":"integrate_rk – FOODIE"},{"text":"private elementalsubroutine finalize_rk(self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Source Code elemental subroutine finalize_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_rk","tags":"","loc":"proc/finalize_rk.html","title":"finalize_rk – FOODIE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, me, we, ord) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension (local image). integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in) :: me ID of this_image(). integer(kind=I_P), intent(in) :: we Number of CAF images used. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. Calls proc~~init~11~~CallsGraph proc~init~11 init weno_constructor_upwind weno_constructor_upwind proc~init~11->weno_constructor_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(weno_factory), public :: factory WENO factory. class(weno_interpolator), public, allocatable :: weno WENO interpolator. integer(kind=I_P), public :: i Space counter. Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , me , we , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension (local image). integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), intent ( IN ) :: me !< ID of this_image(). integer ( I_P ), intent ( IN ) :: we !< Number of CAF images used. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo self % me = me self % we = we #ifdef CAF if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )[ * ]) #else if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )) #endif if ( allocated ( U_L )) deallocate ( U_L ) ; allocate ( U_L ( 1 : self % Nc , 1 : self % Ni )) if ( allocated ( U_R )) deallocate ( U_R ) ; allocate ( U_R ( 1 : self % Nc , 1 : self % Ni )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~11.html","title":"init – FOODIE"},{"text":"private subroutine destroy(self) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) self % me = 0 self % we = 0 if ( allocated ( remote_U )) deallocate ( remote_U ) if ( allocated ( U_L )) deallocate ( U_L ) if ( allocated ( U_R )) deallocate ( U_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~7.html","title":"destroy – FOODIE"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_caf_nf ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: lhs !< Left hand side. class ( euler_1D_caf_nf ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf_nf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R lhs % me = rhs % me lhs % we = rhs % we endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler.html","title":"euler_assign_euler – FOODIE"},{"text":"private subroutine synchronize(self) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. Description Synchronize CAF images. Calls proc~~synchronize~2~~CallsGraph proc~synchronize~2 synchronize images images proc~synchronize~2->images Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Images counter. Source Code subroutine synchronize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( self % we > 1 ) then remote_U = self % U if ( self % me == 1 ) then sync images ( self % me + 1 ) U_R (:,:) = remote_U (:,:)[ self % me + 1 ] else if ( self % me == self % we ) then sync images ( self % me - 1 ) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] else sync images ([ self % me - 1 , self % me + 1 ]) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] U_R (:,:) = remote_U (:,:)[ self % me + 1 ] endif endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize","tags":"","loc":"proc/synchronize~2.html","title":"synchronize – FOODIE"},{"text":"private subroutine impose_boundary_conditions(self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. character(len=:), public, allocatable :: bc_type String containing BC type. Source Code subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. character ( len = :), allocatable :: bc_type !< String containing BC type. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- call self % synchronize bc_type = trim ( adjustl ( self % BC_L )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = 1 - self % Ng , 0 primitive (:, i ) = self % conservative2primitive ( U_L (:, self % Ni + i )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect endif bc_type = trim ( adjustl ( self % BC_R )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = self % conservative2primitive ( U_R (:, i - self % Ni )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect endif return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions.html","title":"impose_boundary_conditions – FOODIE"},{"text":"private subroutine reconstruct_interfaces_states(self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Calls proc~~reconstruct_interfaces_states~~CallsGraph proc~reconstruct_interfaces_states reconstruct_interfaces_states none~eigen_vect_r eigen_vect_R proc~reconstruct_interfaces_states->none~eigen_vect_r none~eigen_vect_l eigen_vect_L proc~reconstruct_interfaces_states->none~eigen_vect_l proc~a a none~eigen_vect_r->proc~a none~eigen_vect_l->proc~a Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: C (1:2,1-self%Ng:-1+self%Ng,1:self%Ns+2) Pseudo characteristic variables. real(kind=R_P), public :: CR (1:self%Ns+2,1:2) Pseudo characteristic reconst. vars. real(kind=R_P), public :: Pm (1:self%Np,1:2) Mean of primitive variables. real(kind=R_P), public :: LPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean left eigenvectors matrix. real(kind=R_P), public :: RPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean right eigenvectors matrix. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: j Counter. integer(kind=I_P), public :: f Counter. integer(kind=I_P), public :: v Counter. Functions purefunction eigen_vect_L(Ns, Np, primitive) result(L) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Left eigenvectors matrix. Description Compute left eigenvectors from primitive variables. purefunction eigen_vect_R(Ns, Np, primitive) result(R) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Right eigenvectors matrix. Description Compute right eigenvectors from primitive variables. Source Code subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states.html","title":"reconstruct_interfaces_states – FOODIE"},{"text":"private puresubroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Calls proc~~riemann_solver~~CallsGraph proc~riemann_solver riemann_solver proc~compute_inter_states compute_inter_states proc~riemann_solver->proc~compute_inter_states proc~e E proc~riemann_solver->proc~e none~fluxes fluxes proc~riemann_solver->none~fluxes proc~h H none~fluxes->proc~h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: F1 (1:3) State 1 fluxes. real(kind=R_P), public :: F4 (1:3) State 4 fluxes. real(kind=R_P), public :: u Velocity of the intermediate states. real(kind=R_P), public :: p Pressure of the intermediate states. real(kind=R_P), public :: S1 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: S4 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: lmax Maximum wave speed estimation. Functions purefunction fluxes(p, r, u, g) result(Fc) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Velocity. real(kind=R_P), intent(in) :: g Specific heats ratio. Return Value real(kind=R_P)\n  (1:3) State fluxes. Description 1D Euler fluxes from primitive variables. Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver.html","title":"riemann_solver – FOODIE"},{"text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( euler_1D_caf_nf ), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~7.html","title":"finalize – FOODIE"},{"text":"private puresubroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Description Compute inter states (23*-states) from state1 and state4. Called By proc~~compute_inter_states~~CalledByGraph proc~compute_inter_states compute_inter_states proc~riemann_solver riemann_solver proc~riemann_solver->proc~compute_inter_states Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: a1 Speed of sound of state 1. real(kind=R_P), public :: a4 Speed of sound of state 4. real(kind=R_P), public :: ram Mean value of rho*a. real(kind=R_P), public, parameter :: toll = 1e-10_R_P Tollerance. Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states.html","title":"compute_inter_states – FOODIE"},{"text":"subroutine init() Arguments None Description Initialize the simulation. Calls proc~~init~12~~CallsGraph proc~init~12 init strz strz proc~init~12->strz proc~save_time_serie~2 save_time_serie proc~init~12->proc~save_time_serie~2 str str proc~init~12->str proc~save_time_serie~2->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~init~12~~CalledByGraph proc~init~12 init program~integrate_euler_1d_caf~2 integrate_euler_1D_caf program~integrate_euler_1d_caf~2->proc~init~12 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. real(kind=R_P), public :: x_L Left abscissa of local image. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~12.html","title":"init – FOODIE"},{"text":"subroutine synchronize() Arguments None Description Synchronize CAF images. Called By proc~~synchronize~3~~CalledByGraph proc~synchronize~3 synchronize program~integrate_euler_1d_caf~2 integrate_euler_1D_caf program~integrate_euler_1d_caf~2->proc~synchronize~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Images counter. Source Code subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize","tags":"","loc":"proc/synchronize~3.html","title":"synchronize – FOODIE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. Calls proc~~save_results~3~~CallsGraph proc~save_results~3 save_results str str proc~save_results~3->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_results~3~~CalledByGraph proc~save_results~3 save_results program~integrate_euler_1d_caf~2 integrate_euler_1D_caf program~integrate_euler_1d_caf~2->proc~save_results~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type(pyplot), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~3.html","title":"save_results – FOODIE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Calls proc~~save_time_serie~2~~CallsGraph proc~save_time_serie~2 save_time_serie str str proc~save_time_serie~2->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~2~~CalledByGraph proc~save_time_serie~2 save_time_serie proc~init~12 init proc~init~12->proc~save_time_serie~2 program~integrate_euler_1d_caf~2 integrate_euler_1D_caf program~integrate_euler_1d_caf~2->proc~save_time_serie~2 program~integrate_euler_1d_caf~2->proc~init~12 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public, save :: tsfile File unit for saving time serie results. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie~2.html","title":"save_time_serie – FOODIE"},{"text":"private purefunction output(self, conservative) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. logical, intent(in), optional :: conservative Output conservative variables instead of primitive. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code pure function output ( self , conservative ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. logical , optional , intent ( IN ) :: conservative !< Output conservative variables instead of primitive. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( conservative )) then state = self % U else allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~3.html","title":"output – FOODIE"},{"text":"private purefunction compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. Calls proc~~compute_dt~2~~CallsGraph proc~compute_dt~2 compute_dt proc~a~2 a proc~compute_dt~2->proc~a~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: P (:) Primitive variables. real(kind=R_P), public :: vmax Maximum propagation speed of signals. integer(kind=I_P), public :: i Counter. Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~2.html","title":"compute_dt – FOODIE"},{"text":"private function dEuler_dt(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: F (:,:) Fluxes of conservative variables. real(kind=R_P), public, allocatable :: P (:,:) Primitive variables. real(kind=R_P), public, allocatable :: PR (:,:,:) Left (1) and right (2) (reconstructed) interface values of primitive variables. integer(kind=I_P), public :: i Counter. Source Code function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D_caf :: dState_dt ) select type ( dState_dt ) class is ( euler_1D_caf ) dState_dt = self endselect select type ( dState_dt ) class is ( euler_1D_caf ) do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt~2.html","title":"dEuler_dt – FOODIE"},{"text":"private function euler_local_error(lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 euler approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. integer(kind=I_P), public :: v Variables counter. Source Code function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf ) error = 0._R_P do i = 1 , lhs % Ni do v = 1 , lhs % Nc error = error + ( lhs % U ( v , i ) - rhs % U ( v , i )) ** 2 / lhs % U ( v , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error","tags":"","loc":"proc/euler_local_error.html","title":"euler_local_error – FOODIE"},{"text":"private function euler_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. Source Code function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler","tags":"","loc":"proc/euler_multiply_euler.html","title":"euler_multiply_euler – FOODIE"},{"text":"private function euler_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. Source Code function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real","tags":"","loc":"proc/euler_multiply_real.html","title":"euler_multiply_real – FOODIE"},{"text":"private function real_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D_caf ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. Source Code function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D_caf ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = rhs endselect select type ( opr ) class is ( euler_1D_caf ) opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler","tags":"","loc":"proc/real_multiply_euler.html","title":"real_multiply_euler – FOODIE"},{"text":"private function add_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. Source Code function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler","tags":"","loc":"proc/add_euler.html","title":"add_euler – FOODIE"},{"text":"private function sub_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. Source Code function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler","tags":"","loc":"proc/sub_euler.html","title":"sub_euler – FOODIE"},{"text":"private purefunction primitive2conservative(self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative~2.html","title":"primitive2conservative – FOODIE"},{"text":"private purefunction conservative2primitive(self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: c (:) Species concentration. Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive~2.html","title":"conservative2primitive – FOODIE"},{"text":"private elementalfunction p(r, a, g) result(pressure) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Description Compute the pressure for an ideal calorically perfect gas. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p~2.html","title":"p – FOODIE"},{"text":"private elementalfunction r(p, a, g) result(density) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Description Compute the density for an ideal calorically perfect gas. Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r~2.html","title":"r – FOODIE"},{"text":"private elementalfunction a(p, r, g) result(ss) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Description Compute the speed of sound for an ideal calorically perfect gas. Called By proc~~a~2~~CalledByGraph proc~a~2 a proc~compute_dt~2 compute_dt proc~compute_dt~2->proc~a~2 none~eigen_vect_r~2 eigen_vect_R none~eigen_vect_r~2->proc~a~2 none~eigen_vect_l~2 eigen_vect_L none~eigen_vect_l~2->proc~a~2 proc~reconstruct_interfaces_states~2 reconstruct_interfaces_states proc~reconstruct_interfaces_states~2->none~eigen_vect_r~2 proc~reconstruct_interfaces_states~2->none~eigen_vect_l~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a~2.html","title":"a – FOODIE"},{"text":"private elementalfunction E(p, r, u, g) result(energy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Description Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~e~2~~CalledByGraph proc~e~2 E proc~riemann_solver~2 riemann_solver proc~riemann_solver~2->proc~e~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e~2.html","title":"E – FOODIE"},{"text":"private elementalfunction H(p, r, u, g) result(entalpy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Description Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~h~2~~CalledByGraph proc~h~2 H none~fluxes~2 fluxes none~fluxes~2->proc~h~2 proc~riemann_solver~2 riemann_solver proc~riemann_solver~2->none~fluxes~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h~2.html","title":"H – FOODIE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, me, we, ord) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension (local image). integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in) :: me ID of this_image(). integer(kind=I_P), intent(in) :: we Number of CAF images used. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. Calls proc~~init~13~~CallsGraph proc~init~13 init weno_constructor_upwind weno_constructor_upwind proc~init~13->weno_constructor_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(weno_factory), public :: factory WENO factory. class(weno_interpolator), public, allocatable :: weno WENO interpolator. integer(kind=I_P), public :: i Space counter. Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , me , we , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension (local image). integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), intent ( IN ) :: me !< ID of this_image(). integer ( I_P ), intent ( IN ) :: we !< Number of CAF images used. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo self % me = me self % we = we #ifdef CAF if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )[ * ]) #else if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )) #endif if ( allocated ( U_L )) deallocate ( U_L ) ; allocate ( U_L ( 1 : self % Nc , 1 : self % Ni )) if ( allocated ( U_R )) deallocate ( U_R ) ; allocate ( U_R ( 1 : self % Nc , 1 : self % Ni )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~13.html","title":"init – FOODIE"},{"text":"private subroutine destroy(self) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) self % me = 0 self % we = 0 if ( allocated ( remote_U )) deallocate ( remote_U ) if ( allocated ( U_L )) deallocate ( U_L ) if ( allocated ( U_R )) deallocate ( U_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~8.html","title":"destroy – FOODIE"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R lhs % me = rhs % me lhs % we = rhs % we endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler~2.html","title":"euler_assign_euler – FOODIE"},{"text":"private subroutine euler_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. Source Code subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real","tags":"","loc":"proc/euler_assign_real.html","title":"euler_assign_real – FOODIE"},{"text":"private subroutine synchronize(self) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. Description Synchronize CAF images. Calls proc~~synchronize~4~~CallsGraph proc~synchronize~4 synchronize images images proc~synchronize~4->images Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Images counter. Source Code subroutine synchronize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( self % we > 1 ) then remote_U = self % U if ( self % me == 1 ) then sync images ( self % me + 1 ) U_R (:,:) = remote_U (:,:)[ self % me + 1 ] else if ( self % me == self % we ) then sync images ( self % me - 1 ) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] else sync images ([ self % me - 1 , self % me + 1 ]) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] U_R (:,:) = remote_U (:,:)[ self % me + 1 ] endif endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize","tags":"","loc":"proc/synchronize~4.html","title":"synchronize – FOODIE"},{"text":"private subroutine impose_boundary_conditions(self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. character(len=:), public, allocatable :: bc_type String containing BC type. Source Code subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. character ( len = :), allocatable :: bc_type !< String containing BC type. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- call self % synchronize bc_type = trim ( adjustl ( self % BC_L )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = 1 - self % Ng , 0 primitive (:, i ) = self % conservative2primitive ( U_L (:, self % Ni + i )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect endif bc_type = trim ( adjustl ( self % BC_R )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = self % conservative2primitive ( U_R (:, i - self % Ni )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect endif return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions~2.html","title":"impose_boundary_conditions – FOODIE"},{"text":"private subroutine reconstruct_interfaces_states(self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Calls proc~~reconstruct_interfaces_states~2~~CallsGraph proc~reconstruct_interfaces_states~2 reconstruct_interfaces_states none~eigen_vect_l~2 eigen_vect_L proc~reconstruct_interfaces_states~2->none~eigen_vect_l~2 none~eigen_vect_r~2 eigen_vect_R proc~reconstruct_interfaces_states~2->none~eigen_vect_r~2 proc~a~2 a none~eigen_vect_l~2->proc~a~2 none~eigen_vect_r~2->proc~a~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: C (1:2,1-self%Ng:-1+self%Ng,1:self%Ns+2) Pseudo characteristic variables. real(kind=R_P), public :: CR (1:self%Ns+2,1:2) Pseudo characteristic reconst. vars. real(kind=R_P), public :: Pm (1:self%Np,1:2) Mean of primitive variables. real(kind=R_P), public :: LPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean left eigenvectors matrix. real(kind=R_P), public :: RPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean right eigenvectors matrix. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: j Counter. integer(kind=I_P), public :: f Counter. integer(kind=I_P), public :: v Counter. Functions purefunction eigen_vect_L(Ns, Np, primitive) result(L) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Left eigenvectors matrix. Description Compute left eigenvectors from primitive variables. purefunction eigen_vect_R(Ns, Np, primitive) result(R) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Right eigenvectors matrix. Description Compute right eigenvectors from primitive variables. Source Code subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states~2.html","title":"reconstruct_interfaces_states – FOODIE"},{"text":"private puresubroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Calls proc~~riemann_solver~2~~CallsGraph proc~riemann_solver~2 riemann_solver proc~compute_inter_states~2 compute_inter_states proc~riemann_solver~2->proc~compute_inter_states~2 none~fluxes~2 fluxes proc~riemann_solver~2->none~fluxes~2 proc~e~2 E proc~riemann_solver~2->proc~e~2 proc~h~2 H none~fluxes~2->proc~h~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: F1 (1:3) State 1 fluxes. real(kind=R_P), public :: F4 (1:3) State 4 fluxes. real(kind=R_P), public :: u Velocity of the intermediate states. real(kind=R_P), public :: p Pressure of the intermediate states. real(kind=R_P), public :: S1 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: S4 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: lmax Maximum wave speed estimation. Functions purefunction fluxes(p, r, u, g) result(Fc) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Velocity. real(kind=R_P), intent(in) :: g Specific heats ratio. Return Value real(kind=R_P)\n  (1:3) State fluxes. Description 1D Euler fluxes from primitive variables. Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver~2.html","title":"riemann_solver – FOODIE"},{"text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( euler_1D_caf ), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~8.html","title":"finalize – FOODIE"},{"text":"private puresubroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Description Compute inter states (23*-states) from state1 and state4. Called By proc~~compute_inter_states~2~~CalledByGraph proc~compute_inter_states~2 compute_inter_states proc~riemann_solver~2 riemann_solver proc~riemann_solver~2->proc~compute_inter_states~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: a1 Speed of sound of state 1. real(kind=R_P), public :: a4 Speed of sound of state 4. real(kind=R_P), public :: ram Mean value of rho*a. real(kind=R_P), public, parameter :: toll = 1e-10_R_P Tollerance. Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states~2.html","title":"compute_inter_states – FOODIE"},{"text":"subroutine init() Arguments None Description Initialize the field. Called By proc~~init~14~~CalledByGraph proc~init~14 init program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie program~integrate_euler_1d_openmp_no_foodie->proc~init~14 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~14.html","title":"init – FOODIE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. Calls proc~~save_results~4~~CallsGraph proc~save_results~4 save_results str str proc~save_results~4->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_results~4~~CalledByGraph proc~save_results~4 save_results program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie program~integrate_euler_1d_openmp_no_foodie->proc~save_results~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type(pyplot), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~4.html","title":"save_results – FOODIE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Calls proc~~save_time_serie~3~~CallsGraph proc~save_time_serie~3 save_time_serie str str proc~save_time_serie~3->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~3~~CalledByGraph proc~save_time_serie~3 save_time_serie program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie program~integrate_euler_1d_openmp_no_foodie->proc~save_time_serie~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public, save :: tsfile File unit for saving time serie results. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie~3.html","title":"save_time_serie – FOODIE"},{"text":"private purefunction output(self) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~4.html","title":"output – FOODIE"},{"text":"private purefunction compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. Calls proc~~compute_dt~3~~CallsGraph proc~compute_dt~3 compute_dt proc~a~3 a proc~compute_dt~3->proc~a~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: P (:) Primitive variables. real(kind=R_P), public :: vmax Maximum propagation speed of signals. integer(kind=I_P), public :: i Counter. Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~3.html","title":"compute_dt – FOODIE"},{"text":"private function dEuler_dt(self) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. Return Value type( euler_1D_omp_nf ) Euler field time derivative. Description Time derivative of Euler field, the residuals function. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: F (:,:) Fluxes of conservative variables. real(kind=R_P), public, allocatable :: P (:,:) Primitive variables. real(kind=R_P), public, allocatable :: PR (:,:,:) Left (1) and right (2) (reconstructed) interface values of primitive variables. integer(kind=I_P), public :: i Counter. Source Code function dEuler_dt ( self ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. type ( euler_1D_omp_nf ) :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F, PR) do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals dState_dt = self !$OMP PARALLEL PRIVATE(i) SHARED(self, dState_dt, F) !$OMP DO do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt~3.html","title":"dEuler_dt – FOODIE"},{"text":"private purefunction primitive2conservative(self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative~3.html","title":"primitive2conservative – FOODIE"},{"text":"private purefunction conservative2primitive(self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: c (:) Species concentration. Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive~3.html","title":"conservative2primitive – FOODIE"},{"text":"private elementalfunction p(r, a, g) result(pressure) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Description Compute the pressure for an ideal calorically perfect gas. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p~3.html","title":"p – FOODIE"},{"text":"private elementalfunction r(p, a, g) result(density) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Description Compute the density for an ideal calorically perfect gas. Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r~3.html","title":"r – FOODIE"},{"text":"private elementalfunction a(p, r, g) result(ss) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Description Compute the speed of sound for an ideal calorically perfect gas. Called By proc~~a~3~~CalledByGraph proc~a~3 a proc~compute_dt~3 compute_dt proc~compute_dt~3->proc~a~3 none~eigen_vect_l~3 eigen_vect_L none~eigen_vect_l~3->proc~a~3 none~eigen_vect_r~3 eigen_vect_R none~eigen_vect_r~3->proc~a~3 proc~reconstruct_interfaces_states~3 reconstruct_interfaces_states proc~reconstruct_interfaces_states~3->none~eigen_vect_l~3 proc~reconstruct_interfaces_states~3->none~eigen_vect_r~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a~3.html","title":"a – FOODIE"},{"text":"private elementalfunction E(p, r, u, g) result(energy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Description Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~e~3~~CalledByGraph proc~e~3 E proc~riemann_solver~3 riemann_solver proc~riemann_solver~3->proc~e~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e~3.html","title":"E – FOODIE"},{"text":"private elementalfunction H(p, r, u, g) result(entalpy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Description Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~h~3~~CalledByGraph proc~h~3 H none~fluxes~3 fluxes none~fluxes~3->proc~h~3 proc~riemann_solver~3 riemann_solver proc~riemann_solver~3->none~fluxes~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h~3.html","title":"H – FOODIE"},{"text":"private elementalsubroutine init_rk(self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. Source Code elemental subroutine init_rk ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init_rk","tags":"","loc":"proc/init_rk~2.html","title":"init_rk – FOODIE"},{"text":"private elementalsubroutine destroy_rk(self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destoy the integrator. Source Code elemental subroutine destroy_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy_rk","tags":"","loc":"proc/destroy_rk~2.html","title":"destroy_rk – FOODIE"},{"text":"private subroutine integrate_rk(self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( euler_1D_omp_nf ), intent(inout) :: U Field to be integrated. class( euler_1D_omp_nf ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coeficients are initialized). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s First stages counter. integer(kind=I_P), public :: ss Second stages counter. Source Code subroutine integrate_rk ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( euler_1D_omp_nf ), intent ( INOUT ) :: U !< Field to be integrated. class ( euler_1D_omp_nf ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s )% U = stage ( s )% U + stage ( ss )% U * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t () enddo ! computing new time step do s = 1 , self % stages U % U = U % U + stage ( s )% U * ( Dt * self % beta ( s )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate_rk","tags":"","loc":"proc/integrate_rk~2.html","title":"integrate_rk – FOODIE"},{"text":"private elementalsubroutine finalize_rk(self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Source Code elemental subroutine finalize_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_rk","tags":"","loc":"proc/finalize_rk~2.html","title":"finalize_rk – FOODIE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, ord) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. Calls proc~~init~15~~CallsGraph proc~init~15 init weno_constructor_upwind weno_constructor_upwind proc~init~15->weno_constructor_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(weno_factory), public :: factory WENO factory. class(weno_interpolator), public, allocatable :: weno WENO interpolator. integer(kind=I_P), public :: i Space counter. Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~15.html","title":"init – FOODIE"},{"text":"private puresubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: self Euler field. Description Destroy field. Source Code pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~9.html","title":"destroy – FOODIE"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_omp_nf ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: lhs !< Left hand side. class ( euler_1D_omp_nf ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_omp_nf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Nc , 1 : lhs % Ni )) endif if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) if ( allocated ( rhs % U )) then !$OMP DO do i = 1 , lhs % Ni lhs % U (:, i ) = rhs % U (:, i ) enddo endif !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler~3.html","title":"euler_assign_euler – FOODIE"},{"text":"private puresubroutine impose_boundary_conditions(self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions~3.html","title":"impose_boundary_conditions – FOODIE"},{"text":"private subroutine reconstruct_interfaces_states(self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Calls proc~~reconstruct_interfaces_states~3~~CallsGraph proc~reconstruct_interfaces_states~3 reconstruct_interfaces_states none~eigen_vect_r~3 eigen_vect_R proc~reconstruct_interfaces_states~3->none~eigen_vect_r~3 none~eigen_vect_l~3 eigen_vect_L proc~reconstruct_interfaces_states~3->none~eigen_vect_l~3 proc~a~3 a none~eigen_vect_r~3->proc~a~3 none~eigen_vect_l~3->proc~a~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: C (1:2,1-self%Ng:-1+self%Ng,1:self%Ns+2) Pseudo characteristic variables. real(kind=R_P), public :: CR (1:self%Ns+2,1:2) Pseudo characteristic reconst. vars. real(kind=R_P), public :: Pm (1:self%Np,1:2) Mean of primitive variables. real(kind=R_P), public :: LPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean left eigenvectors matrix. real(kind=R_P), public :: RPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean right eigenvectors matrix. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: j Counter. integer(kind=I_P), public :: f Counter. integer(kind=I_P), public :: v Counter. Functions purefunction eigen_vect_L(Ns, Np, primitive) result(L) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Left eigenvectors matrix. Description Compute left eigenvectors from primitive variables. purefunction eigen_vect_R(Ns, Np, primitive) result(R) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Right eigenvectors matrix. Description Compute right eigenvectors from primitive variables. Source Code subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- !$OMP PARALLEL PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) SHARED(self, primitive, r_primitive) select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction !$OMP DO do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction !$OMP DO do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect !$OMP END PARALLEL return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states~3.html","title":"reconstruct_interfaces_states – FOODIE"},{"text":"private puresubroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Calls proc~~riemann_solver~3~~CallsGraph proc~riemann_solver~3 riemann_solver none~fluxes~3 fluxes proc~riemann_solver~3->none~fluxes~3 proc~compute_inter_states~3 compute_inter_states proc~riemann_solver~3->proc~compute_inter_states~3 proc~e~3 E proc~riemann_solver~3->proc~e~3 proc~h~3 H none~fluxes~3->proc~h~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: F1 (1:3) State 1 fluxes. real(kind=R_P), public :: F4 (1:3) State 4 fluxes. real(kind=R_P), public :: u Velocity of the intermediate states. real(kind=R_P), public :: p Pressure of the intermediate states. real(kind=R_P), public :: S1 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: S4 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: lmax Maximum wave speed estimation. Functions purefunction fluxes(p, r, u, g) result(Fc) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Velocity. real(kind=R_P), intent(in) :: g Specific heats ratio. Return Value real(kind=R_P)\n  (1:3) State fluxes. Description 1D Euler fluxes from primitive variables. Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver~3.html","title":"riemann_solver – FOODIE"},{"text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( euler_1D_omp_nf ), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~9.html","title":"finalize – FOODIE"},{"text":"private puresubroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Description Compute inter states (23*-states) from state1 and state4. Called By proc~~compute_inter_states~3~~CalledByGraph proc~compute_inter_states~3 compute_inter_states proc~riemann_solver~3 riemann_solver proc~riemann_solver~3->proc~compute_inter_states~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: a1 Speed of sound of state 1. real(kind=R_P), public :: a4 Speed of sound of state 4. real(kind=R_P), public :: ram Mean value of rho*a. real(kind=R_P), public, parameter :: toll = 1e-10_R_P Tollerance. Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states~3.html","title":"compute_inter_states – FOODIE"},{"text":"subroutine init() Arguments None Description Initialize the field. Called By proc~~init~16~~CalledByGraph proc~init~16 init program~integrate_euler_1d_openmp integrate_euler_1D_openmp program~integrate_euler_1d_openmp->proc~init~16 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~16.html","title":"init – FOODIE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. Calls proc~~save_results~5~~CallsGraph proc~save_results~5 save_results str str proc~save_results~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_results~5~~CalledByGraph proc~save_results~5 save_results program~integrate_euler_1d_openmp integrate_euler_1D_openmp program~integrate_euler_1d_openmp->proc~save_results~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type(pyplot), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~5.html","title":"save_results – FOODIE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Calls proc~~save_time_serie~4~~CallsGraph proc~save_time_serie~4 save_time_serie str str proc~save_time_serie~4->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~4~~CalledByGraph proc~save_time_serie~4 save_time_serie program~integrate_euler_1d_openmp integrate_euler_1D_openmp program~integrate_euler_1d_openmp->proc~save_time_serie~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public, save :: tsfile File unit for saving time serie results. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie~4.html","title":"save_time_serie – FOODIE"},{"text":"private purefunction output(self) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~5.html","title":"output – FOODIE"},{"text":"private purefunction compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. Calls proc~~compute_dt~4~~CallsGraph proc~compute_dt~4 compute_dt proc~a~4 a proc~compute_dt~4->proc~a~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: P (:) Primitive variables. real(kind=R_P), public :: vmax Maximum propagation speed of signals. integer(kind=I_P), public :: i Counter. Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~4.html","title":"compute_dt – FOODIE"},{"text":"private function dEuler_dt(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: F (:,:) Fluxes of conservative variables. real(kind=R_P), public, allocatable :: P (:,:) Primitive variables. real(kind=R_P), public, allocatable :: PR (:,:,:) Left (1) and right (2) (reconstructed) interface values of primitive variables. integer(kind=I_P), public :: i Counter. Source Code function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F, PR) do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D_openmp :: dState_dt ) select type ( dState_dt ) class is ( euler_1D_openmp ) dState_dt = self endselect !$OMP PARALLEL PRIVATE(i) SHARED(self, dState_dt, F) select type ( dState_dt ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt~4.html","title":"dEuler_dt – FOODIE"},{"text":"private function euler_local_error(lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 euler approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. integer(kind=I_P), public :: v Variables counter. Source Code function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_openmp ) error = 0._R_P do i = 1 , lhs % Ni do v = 1 , lhs % Nc error = error + ( lhs % U ( v , i ) - rhs % U ( v , i )) ** 2 / lhs % U ( v , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error","tags":"","loc":"proc/euler_local_error~2.html","title":"euler_local_error – FOODIE"},{"text":"private function euler_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) * rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler","tags":"","loc":"proc/euler_multiply_euler~2.html","title":"euler_multiply_euler – FOODIE"},{"text":"private function euler_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) * rhs enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real","tags":"","loc":"proc/euler_multiply_real~2.html","title":"euler_multiply_real – FOODIE"},{"text":"private function real_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D_openmp ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D_openmp ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = rhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , rhs % Ni opr % U (:, i ) = rhs % U (:, i ) * lhs enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler","tags":"","loc":"proc/real_multiply_euler~2.html","title":"real_multiply_euler – FOODIE"},{"text":"private function add_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) + rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler","tags":"","loc":"proc/add_euler~2.html","title":"add_euler – FOODIE"},{"text":"private function sub_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) - rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler","tags":"","loc":"proc/sub_euler~2.html","title":"sub_euler – FOODIE"},{"text":"private purefunction primitive2conservative(self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative~4.html","title":"primitive2conservative – FOODIE"},{"text":"private purefunction conservative2primitive(self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: c (:) Species concentration. Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive~4.html","title":"conservative2primitive – FOODIE"},{"text":"private elementalfunction p(r, a, g) result(pressure) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Description Compute the pressure for an ideal calorically perfect gas. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p~4.html","title":"p – FOODIE"},{"text":"private elementalfunction r(p, a, g) result(density) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Description Compute the density for an ideal calorically perfect gas. Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r~4.html","title":"r – FOODIE"},{"text":"private elementalfunction a(p, r, g) result(ss) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Description Compute the speed of sound for an ideal calorically perfect gas. Called By proc~~a~4~~CalledByGraph proc~a~4 a proc~compute_dt~4 compute_dt proc~compute_dt~4->proc~a~4 none~eigen_vect_r~4 eigen_vect_R none~eigen_vect_r~4->proc~a~4 none~eigen_vect_l~4 eigen_vect_L none~eigen_vect_l~4->proc~a~4 proc~reconstruct_interfaces_states~4 reconstruct_interfaces_states proc~reconstruct_interfaces_states~4->none~eigen_vect_r~4 proc~reconstruct_interfaces_states~4->none~eigen_vect_l~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a~4.html","title":"a – FOODIE"},{"text":"private elementalfunction E(p, r, u, g) result(energy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Description Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~e~4~~CalledByGraph proc~e~4 E proc~riemann_solver~4 riemann_solver proc~riemann_solver~4->proc~e~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e~4.html","title":"E – FOODIE"},{"text":"private elementalfunction H(p, r, u, g) result(entalpy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Description Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~h~4~~CalledByGraph proc~h~4 H none~fluxes~4 fluxes none~fluxes~4->proc~h~4 proc~riemann_solver~4 riemann_solver proc~riemann_solver~4->none~fluxes~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h~4.html","title":"H – FOODIE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, ord) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. Calls proc~~init~17~~CallsGraph proc~init~17 init weno_constructor_upwind weno_constructor_upwind proc~init~17->weno_constructor_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(weno_factory), public :: factory WENO factory. class(weno_interpolator), public, allocatable :: weno WENO interpolator. integer(kind=I_P), public :: i Space counter. Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~17.html","title":"init – FOODIE"},{"text":"private puresubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: self Euler field. Description Destroy field. Source Code pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~10.html","title":"destroy – FOODIE"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_openmp ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Nc , 1 : lhs % Ni )) endif if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) select type ( rhs ) class is ( euler_1D_openmp ) if ( allocated ( rhs % U )) then !$OMP DO do i = 1 , lhs % Ni lhs % U (:, i ) = rhs % U (:, i ) enddo endif endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler~4.html","title":"euler_assign_euler – FOODIE"},{"text":"private subroutine euler_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) then !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) do i = 1 , lhs % Ni lhs % U (:, i ) = rhs enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real","tags":"","loc":"proc/euler_assign_real~2.html","title":"euler_assign_real – FOODIE"},{"text":"private puresubroutine impose_boundary_conditions(self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions~4.html","title":"impose_boundary_conditions – FOODIE"},{"text":"private subroutine reconstruct_interfaces_states(self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Calls proc~~reconstruct_interfaces_states~4~~CallsGraph proc~reconstruct_interfaces_states~4 reconstruct_interfaces_states none~eigen_vect_l~4 eigen_vect_L proc~reconstruct_interfaces_states~4->none~eigen_vect_l~4 none~eigen_vect_r~4 eigen_vect_R proc~reconstruct_interfaces_states~4->none~eigen_vect_r~4 proc~a~4 a none~eigen_vect_l~4->proc~a~4 none~eigen_vect_r~4->proc~a~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: C (1:2,1-self%Ng:-1+self%Ng,1:self%Ns+2) Pseudo characteristic variables. real(kind=R_P), public :: CR (1:self%Ns+2,1:2) Pseudo characteristic reconst. vars. real(kind=R_P), public :: Pm (1:self%Np,1:2) Mean of primitive variables. real(kind=R_P), public :: LPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean left eigenvectors matrix. real(kind=R_P), public :: RPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean right eigenvectors matrix. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: j Counter. integer(kind=I_P), public :: f Counter. integer(kind=I_P), public :: v Counter. Functions purefunction eigen_vect_L(Ns, Np, primitive) result(L) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Left eigenvectors matrix. Description Compute left eigenvectors from primitive variables. purefunction eigen_vect_R(Ns, Np, primitive) result(R) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Right eigenvectors matrix. Description Compute right eigenvectors from primitive variables. Source Code subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- !$OMP PARALLEL PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) SHARED(self, primitive, r_primitive) select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction !$OMP DO do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction !$OMP DO do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect !$OMP END PARALLEL return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states~4.html","title":"reconstruct_interfaces_states – FOODIE"},{"text":"private puresubroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Calls proc~~riemann_solver~4~~CallsGraph proc~riemann_solver~4 riemann_solver proc~compute_inter_states~4 compute_inter_states proc~riemann_solver~4->proc~compute_inter_states~4 none~fluxes~4 fluxes proc~riemann_solver~4->none~fluxes~4 proc~e~4 E proc~riemann_solver~4->proc~e~4 proc~h~4 H none~fluxes~4->proc~h~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: F1 (1:3) State 1 fluxes. real(kind=R_P), public :: F4 (1:3) State 4 fluxes. real(kind=R_P), public :: u Velocity of the intermediate states. real(kind=R_P), public :: p Pressure of the intermediate states. real(kind=R_P), public :: S1 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: S4 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: lmax Maximum wave speed estimation. Functions purefunction fluxes(p, r, u, g) result(Fc) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Velocity. real(kind=R_P), intent(in) :: g Specific heats ratio. Return Value real(kind=R_P)\n  (1:3) State fluxes. Description 1D Euler fluxes from primitive variables. Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver~4.html","title":"riemann_solver – FOODIE"},{"text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( euler_1D_openmp ), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~10.html","title":"finalize – FOODIE"},{"text":"private puresubroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Description Compute inter states (23*-states) from state1 and state4. Called By proc~~compute_inter_states~4~~CalledByGraph proc~compute_inter_states~4 compute_inter_states proc~riemann_solver~4 riemann_solver proc~riemann_solver~4->proc~compute_inter_states~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: a1 Speed of sound of state 1. real(kind=R_P), public :: a4 Speed of sound of state 4. real(kind=R_P), public :: ram Mean value of rho*a. real(kind=R_P), public, parameter :: toll = 1e-10_R_P Tollerance. Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states~4.html","title":"compute_inter_states – FOODIE"},{"text":"subroutine init() Arguments None Description Initialize the field. Called By proc~~init~18~~CalledByGraph proc~init~18 init program~integrate_burgers integrate_burgers program~integrate_burgers->proc~init~18 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, parameter :: pi = 4._R_P*atan(1._R_P) Pi greek. integer(kind=I_P), public :: i Space counter. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- h = 2._R_P * pi / Ni do i = 1 , Ni x ( i ) = h * ( i - 1 ) initial_state ( i ) = 1 0._R_P * sin ( x ( i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~18.html","title":"init – FOODIE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. Called By proc~~save_results~6~~CalledByGraph proc~save_results~6 save_results proc~test_ab~2 test_ab proc~test_ab~2->proc~save_results~6 proc~test_leapfrog~2 test_leapfrog proc~test_leapfrog~2->proc~save_results~6 proc~test_tvd_rk~2 test_tvd_rk proc~test_tvd_rk~2->proc~save_results~6 proc~test_ls_rk~2 test_ls_rk proc~test_ls_rk~2->proc~save_results~6 proc~test_euler~2 test_euler proc~test_euler~2->proc~save_results~6 program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_ab~2 program~integrate_burgers->proc~test_leapfrog~2 program~integrate_burgers->proc~test_tvd_rk~2 program~integrate_burgers->proc~test_ls_rk~2 program~integrate_burgers->proc~test_euler~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type(pyplot), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"U\"' do i = 1 , Ni write ( rawfile , '(2(' // FR_P // ',1X))' ) x ( i ), final_state ( i ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) call plt % add_plot ( x = x , y = final_state , label = 'U' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~6.html","title":"save_results – FOODIE"},{"text":"subroutine test_ab() Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Calls proc~~test_ab~2~~CallsGraph proc~test_ab~2 test_ab str str proc~test_ab~2->str proc~save_results~6 save_results proc~test_ab~2->proc~save_results~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_ab~2~~CalledByGraph proc~test_ab~2 test_ab program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_ab~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( burgers ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( adams_bashforth_integrator ), public :: ab_integrator Adams-Bashforth integrator. integer, public, parameter :: ab_steps = 4 Adams-Bashforth steps number. type( burgers ), public :: previous (1:ab_steps) Previous time steps solutions. integer, public :: step Time steps counter. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t (1:ab_steps) Times. integer(kind=I_P), public :: s AB steps counter. integer(kind=I_P), public :: ss AB substeps counter. Source Code subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( burgers ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = s ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t ( s ) < t_final ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), Dt = Dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit ' // & 'Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'burgers_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab~2.html","title":"test_ab – FOODIE"},{"text":"subroutine test_euler() Arguments None Description Test explicit forward Euler ODE solver. Calls proc~~test_euler~2~~CallsGraph proc~test_euler~2 test_euler proc~save_results~6 save_results proc~test_euler~2->proc~save_results~6 str str proc~test_euler~2->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_euler~2~~CalledByGraph proc~test_euler~2 test_euler program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_euler~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( euler_explicit_integrator ), public :: euler_integrator Euler integrator. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of explicit Euler solver' call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit Euler' , & filename = 'burgers_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler~2.html","title":"test_euler – FOODIE"},{"text":"subroutine test_leapfrog() Arguments None Description Test explicit leapfrog class of ODE solvers. Calls proc~~test_leapfrog~2~~CallsGraph proc~test_leapfrog~2 test_leapfrog proc~save_results~6 save_results proc~test_leapfrog~2->proc~save_results~6 str str proc~test_leapfrog~2->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_leapfrog~2~~CalledByGraph proc~test_leapfrog~2 test_leapfrog program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_leapfrog~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 2 Runge-Kutta stages number. type( burgers ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( burgers ), public :: filter Filter displacement. type( leapfrog_integrator ), public :: lf_integrator Leapfrog integrator. type( burgers ), public :: previous (1:2) Previous time steps solutions. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer, public :: step Time steps counter. Source Code subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( burgers ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( burgers ) :: previous ( 1 : 2 ) !< Previous time steps solutions. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = 2 ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t < t_final ) if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit leapfrog scheme' ,& filename = 'burgers_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog","tags":"","loc":"proc/test_leapfrog~2.html","title":"test_leapfrog – FOODIE"},{"text":"subroutine test_ls_rk() Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. Calls proc~~test_ls_rk~2~~CallsGraph proc~test_ls_rk~2 test_ls_rk str str proc~test_ls_rk~2->str proc~save_results~6 save_results proc~test_ls_rk~2->proc~save_results~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_ls_rk~2~~CalledByGraph proc~test_ls_rk~2 test_ls_rk program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_ls_rk~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( ls_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. integer, public, parameter :: registers = 2 Runge-Kutta stages number. type( burgers ), public :: rk_stage (1:registers) Runge-Kutta stages. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer(kind=I_P), public :: s RK stages counter. Source Code subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit low storage Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk","tags":"","loc":"proc/test_ls_rk~2.html","title":"test_ls_rk – FOODIE"},{"text":"subroutine test_tvd_rk() Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Calls proc~~test_tvd_rk~2~~CallsGraph proc~test_tvd_rk~2 test_tvd_rk str str proc~test_tvd_rk~2->str proc~save_results~6 save_results proc~test_tvd_rk~2->proc~save_results~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_tvd_rk~2~~CalledByGraph proc~test_tvd_rk~2 test_tvd_rk program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_tvd_rk~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( burgers ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer(kind=I_P), public :: s RK stages counter. Source Code subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit TVD Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk","tags":"","loc":"proc/test_tvd_rk~2.html","title":"test_tvd_rk – FOODIE"},{"text":"private purefunction output(self) result(state) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value real(kind=R_P),\n  dimension(:),allocatable Burgers state variable. Description Output the Burgers field state. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Burgers field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), dimension (:), allocatable :: state !< Burgers state variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~6.html","title":"output – FOODIE"},{"text":"private purefunction compute_dt(self, CFL) result(dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in) :: CFL Courant-Friedricks-Lewi stability coefficient. Return Value real(kind=R_P) Current time step. Description Compute the current time step, by means of CFL condition. Source Code pure function compute_dt ( self , CFL ) result ( dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step, by means of CFL condition. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), intent ( IN ) :: CFL !< Courant-Friedricks-Lewi stability coefficient. real ( R_P ) :: dt !< Current time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dt = CFL * self % h ** 2 / self % nu return !--------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~5.html","title":"compute_dt – FOODIE"},{"text":"private function dBurgers_dt(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Burgers field time derivative. Description Time derivative of Burgers field, residuals function. Source Code function dBurgers_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Burgers field, residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Burgers field time derivative. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: dState_dt ) select type ( dState_dt ) class is ( burgers ) dState_dt = self dState_dt = self % xx () * self % nu dState_dt = dState_dt - self * self % x () endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dBurgers_dt","tags":"","loc":"proc/dburgers_dt.html","title":"dBurgers_dt – FOODIE"},{"text":"private function previous_step(self, n) result(previous) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Burgers field. Description Extract previous time solution of Burgers field. Source Code function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: previous ) select type ( previous ) class is ( burgers ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step","tags":"","loc":"proc/previous_step.html","title":"previous_step – FOODIE"},{"text":"private function burgers_local_error(lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 burgers approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code function burgers_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 burgers approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( burgers ) error = 0._R_P do i = 1 , lhs % dims error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_local_error","tags":"","loc":"proc/burgers_local_error.html","title":"burgers_local_error – FOODIE"},{"text":"private function burgers_multiply_burgers(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by another one. Source Code function burgers_multiply_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_burgers","tags":"","loc":"proc/burgers_multiply_burgers.html","title":"burgers_multiply_burgers – FOODIE"},{"text":"private function burgers_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by a real scalar. Source Code function burgers_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_real","tags":"","loc":"proc/burgers_multiply_real.html","title":"burgers_multiply_real – FOODIE"},{"text":"private function real_multiply_burgers(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( burgers ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Burgers field. Source Code function real_multiply_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( burgers ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_burgers","tags":"","loc":"proc/real_multiply_burgers.html","title":"real_multiply_burgers – FOODIE"},{"text":"private function add_burgers(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Burgers fields. Source Code function add_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_burgers","tags":"","loc":"proc/add_burgers.html","title":"add_burgers – FOODIE"},{"text":"private function sub_burgers(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Burgers fields. Source Code function sub_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_burgers","tags":"","loc":"proc/sub_burgers.html","title":"sub_burgers – FOODIE"},{"text":"private function dBurgers_dx(self) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative. Description Compute the first order spatial derivative of Burgers field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter.","tags":"","loc":"proc/dburgers_dx.html","title":"dBurgers_dx – FOODIE"},{"text":"private function d2Burgers_dx2(self) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative. Description Compute the second order spatial derivative of Burgers field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter.","tags":"","loc":"proc/d2burgers_dx2.html","title":"d2Burgers_dx2 – FOODIE"},{"text":"private subroutine init(self, initial_state, Ni, h, nu, steps) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. real(kind=R_P), intent(in), dimension(1:Ni) :: initial_state Initial state of Burgers field domain. integer(kind=I_P), intent(in) :: Ni Number of grid nodes. real(kind=R_P), intent(in) :: h Space step discretization. real(kind=R_P), intent(in) :: nu Viscosity. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Burgers field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Time steps counter. Source Code subroutine init ( self , initial_state , Ni , h , nu , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: Ni !< Number of grid nodes. real ( R_P ), dimension ( 1 : Ni ), intent ( IN ) :: initial_state !< Initial state of Burgers field domain. real ( R_P ), intent ( IN ) :: h !< Space step discretization. real ( R_P ), intent ( IN ) :: nu !< Viscosity. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : Ni , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % Ni = Ni self % h = h self % nu = nu return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~19.html","title":"init – FOODIE"},{"text":"private subroutine update_previous_steps(self, filter, weights) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Time steps counter. Source Code subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( burgers ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps.html","title":"update_previous_steps – FOODIE"},{"text":"private subroutine burgers_assign_burgers(lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Burgers field to another. Source Code subroutine burgers_assign_burgers ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Burgers field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( burgers ) lhs % Ni = rhs % Ni lhs % steps = rhs % steps lhs % h = rhs % h lhs % nu = rhs % nu if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_burgers","tags":"","loc":"proc/burgers_assign_burgers.html","title":"burgers_assign_burgers – FOODIE"},{"text":"private subroutine burgers_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Burgers field. Source Code subroutine burgers_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_real","tags":"","loc":"proc/burgers_assign_real.html","title":"burgers_assign_real – FOODIE"},{"text":"subroutine init() Arguments None Description Initialize the field. Calls proc~~init~20~~CallsGraph proc~init~20 init str str proc~init~20->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~init~20~~CalledByGraph proc~init~20 init program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~init~20 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, parameter :: pi = 4._R_P*atan(1._R_P) Pi greek. integer(kind=I_P), public :: i Space counter. integer(kind=I_P), public :: s Species counter. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Species counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( xcenter ( 1 : Ni )) allocate ( xnode ( 0 : Ni )) Dx = 1._R_P / Ni do i = 1 , Ni xcenter ( i ) = Dx * i - 0.5_R_P * Dx enddo do i = 0 , Ni xnode ( i ) = Dx * i enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then allocate ( av_xnode ( 0 : av_Ni )) do i = 0 , av_Ni av_xnode ( i ) = 1._R_P / av_Ni * i enddo endif select case ( trim ( adjustl ( problem ))) case ( 'sod' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.2_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str (. true ., s )) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case ( 'smooth' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.1_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str (. true ., s )) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni initial_state (:, i ) = [ 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! rho(s) 0.5_R_P * ( xcenter ( i ) - 0.5_R_P ) ** 4 , & ! u 1 0._R_P + 2._R_P * xcenter ( i ) ** 4 , & ! p 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case default print \"(A)\" , 'Error: unknown problem \"' // trim ( adjustl ( problem )) // '\"' print \"(A)\" , 'Valid problem names are:' print \"(A)\" , '  + sod' print \"(A)\" , '  + smooth' stop endselect if ( trim ( adjustl ( output_cli )) /= 'unset' ) then output = trim ( adjustl ( output_cli )) // '-' // trim ( adjustl ( solver )) else output = 'euler_1D_integration-' // trim ( adjustl ( solver )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~20.html","title":"init – FOODIE"},{"text":"subroutine average_solution() Arguments None Description Average the solution over an average grid. Called By proc~~average_solution~~CalledByGraph proc~average_solution average_solution proc~save_results~7 save_results proc~save_results~7->proc~average_solution proc~test_tvd_rk~3 test_tvd_rk proc~test_tvd_rk~3->proc~save_results~7 proc~test_leapfrog~3 test_leapfrog proc~test_leapfrog~3->proc~save_results~7 proc~test_ls_rk~3 test_ls_rk proc~test_ls_rk~3->proc~save_results~7 proc~test_ab~3 test_ab proc~test_ab~3->proc~save_results~7 proc~test_euler~3 test_euler proc~test_euler~3->proc~save_results~7 program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_tvd_rk~3 program~integrate_euler_1d->proc~test_leapfrog~3 program~integrate_euler_1d->proc~test_ls_rk~3 program~integrate_euler_1d->proc~test_ab~3 program~integrate_euler_1d->proc~test_euler~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i integer(kind=I_P), public :: ii integer(kind=I_P), public :: i1 integer(kind=I_P), public :: i2 Counters. Source Code subroutine average_solution () !--------------------------------------------------------------------------------------------------------------------------------- !< Average the solution over an average grid. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i , ii , i1 , i2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then if ( allocated ( av_state )) deallocate ( av_state ) ; allocate ( av_state ( 1 : Np , 1 : av_Ni )) do i = 1 , av_Ni i1 = minloc ( array = xcenter , dim = 1 , mask = ( xcenter >= av_xnode ( i - 1 ))) i2 = maxloc ( array = xcenter , dim = 1 , mask = ( xcenter <= av_xnode ( i ))) av_state (:, i ) = 0._R_P do ii = i1 , i2 av_state (:, i ) = av_state (:, i ) + final_state (:, ii ) enddo av_state (:, i ) = av_state (:, i ) / ( i2 - i1 + 1 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine average_solution","tags":"","loc":"proc/average_solution.html","title":"average_solution – FOODIE"},{"text":"subroutine save_results(title, basename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: basename Output basename. Description Save results. Calls proc~~save_results~7~~CallsGraph proc~save_results~7 save_results proc~average_solution average_solution proc~save_results~7->proc~average_solution str str proc~save_results~7->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_results~7~~CalledByGraph proc~save_results~7 save_results proc~test_tvd_rk~3 test_tvd_rk proc~test_tvd_rk~3->proc~save_results~7 proc~test_leapfrog~3 test_leapfrog proc~test_leapfrog~3->proc~save_results~7 proc~test_ls_rk~3 test_ls_rk proc~test_ls_rk~3->proc~save_results~7 proc~test_ab~3 test_ab proc~test_ab~3->proc~save_results~7 proc~test_euler~3 test_euler proc~test_euler~3->proc~save_results~7 program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_tvd_rk~3 program~integrate_euler_1d->proc~test_leapfrog~3 program~integrate_euler_1d->proc~test_ls_rk~3 program~integrate_euler_1d->proc~test_ab~3 program~integrate_euler_1d->proc~test_euler~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type(pyplot), public :: plt Plot file handler. integer(kind=I_P), public :: v Counter. Source Code subroutine save_results ( title , basename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: basename !< Output basename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = basename // '-' // trim ( str (. true ., Ni )) // '_cells.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) variables write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str (. true ., Ni )) // ' cells\", I=' // trim ( str (. true ., Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 1 )) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str (. true ., Ni + 1 )) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( rawfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then print \"(A)\" , ' Average solution from Ni: ' // trim ( str (. true ., Ni )) // ' to av_Ni: ' // trim ( str (. true ., av_Ni )) call average_solution write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str (. true ., Ni )) // ' cells averaged over ' // trim ( str (. true ., av_Ni )) // & ' cells\", I=' // trim ( str (. true ., av_Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 1 )) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str (. true ., av_Ni + 1 )) // '(' // FR_P // ',1X))' ) av_xnode do v = 1 , Np write ( rawfile , '(' // trim ( str (. true ., av_Ni )) // '(' // FR_P // ',1X))' ) av_state ( v , :) enddo endif close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = xcenter , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = xcenter , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( basename // '-' // trim ( str (. true ., Ni )) // '_cells.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~7.html","title":"save_results – FOODIE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Calls proc~~save_time_serie~5~~CallsGraph proc~save_time_serie~5 save_time_serie str str proc~save_time_serie~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~5~~CalledByGraph proc~save_time_serie~5 save_time_serie proc~test_tvd_rk~3 test_tvd_rk proc~test_tvd_rk~3->proc~save_time_serie~5 proc~test_leapfrog~3 test_leapfrog proc~test_leapfrog~3->proc~save_time_serie~5 proc~test_ls_rk~3 test_ls_rk proc~test_ls_rk~3->proc~save_time_serie~5 proc~test_ab~3 test_ab proc~test_ab~3->proc~save_time_serie~5 proc~test_euler~3 test_euler proc~test_euler~3->proc~save_time_serie~5 program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_tvd_rk~3 program~integrate_euler_1d->proc~test_leapfrog~3 program~integrate_euler_1d->proc~test_ls_rk~3 program~integrate_euler_1d->proc~test_ab~3 program~integrate_euler_1d->proc~test_euler~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public, save :: tsfile File unit for saving time serie results. integer(kind=I_P), public :: v Counter. Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) 'TITLE=\"' // title // '\"' endif write ( tsfile , '(A)' ) variables // ' \"t\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\", I=' // trim ( str (. true ., Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 2 )) // ']=CELLCENTERED)' write ( tsfile , '(' // trim ( str (. true ., Ni + 1 )) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( tsfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo write ( tsfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' )( t , v = 1 , Ni ) if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie~5.html","title":"save_time_serie – FOODIE"},{"text":"subroutine test_ab() Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Calls proc~~test_ab~3~~CallsGraph proc~test_ab~3 test_ab proc~save_results~7 save_results proc~test_ab~3->proc~save_results~7 str str proc~test_ab~3->str proc~save_time_serie~5 save_time_serie proc~test_ab~3->proc~save_time_serie~5 proc~save_results~7->str proc~average_solution average_solution proc~save_results~7->proc~average_solution proc~save_time_serie~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_ab~3~~CalledByGraph proc~test_ab~3 test_ab program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_ab~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( adams_bashforth_integrator ), public :: ab_integrator Adams-Bashforth integrator. integer, public, parameter :: ab_steps = 4 Adams-Bashforth steps number. type(euler_1D), public :: previous (1:ab_steps) Previous time steps solutions. integer, public :: step Time steps counter. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t (1:ab_steps) Times. integer(kind=I_P), public :: s AB steps counter. integer(kind=I_P), public :: ss AB substeps counter. integer(kind=I_P), public :: steps_range (1:2) Steps used. character(len=:), public, allocatable :: title Output files title. Source Code subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( euler_1D ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of Adams-Bashforth class of solvers' steps_range = [ 1 , ab_steps ] ; if ( stages_steps > 0 ) steps_range = [ stages_steps , stages_steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' AB-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' steps' call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 1 ) call rk_integrator % init ( stages = s ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 3 ) call rk_integrator % init ( stages = s ) case ( 4 , 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 7 ) call rk_integrator % init ( stages = 5 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , t = t ( s )) step = 1 do while ( t ( s ) < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t ( s ), CFL = 0.1_R_P * CFL ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), dt = dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 call save_time_serie ( t = t ( s )) enddo call save_time_serie ( t = t ( s ), finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab~3.html","title":"test_ab – FOODIE"},{"text":"subroutine test_euler() Arguments None Description Test explicit forward Euler ODE solver. Calls proc~~test_euler~3~~CallsGraph proc~test_euler~3 test_euler proc~save_results~7 save_results proc~test_euler~3->proc~save_results~7 str str proc~test_euler~3->str proc~save_time_serie~5 save_time_serie proc~test_euler~3->proc~save_time_serie~5 proc~save_results~7->str proc~average_solution average_solution proc~save_results~7->proc~average_solution proc~save_time_serie~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_euler~3~~CalledByGraph proc~test_euler~3 test_euler program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_euler~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( euler_explicit_integrator ), public :: euler_integrator Euler integrator. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. character(len=:), public, allocatable :: title Output files title. Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of explicit Euler solver' title = '1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '  Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler~3.html","title":"test_euler – FOODIE"},{"text":"subroutine test_leapfrog() Arguments None Description Test explicit leapfrog class of ODE solvers. Calls proc~~test_leapfrog~3~~CallsGraph proc~test_leapfrog~3 test_leapfrog proc~save_results~7 save_results proc~test_leapfrog~3->proc~save_results~7 str str proc~test_leapfrog~3->str proc~save_time_serie~5 save_time_serie proc~test_leapfrog~3->proc~save_time_serie~5 proc~save_results~7->str proc~average_solution average_solution proc~save_results~7->proc~average_solution proc~save_time_serie~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_leapfrog~3~~CalledByGraph proc~test_leapfrog~3 test_leapfrog program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_leapfrog~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 2 Runge-Kutta stages number. type(euler_1D), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type(euler_1D), public :: filter Filter displacement. type( leapfrog_integrator ), public :: lf_integrator Leapfrog integrator. type(euler_1D), public :: previous (1:2) Previous time steps solutions. integer, public :: step Time steps counter. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. character(len=:), public, allocatable :: title Output files title. Source Code subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( euler_1D ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( euler_1D ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of leapfrog (RAW filtered) class of solvers' title = '1D Euler equations integration, explicit leapfrog (RAW filtered), t=' // str ( n = t_final ) call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = 2 , ord = 3 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) step = 1 do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = 0.1_R_P * CFL ) if ( 2 >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog","tags":"","loc":"proc/test_leapfrog~3.html","title":"test_leapfrog – FOODIE"},{"text":"subroutine test_ls_rk() Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. Calls proc~~test_ls_rk~3~~CallsGraph proc~test_ls_rk~3 test_ls_rk proc~save_results~7 save_results proc~test_ls_rk~3->proc~save_results~7 str str proc~test_ls_rk~3->str proc~save_time_serie~5 save_time_serie proc~test_ls_rk~3->proc~save_time_serie~5 proc~save_results~7->str proc~average_solution average_solution proc~save_results~7->proc~average_solution proc~save_time_serie~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_ls_rk~3~~CalledByGraph proc~test_ls_rk~3 test_ls_rk program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_ls_rk~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( ls_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. integer, public, parameter :: registers = 2 Runge-Kutta stages number. type(euler_1D), public :: rk_stage (1:registers) Runge-Kutta stages. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: stages_range (1:2) Stages used. character(len=:), public, allocatable :: title Output files title. Source Code subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of low storage (2N) Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk","tags":"","loc":"proc/test_ls_rk~3.html","title":"test_ls_rk – FOODIE"},{"text":"subroutine test_tvd_rk() Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Calls proc~~test_tvd_rk~3~~CallsGraph proc~test_tvd_rk~3 test_tvd_rk proc~save_results~7 save_results proc~test_tvd_rk~3->proc~save_results~7 str str proc~test_tvd_rk~3->str proc~save_time_serie~5 save_time_serie proc~test_tvd_rk~3->proc~save_time_serie~5 proc~save_results~7->str proc~average_solution average_solution proc~save_results~7->proc~average_solution proc~save_time_serie~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_tvd_rk~3~~CalledByGraph proc~test_tvd_rk~3 test_tvd_rk program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_tvd_rk~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D), public :: rk_stage (1:rk_stages) Runge-Kutta stages. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: stages_range (1:2) Stages used. character(len=:), public, allocatable :: title Output files title. Source Code subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of TVD/SSP Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit TVD/SSP Runge-Kutta, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk","tags":"","loc":"proc/test_tvd_rk~3.html","title":"test_tvd_rk – FOODIE"},{"text":"private purefunction output(self) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~7.html","title":"output – FOODIE"},{"text":"private purefunction compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. Calls proc~~compute_dt~6~~CallsGraph proc~compute_dt~6 compute_dt proc~a~5 a proc~compute_dt~6->proc~a~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: P (:) Primitive variables. real(kind=R_P), public :: vmax Maximum propagation speed of signals. integer(kind=I_P), public :: i Counter. Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~6.html","title":"compute_dt – FOODIE"},{"text":"private function dEuler_dt(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. Calls proc~~deuler_dt~5~~CallsGraph proc~deuler_dt~5 dEuler_dt u u proc~deuler_dt~5->u Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: F (:,:) Fluxes of conservative variables. real(kind=R_P), public, allocatable :: P (:,:) Primitive variables. real(kind=R_P), public, allocatable :: PR (:,:,:) Left (1) and right (2) (reconstructed) interface values of primitive variables. integer(kind=I_P), public :: i Counter. Source Code function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Nc => self % Nc , Np => self % Np , Ns => self % Ns , U => self % U , previous => self % previous ) ! allocate temporary arrays allocate ( F ( 1 : Nc , 0 : Ni )) ; F = 0._R_P allocate ( P ( 1 : Np , 1 - Ng : Ni + Ng )) ; P = 0._R_P allocate ( PR ( 1 : Np , 1 : 2 , 0 : Ni + 1 )) ; PR = 0._R_P ! compute primitive variables do i = 1 , Ni P (:, i ) = self % conservative2primitive ( U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , Ni call self % riemann_solver ( r1 = PR ( Ns + 3 , 2 , i ), u1 = PR ( Ns + 1 , 2 , i ), p1 = PR ( Ns + 2 , 2 , i ), g1 = PR ( Ns + 4 , 2 , i ), & r4 = PR ( Ns + 3 , 1 , i + 1 ), u4 = PR ( Ns + 1 , 1 , i + 1 ), p4 = PR ( Ns + 2 , 1 , i + 1 ), g4 = PR ( Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : Ns , 2 , i ) / PR ( Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : Ns , 1 , i + 1 ) / PR ( Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D :: dState_dt ) select type ( dState_dt ) class is ( euler_1D ) dState_dt = self do i = 1 , Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt~5.html","title":"dEuler_dt – FOODIE"},{"text":"private function previous_step(self, n) result(previous) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Euler field. Description Extract previous time solution of Euler field. Source Code function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: previous ) select type ( previous ) class is ( euler_1D ) previous = self previous % U = self % previous (:, :, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step","tags":"","loc":"proc/previous_step~2.html","title":"previous_step – FOODIE"},{"text":"private function euler_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. Source Code function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler","tags":"","loc":"proc/euler_multiply_euler~3.html","title":"euler_multiply_euler – FOODIE"},{"text":"private function euler_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. Source Code function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real","tags":"","loc":"proc/euler_multiply_real~3.html","title":"euler_multiply_real – FOODIE"},{"text":"private function real_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. Source Code function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler","tags":"","loc":"proc/real_multiply_euler~3.html","title":"real_multiply_euler – FOODIE"},{"text":"private function add_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. Source Code function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler","tags":"","loc":"proc/add_euler~3.html","title":"add_euler – FOODIE"},{"text":"private function sub_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. Source Code function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler","tags":"","loc":"proc/sub_euler~3.html","title":"sub_euler – FOODIE"},{"text":"private purefunction primitive2conservative(self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative~5.html","title":"primitive2conservative – FOODIE"},{"text":"private purefunction conservative2primitive(self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: c (:) Species concentration. Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive~5.html","title":"conservative2primitive – FOODIE"},{"text":"private elementalfunction p(r, a, g) result(pressure) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Description Compute the pressure for an ideal calorically perfect gas. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p~5.html","title":"p – FOODIE"},{"text":"private elementalfunction r(p, a, g) result(density) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Description Compute the density for an ideal calorically perfect gas. Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r~5.html","title":"r – FOODIE"},{"text":"private elementalfunction a(p, r, g) result(ss) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Description Compute the speed of sound for an ideal calorically perfect gas. Called By proc~~a~5~~CalledByGraph proc~a~5 a proc~compute_dt~6 compute_dt proc~compute_dt~6->proc~a~5 none~eigen_vect_r~5 eigen_vect_R none~eigen_vect_r~5->proc~a~5 none~eigen_vect_l~5 eigen_vect_L none~eigen_vect_l~5->proc~a~5 proc~reconstruct_interfaces_states~5 reconstruct_interfaces_states proc~reconstruct_interfaces_states~5->none~eigen_vect_r~5 proc~reconstruct_interfaces_states~5->none~eigen_vect_l~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a~5.html","title":"a – FOODIE"},{"text":"private elementalfunction E(p, r, u, g) result(energy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Description Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~e~5~~CalledByGraph proc~e~5 E proc~riemann_solver~5 riemann_solver proc~riemann_solver~5->proc~e~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e~5.html","title":"E – FOODIE"},{"text":"private elementalfunction H(p, r, u, g) result(entalpy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Description Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~h~5~~CalledByGraph proc~h~5 H none~fluxes~5 fluxes none~fluxes~5->proc~h~5 proc~riemann_solver~5 riemann_solver proc~riemann_solver~5->none~fluxes~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h~5.html","title":"H – FOODIE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, steps, ord) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: steps Time steps stored. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. Calls proc~~init~21~~CallsGraph proc~init~21 init weno_constructor_upwind weno_constructor_upwind proc~init~21->weno_constructor_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(weno_factory), public :: factory WENO factory. class(weno_interpolator), public, allocatable :: weno WENO interpolator. integer(kind=I_P), public :: i Space counter. integer(kind=I_P), public :: s Steps counter. Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , steps , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 ; if ( present ( steps )) self % steps = steps self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % Nc , 1 : Ni , 1 : self % steps )) endif self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo if ( self % steps > 0 ) then do s = 1 , self % steps do i = 1 , Ni self % previous (:, i , s ) = self % primitive2conservative ( initial_state (:, i )) enddo enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~21.html","title":"init – FOODIE"},{"text":"private puresubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. Description Destroy field. Source Code pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % previous )) deallocate ( self % previous ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~11.html","title":"destroy – FOODIE"},{"text":"private subroutine update_previous_steps(self, filter, weights) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. Variables Type Visibility Attributes Name Initial integer, public :: s Time steps counter. Source Code subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, :, s ) = self % previous (:, :, s + 1 ) enddo self % previous (:, :, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( euler_1D ) do s = 1 , self % steps self % previous (:, :, s ) = self % previous (:, :, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps~2.html","title":"update_previous_steps – FOODIE"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) lhs % steps = rhs % steps lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler~5.html","title":"euler_assign_euler – FOODIE"},{"text":"private subroutine euler_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. Source Code subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real","tags":"","loc":"proc/euler_assign_real~3.html","title":"euler_assign_real – FOODIE"},{"text":"private puresubroutine impose_boundary_conditions(self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions~5.html","title":"impose_boundary_conditions – FOODIE"},{"text":"private puresubroutine reconstruct_interfaces_states(self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Calls proc~~reconstruct_interfaces_states~5~~CallsGraph proc~reconstruct_interfaces_states~5 reconstruct_interfaces_states none~eigen_vect_l~5 eigen_vect_L proc~reconstruct_interfaces_states~5->none~eigen_vect_l~5 none~eigen_vect_r~5 eigen_vect_R proc~reconstruct_interfaces_states~5->none~eigen_vect_r~5 proc~a~5 a none~eigen_vect_l~5->proc~a~5 none~eigen_vect_r~5->proc~a~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: C (1:2,1-self%Ng:-1+self%Ng,1:self%Ns+2) Pseudo characteristic variables. real(kind=R_P), public :: CR (1:self%Ns+2,1:2) Pseudo characteristic reconst. vars. real(kind=R_P), public :: Pm (1:self%Np,1:2) Mean of primitive variables. real(kind=R_P), public :: LPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean left eigenvectors matrix. real(kind=R_P), public :: RPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean right eigenvectors matrix. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: j Counter. integer(kind=I_P), public :: f Counter. integer(kind=I_P), public :: v Counter. Functions purefunction eigen_vect_L(Ns, Np, primitive) result(L) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Left eigenvectors matrix. Description Compute left eigenvectors from primitive variables. purefunction eigen_vect_R(Ns, Np, primitive) result(R) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Right eigenvectors matrix. Description Compute right eigenvectors from primitive variables. Source Code pure subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Ns => self % Ns , Np => self % Np , ord => self % ord , cv0 => self % cv0 , cp0 => self % cp0 , weno => self % weno ) select case ( ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = Ns , Np = Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = Ns , Np = Np , primitive = Pm (:, f )) enddo do j = i + 1 - Ng , i - 1 + Ng do f = 1 , 2 do v = 1 , Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : Ns + 2 , f ), primitive ( 1 : Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , Ns + 2 call weno % interpolate ( S = Ng , & stencil = C ( 1 : 2 , 1 - Ng : - 1 + Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : Ns + 2 , f ), CR ( 1 : Ns + 2 , f )) enddo r_primitive ( Ns + 3 , f , i ) = sum ( r_primitive ( 1 : Ns , f , i )) r_primitive ( Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cp0 ) / & dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cv0 ) enddo enddo endselect endassociate return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states~5.html","title":"reconstruct_interfaces_states – FOODIE"},{"text":"private puresubroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Calls proc~~riemann_solver~5~~CallsGraph proc~riemann_solver~5 riemann_solver proc~compute_inter_states~5 compute_inter_states proc~riemann_solver~5->proc~compute_inter_states~5 none~fluxes~5 fluxes proc~riemann_solver~5->none~fluxes~5 proc~e~5 E proc~riemann_solver~5->proc~e~5 proc~h~5 H none~fluxes~5->proc~h~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: F1 (1:3) State 1 fluxes. real(kind=R_P), public :: F4 (1:3) State 4 fluxes. real(kind=R_P), public :: u Velocity of the intermediate states. real(kind=R_P), public :: p Pressure of the intermediate states. real(kind=R_P), public :: S1 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: S4 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: lmax Maximum wave speed estimation. Functions purefunction fluxes(p, r, u, g) result(Fc) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Velocity. real(kind=R_P), intent(in) :: g Specific heats ratio. Return Value real(kind=R_P)\n  (1:3) State fluxes. Description 1D Euler fluxes from primitive variables. Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver~5.html","title":"riemann_solver – FOODIE"},{"text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( euler_1D ), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~11.html","title":"finalize – FOODIE"},{"text":"private puresubroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Description Compute inter states (23*-states) from state1 and state4. Called By proc~~compute_inter_states~5~~CalledByGraph proc~compute_inter_states~5 compute_inter_states proc~riemann_solver~5 riemann_solver proc~riemann_solver~5->proc~compute_inter_states~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: a1 Speed of sound of state 1. real(kind=R_P), public :: a4 Speed of sound of state 4. real(kind=R_P), public :: ram Mean value of rho*a. real(kind=R_P), public, parameter :: toll = 1e-10_R_P Tollerance. Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states~5.html","title":"compute_inter_states – FOODIE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. Called By proc~~save_results~8~~CalledByGraph proc~save_results~8 save_results proc~test_ab~4 test_ab proc~test_ab~4->proc~save_results~8 proc~test_leapfrog~4 test_leapfrog proc~test_leapfrog~4->proc~save_results~8 proc~test_tvd_rk~4 test_tvd_rk proc~test_tvd_rk~4->proc~save_results~8 proc~test_ls_rk~4 test_ls_rk proc~test_ls_rk~4->proc~save_results~8 proc~test_euler~4 test_euler proc~test_euler~4->proc~save_results~8 program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_ab~4 program~integrate_lorenz->proc~test_leapfrog~4 program~integrate_lorenz->proc~test_tvd_rk~4 program~integrate_lorenz->proc~test_ls_rk~4 program~integrate_lorenz->proc~test_euler~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type(pyplot), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: s Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\" \"z\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 3 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'x' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'y' , linestyle = 'b-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 3 , :), label = 'z' , linestyle = 'g-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'x-y path' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 3 , :), label = 'x-z path' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 2 , :), y = solution ( 3 , :), label = 'y-z path' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~8.html","title":"save_results – FOODIE"},{"text":"subroutine test_ab() Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Calls proc~~test_ab~4~~CallsGraph proc~test_ab~4 test_ab str str proc~test_ab~4->str proc~save_results~8 save_results proc~test_ab~4->proc~save_results~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_ab~4~~CalledByGraph proc~test_ab~4 test_ab program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_ab~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( lorenz ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( adams_bashforth_integrator ), public :: ab_integrator Adams-Bashforth integrator. integer, public, parameter :: ab_steps = 4 Adams-Bashforth steps number. type( lorenz ), public :: previous (1:ab_steps) Previous time steps solutions. integer(kind=I_P), public :: s AB steps counter. integer, public :: step Time steps counter. Source Code subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( lorenz ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call ab_integrator % integrate ( U = attractor , previous = previous ( 1 : s ), dt = dt , t = solution ( 0 , step - s : step - 1 )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'lorenz_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab~4.html","title":"test_ab – FOODIE"},{"text":"subroutine test_euler() Arguments None Description Test explicit forward Euler ODE solver. Calls proc~~test_euler~4~~CallsGraph proc~test_euler~4 test_euler proc~save_results~8 save_results proc~test_euler~4->proc~save_results~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_euler~4~~CalledByGraph proc~test_euler~4 test_euler program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_euler~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( euler_explicit_integrator ), public :: euler_integrator Euler integrator. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of explicit Euler solver' call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call euler_integrator % integrate ( U = attractor , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Euler' , & filename = 'lorenz_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler~4.html","title":"test_euler – FOODIE"},{"text":"subroutine test_leapfrog() Arguments None Description Test explicit leapfrog class of ODE solvers. Calls proc~~test_leapfrog~4~~CallsGraph proc~test_leapfrog~4 test_leapfrog proc~save_results~8 save_results proc~test_leapfrog~4->proc~save_results~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_leapfrog~4~~CalledByGraph proc~test_leapfrog~4 test_leapfrog program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_leapfrog~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( lorenz ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( lorenz ), public :: filter Filter displacement. type( leapfrog_integrator ), public :: lf_integrator Leapfrog integrator. type( lorenz ), public :: previous (1:2) Previous time steps solutions. integer, public :: step Time steps counter. Source Code subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( lorenz ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( lorenz ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = 2 ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call lf_integrator % integrate ( U = attractor , previous = previous , dt = dt , t = solution ( 0 , step ), filter = filter ) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit leapfrog scheme' ,& filename = 'lorenz_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog","tags":"","loc":"proc/test_leapfrog~4.html","title":"test_leapfrog – FOODIE"},{"text":"subroutine test_ls_rk() Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. Calls proc~~test_ls_rk~4~~CallsGraph proc~test_ls_rk~4 test_ls_rk str str proc~test_ls_rk~4->str proc~save_results~8 save_results proc~test_ls_rk~4->proc~save_results~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_ls_rk~4~~CalledByGraph proc~test_ls_rk~4 test_ls_rk program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_ls_rk~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( ls_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. integer, public, parameter :: registers = 2 Runge-Kutta stages number. type( lorenz ), public :: rk_stage (1:registers) Runge-Kutta stages. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit low storage Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'lorenz_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk","tags":"","loc":"proc/test_ls_rk~4.html","title":"test_ls_rk – FOODIE"},{"text":"subroutine test_tvd_rk() Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Calls proc~~test_tvd_rk~4~~CallsGraph proc~test_tvd_rk~4 test_tvd_rk str str proc~test_tvd_rk~4->str proc~save_results~8 save_results proc~test_tvd_rk~4->proc~save_results~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test_tvd_rk~4~~CalledByGraph proc~test_tvd_rk~4 test_tvd_rk program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_tvd_rk~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( lorenz ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit TVD Runge-Kutta ' // trim ( str (. true ., s )) // ' stages' ,& filename = 'lorenz_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk","tags":"","loc":"proc/test_tvd_rk~4.html","title":"test_tvd_rk – FOODIE"},{"text":"private purefunction output(self) result(state) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value real(kind=R_P),\n  dimension(:),allocatable Lorenz state vector. Description Output the Lorenz field state. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Lorenz field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), dimension (:), allocatable :: state !< Lorenz state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~8.html","title":"output – FOODIE"},{"text":"private function dLorenz_dt(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Lorenz field time derivative. Description Time derivative of Lorenz field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: dn Time level, dummy variable. Source Code function dLorenz_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Lorenz field time derivative. integer ( I_P ) :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: dState_dt ) select type ( dState_dt ) class is ( lorenz ) dState_dt = self dState_dt % U ( 1 ) = self % sigma * ( self % U ( 2 ) - self % U ( 1 )) dState_dt % U ( 2 ) = self % U ( 1 ) * ( self % rho - self % U ( 3 )) - self % U ( 2 ) dState_dt % U ( 3 ) = self % U ( 1 ) * self % U ( 2 ) - self % beta * self % U ( 3 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dLorenz_dt","tags":"","loc":"proc/dlorenz_dt.html","title":"dLorenz_dt – FOODIE"},{"text":"private function previous_step(self, n) result(previous) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Lorenz field. Description Extract previous time solution of Lorenz field. Source Code function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: previous ) select type ( previous ) class is ( lorenz ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step","tags":"","loc":"proc/previous_step~3.html","title":"previous_step – FOODIE"},{"text":"private function lorenz_local_error(lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 lorenz approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code function lorenz_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 lorenz approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) error = 0._R_P do i = 1 , lhs % dims error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_local_error","tags":"","loc":"proc/lorenz_local_error.html","title":"lorenz_local_error – FOODIE"},{"text":"private function lorenz_multiply_lorenz(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a lorenz field by another one. Source Code function lorenz_multiply_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a lorenz field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_lorenz","tags":"","loc":"proc/lorenz_multiply_lorenz.html","title":"lorenz_multiply_lorenz – FOODIE"},{"text":"private function lorenz_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Lorenz field by a real scalar. Source Code function lorenz_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Lorenz field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_real","tags":"","loc":"proc/lorenz_multiply_real.html","title":"lorenz_multiply_real – FOODIE"},{"text":"private function real_multiply_lorenz(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( lorenz ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Lorenz field. Source Code function real_multiply_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( lorenz ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_lorenz","tags":"","loc":"proc/real_multiply_lorenz.html","title":"real_multiply_lorenz – FOODIE"},{"text":"private function add_lorenz(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Lorenz fields. Source Code function add_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Lorenz","tags":"","loc":"proc/add_lorenz.html","title":"add_lorenz – FOODIE"},{"text":"private function sub_lorenz(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Lorenz fields. Source Code function sub_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_lorenz","tags":"","loc":"proc/sub_lorenz.html","title":"sub_lorenz – FOODIE"},{"text":"private subroutine init(self, initial_state, sigma, rho, beta, steps) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Lorenz field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Time steps counter. Source Code subroutine init ( self , initial_state , sigma , rho , beta , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Initial state of Lorenz field vector. real ( R_P ), intent ( IN ) :: sigma !< Lorenz  \\sigma. real ( R_P ), intent ( IN ) :: rho !< Lorenz  \\rho. real ( R_P ), intent ( IN ) :: beta !< Lorenz  \\beta. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % dims )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % dims , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % sigma = sigma self % rho = rho self % beta = beta return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~22.html","title":"init – FOODIE"},{"text":"private subroutine update_previous_steps(self, filter, weights) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. Variables Type Visibility Attributes Name Initial integer, public :: s Time steps counter. Source Code subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( lorenz ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps~3.html","title":"update_previous_steps – FOODIE"},{"text":"private subroutine lorenz_assign_lorenz(lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Lorenz field to another. Source Code subroutine lorenz_assign_lorenz ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Lorenz field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) lhs % dims = rhs % dims lhs % steps = rhs % steps if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous lhs % sigma = rhs % sigma lhs % rho = rhs % rho lhs % beta = rhs % beta endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_lorenz","tags":"","loc":"proc/lorenz_assign_lorenz.html","title":"lorenz_assign_lorenz – FOODIE"},{"text":"private subroutine lorenz_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Lorenz field. Source Code subroutine lorenz_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_real","tags":"","loc":"proc/lorenz_assign_real.html","title":"lorenz_assign_real – FOODIE"},{"text":"Uses: foodie_adt_integrand foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_moulton foodie_integrator_emd_runge_kutta foodie_integrator_euler_explicit foodie_integrator_leapfrog foodie_integrator_low_storage_runge_kutta foodie_integrator_tvd_runge_kutta module~~foodie~~UsesGraph module~foodie foodie module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_euler_explicit->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta var panmodulefoodieUsesGraph = svgPanZoom('#modulefoodieUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. FOODIE is a KISS library for solving systems of Ordinary Differential Equation (ODE) into the Initial Values Problems (IVP)\n contest. The mathematical formulation of the problem is: U_t = R(t,U)\n U_0 = F(0) where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function and F is the (vectorial) initial conditions function. FOODIE is aimed to the time-like integration of the above system of ODE. To this aim, different numerical schemes are provided: explicit Adams-Bashforth class of schemes: 1 step, namely the explicit forward Euler scheme, 1st order accurate; 2 steps, 2nd order accurate; 3 steps, 3rd order accurate; 4 steps, 4th order accurate; forward explicit Euler scheme, a 1st order accurate; explicit Leapfrog : Unfiltered, 2nd order accurate, (mostly) unstable; Robert-Asselin filtered, 1st order accurate; Robert-Asselin-Williams filter, 2nd order accurate; explicit low storage Runge-Kutta 2N class schemes: LS(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; LS(5,4): 5 stages, 4th order accurate; explicit TVD or SSP Runge-Kutta class schemes: TVD(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; SSP(2,2): 2 stages, 2nd order accurate; SSP(3,3): 3 stages, 3rd order accurate; SSP(5,4): 5 stages, 4th order accurate; explicit embedded Runge-Kutta class schemes: DP(7,4): 7 stages, 4th order accurate, Dormand and Prince scheme; implicit Adams-Moulton class of schemes: 0 step, namely the implicit backward Euler scheme, 1st order accurate; 1 step, 2nd order accurate; 2 steps, 3rd order accurate; 3 steps, 4th order accurate; predictor-corrector Adams-Bashforth-Moulton class of schemes: P=AB(1)-C=AM(0) step, namely the explicit/implicit forward/backward Euler scheme, 1st order accurate; P=AB(2)-C=AM(1) step, 2nd order accurate; P=AB(3)-C=AM(2) steps, 3rd order accurate; P=AB(4)-C=AM(3) steps, 4th order accurate; Usage FOODIE schemes must be applied to only subclass extensions of the abstract class integrand . To use FOODIE you must: extend integrand abstract class provided by FOODIE implementing your concrete integrand field For example for the Lorenz' ODE system type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODIE integrand class. private real ( R_P ), dimension (:), allocatable :: state !< Solution vector. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivate, resiuduals function. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz oprator. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. ... endtype lorenz use one of the provided FOODIE integrator For example using the forward explicit Euler scheme to the above Lorenz' ODE system use foodie , only : euler_explicit_integrator use type_lorenz , only : lorenz type ( euler_explicit_integrator ) :: euler_integrator type ( lorenz ) :: attractor real :: dt = 0.01 do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt ) enddo Used By module~~foodie~~UsedByGraph module~foodie foodie program~integrate_oscillation integrate_oscillation module~foodie->program~integrate_oscillation module~type_burgers type_burgers module~foodie->module~type_burgers module~type_oscillation type_oscillation module~foodie->module~type_oscillation module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~type_oscillation->program~integrate_oscillation module~type_euler_1d->program~integrate_euler_1d module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_lorenz->program~integrate_lorenz module~type_euler_1d_openmp->program~integrate_euler_1d_openmp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"module/foodie.html","title":"foodie – FOODIE"},{"text":"Uses: foodie_kinds module~~foodie_adt_integrand~~UsesGraph module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_adt_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define the abstract type integrand for building FOODIE ODE integrators. Used By module~~foodie_adt_integrand~~UsedByGraph module~foodie_adt_integrand foodie_adt_integrand module~foodie foodie module~foodie_adt_integrand->module~foodie module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta program~integrate_oscillation integrate_oscillation module~foodie->program~integrate_oscillation module~type_burgers type_burgers module~foodie->module~type_burgers module~type_oscillation type_oscillation module~foodie->module~type_oscillation module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~type_burgers->program~integrate_burgers module~type_oscillation->program~integrate_oscillation module~type_euler_1d->program~integrate_euler_1d module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_lorenz->program~integrate_lorenz module~type_euler_1d_openmp->program~integrate_euler_1d_openmp var panmodulefoodie_adt_integrandUsedByGraph = svgPanZoom('#modulefoodie_adt_integrandUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private subroutine assignment_integrand (lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function time_derivative (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function local_error_operator (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 solution approximations. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function integrand_op_real (lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function real_op_integrand (lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function symmetric_operator (lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. Derived Types type, public, abstract :: integrand Components Type Visibility Attributes Name Initial class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. Type-Bound Procedures procedure(time_derivative), public, pass(self), deferred :: t Time derivative, residuals. procedure(local_error_operator), public, pass(lhs), deferred :: local_error ||integrand - integrand||. procedure(symmetric_operator), public, pass(lhs), deferred :: integrand_multiply_integrand Integrand * integrand operator. procedure(integrand_op_real), public, pass(lhs), deferred :: integrand_multiply_real Integrand * real operator. procedure(real_op_integrand), public, pass(rhs), deferred :: real_multiply_integrand Real * integrand operator. procedure(symmetric_operator), public, pass(lhs), deferred :: add Integrand + integrand operator. procedure(symmetric_operator), public, pass(lhs), deferred :: sub Integrand - integrand operator. procedure(assignment_integrand), public, pass(lhs), deferred :: assign_integrand Integrand = integrand. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. generic, public :: operator(+) => add Overloading + operator. generic, public :: operator(-) => sub Overloading - operator. generic, public :: operator(*) => integrand_multiply_integrand, real_multiply_integrand, integrand_multiply_real Overloading * operator. generic, public :: assignment(=) => assign_integrand Overloading = assignament. Description Abstract type for building FOODIE ODE integrators.","tags":"","loc":"module/foodie_adt_integrand.html","title":"foodie_adt_integrand – FOODIE"},{"text":"Uses: foodie_kinds foodie_adt_integrand module~~foodie_integrator_adams_bashforth~~UsesGraph module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 4rd order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Adams-Bashforth class scheme implemented is:  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s}{ b_s \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  where N_s is the number of previous steps considered. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit. The coefficients b_s define the actual scheme, that is selected accordingly to the number of steps used. Currently, the following schemes are available: 1 step, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order.\n The b coefficient is:\n b = \\left[b_1\\right] = \\left[1\\right]\n The scheme is:\n  U&#94;{n+1} = U&#94;n + \\Delta t R(t&#94;n,U&#94;n)  2 steps This scheme is 2nd order.\n The b coefficients are:\n b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] =\n       \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+2} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right]  3 steps This scheme is 3rd order.\n The b coefficients are:\n b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] =\n       \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+3} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1})\n +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right]  4 steps This scheme is 4th order.\n The b coefficients are:\n b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 & b_4 \\end{array}} \\right] =\n       \\left[ {\\begin{array}{*{20}{c}} -\\frac{9}{24} & \\frac{37}{24} & -\\frac{59}{24} & \\frac{55}{24} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+4} = U&#94;{n+3} +\\Delta t \\left[ \\frac{55}{24}R(t&#94;{n+3}, U&#94;{n+3}) - \\frac{59}{24}R(t&#94;{n+2}, U&#94;{n+2})\n +\\frac{37}{24} R(t&#94;{n+1}, U&#94;{n+1}) - \\frac{9}{24} R(t&#94;{n}, U&#94;{n}) \\right]  Bibliography Used By module~~foodie_integrator_adams_bashforth~~UsedByGraph module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton program~integrate_oscillation integrate_oscillation module~foodie->program~integrate_oscillation module~type_burgers type_burgers module~foodie->module~type_burgers module~type_oscillation type_oscillation module~foodie->module~type_oscillation module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_integrator_adams_bashforth_moulton->module~foodie module~type_burgers->program~integrate_burgers module~type_oscillation->program~integrate_oscillation module~type_euler_1d->program~integrate_euler_1d module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_lorenz->program~integrate_lorenz module~type_euler_1d_openmp->program~integrate_euler_1d_openmp var panmodulefoodie_integrator_adams_bashforthUsedByGraph = svgPanZoom('#modulefoodie_integrator_adams_bashforthUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: adams_bashforth_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps. real(kind=R_P), private, allocatable :: b (:) b coefficients. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_adams_bashforth.html","title":"foodie_integrator_adams_bashforth – FOODIE"},{"text":"Uses: foodie_kinds foodie_adt_integrand foodie_integrator_adams_bashforth foodie_integrator_adams_moulton module~~foodie_integrator_adams_bashforth_moulton~~UsesGraph module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton var panmodulefoodie_integrator_adams_bashforth_moultonUsesGraph = svgPanZoom('#modulefoodie_integrator_adams_bashforth_moultonUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order\n accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Adams-Bashforth-Moulton class scheme implemented is: predictor  U&#94;{n+N_s&#94;p} = U&#94;{n+N_s&#94;p-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s&#94;p}{ b_s&#94;p \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  corrector  U&#94;{n+N_s&#94;c} = U&#94;{n+N_s&#94;c-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s&#94;c}{ b_s&#94;c \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } \\right]  where N_s&#94;p is the number of previous steps considered for the predictor and N_s&#94;c is the number of previous steps\nconsidered for the corrector. Note The value of \\Delta t must be provided, it not being computed by the integrator. The coefficients b_s&#94;{p,c} define the actual scheme, that is selected accordingly to the number of steps used. The predictor and corrector schemes should have the same formal order of accuracy, thus N_s&#94;p=N_s&#94;c+1\n should hold. Currently, the following schemes are available: P=AB(1)-C=AM(0) step, Explicit/Implicit Farward/Backward Euler, 1st order This scheme is TVD and reverts to Explicit/Implicit Farward/Backward Euler, it being 1st order.\n The b coefficient is:\n b&#94;p = \\left[b_1\\right] = \\left[1\\right]\n b&#94;c = \\left[b_0\\right] = \\left[1\\right]\n The scheme is:\n  U&#94;{n+1,p} = U&#94;{n} + \\Delta t R(t&#94;{n},U&#94;{n}) \n  U&#94;{n+1,c} = U&#94;{n} + \\Delta t R(t&#94;{n+1},U&#94;{n+1,p})  P=AB(2)-C=AM(1) steps This scheme is 2nd order.\n The b coefficients are:\n b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right]\n b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2} & \\frac{1}{2} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+2,p} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right] \n  U&#94;{n+2,c} = U&#94;{n+1} +\\Delta t \\left[ \\frac{1}{2} R(t&#94;{n+2,p}, U&#94;{n+2})+\\frac{1}{2} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  P=AB(3)-C=AM(2) steps This scheme is 3rd order.\n The b coefficients are:\n b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right]\n b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{12} & \\frac{2}{3} & \\frac{5}{12} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+3,p} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1})\n +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right] \n  U&#94;{n+3,c} = U&#94;{n+2} +\\Delta t \\left[ \\frac{5}{12}R(t&#94;{n+3}, U&#94;{n+3,p}) + \\frac{2}{3}R(t&#94;{n+2}, U&#94;{n+2})\n -\\frac{1}{12} R(t&#94;{n+1}, U&#94;{n+1})  \\right]  P=AB(4)-C=AM(3) steps This scheme is 4th order.\n The b coefficients are:\n b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 & b_4 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} -\\frac{9}{24} & \\frac{37}{24} & -\\frac{59}{24} & \\frac{55}{24} \\end{array}} \\right]\n b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 & b_3 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{24} & -\\frac{5}{24} & \\frac{19}{24} & \\frac{9}{24} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+4,p} = U&#94;{n+3} +\\Delta t \\left[ \\frac{55}{24}R(t&#94;{n+3}, U&#94;{n+3}) - \\frac{59}{24}R(t&#94;{n+2}, U&#94;{n+2})\n +\\frac{37}{24} R(t&#94;{n+1}, U&#94;{n+1}) - \\frac{9}{24} R(t&#94;{n}, U&#94;{n}) \\right] \n  U&#94;{n+4,c} = U&#94;{n+3} +\\Delta t \\left[ \\frac{9}{24}R(t&#94;{n+4}, U&#94;{n+4,p}) + \\frac{19}{24}R(t&#94;{n+3}, U&#94;{n+3})\n -\\frac{5}{24} R(t&#94;{n+2}, U&#94;{n+2}) + \\frac{1}{24} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  Bibliography Used By module~~foodie_integrator_adams_bashforth_moulton~~UsedByGraph module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie program~integrate_oscillation integrate_oscillation module~foodie->program~integrate_oscillation module~type_burgers type_burgers module~foodie->module~type_burgers module~type_oscillation type_oscillation module~foodie->module~type_oscillation module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~type_oscillation->program~integrate_oscillation module~type_euler_1d->program~integrate_euler_1d module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_lorenz->program~integrate_lorenz module~type_euler_1d_openmp->program~integrate_euler_1d_openmp var panmodulefoodie_integrator_adams_bashforth_moultonUsedByGraph = svgPanZoom('#modulefoodie_integrator_adams_bashforth_moultonUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: adams_bashforth_moulton_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = -1 Number of time steps. type( adams_bashforth_integrator ), private :: predictor Predictor solver. type( adams_moulton_integrator ), private :: corrector Corrector solver. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_adams_bashforth_moulton.html","title":"foodie_integrator_adams_bashforth_moulton – FOODIE"},{"text":"Uses: foodie_kinds foodie_adt_integrand module~~foodie_integrator_adams_moulton~~UsesGraph module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_adt_integrand->module~foodie_integrator_adams_moulton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 4rd order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Adams-Moulton class scheme implemented is:  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s-1}{ b_s \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } +\n b_{N_S}\\cdot R(t&#94;{n+N_s}, U&#94;{n+N_s}) \\right]  where N_s is the number of previous steps considered. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are implicit. The coefficients b_s define the actual scheme, that is selected accordingly to the number of steps used. Currently, the following schemes are available: 0 step, Implicit Backward Euler, 1st order This scheme is TVD and reverts to Implicit Backward Euler, it being 1st order.\n The b coefficient is:\n b = \\left[b_0\\right] = \\left[1\\right]\n The scheme is:\n  U&#94;{n} = U&#94;{n-1} + \\Delta t R(t&#94;{n},U&#94;{n})  1 step This scheme is 2nd order.\n The b coefficients are:\n b = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 \\end{array}} \\right] =\n       \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2} & \\frac{1}{2} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+1} = U&#94;{n} +\\Delta t \\left[ \\frac{1}{2} R(t&#94;{n+1}, U&#94;{n+1})+\\frac{1}{2} R(t&#94;{n}, U&#94;{n}) \\right]  2 steps This scheme is 3rd order.\n The b coefficients are:\n b = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 \\end{array}} \\right] =\n       \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{12} & \\frac{2}{3} & \\frac{5}{12} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+2} = U&#94;{n+1} +\\Delta t \\left[ \\frac{5}{12}R(t&#94;{n+2}, U&#94;{n+2}) + \\frac{2}{3}R(t&#94;{n+1}, U&#94;{n+1})\n -\\frac{1}{12} R(t&#94;{n}, U&#94;{n})  \\right]  3 steps This scheme is 4th order.\n The b coefficients are:\n b = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 & b_3 \\end{array}} \\right] =\n       \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{24} & -\\frac{5}{24} & \\frac{19}{24} & \\frac{9}{24} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+3} = U&#94;{n+2} +\\Delta t \\left[ \\frac{9}{24}R(t&#94;{n+3}, U&#94;{n+3}) + \\frac{19}{24}R(t&#94;{n+2}, U&#94;{n+2})\n -\\frac{5}{24} R(t&#94;{n+1}, U&#94;{n+1}) + \\frac{1}{24} R(t&#94;{n}, U&#94;{n}) \\right]  Bibliography Used By module~~foodie_integrator_adams_moulton~~UsedByGraph module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie foodie module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie program~integrate_oscillation integrate_oscillation module~foodie->program~integrate_oscillation module~type_burgers type_burgers module~foodie->module~type_burgers module~type_oscillation type_oscillation module~foodie->module~type_oscillation module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~type_oscillation->program~integrate_oscillation module~type_euler_1d->program~integrate_euler_1d module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_lorenz->program~integrate_lorenz module~type_euler_1d_openmp->program~integrate_euler_1d_openmp var panmodulefoodie_integrator_adams_moultonUsedByGraph = svgPanZoom('#modulefoodie_integrator_adams_moultonUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: adams_moulton_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = -1 Number of time steps. real(kind=R_P), private, allocatable :: b (:) b coefficients. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_adams_moulton.html","title":"foodie_integrator_adams_moulton – FOODIE"},{"text":"Uses: foodie_kinds foodie_adt_integrand module~~foodie_integrator_emd_runge_kutta~~UsesGraph module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 6th order accurate. The integrators provided have the embedded pairs property allowing for automatic step size control.\n The schemes are explicit and defined through the extended Butcher's table syntax, see[1] . Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form:  U_p&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_p&#94;s K&#94;s \n  U_{p+1}&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_{p+1}&#94;s K&#94;s  p is the lower accuracy order scheme and p+1 is the higher one; Ns is the number of stages used and K&#94;s is\n the s&#94;{th} stage computed as:  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are\n given in the extended Butcher table form: gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns}\n  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns}\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns}\n ------------|-------------------------------------------------------------\n             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns}\n             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: gamma&#94;1    | 0                 0                 ...        0\n  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0\n ------------|-------------------------------------------------------------\n             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns}\n             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} Moreover the following relation always holds:\n  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: 2 stages, 2th order This scheme is due to Heun-Euler. 0  | 0\n  1  | 1     0\n ----------------\n     | 1/2   1/2\n     | 1      0 6 stages, 5th order This scheme is due to Cash and Karp, see [3]. 0    | 0\n  1/5    | 1/5\n  3/10 | 3/40            9/40\n  3/5    | 3/10          -9/10        6/5\n  1    | -11/54        5/2          -70/27      35/27\n  7/8    | 1631/55296    175/512      575/13824   44275/110592     253/4096     0\n ----------------------------------------------------------------------------------------\n       | 37/378        0           250/621      125/594          0            512/1771\n       | 2825/27648    0           18575/48384  13525/55296      277/14336    1/4 7 stages, 4th order This scheme is due to Dormand and Prince, see [1]. 0    | 0\n  1/5  | 1/5\n  3/10 | 3/40          9/40\n  4/5  | 44/45        -56/15        32/9\n  8/9  | 19372/6561   -25360/2187   64448/6561   -212/729\n  1    | 9017/3168    -355/33       46732/5247    49/176      -5103/18656\n  1    | 35/384        0            500/1113      125/192     -2187/6784      11/84      0\n --------------------------------------------------------------------------------------------\n       | 5179/57600    0            7571/16695    393/640     -92097/339200   187/2100   1/40\n       | 35/384        0            500/1113      125/192     -2187/6784      11/84      0 9 stages, 6th order This scheme is due to Calvo et al., see [2]. 0                 | 0\n  2/15              | 2/15\n  1/5               | 1/20                  3/20\n  3/10              | 3/40                  0                      9/40\n  14/25             | 86727015/196851553    -60129073/52624712     957436434/1378352377    83886832/147842441\n  19/25             | -86860849/45628967    111022885/25716487     108046682/101167669     -141756746/36005461\n  35226607/35688279 | 77759591/16096467     -49252809/6452555      -381680111/51572984     879269579/66788831\n  1                 | 237564263/39280295    -100523239/10677940    -265574846/27330247     317978411/18988713\n  1                 | 17572349/289262523    0                      57513011/201864250      15587306/354501571\n --------------------------------------------------------------------------------------------------------------\n                    | 17572349/289262523    0                      57513011/201864250      15587306/354501571\n                    | 15231665/510830334    0                      59452991/116050448      -28398517/122437738\n ...continued...\n  0                 |\n  2/15              |\n  1/5               |\n  3/10              |\n  14/25             |\n  19/25             | 73139862/60170633\n  35226607/35688279 | -90453121/33722162     111179552/157155827\n  1                 | -124494385/35453627    86822444/100138635     -12873523/724232625\n  1                 | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0\n -----------------------------------------------------------------------------------------------------------------------\n                    | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0\n                    | 56673824/137010559     68003849/426673583     7097631/37564021       -71226429/583093742    1/20 17 stages, 10th order This scheme is due to Feagin, see [4]. 0                        |  0\n  0.1                      |  0.1\n  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052\n  0.809036761204472681298  |  0.202259190301118170324  0                        0.606777570903354510974\n  0.309036761204472681298  |  0.184024714708643575149  0                        0.197966831227192369068\n  0.981074190219795268254  |  0.087900734020668133731  0                        0\n  0.833333333333333333333  |  0.085970050490246030218  0                        0\n  0.354017365856802376329  |  0.120930449125333720660  0                        0\n  0.882527661964732346425  |  0.110854379580391483508  0                        0\n  0.642615758240322548157  |  0.112054414752879004829  0                        0\n  0.357384241759677451842  |  0.113976783964185986138  0                        0\n  0.117472338035267653574  |  0.079831452828019604635  0                        0\n  0.833333333333333333333  |  0.985115610164857280120  0                        0\n  0.309036761204472681298  |  0.895080295771632891049  0                        0.197966831227192369068\n  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052  0\n  0.1                      |  0.1                      0                       -0.157178665799771163367\n  1                        |  0.181781300700095283888  0.675                    0.342758159847189839942\n ------------------------------------------------------------------------------------------------------\n                           |  0.033333333333333333333  0.025                    0.033333333333333333333\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  | -0.072954784731363262918\n  0.981074190219795268254  |  0.410459702520260645318  0.482713753678866489204\n  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -0.073185637507085073678\n  0.354017365856802376329  |  0                        0.260124675758295622809  0.032540262154909133015\n  0.882527661964732346425  |  0                        0                       -0.060576148825500558762\n  0.642615758240322548157  |  0                        0                       -0.144942775902865915672\n  0.357384241759677451842  |  0                        0                       -0.076881336420335693858\n  0.117472338035267653574  |  0                        0                       -0.052032968680060307651\n  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -1.378964865748435675821\n  0.309036761204472681298  | -0.072954784731363262918  0                       -0.851236239662007619739\n  0.539357840802981787532  |  0                       -0.777333643644968233538  0\n  0.1                      |  0                        0                        0\n  1                        |  0                        0.259111214548322744512 -0.358278966717952089048\n ------------------------------------------------------------------------------------------------------\n                           |  0                        0.05                     0\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  | -0.059578021181736100156\n  0.882527661964732346425  |  0.321763705601778390100  0.510485725608063031577\n  0.642615758240322548157  | -0.333269719096256706589  0.499269229556880061353  0.509504608929686104236\n  0.357384241759677451842  |  0.239527360324390649107  0.397774662368094639047  0.010755895687360745555\n  0.117472338035267653574  | -0.057695414616854888173  0.194781915712104164976  0.145384923188325069727\n  0.833333333333333333333  | -0.861164195027635666673  5.784288136375372200229  3.288077619851035668904\n  0.309036761204472681298  |  0.398320112318533301719  3.639372631810356060294  1.548228770398303223653\n  0.539357840802981787532  | -0.091089566215517606959  0                        0\n  0.1                      |  0                        0                        0\n  1                        | -1.045948959408833060950  0.930327845415626983292  1.779509594317081024461\n ------------------------------------------------------------------------------------------------------\n                           |  0.04                     0                        0.189237478148923490158\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  |\n  0.882527661964732346425  |\n  0.642615758240322548157  |\n  0.357384241759677451842  | -0.327769124164018874147\n  0.117472338035267653574  | -0.078294271035167077755 -0.114503299361098912184\n  0.833333333333333333333  | -2.386339050931363840134 -3.254793424836439186545 -2.163435416864229823539\n  0.309036761204472681298  | -2.122217147040537160260 -1.583503985453261727133 -1.715616082859362649220\n  0.539357840802981787532  |  0                        0                        0\n  0.1                      |  0                        0                        0\n  1                        |  0.1                     -0.282547569539044081612 -0.159327350119972549169\n ------------------------------------------------------------------------------------------------------\n                           |  0.277429188517743176508  0.277429188517743176508  0.189237478148923490158\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  |\n  0.882527661964732346425  |\n  0.642615758240322548157  |\n  0.357384241759677451842  |\n  0.117472338035267653574  |\n  0.833333333333333333333  |\n  0.309036761204472681298  | -0.024403640575012745213\n  0.539357840802981787532  |  0.091089566215517606959  0.777333643644968233538\n  0.1                      |  0                        0                        0.157178665799771163367\n  1                        | -0.145515894647001510860 -0.259111214548322744512 -0.342758159847189839942 -0.675\n -------------------------------------------------------------------------------------------------------------\n                           | -0.04                    -0.05                    -0.033333333333333333333 -0.025\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  |\n  0.882527661964732346425  |\n  0.642615758240322548157  |\n  0.357384241759677451842  |\n  0.117472338035267653574  |\n  0.833333333333333333333  |\n  0.309036761204472681298  |\n  0.539357840802981787532  |\n  0.1                      |\n  1                        |\n ---------------------------------------------------\n                           | 0.033333333333333333333 Bibliography [1] A family of embedded Runge-Kutta formulae , Dormand, J. R., Prince, P. J. (1980), Journal of Computational and\n Applied Mathematics 6 (1): 19–26, doi:10.1016/0771-050X(80)90013-3. [2] A New Embedded Pair of Runge-Kutta Formulas of orders 5 and 6 , M. Calvo, J.I. Montijano, L. Randez, Computers & Mathematics\n with Applications, Volume 20, Issue 1, 1990, Pages 15–24, ISSN 0898-1221, http://dx.doi.org/10.1016/0898-1221(90)90064-Q. [3] A variable order Runge-Kutta method for initial value problems with rapidly varying right-hand sides , J. R. Cash,\n A. H. Karp, ACM Transactions on Mathematical Software, vol. 16,  pp. 201–222, 1990, doi:10.1145/79505.79507. [4] A tenth-order Runge-Kutta method with error estimate , Feagin, T., Proceedings of the IAENG Conf. on Scientific\n Computing. 2007. Used By module~~foodie_integrator_emd_runge_kutta~~UsedByGraph module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie foodie module~foodie_integrator_emd_runge_kutta->module~foodie program~integrate_oscillation integrate_oscillation module~foodie->program~integrate_oscillation module~type_burgers type_burgers module~foodie->module~type_burgers module~type_oscillation type_oscillation module~foodie->module~type_oscillation module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~type_oscillation->program~integrate_oscillation module~type_euler_1d->program~integrate_euler_1d module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_lorenz->program~integrate_lorenz module~type_euler_1d_openmp->program~integrate_euler_1d_openmp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: emd_runge_kutta_integrator Components Type Visibility Attributes Name Initial real(kind=R_P), public :: tolerance = 0._R_P Tolerance on the local truncation error. real(kind=R_P), public :: pp1_inv = 0._R_P 1/(p+1) where p is the accuracy order of the lower accurate scheme of the pair. integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:,:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_emd_runge_kutta.html","title":"foodie_integrator_emd_runge_kutta – FOODIE"},{"text":"Uses: foodie_kinds foodie_adt_integrand module~~foodie_integrator_euler_explicit~~UsesGraph module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_adt_integrand->module~foodie_integrator_euler_explicit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Forward Explicit Euler scheme implemented is:  U&#94;{n+1} = U&#94;n +\\Delta t R(t, U&#94;n)  Note The value of \\Delta t must be provided, it not being computed by the integrator. Used By module~~foodie_integrator_euler_explicit~~UsedByGraph module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie foodie module~foodie_integrator_euler_explicit->module~foodie program~integrate_oscillation integrate_oscillation module~foodie->program~integrate_oscillation module~type_burgers type_burgers module~foodie->module~type_burgers module~type_oscillation type_oscillation module~foodie->module~type_oscillation module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~type_oscillation->program~integrate_oscillation module~type_euler_1d->program~integrate_euler_1d module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_lorenz->program~integrate_lorenz module~type_euler_1d_openmp->program~integrate_euler_1d_openmp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: euler_explicit_integrator Type-Bound Procedures procedure, public, nopass :: integrate Integrate integrand field. Description FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. Subroutines private subroutine integrate (U, Dt, t) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. Description Integrate field with explicit Euler scheme, 1st order.","tags":"","loc":"module/foodie_integrator_euler_explicit.html","title":"foodie_integrator_euler_explicit – FOODIE"},{"text":"Uses: foodie_kinds foodie_adt_integrand module~~foodie_integrator_leapfrog~~UsesGraph module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_adt_integrand->module~foodie_integrator_leapfrog Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the leapfrog class scheme implemented (see [3]) is:  U&#94;{n+2} = U&#94;{n} + 2\\Delta t \\cdot R(t&#94;{n+1}, U&#94;{n+1})  Optionally, the Robert-Asselin-Williams (RAW) filter (see [3]) is applied to the computed integration steps:\n  \\Delta = \\frac{\\nu}{2}(U&#94;{n} - 2 U&#94;{n+1} + U&#94;{n+2}) \n  U&#94;{n+1} = U&#94;{n+1} + \\Delta * \\alpha \n  U&#94;{n+2} = U&#94;{n+2} + \\Delta * (\\alpha-1) \n Note that for \\alpha=1 the filter reverts back to the standard Robert-Asselin scheme.\n The filter coefficients should be taken as \\nu \\in (0,1] and \\alpha \\in (0.5,1]. The default values are \\nu=0.01 \\alpha=0.53 Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit. The filter coefficients \\nu,\\,\\alpha  define the actual scheme. Bibliography [1] The integration of a low order spectral form of the primitive meteorological equations , Robert, A. J., J. Meteor. Soc.\n Japan,vol. 44, pages 237–245, 1966. [2] Frequency filter for time integrations , Asselin, R., Monthly Weather Review, vol. 100, pages 487–490, 1972. [3] The RAW filter: An improvement to the Robert–Asselin filter in semi-implicit integrations , Williams, P.D., Monthly\n Weather Review, vol. 139(6), pages 1996–2007, June 2011. Used By module~~foodie_integrator_leapfrog~~UsedByGraph module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie foodie module~foodie_integrator_leapfrog->module~foodie program~integrate_oscillation integrate_oscillation module~foodie->program~integrate_oscillation module~type_burgers type_burgers module~foodie->module~type_burgers module~type_oscillation type_oscillation module~foodie->module~type_oscillation module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~type_oscillation->program~integrate_oscillation module~type_euler_1d->program~integrate_euler_1d module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_lorenz->program~integrate_lorenz module~type_euler_1d_openmp->program~integrate_euler_1d_openmp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: leapfrog_integrator Components Type Visibility Attributes Name Initial real(kind=R_P), private :: nu = 0.01_R_P Robert-Asselin filter coefficient. real(kind=R_P), private :: alpha = 0.53_R_P Robert-Asselin-Williams filter coefficient. Type-Bound Procedures procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. Description FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Subroutines private elementalsubroutine init (self, nu, alpha) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(inout) :: self LF integrator. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. Description Create the actual leapfrog integrator: initialize the filter coefficient. private subroutine integrate (self, U, previous, Dt, t, filter) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(in) :: self LF integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:2) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. class( integrand ), intent(inout), optional :: filter Filter field displacement. Description Integrate field with leapfrog class scheme.","tags":"","loc":"module/foodie_integrator_leapfrog.html","title":"foodie_integrator_leapfrog – FOODIE"},{"text":"Uses: iso_fortran_env foodie_kinds foodie_adt_integrand module~~foodie_integrator_low_storage_runge_kutta~~UsesGraph module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. The integrators provided have the low storage property allowing for an efficient use of the memory.\n Following Williamson approach [1], the LSRK(5,4)2N (solution 3) scheme of Carpenter et al. [2] is implemented. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form: \\begin{matrix}\n K_1 = U&#94;n \\\\\n K_2 = 0 \\\\\n\\left.\\begin{matrix}\n K_2 = A_s K_2 + \\Delta t R(t&#94;n + C_s \\Delta t, K_1) \\\\\n K_1 = K_1 + B_s K_2\n\\end{matrix}\\right\\} s=1,2,...N_s\\\\\nU&#94;{n+1} = K_1\n\\end{matrix} where Ns is the number of stages used and K_1, K_2 are the 2 registers used for stages computation. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus A_1=C_1=0. The coefficients A_s, B_s, C_s are given in the Williamson low storage table\n form. The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: 1 stage, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. It is not a real low storage scheme, this being\n meaningless for a first order scheme. However it is added for safety reason. Stage A B C 1 0 1 0 5 stages, SSP, 4th order This scheme is a low storage RK(5, 4), based on the solution 3 proposed in [2]. Stage A B C 1 0 1432997174477/9575080441755 0 2 -567301805773 /1357537059087 5161836677717/13612068292357 1432997174477/9575080441755 3 -2404267990393/2016746695238 1720146321549/2090206949498 2526269341429/6820363962896 4 -3550918686646/2091501179385 3134564353537/4481467310338 2006345519317/3224310063776 5 -1275806237668/842570457699 2277821191437/14882151754819 2802321613138/2924317926251 6 stages, 4th order This scheme is a low storage RK(6, 4), by [3]. Stage A B C 1 0 0.122000000000 0 2 -0.691750960670 0.477263056358 0.122000000000 3 -1.727127405211 0.381941220320 0.269115878630 4 -0.694890150986 0.447757195744 0.447717183551 5 -1.039942756197 0.498614246822 0.749979795490 6 -1.531977447611 0.186648570846 0.898555413085 7 stages, 4th order This scheme is a low storage RK(7, 4), by [3]. Stage A B C 1 0 0.117322146869 0 2 -0.647900745934 0.503270262127 0.117322146869 3 -2.704760863204 0.233663281658 0.294523230758 4 -0.460080550118 0.283419634625 0.305658622131 5 -0.500581787785 0.540367414023 0.582864148403 6 -1.906532255913 0.371499414620 0.858664273599 7 -1.450000000000 0.136670099385 0.868664273599 12 stages, 4th order This scheme is a low storage RK(12, 4), by [4]. Stage A B C 1 0 0.0650008435125904 0 2 -0.0923311242368072 0.0161459902249842 0.0650008435125904 3 -0.9441056581158819 0.5758627178358159 0.0796560563081853 4 -4.3271273247576394 0.1649758848361671 0.1620416710085376 5 -2.1557771329026072 0.3934619494248182 0.2248877362907778 6 -0.9770727190189062 0.0443509641602719 0.2952293985641261 7 -0.7581835342571139 0.2074504268408778 0.3318332506149405 8 -1.7977525470825499 0.6914247433015102 0.4094724050198658 9 -2.6915667972700770 0.3766646883450449 0.6356954475753369 10 -4.6466798960268143 0.0757190350155483 0.6806551557645497 11 -0.1539613783825189 0.2027862031054088 0.7143773712418350 12 -0.5943293901830616 0.2167029365631842 0.9032588871651854 13 stages, 4th order This scheme is a low storage RK(13, 4), by [4]. Stage A B C 1 0 0.0271990297818803 0 2 -0.6160178650170565 0.1772488819905108 0.0271990297818803 3 -0.4449487060774118 0.0378528418949694 0.0952594339119365 4 -1.0952033345276178 0.6086431830142991 0.1266450286591127 5 -1.2256030785959187 0.2154313974316100 0.1825883045699772 6 -0.2740182222332805 0.2066152563885843 0.3737511439063931 7 -0.0411952089052647 0.0415864076069797 0.5301279418422206 8 -0.1797084899153560 0.0219891884310925 0.5704177433952291 9 -1.1771530652064288 0.9893081222650993 0.5885784947099155 10 -0.4078831463120878 0.0063199019859826 0.6160769826246714 11 -0.8295636426191777 0.3749640721105318 0.6223252334314046 12 -4.7895970584252288 1.6080235151003195 0.6897593128753419 13 -0.6606671432964504 0.0961209123818189 0.9126827615920843 14 stages, 4th order This scheme is a low storage RK(14, 4), by [4]. Stage A B C 1 0 0.0367762454319673 0 2 -0.7188012108672410 0.3136296607553959 0.0367762454319673 3 -0.7785331173421570 0.1531848691869027 0.1249685262725025 4 -0.0053282796654044 0.0030097086818182 0.2446177702277698 5 -0.8552979934029281 0.3326293790646110 0.2476149531070420 6 -3.9564138245774565 0.2440251405350864 0.2969311120382472 7 -1.5780575380587385 0.3718879239592277 0.3978149645802642 8 -2.0837094552574054 0.6204126221582444 0.5270854589440328 9 -0.7483334182761610 0.1524043173028741 0.6981269994175695 10 -0.7032861106563359 0.0760894927419266 0.8190890835352128 11 0.0013917096117681 0.0077604214040978 0.8527059887098624 12 -0.0932075369637460 0.0024647284755382 0.8604711817462826 13 -0.9514200470875948 0.0780348340049386 0.8627060376969976 14 -7.1151571693922548 5.5059777270269628 0.8734213127600976 Bibliography [1] Low-Storage Runge-Kutta Schemes , J. H. Williamson, Journal of Computational Physics, vol. 35, 1980, pp. 48–56. [2] Fourth-Order 2N-Storage Runge-Kutta Schemes , Mark H. Carpenter, Christopher A. Kennedy, NASA Technical Memorandum 109112,\n June 1994. [3] High-accuracy large-step explicit Runge–Kutta (HALE-RK) schemes for computational aeroacoustics , Vasanth Allampalli and\n Ray Hixon and M. Nallasamy and Scott D. Sawyer, Journal of Computational Physics, vol. 228, 2009, pp. 3837–3850. [4] Efficient low-storage Runge–Kutta schemes with optimized stability regions , Jens Niegemann and Richard Diehl and Kurt\n Busch, Journal of Computational Physics, vol. 231, 2012, pp. 364–372. Used By module~~foodie_integrator_low_storage_runge_kutta~~UsedByGraph module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie program~integrate_oscillation integrate_oscillation module~foodie->program~integrate_oscillation module~type_burgers type_burgers module~foodie->module~type_burgers module~type_oscillation type_oscillation module~foodie->module~type_oscillation module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~type_oscillation->program~integrate_oscillation module~type_euler_1d->program~integrate_euler_1d module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_lorenz->program~integrate_lorenz module~type_euler_1d_openmp->program~integrate_euler_1d_openmp var panmodulefoodie_integrator_low_storage_runge_kuttaUsedByGraph = svgPanZoom('#modulefoodie_integrator_low_storage_runge_kuttaUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: ls_runge_kutta_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: A (:) Low storage A coefficients. real(kind=R_P), public, allocatable :: B (:) Low storage B coefficients. real(kind=R_P), public, allocatable :: C (:) Low storage C coefficients. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_low_storage_runge_kutta.html","title":"foodie_integrator_low_storage_runge_kutta – FOODIE"},{"text":"Uses: foodie_kinds foodie_adt_integrand module~~foodie_integrator_tvd_runge_kutta~~UsesGraph module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. The integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP)\n one. The schemes are explicit and defined through the Butcher's table syntax, see[1] . Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form:  U&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta&#94;s K&#94;s  where Ns is the number of stages used and K&#94;s is the s&#94;{th} stage computed as:  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are\n given in the Butcher table form: gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns}\n  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns}\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns}\n ------------|-------------------------------------------------------------\n             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: gamma&#94;1    | 0                 0                 ...        0\n  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0\n ------------|-------------------------------------------------------------\n             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} Moreover the following relation always holds:\n  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: 1 stage, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. 0 | 0\n ---|---\n    | 1 2 stages, SSP, 2nd order This scheme is an optmial SSP(2, 2) without low-storage algorithm, see [2]. 0 | 0     0\n  1 | 1     0\n ---|-----------\n    | 1/2   1/2 3 stages, SSP, 3rd order This scheme is an optmial SSP(3, 3) without low-storage algorithm, see [2]. 0   | 0     0     0\n  1   | 1     0     0\n  1/2 | 1/4   1/4   0\n -----|-----------------\n      | 1/6   1/6   1/3 5 stages, SSP, 4th order This scheme is an optmial SSP(5, 4) without low-storage algorithm, see [2]. 0                | 0                  0                  0                  0                  0\n  0.39175222700392 | 0.39175222700392   0                  0                  0                  0\n  0.58607968896780 | 0.21766909633821   0.36841059262959   0                  0                  0\n  0.47454236302687 | 0.08269208670950   0.13995850206999   0.25189177424738   0                  0\n  0.93501063100924 | 0.06796628370320   0.11503469844438   0.20703489864929   0.54497475021237   0\n ------------------|---------------------------------------------------------------------------------------------\n                   | 0.14681187618661   0.24848290924556   0.10425883036650   0.27443890091960   0.22600748319395 Bibliography [1] Coefficients for the study of Runge-Kutta integration processes , Butcher, J.C., J. Austral. Math. Soc., Vol. 3,\n pages: 185–201, 1963. [2] High Order Strong Stability Preserving Time Discretizations , Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of\n Scientific Computing, vol. 38, N. 3, 2009, pp. 251-289. Used By module~~foodie_integrator_tvd_runge_kutta~~UsedByGraph module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie foodie module~foodie_integrator_tvd_runge_kutta->module~foodie program~integrate_oscillation integrate_oscillation module~foodie->program~integrate_oscillation module~type_burgers type_burgers module~foodie->module~type_burgers module~type_oscillation type_oscillation module~foodie->module~type_oscillation module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~type_oscillation->program~integrate_oscillation module~type_euler_1d->program~integrate_euler_1d module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_lorenz->program~integrate_lorenz module~type_euler_1d_openmp->program~integrate_euler_1d_openmp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: tvd_runge_kutta_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_tvd_runge_kutta.html","title":"foodie_integrator_tvd_runge_kutta – FOODIE"},{"text":"FOODIE kinds: definition of reals and integer kind parameters of FOODIE library. Used By module~~foodie_kinds~~UsedByGraph module~foodie_kinds foodie_kinds module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie program~integrate_oscillation integrate_oscillation module~foodie->program~integrate_oscillation module~type_burgers type_burgers module~foodie->module~type_burgers module~type_oscillation type_oscillation module~foodie->module~type_oscillation module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~type_lorenz type_lorenz module~foodie->module~type_lorenz program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~type_burgers->program~integrate_burgers module~type_oscillation->program~integrate_oscillation module~type_euler_1d->program~integrate_euler_1d module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 module~type_lorenz->program~integrate_lorenz module~type_euler_1d_openmp->program~integrate_euler_1d_openmp var panmodulefoodie_kindsUsedByGraph = svgPanZoom('#modulefoodie_kindsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: R8P = selected_real_kind(15,307) 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6,37) 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision.","tags":"","loc":"module/foodie_kinds.html","title":"foodie_kinds – FOODIE"},{"text":"Uses: IR_Precision foodie module~~type_oscillation~~UsesGraph module~type_oscillation type_oscillation IR_Precision IR_Precision IR_Precision->module~type_oscillation module~foodie foodie module~foodie->module~type_oscillation module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_euler_explicit->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta var panmoduletype_oscillationUsesGraph = svgPanZoom('#moduletype_oscillationUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Oscillation field that is a concrete extension of the abstract integrand type. Used By module~~type_oscillation~~UsedByGraph module~type_oscillation type_oscillation program~integrate_oscillation integrate_oscillation module~type_oscillation->program~integrate_oscillation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: oscillation Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. real(kind=R_P), private :: f = 0._R_P Oscillation frequency (Hz). real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, [1:dims]. Type-Bound Procedures procedure, public, pass(self) :: init Init field. procedure, public, pass(self) :: output Extract Oscillation field. procedure, public, pass(self) :: t => dOscillation_dt Time derivative, residuals. procedure, public, pass(lhs) :: local_error => oscillation_local_error ||Oscillation-oscillation||. procedure, public, pass(lhs) :: integrand_multiply_integrand => oscillation_multiply_oscillation Oscillation * oscillation. procedure, public, pass(lhs) :: integrand_multiply_real => oscillation_multiply_real Oscillation * real. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_oscillation Real * Oscillation. procedure, public, pass(lhs) :: add => add_oscillation Oscillation + Oscillation. procedure, public, pass(lhs) :: sub => sub_oscillation Oscillation - Oscillation. procedure, public, pass(lhs) :: assign_integrand => oscillation_assign_oscillation Oscillation = Oscillation. Description Oscillation equations field. Functions private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. Return Value real(kind=R_P),\n  dimension(:),allocatable Oscillation state vector. Description Output the Oscillation field state. private function dOscillation_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Oscillation field time derivative. Description Time derivative of Oscillation field. private function oscillation_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 oscillation approximations. private function oscillation_multiply_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a oscillation field by another one. private function oscillation_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Oscillation field by a real scalar. private function real_multiply_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( oscillation ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Oscillation field. private function add_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Oscillation fields. private function sub_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Oscillation fields. Subroutines private subroutine init (self, initial_state, f) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of the Oscillation field vector. real(kind=R_P), intent(in) :: f Frequency. Description Construct an initialized Oscillation field. private subroutine oscillation_assign_oscillation (lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Oscillation field to another.","tags":"","loc":"module/type_oscillation.html","title":"type_oscillation – FOODIE"},{"text":"Uses: IR_Precision wenoof module~~type_euler_1d_caf_no_foodie~~UsesGraph module~type_euler_1d_caf_no_foodie type_euler_1D_caf_no_foodie IR_Precision IR_Precision IR_Precision->module~type_euler_1d_caf_no_foodie wenoof wenoof wenoof->module~type_euler_1d_caf_no_foodie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Euler 1D (CAF enabled) field without extending FOODIE integrand. Used By module~~type_euler_1d_caf_no_foodie~~UsedByGraph module~type_euler_1d_caf_no_foodie type_euler_1D_caf_no_foodie program~integrate_euler_1d_caf integrate_euler_1D_caf module~type_euler_1d_caf_no_foodie->program~integrate_euler_1d_caf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: remote_U (:,:)[:] CAF buffer for sharing remote conservative variables. real(kind=R_P), private, allocatable :: remote_U (:,:) CAF buffer for sharing remote conservative variables. real(kind=R_P), private, allocatable :: U_L (:,:) Integrand (state) variables, left ghost cells [1:Nc,1:Ng]. real(kind=R_P), private, allocatable :: U_R (:,:) Integrand (state) variables, right ghost cells [1:Nc,Ni-Ng+1:Ni]. Derived Types type, public :: euler_1D_caf_nf Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type(weno_interpolator_upwind), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. integer(kind=I_P), private :: me = 0 ID of this_image(). integer(kind=I_P), private :: we = 0 Number of CAF images used. Finalizations Procedures final :: finalize","tags":"","loc":"module/type_euler_1d_caf_no_foodie.html","title":"type_euler_1D_caf_no_foodie – FOODIE"},{"text":"Uses: IR_Precision foodie wenoof module~~type_euler_1d_caf~~UsesGraph module~type_euler_1d_caf type_euler_1D_caf IR_Precision IR_Precision IR_Precision->module~type_euler_1d_caf wenoof wenoof wenoof->module~type_euler_1d_caf module~foodie foodie module~foodie->module~type_euler_1d_caf module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_euler_explicit->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta var panmoduletype_euler_1d_cafUsesGraph = svgPanZoom('#moduletype_euler_1d_cafUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Euler 1D (CAF enabled) field that is a concrete extension of the abstract integrand type. Used By module~~type_euler_1d_caf~~UsedByGraph module~type_euler_1d_caf type_euler_1D_caf program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: remote_U (:,:)[:] CAF buffer for sharing remote conservative variables. real(kind=R_P), private, allocatable :: remote_U (:,:) CAF buffer for sharing remote conservative variables. real(kind=R_P), private, allocatable :: U_L (:,:) Integrand (state) variables, left ghost cells [1:Nc,1:Ng]. real(kind=R_P), private, allocatable :: U_R (:,:) Integrand (state) variables, right ghost cells [1:Nc,Ni-Ng+1:Ni]. Derived Types type, public, extends(integrand) :: euler_1D_caf Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type(weno_interpolator_upwind), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. integer(kind=I_P), private :: me = 0 ID of this_image(). integer(kind=I_P), private :: we = 0 Number of CAF images used. Finalizations Procedures final :: finalize","tags":"","loc":"module/type_euler_1d_caf.html","title":"type_euler_1D_caf – FOODIE"},{"text":"Uses: IR_Precision wenoof module~~type_euler_1d_openmp_no_foodie~~UsesGraph module~type_euler_1d_openmp_no_foodie type_euler_1D_openmp_no_foodie IR_Precision IR_Precision IR_Precision->module~type_euler_1d_openmp_no_foodie wenoof wenoof wenoof->module~type_euler_1d_openmp_no_foodie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Euler 1D (OpenMP enabled) field without extending FOODIE integrand. Used By module~~type_euler_1d_openmp_no_foodie~~UsedByGraph module~type_euler_1d_openmp_no_foodie type_euler_1D_openmp_no_foodie program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie module~type_euler_1d_openmp_no_foodie->program~integrate_euler_1d_openmp_no_foodie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: euler_1D_omp_nf Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type(weno_interpolator_upwind), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalizations Procedures final :: finalize","tags":"","loc":"module/type_euler_1d_openmp_no_foodie.html","title":"type_euler_1D_openmp_no_foodie – FOODIE"},{"text":"Uses: IR_Precision foodie wenoof module~~type_euler_1d_openmp~~UsesGraph module~type_euler_1d_openmp type_euler_1D_openmp IR_Precision IR_Precision IR_Precision->module~type_euler_1d_openmp wenoof wenoof wenoof->module~type_euler_1d_openmp module~foodie foodie module~foodie->module~type_euler_1d_openmp module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_euler_explicit->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta var panmoduletype_euler_1d_openmpUsesGraph = svgPanZoom('#moduletype_euler_1d_openmpUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Euler 1D (OpenMP enabled) field that is a concrete extension of the abstract integrand type. Used By module~~type_euler_1d_openmp~~UsedByGraph module~type_euler_1d_openmp type_euler_1D_openmp program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~type_euler_1d_openmp->program~integrate_euler_1d_openmp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: euler_1D_openmp Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type(weno_interpolator_upwind), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalizations Procedures final :: finalize","tags":"","loc":"module/type_euler_1d_openmp.html","title":"type_euler_1D_openmp – FOODIE"},{"text":"Uses: IR_Precision foodie module~~type_burgers~~UsesGraph module~type_burgers type_burgers IR_Precision IR_Precision IR_Precision->module~type_burgers module~foodie foodie module~foodie->module~type_burgers module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_euler_explicit->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta var panmoduletype_burgersUsesGraph = svgPanZoom('#moduletype_burgersUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Burgers field that is a concrete extension of the abstract integrand type. Used By module~~type_burgers~~UsedByGraph module~type_burgers type_burgers program~integrate_burgers integrate_burgers module~type_burgers->program~integrate_burgers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: burgers Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. integer(kind=I_P), private :: Ni = 0 Number of grid nodes. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private :: h = 0._R_P Space step discretization. real(kind=R_P), private :: nu = 0._R_P Viscosity. real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, whole physical domain, [1:Ni]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:Ni,1:steps]. Type-Bound Procedures procedure, public, pass(self) :: init Init field. procedure, public, pass(self) :: output Extract Burgers field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. procedure, public, pass(self) :: t => dBurgers_dt Time derivative, residuals func. procedure, public, pass(self) :: update_previous_steps Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. procedure, public, pass(lhs) :: local_error => burgers_local_error Local error. procedure, public, pass(lhs) :: integrand_multiply_integrand => burgers_multiply_burgers Burgers * burgers operator. procedure, public, pass(lhs) :: integrand_multiply_real => burgers_multiply_real Burgers * real operator. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_burgers Real * Burgers operator. procedure, public, pass(lhs) :: add => add_burgers Burgers + Burgers operator. procedure, public, pass(lhs) :: sub => sub_burgers Burgers - Burgers operator. procedure, public, pass(lhs) :: assign_integrand => burgers_assign_burgers Burgers = Burgers. procedure, public, pass(lhs) :: assign_real => burgers_assign_real Burgers = real. procedure, private, pass(self) :: x => dBurgers_dx 1st derivative. procedure, private, pass(self) :: xx => d2Burgers_dx2 2nd derivative. Description Burgers equations field. Functions private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value real(kind=R_P),\n  dimension(:),allocatable Burgers state variable. Description Output the Burgers field state. private purefunction compute_dt (self, CFL) result(dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in) :: CFL Courant-Friedricks-Lewi stability coefficient. Return Value real(kind=R_P) Current time step. Description Compute the current time step, by means of CFL condition. private function dBurgers_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Burgers field time derivative. Description Time derivative of Burgers field, residuals function. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Burgers field. Description Extract previous time solution of Burgers field. private function burgers_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 burgers approximations. private function burgers_multiply_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by another one. private function burgers_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by a real scalar. private function real_multiply_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( burgers ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Burgers field. private function add_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Burgers fields. private function sub_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Burgers fields. private function dBurgers_dx (self) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative. Description Compute the first order spatial derivative of Burgers field. private function d2Burgers_dx2 (self) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative. Description Compute the second order spatial derivative of Burgers field. Subroutines private subroutine init (self, initial_state, Ni, h, nu, steps) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. real(kind=R_P), intent(in), dimension(1:Ni) :: initial_state Initial state of Burgers field domain. integer(kind=I_P), intent(in) :: Ni Number of grid nodes. real(kind=R_P), intent(in) :: h Space step discretization. real(kind=R_P), intent(in) :: nu Viscosity. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Burgers field. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. private subroutine burgers_assign_burgers (lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Burgers field to another. private subroutine burgers_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Burgers field.","tags":"","loc":"module/type_burgers.html","title":"type_burgers – FOODIE"},{"text":"Uses: IR_Precision foodie wenoof module~~type_euler_1d~~UsesGraph module~type_euler_1d type_euler_1D IR_Precision IR_Precision IR_Precision->module~type_euler_1d wenoof wenoof wenoof->module~type_euler_1d module~foodie foodie module~foodie->module~type_euler_1d module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_euler_explicit->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta var panmoduletype_euler_1dUsesGraph = svgPanZoom('#moduletype_euler_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Euler 1D field that is a concrete extension of the abstract integrand type. Used By module~~type_euler_1d~~UsedByGraph module~type_euler_1d type_euler_1D program~integrate_euler_1d integrate_euler_1D module~type_euler_1d->program~integrate_euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: euler_1D Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps stored. integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type(weno_interpolator_upwind), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real(kind=R_P), private, allocatable :: previous (:,:,:) Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalizations Procedures final :: finalize","tags":"","loc":"module/type_euler_1d.html","title":"type_euler_1D – FOODIE"},{"text":"Uses: IR_Precision foodie module~~type_lorenz~~UsesGraph module~type_lorenz type_lorenz IR_Precision IR_Precision IR_Precision->module~type_lorenz module~foodie foodie module~foodie->module~type_lorenz module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_euler_explicit->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta var panmoduletype_lorenzUsesGraph = svgPanZoom('#moduletype_lorenzUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Lorenz field that is a concrete extension of the abstract integrand type. Used By module~~type_lorenz~~UsedByGraph module~type_lorenz type_lorenz program~integrate_lorenz integrate_lorenz module~type_lorenz->program~integrate_lorenz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: lorenz Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, [1:dims]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:dims,1:steps]. real(kind=R_P), private :: sigma = 0._R_P Lorenz \\sigma. real(kind=R_P), private :: rho = 0._R_P Lorenz \\rho. real(kind=R_P), private :: beta = 0._R_P Lorenz \\beta. Type-Bound Procedures procedure, public, pass(self) :: init Init field. procedure, public, pass(self) :: output Extract Lorenz field. procedure, public, pass(self) :: t => dLorenz_dt Time derivative, residuals function. procedure, public, pass(lhs) :: local_error => lorenz_local_error Local error. procedure, public, pass(self) :: update_previous_steps Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. procedure, public, pass(lhs) :: integrand_multiply_integrand => lorenz_multiply_lorenz Lorenz * Lorenz operator. procedure, public, pass(lhs) :: integrand_multiply_real => lorenz_multiply_real Lorenz * real operator. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_lorenz Real * Lorenz operator. procedure, public, pass(lhs) :: add => add_lorenz Lorenz + Lorenz operator. procedure, public, pass(lhs) :: sub => sub_lorenz Lorenz - Lorenz. procedure, public, pass(lhs) :: assign_integrand => lorenz_assign_lorenz Lorenz = Lorenz. procedure, public, pass(lhs) :: assign_real => lorenz_assign_real Lorenz = real. Description Lorenz equations field. Functions private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value real(kind=R_P),\n  dimension(:),allocatable Lorenz state vector. Description Output the Lorenz field state. private function dLorenz_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Lorenz field time derivative. Description Time derivative of Lorenz field. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Lorenz field. Description Extract previous time solution of Lorenz field. private function lorenz_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 lorenz approximations. private function lorenz_multiply_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a lorenz field by another one. private function lorenz_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Lorenz field by a real scalar. private function real_multiply_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( lorenz ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Lorenz field. private function add_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Lorenz fields. private function sub_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Lorenz fields. Subroutines private subroutine init (self, initial_state, sigma, rho, beta, steps) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Lorenz field. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. private subroutine lorenz_assign_lorenz (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Lorenz field to another. private subroutine lorenz_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Lorenz field.","tags":"","loc":"module/type_lorenz.html","title":"type_lorenz – FOODIE"},{"text":"Uses: IR_Precision type_oscillation Data_Type_Command_Line_Interface foodie pyplot_module program~~integrate_oscillation~~UsesGraph program~integrate_oscillation integrate_oscillation IR_Precision IR_Precision IR_Precision->program~integrate_oscillation module~type_oscillation type_oscillation IR_Precision->module~type_oscillation Data_Type_Command_Line_Interface Data_Type_Command_Line_Interface Data_Type_Command_Line_Interface->program~integrate_oscillation pyplot_module pyplot_module pyplot_module->program~integrate_oscillation module~foodie foodie module~foodie->program~integrate_oscillation module~foodie->module~type_oscillation module~type_oscillation->program~integrate_oscillation module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_euler_explicit->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta var panprogramintegrate_oscillationUsesGraph = svgPanZoom('#programintegrate_oscillationUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODIE with the integration of Oscillation equations. Calls program~~integrate_oscillation~~CallsGraph program~integrate_oscillation integrate_oscillation proc~test_euler test_euler program~integrate_oscillation->proc~test_euler proc~test_ls_rk test_ls_rk program~integrate_oscillation->proc~test_ls_rk proc~test_leapfrog test_leapfrog program~integrate_oscillation->proc~test_leapfrog proc~test_emd_rk test_emd_rk program~integrate_oscillation->proc~test_emd_rk proc~test_ab test_ab program~integrate_oscillation->proc~test_ab proc~test_abm test_abm program~integrate_oscillation->proc~test_abm proc~test_tvd_rk test_tvd_rk program~integrate_oscillation->proc~test_tvd_rk proc~perform_errors_analysis perform_errors_analysis program~integrate_oscillation->proc~perform_errors_analysis proc~test_am test_am program~integrate_oscillation->proc~test_am proc~euler_solver euler_solver proc~test_euler->proc~euler_solver proc~init~8 init proc~test_euler->proc~init~8 proc~save_results save_results proc~test_euler->proc~save_results str str proc~test_euler->str proc~test_ls_rk->proc~init~8 proc~test_ls_rk->proc~save_results proc~test_ls_rk->str proc~ls_rk_solver ls_rk_solver proc~test_ls_rk->proc~ls_rk_solver proc~test_leapfrog->proc~init~8 proc~test_leapfrog->proc~save_results proc~test_leapfrog->str proc~leapfrog_solver leapfrog_solver proc~test_leapfrog->proc~leapfrog_solver proc~test_emd_rk->proc~init~8 proc~test_emd_rk->proc~save_results proc~test_emd_rk->str proc~emd_rk_solver emd_rk_solver proc~test_emd_rk->proc~emd_rk_solver proc~test_ab->proc~init~8 proc~test_ab->proc~save_results proc~test_ab->str proc~ab_solver ab_solver proc~test_ab->proc~ab_solver proc~test_abm->proc~init~8 proc~test_abm->proc~save_results proc~test_abm->str proc~abm_solver abm_solver proc~test_abm->proc~abm_solver proc~test_tvd_rk->proc~init~8 proc~test_tvd_rk->proc~save_results proc~test_tvd_rk->str proc~tvd_rk_solver tvd_rk_solver proc~test_tvd_rk->proc~tvd_rk_solver proc~perform_errors_analysis->proc~init~8 proc~perform_errors_analysis->proc~save_results proc~perform_errors_analysis->str proc~perform_errors_analysis->proc~ls_rk_solver proc~perform_errors_analysis->proc~leapfrog_solver proc~perform_errors_analysis->proc~emd_rk_solver proc~perform_errors_analysis->proc~ab_solver proc~perform_errors_analysis->proc~abm_solver proc~perform_errors_analysis->proc~tvd_rk_solver proc~estimate_orders estimate_orders proc~perform_errors_analysis->proc~estimate_orders proc~print_analysis print_analysis proc~perform_errors_analysis->proc~print_analysis proc~compute_errors compute_errors proc~perform_errors_analysis->proc~compute_errors proc~am_solver am_solver proc~perform_errors_analysis->proc~am_solver proc~test_am->proc~init~8 proc~test_am->proc~save_results proc~test_am->str proc~test_am->proc~am_solver proc~init~8->str strz strz proc~init~8->strz proc~exact_solution exact_solution proc~save_results->proc~exact_solution proc~print_analysis->str proc~compute_errors->proc~exact_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. integer, parameter :: space_dimension = 2 Space dimensions. real(kind=R_P), parameter :: initial_state (1:space_dimension) = [0._R_P,1._R_P] Initial state. real(kind=R_P) :: f Oscillation frequency. real(kind=R_P) :: t_final Final time. real(kind=R_P) :: Dt Time step. real(kind=R_P) :: tolerance Tolerance on local truncation error. integer(kind=I_P) :: error Error handler. integer(kind=I_P) :: stages_steps Number of stages/steps used. integer(kind=I_P) :: implicit_iterations Number of iterations for implicit solvers. character(len=99) :: solver Solver used. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. character(len=99) :: output_cli Output files basename. logical :: errors_analysis Flag for activating errors analysis. Functions function exact_solution (t) result(ex_sol) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: t Time. Return Value real(kind=R_P)\n  (1:space_dimension) Exact solution. Description Compute the exact solution. function compute_errors (solution) result(error_L2) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: solution (0:,0:) Solution at each time step. Return Value real(kind=R_P)\n  (1:space_dimension) L2 norm of the numerical error. Description Compute the L2 norm of numerical error with respect the exact solution. function estimate_orders (solver_error, Dt_used) result(order) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: solver_error (1:space_dimension,1:2) Computed errors. real(kind=R_P), intent(in) :: Dt_used (1:2) Time steps used. Return Value real(kind=R_P)\n  (1:space_dimension) Estimation of the order of accuracy. Description Estimate the order of accuracy using 2 subsequent refined numerical solutions. Subroutines subroutine init (output, solution) Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: output Output files basename. real(kind=R_P), intent(out), allocatable :: solution (:,:) Solution at each time step. Description Initialize solver local variable from global variables. subroutine save_results (title, basename, solution) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: basename Output files basename. real(kind=R_P), intent(in) :: solution (0:,0:) Solution at each time step. Description Save plots of results. subroutine test_ab (steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of steps used: if negative all AB solvers are used. Description Test explicit Adams-Bashforth class of ODE solvers. subroutine test_abm (steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of steps used: if negative all AB solvers are used. Description Test predictor-corrector Adams-Bashforth-Moulton class of ODE solvers. subroutine test_am (steps) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of steps used: if negative all AB solvers are used. Description Test implicit Adams-Moulton class of ODE solvers. subroutine test_emd_rk (stages) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used: if negative all RK solvers are used. Description Test explicit embedded Runge-Kutta class of ODE solvers. subroutine test_euler () Arguments None Description Test explicit forward Euler ODE solver. subroutine test_leapfrog (raw) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: raw Activate RAW filter. Description Test explicit leapfrog class of ODE solvers. subroutine test_ls_rk (stages) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used: if negative all RK solvers are used. Description Test explicit low storage Runge-Kutta class of ODE solvers. subroutine test_tvd_rk (stages) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used: if negative all RK solvers are used. Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. subroutine ab_solver (steps, solution) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of steps used: if negative all AB solvers are used. real(kind=R_P), intent(out) :: solution (0:,0:) Solution at each time step. Description Solve problem with explicit Adams-Bashforth class of ODE solvers. subroutine abm_solver (steps, solution) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of steps used: if negative all ABM solvers are used. real(kind=R_P), intent(out) :: solution (0:,0:) Solution at each time step. Description Solve problem with predictor-corrector Adams-Bashforth-Moulton class of ODE solvers. subroutine am_solver (steps, iterations, solution) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of steps used: if negative all AM solvers are used. integer(kind=I_P), intent(in), optional :: iterations Number of fixed point iterations. real(kind=R_P), intent(out) :: solution (0:,0:) Solution at each time step. Description Solve problem with implicit Adams-Moulton class of ODE solvers. subroutine emd_rk_solver (stages, tol, solution, last_step) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used: if negative all RK solvers are used. real(kind=R_P), intent(in) :: tol Tolerance on local truncation error. real(kind=R_P), intent(out) :: solution (0:,0:) Solution at each time step. integer(kind=I_P), intent(out) :: last_step Last time step number. Description Solve problem with explicit embedded Runge-Kutta class of ODE solvers. subroutine euler_solver (solution) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(out) :: solution (0:,0:) Solution at each time step. Description Solve problem with explicit forward Euler ODE solver. subroutine leapfrog_solver (solution, raw) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(out) :: solution (0:,0:) Solution at each time step. logical, intent(in), optional :: raw Activate RAW filter. Description Solve problem with explicit leapfrog class of ODE solvers. subroutine ls_rk_solver (stages, solution) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used: if negative all RK solvers are used. real(kind=R_P), intent(out) :: solution (0:,0:) Solution at each time step. Description Solve problem with explicit low storage Runge-Kutta class of ODE solvers. subroutine tvd_rk_solver (stages, solution) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used: if negative all RK solvers are used. real(kind=R_P), intent(out) :: solution (0:,0:) Solution at each time step. Description Solve problem with explicit TVD/SSP Runge-Kutta class of ODE solvers. subroutine perform_errors_analysis () Arguments None Description Peform errors analysis. subroutine print_analysis (solver, time_steps, mean_time_steps, errors, orders) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: solver Solver name. real(kind=R_P), intent(in), optional :: time_steps (:) Time steps exercised. real(kind=R_P), intent(in), optional :: mean_time_steps (:,:) Mean time steps exercised. real(kind=R_P), intent(in) :: errors (:,:,:) Errors of the solver. real(kind=R_P), intent(in) :: orders (:,:,:) Observed orders of the solver. Description Print summary of the error analysis. Source Code program integrate_oscillation !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Oscillation equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str , strz use type_oscillation , only : oscillation use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & adams_bashforth_moulton_integrator , & adams_moulton_integrator , & emd_runge_kutta_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. integer , parameter :: space_dimension = 2 !< Space dimensions. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 0._R_P , 1._R_P ] !< Initial state. real ( R_P ) :: f !< Oscillation frequency. real ( R_P ) :: t_final !< Final time. real ( R_P ) :: Dt !< Time step. real ( R_P ) :: tolerance !< Tolerance on local truncation error. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: stages_steps !< Number of stages/steps used. integer ( I_P ) :: implicit_iterations !< Number of iterations for implicit solvers. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. character ( 99 ) :: output_cli !< Output files basename. logical :: errors_analysis !< Flag for activating errors analysis. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'oscillation' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Oscillation equations integration' , & examples = [ \"oscillation --solver euler --results  \" , & \"oscillation --solver ls-runge-kutta -r\" , & \"oscillation --solver adams-bashforth  \" , & \"oscillation --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . false ., def = 'all' , act = 'store' ) call cli % add ( switch = '--ss' , help = 'Stages/steps used' , required = . false ., act = 'store' , def = '-1' ) call cli % add ( switch = '--iterations' , help = 'Number of iterations for implicit solvers' , required = . false ., act = 'store' , def = '5' ) call cli % add ( switch = '--frequency' , switch_ab = '-f' , help = 'Oscillation frequency' , required = . false ., def = '1e-4' , act = 'store' ) call cli % add ( switch = '--time_step' , switch_ab = '-Dt' , help = 'Integration time step' , required = . false ., def = '100.d0' , act = 'store' ) call cli % add ( switch = '--tolerance' , switch_ab = '-tol' , help = 'Tolerance on local error' , required = . false ., def = '0.001d0' , act = 'store' ) call cli % add ( switch = '--t_final' , switch_ab = '-tf' , help = 'Final integration time' , required = . false ., def = '1e6' , act = 'store' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--output' , help = 'Output files basename' , required = . false ., act = 'store' , def = 'unset' ) call cli % add ( switch = '--errors_analysis' , help = 'Peform errors analysis' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--ss' , val = stages_steps , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--iterations' , val = implicit_iterations , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-f' , val = f , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-Dt' , val = Dt , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-tol' , val = tolerance , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-tf' , val = t_final , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--output' , val = output_cli , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--errors_analysis' , val = errors_analysis , error = error ) ; if ( error /= 0 ) stop if ( errors_analysis ) then call perform_errors_analysis else select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab ( steps = stages_steps ) case ( 'adams-bashforth-moulton' ) call test_abm ( steps = stages_steps ) case ( 'adams-moulton' ) call test_am ( steps = stages_steps ) case ( 'emd-runge-kutta' ) call test_emd_rk ( stages = stages_steps ) case ( 'euler' ) call test_euler case ( 'leapfrog' ) call test_leapfrog case ( 'leapfrog-raw' ) call test_leapfrog ( raw = . true .) case ( 'ls-runge-kutta' ) call test_ls_rk ( stages = stages_steps ) case ( 'tvd-runge-kutta' ) call test_tvd_rk ( stages = stages_steps ) case ( 'all' ) call test_ab ( steps = stages_steps ) call test_abm ( steps = stages_steps ) call test_am ( steps = stages_steps ) call test_emd_rk ( stages = stages_steps ) call test_euler call test_leapfrog call test_ls_rk ( stages = stages_steps ) call test_tvd_rk ( stages = stages_steps ) case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + adams-bashforth-moulton' print \"(A)\" , '  + adams-moulton' print \"(A)\" , '  + emd-runge-kutta' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + leapfrog-raw' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect endif stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init ( output , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize solver local variable from global variables. !--------------------------------------------------------------------------------------------------------------------------------- character ( len = :), allocatable , intent ( OUT ) :: output !< Output files basename. real ( R_P ), allocatable , intent ( OUT ) :: solution (:,:) !< Solution at each time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( mod ( t_final , Dt ) /= 0 ) then print \"(A)\" , 'Error: the final integration time must be an exact multiple of the time step used!' print \"(A)\" , 'Final integration time: ' // str (. true ., t_final ) print \"(A)\" , 'Time step: ' // str (. true ., Dt ) stop endif if ( trim ( adjustl ( output_cli )) /= 'unset' ) then if ( trim ( adjustl ( solver )) /= 'emd-runge-kutta' ) then output = trim ( adjustl ( output_cli )) // '-' // trim ( strz ( 10 , int ( t_final / Dt ))) // '-time_steps-' // trim ( adjustl ( solver )) else output = trim ( adjustl ( output_cli )) // '-' // trim ( str (. true ., n = tolerance )) // '-tolerance-' // trim ( adjustl ( solver )) endif else if ( trim ( adjustl ( solver )) /= 'emd-runge-kutta' ) then output = 'oscillation_integration-' // trim ( strz ( 10 , int ( t_final / Dt ))) // '-time_steps-' // trim ( adjustl ( solver )) else output = 'oscillation_integration-' // trim ( str (. true ., n = tolerance )) // '-tolerance-' // trim ( adjustl ( solver )) endif endif if ( allocated ( solution )) deallocate ( solution ) ; allocate ( solution ( 0 : space_dimension , 0 : int ( t_final / Dt ))) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init function exact_solution ( t ) result ( ex_sol ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the exact solution. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ) :: ex_sol ( 1 : space_dimension ) !< Exact solution. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ex_sol ( 1 ) = initial_state ( 1 ) * cos ( f * t ) - initial_state ( 2 ) * sin ( f * t ) ex_sol ( 2 ) = initial_state ( 1 ) * sin ( f * t ) + initial_state ( 2 ) * cos ( f * t ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction exact_solution subroutine save_results ( title , basename , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: basename !< Output files basename. real ( R_P ), intent ( IN ) :: solution ( 0 :, 0 :) !< Solution at each time step. integer ( I_P ) :: rawfile !< Raw file unit for saving results. real ( R_P ) :: ex_sol ( 1 : space_dimension ) !< Exact solution. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = basename // '.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) 'VARIABLES=\"t\" \"x\" \"y\"' write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE time serie\"' do s = 0 , ubound ( solution , dim = 2 ) write ( rawfile , '(3(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , space_dimension ) enddo write ( rawfile , '(A)' ) 'ZONE T=\"Exact solution\"' do s = 0 , ubound ( solution , dim = 2 ) ex_sol = exact_solution ( t = solution ( 0 , s )) write ( rawfile , '(3(' // FR_P // ',1X))' ) solution ( 0 , s ), ( ex_sol ( i ), i = 1 , space_dimension ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'v' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( basename // '.png' ) call plt % initialize ( grid = . true ., xlabel = 'v1' , ylabel = 'v2' , title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'path' , linestyle = 'r-' , linewidth = 1 ) call plt % savefig ( 'path-' // basename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all AB solvers are used. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'adams-bashforth' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of Adams-Bashforth class of solvers' steps_range = [ 1 , ab_steps ] ; if ( steps > 0 ) steps_range = [ steps , steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' AB-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // ' steps=' // trim ( str (. true ., s )) call ab_solver ( steps = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_abm ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test predictor-corrector Adams-Bashforth-Moulton class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all AB solvers are used. integer , parameter :: abm_steps = 4 !< Adams-Bashforth-Moulton steps number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< ABM steps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'adams-bashforth-moulton' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of Adams-Bashforth-Moulton class of solvers' steps_range = [ 1 , abm_steps ] ; if ( steps > 0 ) steps_range = [ steps , steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' ABM-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, predictor/corrector Adams-Bashforth-Moulton, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) call abm_solver ( steps = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_abm subroutine test_am ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test implicit Adams-Moulton class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all AB solvers are used. integer , parameter :: am_steps = 3 !< Adams-Moulton steps number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< AM steps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'adams-moulton' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of Adams-Moulton class of solvers' steps_range = [ 0 , am_steps ] ; if ( steps > 0 ) steps_range = [ steps , steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' AM-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, implicit Adams-Moulton, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) if ( implicit_iterations > 1 ) then call am_solver ( steps = s , solution = solution , iterations = implicit_iterations ) else call am_solver ( steps = s , solution = solution ) endif call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_am subroutine test_emd_rk ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit embedded Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. integer , parameter :: rk_stages = 17 !< Runge-Kutta stages number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. integer ( I_P ) :: last_step !< Last time step computed. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'emd-runge-kutta' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of embedded Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages > 0 ) stages_range = [ stages , stages ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 1 ) cycle ! 1 stages not allowed if ( s == 2 ) cycle ! 2 stages not suited for test if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 5 ) cycle ! 5 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented if ( s == 12 ) cycle ! 12 stages not yet implemented if ( s == 13 ) cycle ! 13 stages not yet implemented if ( s == 14 ) cycle ! 14 stages not yet implemented if ( s == 15 ) cycle ! 15 stages not yet implemented if ( s == 16 ) cycle ! 16 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, explicit embedded Runge-Kutta, t=' // str ( n = t_final ) // ' steps=' // trim ( str (. true ., s )) call emd_rk_solver ( stages = s , tol = tolerance , solution = solution , last_step = last_step ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution (:, 0 : last_step )) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_emd_rk subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'euler' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of explicit Euler solver' title = 'Oscillation equation integration, explicit Euler, t=' // str ( n = t_final ) call euler_solver ( solution = solution ) call save_results ( title = title , basename = output , solution = solution ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- logical , optional , intent ( IN ) :: raw !< Activate RAW filter. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'leapfrog' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of leapfrog (RAW filtered) class of solvers' title = 'Oscillation equation integration, leapfrog (RAW filtered), t=' // str ( n = t_final ) call leapfrog_solver ( solution = solution , raw = raw ) call save_results ( title = title , basename = output , solution = solution ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. integer , parameter :: rk_stages = 14 !< Runge-Kutta stages number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'ls-runge-kutta' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of low storage (2N) Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages > 0 ) stages_range = [ stages , stages ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 9 ) cycle ! 9 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) call ls_rk_solver ( stages = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- solver = 'tvd-runge-kutta' call init ( output = output , solution = solution ) print \"(A)\" , 'Integrating Oscillation equations by means of TVD/SSP Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages > 0 ) stages_range = [ stages , stages ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = 'Oscillation equation integration, explicit TVD/SSP Runge-Kutta, t=' // str ( n = t_final ) // ' steps=' // trim ( str (. true ., s )) call tvd_rk_solver ( stages = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk subroutine ab_solver ( steps , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all AB solvers are used. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. type ( oscillation ) :: previous ( 1 : steps ) !< Previous time steps solutions. type ( oscillation ) :: oscillator !< Oscillation field. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call ab_integrator % init ( steps = steps ) select case ( steps ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = steps ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 if ( steps >= step ) then ! time steps from 1 to s - 1 must be computed with other scheme call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) previous ( step ) = oscillator else call ab_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step - steps : step - 1 )) endif solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine ab_solver subroutine abm_solver ( steps , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with predictor-corrector Adams-Bashforth-Moulton class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all ABM solvers are used. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_moulton_integrator ) :: abm_integrator !< Adams-Bashforth-Moulton integrator. type ( oscillation ) :: previous ( 1 : steps ) !< Previous time steps solutions. type ( oscillation ) :: oscillator !< Oscillation field. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call abm_integrator % init ( steps = steps ) select case ( steps ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = steps ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 if ( steps >= step ) then ! time steps from 1 to s - 1 must be computed with other scheme call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) previous ( step ) = oscillator else call abm_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step - steps : step - 1 )) endif solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine abm_solver subroutine am_solver ( steps , iterations , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with implicit Adams-Moulton class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of steps used: if negative all AM solvers are used. integer ( I_P ), optional , intent ( IN ) :: iterations !< Number of fixed point iterations. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_moulton_integrator ) :: am_integrator !< Adams-Moulton integrator. type ( oscillation ) :: previous ( 1 : steps ) !< Previous time steps solutions. type ( oscillation ) :: oscillator !< Oscillation field. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call am_integrator % init ( steps = steps ) select case ( steps ) case ( 0 , 1 , 2 ) call rk_integrator % init ( stages = steps + 1 ) case ( 3 ) call rk_integrator % init ( stages = 5 ) endselect call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 if ( steps >= step ) then ! time steps from 1 to s - 1 must be computed with other scheme call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) previous ( step ) = oscillator else if ( steps == 0 ) then call am_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step - 1 : step - 1 ), iterations = iterations ) else call am_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step - steps : step - 1 ), iterations = iterations ) endif endif solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine am_solver subroutine emd_rk_solver ( stages , tol , solution , last_step ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit embedded Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. real ( R_P ), intent ( IN ) :: tol !< Tolerance on local truncation error. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. integer ( I_P ), intent ( OUT ) :: last_step !< Last time step number. type ( emd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. type ( oscillation ) :: rk_stage ( 1 : stages ) !< Runge-Kutta stages. type ( oscillation ) :: oscillator !< Oscillation field. integer ( I_P ) :: step !< Time steps counter. real ( R_P ) :: Dt_a !< Adaptive time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Dt_a = 1000 0._R_P ! initial step very large to trigger adaptation call rk_integrator % init ( stages = stages , tolerance = tol ) call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt_a , t = solution ( 0 , step )) solution ( 0 , step ) = solution ( 0 , step - 1 ) + Dt_a solution ( 1 : space_dimension , step ) = oscillator % output () enddo last_step = step return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine emd_rk_solver subroutine euler_solver ( solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. type ( oscillation ) :: oscillator !< Oscillation field. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 call euler_integrator % integrate ( U = oscillator , Dt = Dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_solver subroutine leapfrog_solver ( solution , raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. logical , optional , intent ( IN ) :: raw !< Activate RAW filter. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( oscillation ) :: previous ( 1 : 2 ) !< Previous time steps solutions. type ( oscillation ) :: filter !< Filter displacement. type ( oscillation ) :: oscillator !< Oscillation field. integer :: step !< Time steps counter. logical :: filtered !< Activate RAW filter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- filtered = . false . ; if ( present ( raw )) filtered = raw call lf_integrator % init () call rk_integrator % init ( stages = rk_stages ) call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 if ( 2 >= step ) then ! time steps from 1 to 2 must be computed with other scheme call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) previous ( step ) = oscillator else if ( filtered ) then call lf_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step ), filter = filter ) else call lf_integrator % integrate ( U = oscillator , previous = previous , Dt = Dt , t = solution ( 0 , step )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine leapfrog_solver subroutine ls_rk_solver ( stages , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: registers = 2 !< Runge-Kutta stages registers number. type ( oscillation ) :: rk_stage ( 1 : registers ) !< Runge-Kutta registers. type ( oscillation ) :: oscillator !< Oscillation field. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call rk_integrator % init ( stages = stages ) call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine ls_rk_solver subroutine tvd_rk_solver ( stages , solution ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve problem with explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used: if negative all RK solvers are used. real ( R_P ), intent ( OUT ) :: solution ( 0 :, 0 :) !< Solution at each time step. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. type ( oscillation ) :: rk_stage ( 1 : stages ) !< Runge-Kutta stages. type ( oscillation ) :: oscillator !< Oscillation field. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call rk_integrator % init ( stages = stages ) call oscillator % init ( initial_state = initial_state , f = f ) solution = 0._R_P solution ( 1 : space_dimension , 0 ) = oscillator % output () step = 0 do while ( solution ( 0 , step ) < t_final ) step = step + 1 call rk_integrator % integrate ( U = oscillator , stage = rk_stage , Dt = Dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * Dt solution ( 1 : space_dimension , step ) = oscillator % output () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tvd_rk_solver subroutine perform_errors_analysis () !--------------------------------------------------------------------------------------------------------------------------------- !< Peform errors analysis. !< !< The analysis is based on the integration of the Oscillation equations with different, decreasing time steps in the range !< *[5000, 2500, 1250, 625, 320, 100]*. The error is estimated by the L2 norm of the difference between the exact (U_e) and !< the numerical (U_{\\Delta t}) solutions for each time step: !< !< !<\\varepsilon (\\Delta t) = || U_e - U_{\\Delta t} ||_2 = \\sqrt{ \\sum_{s=1}&#94;{N_s} { \\left(U_e(t_0 + s * \\Delta t) - !<U_{\\Delta t}(t_0 + s * \\Delta t) \\right)&#94;2 }} !< !< !< Using two pairs of subsequent-decreasing time steps solution is possible to estimate the order of accuracy of the solver !< employed computing the \\emph{observed order} of accuracy: !< !< !<p = \\frac{log10 \\left( \\frac{\\varepsilon (\\Delta t_1)}{\\varepsilon (\\Delta t_2)} \\right)} !<{log10 \\left( \\frac{\\Delta t_1}{\\Delta t_2} \\right)} !< !< !<where \\frac{\\Delta t_1}{\\Delta t_2}>1. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), parameter :: NDt = 6 !< Number of time steps exercised. real ( R_P ), parameter :: time_steps ( 1 : NDt ) = [ 500 0._R_P , & 250 0._R_P , & 125 0._R_P , & 62 5._R_P , & 32 0._R_P , & 10 0._R_P ] !< Time steps exercised. real ( R_P ), parameter :: tolerances ( 1 : NDt ) = [ 0.001_R_P , & 0.0001_R_P , & 0.00001_R_P , & 0.000001_R_P , & 0.0000001_R_P , & 0.00000001_R_P ] !< Tolerances for embedded RK solvers. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. integer , parameter :: emd_rk_stages = 17 !< Embedded Runge-Kutta stages number. integer , parameter :: tvd_rk_stages = 5 !< TVD/SSP Runge-Kutta stages number. integer , parameter :: ls_rk_stages = 14 !< Low storage Runge-Kutta stages number. integer ( I_P ) :: s !< Steps/stages counter. integer ( I_P ) :: d !< Time steps-exercised counter. character ( len = :), allocatable :: output !< Output files basename. character ( len = :), allocatable :: title !< Output files title. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. integer ( I_P ) :: last_step !< Last time step computed. real ( R_P ) :: emd_Dt_mean ( 1 : emd_rk_stages , 1 : NDt ) !< Mean time resolution for adaptive step methods. ! errors and orders real ( R_P ) :: ab_errors ( 1 : space_dimension , 1 : ab_steps , 1 : NDt ) !< Adams-Bashforth errors. real ( R_P ) :: abm_errors ( 1 : space_dimension , 1 : ab_steps , 1 : NDt ) !< Adams-Bashforth-Moulton errors. real ( R_P ) :: am_errors ( 1 : space_dimension , 1 : ab_steps , 1 : NDt ) !< Adams-Moulton errors. real ( R_P ) :: emd_rk_errors ( 1 : space_dimension , 1 : emd_rk_stages , 1 : NDt ) !< TVD/SSP Runge-Kutta errors. real ( R_P ) :: lf_errors ( 1 : space_dimension , 1 : 2 , 1 : NDt ) !< Leapfrog errors. real ( R_P ) :: ls_rk_errors ( 1 : space_dimension , 1 : ls_rk_stages , 1 : NDt ) !< Low storage Runge-Kutta errors. real ( R_P ) :: tvd_rk_errors ( 1 : space_dimension , 1 : tvd_rk_stages , 1 : NDt ) !< TVD/SSP Runge-Kutta errors. real ( R_P ) :: ab_orders ( 1 : space_dimension , 1 : ab_steps , 1 : NDt - 1 ) !< Adams-Bashforth orders. real ( R_P ) :: abm_orders ( 1 : space_dimension , 1 : ab_steps , 1 : NDt - 1 ) !< Adams-Bashforth-Moulton orders. real ( R_P ) :: am_orders ( 1 : space_dimension , 1 : ab_steps , 1 : NDt - 1 ) !< Adams-Moulton orders. real ( R_P ) :: emd_rk_orders ( 1 : space_dimension , 1 : emd_rk_stages , 1 : NDt - 1 ) !< Embedded Runge-Kutta orders. real ( R_P ) :: lf_orders ( 1 : space_dimension , 1 : 2 , 1 : NDt - 1 ) !< Leapfrog orders. real ( R_P ) :: ls_rk_orders ( 1 : space_dimension , 1 : ls_rk_stages , 1 : NDt - 1 ) !< Low storage Runge-Kutta orders. real ( R_P ) :: tvd_rk_orders ( 1 : space_dimension , 1 : tvd_rk_stages , 1 : NDt - 1 ) !< TVD/SSP Runge-Kutta orders. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ab_errors = - 1._R_P ; ab_orders = 0._R_P abm_errors = - 1._R_P ; abm_orders = 0._R_P am_errors = - 1._R_P ; am_orders = 0._R_P emd_rk_errors = - 1._R_P ; emd_rk_orders = 0._R_P lf_errors = - 1._R_P ; lf_orders = 0._R_P ls_rk_errors = - 1._R_P ; ls_rk_orders = 0._R_P tvd_rk_errors = - 1._R_P ; tvd_rk_orders = 0._R_P if ( allocated ( solution )) deallocate ( solution ) ; allocate ( solution ( 0 : space_dimension , 0 : int ( t_final / Dt ))) results = . true . ! activate results saving ! Analyze errors of Adams-Bashforth solvers do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'adams-bashforth' call init ( output = output , solution = solution ) do s = 1 , ab_steps title = 'Oscillation equation integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // ' steps=' // trim ( str (. true ., s )) call ab_solver ( steps = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) ab_errors (:, s , d ) = compute_errors ( solution = solution ) enddo enddo do s = 1 , ab_steps do d = 1 , NDt - 1 ab_orders (:, s , d ) = estimate_orders ( solver_error = ab_errors (:, s , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo enddo ! Analyze errors of Adams-Bashforth-Moulton solvers do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'adams-bashforth-moulton' call init ( output = output , solution = solution ) do s = 1 , ab_steps title = 'Oscillation equation integration, predictor-corrector Adams-Bashforth-Moulton, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) call abm_solver ( steps = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) abm_errors (:, s , d ) = compute_errors ( solution = solution ) enddo enddo do s = 1 , ab_steps do d = 1 , NDt - 1 abm_orders (:, s , d ) = estimate_orders ( solver_error = abm_errors (:, s , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo enddo ! Analyze errors of Adams-Moulton solvers do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'adams-moulton' call init ( output = output , solution = solution ) do s = 0 , ab_steps - 1 title = 'Oscillation equation integration, implicit Adams-Moulton, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) if ( implicit_iterations > 1 ) then call am_solver ( steps = s , solution = solution , iterations = implicit_iterations ) else call am_solver ( steps = s , solution = solution ) endif call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) am_errors (:, s + 1 , d ) = compute_errors ( solution = solution ) enddo enddo do s = 0 , ab_steps - 1 do d = 1 , NDt - 1 am_orders (:, s + 1 , d ) = estimate_orders ( solver_error = am_errors (:, s + 1 , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo enddo ! Analyze errors of embedded Runge-Kutta solvers emd_Dt_mean = 0._R_P do d = 1 , NDt ! loop over exercised tolerances Dt = time_steps ( NDt ) tolerance = tolerances ( d ) solver = 'emd-runge-kutta' call init ( output = output , solution = solution ) do s = 1 , emd_rk_stages if ( s == 1 ) cycle ! 1 stages not allowed if ( s == 2 ) cycle ! 2 stages not suited for test if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 5 ) cycle ! 5 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented if ( s == 12 ) cycle ! 12 stages not yet implemented if ( s == 13 ) cycle ! 13 stages not yet implemented if ( s == 14 ) cycle ! 14 stages not yet implemented if ( s == 15 ) cycle ! 15 stages not yet implemented if ( s == 16 ) cycle ! 16 stages not yet implemented title = 'Oscillation equation integration, explicit embedded Runge-Kutta t=' // str ( n = t_final ) // ' stages=' // trim ( str (. true ., s )) if ( s == 17 ) then call emd_rk_solver ( stages = s , tol = tolerances ( d ) / 100 0._R_P , solution = solution , last_step = last_step ) else call emd_rk_solver ( stages = s , tol = tolerances ( d ), solution = solution , last_step = last_step ) endif emd_Dt_mean ( s , d ) = t_final / real ( last_step , kind = R_P ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution (:, 0 : last_step )) emd_rk_errors (:, s , d ) = compute_errors ( solution = solution (:, 0 : last_step )) enddo enddo do s = 1 , emd_rk_stages if ( s == 1 ) cycle ! 1 stages not allowed if ( s == 2 ) cycle ! 2 stages not suited for test if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 5 ) cycle ! 5 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented if ( s == 12 ) cycle ! 12 stages not yet implemented if ( s == 13 ) cycle ! 13 stages not yet implemented if ( s == 14 ) cycle ! 14 stages not yet implemented if ( s == 15 ) cycle ! 15 stages not yet implemented if ( s == 16 ) cycle ! 16 stages not yet implemented do d = 1 , NDt - 1 emd_rk_orders (:, s , d ) = estimate_orders ( solver_error = emd_rk_errors (:, s , d : d + 1 ), Dt_used = emd_Dt_mean ( s , d : d + 1 )) enddo enddo ! Analyze errors of leapfrog solver do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'leapfrog' call init ( output = output , solution = solution ) title = 'Oscillation equation integration, leapfrog (unfiltered), t=' // str ( n = t_final ) call leapfrog_solver ( solution = solution ) call save_results ( title = title , basename = output , solution = solution ) lf_errors (:, 1 , d ) = compute_errors ( solution = solution ) Dt = time_steps ( d ) solver = 'leapfrog' call init ( output = output , solution = solution ) title = 'Oscillation equation integration, leapfrog (RAW filtered), t=' // str ( n = t_final ) call leapfrog_solver ( solution = solution , raw = . true .) call save_results ( title = title , basename = output // '-raw' , solution = solution ) lf_errors (:, 2 , d ) = compute_errors ( solution = solution ) enddo do d = 1 , NDt - 1 lf_orders (:, 1 , d ) = estimate_orders ( solver_error = lf_errors (:, 1 , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) lf_orders (:, 2 , d ) = estimate_orders ( solver_error = lf_errors (:, 2 , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo ! Analyze errors of low storage Runge-Kutta solvers do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'ls-runge-kutta' call init ( output = output , solution = solution ) do s = 1 , ls_rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 9 ) cycle ! 9 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented title = 'Oscillation equation integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // & ' steps=' // trim ( str (. true ., s )) call ls_rk_solver ( stages = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) ls_rk_errors (:, s , d ) = compute_errors ( solution = solution ) enddo enddo do s = 1 , ls_rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented if ( s == 8 ) cycle ! 8 stages not yet implemented if ( s == 9 ) cycle ! 9 stages not yet implemented if ( s == 10 ) cycle ! 10 stages not yet implemented if ( s == 11 ) cycle ! 11 stages not yet implemented do d = 1 , NDt - 1 ls_rk_orders (:, s , d ) = estimate_orders ( solver_error = ls_rk_errors (:, s , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo enddo ! Analyze errors of TVD/SSP Runge-Kutta solvers do d = 1 , NDt ! loop over exercised time steps Dt = time_steps ( d ) solver = 'tvd-runge-kutta' call init ( output = output , solution = solution ) do s = 1 , tvd_rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented title = 'Oscillation equation integration, explicit TVD/SSP Runge-Kutta, t=' // str ( n = t_final ) // ' steps=' // trim ( str (. true ., s )) call tvd_rk_solver ( stages = s , solution = solution ) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s )), solution = solution ) tvd_rk_errors (:, s , d ) = compute_errors ( solution = solution ) enddo enddo do s = 1 , tvd_rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented do d = 1 , NDt - 1 tvd_rk_orders (:, s , d ) = estimate_orders ( solver_error = tvd_rk_errors (:, s , d : d + 1 ), Dt_used = time_steps ( d : d + 1 )) enddo enddo print \"(A)\" , \"Solver & Time Step & f*Dt & Error X & Error Y & Observed Order of Accuracy X & Observed Order of Accuracy Y\" call print_analysis ( solver = 'adams-bashforth' , time_steps = time_steps , errors = ab_errors , orders = ab_orders ) call print_analysis ( solver = 'adams-bashforth-moulton' , time_steps = time_steps , errors = abm_errors , orders = abm_orders ) call print_analysis ( solver = 'adams-moulton' , time_steps = time_steps , errors = am_errors , orders = am_orders ) call print_analysis ( solver = 'emd-runge-kutta' , mean_time_steps = emd_Dt_mean , errors = emd_rk_errors , orders = emd_rk_orders ) call print_analysis ( solver = 'leapfrog' , time_steps = time_steps , errors = lf_errors , orders = lf_orders ) call print_analysis ( solver = 'ls-runge-kutta' , time_steps = time_steps , errors = ls_rk_errors , orders = ls_rk_orders ) call print_analysis ( solver = 'tvd-runge-kutta' , time_steps = time_steps , errors = tvd_rk_errors , orders = tvd_rk_orders ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine perform_errors_analysis function compute_errors ( solution ) result ( error_L2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the L2 norm of numerical error with respect the exact solution. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: solution ( 0 :, 0 :) !< Solution at each time step. real ( R_P ) :: error_L2 ( 1 : space_dimension ) !< L2 norm of the numerical error. real ( R_P ) :: ex_sol ( 1 : space_dimension ) !< Exact solution. integer ( I_P ) :: s !< Steps/stages counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- error_L2 = 0._R_P do s = 0 , ubound ( solution , dim = 2 ) ex_sol = exact_solution ( t = solution ( 0 , s )) do v = 1 , space_dimension error_L2 ( v ) = error_L2 ( v ) + ( solution ( v , s ) - ex_sol ( v )) ** 2 enddo enddo error_L2 = sqrt ( error_L2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction compute_errors function estimate_orders ( solver_error , Dt_used ) result ( order ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate the order of accuracy using 2 subsequent refined numerical solutions. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: solver_error ( 1 : space_dimension , 1 : 2 ) !< Computed errors. real ( R_P ), intent ( IN ) :: Dt_used ( 1 : 2 ) !< Time steps used. real ( R_P ) :: order ( 1 : space_dimension ) !< Estimation of the order of accuracy. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do v = 1 , space_dimension order ( v ) = log ( solver_error ( v , 1 ) / solver_error ( v , 2 )) / log ( Dt_used ( 1 ) / Dt_used ( 2 )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction estimate_orders subroutine print_analysis ( solver , time_steps , mean_time_steps , errors , orders ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print summary of the error analysis. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: solver !< Solver name. real ( R_P ), optional , intent ( IN ) :: time_steps (:) !< Time steps exercised. real ( R_P ), optional , intent ( IN ) :: mean_time_steps (:,:) !< Mean time steps exercised. real ( R_P ), intent ( IN ) :: errors (:,:,:) !< Errors of the solver. real ( R_P ), intent ( IN ) :: orders (:,:,:) !< Observed orders of the solver. integer ( I_P ) :: s !< Solver index. integer ( I_P ) :: d !< Time steps-exercised counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( time_steps )) then do s = 1 , size ( errors , dim = 2 ) if ( errors ( 1 , s , 1 ) < 0._R_P ) cycle print \"(A)\" , solver // '-' // trim ( str (. true ., s )) do d = 1 , size ( errors , dim = 3 ) if ( d == 1 ) then print \"(A,F8.1,A,F10.3,A,E10.3,A,E10.3,A)\" , & \"  & \" , time_steps ( d ), \" & \" , f * time_steps ( d ), \" & \" , & errors ( 1 , s , d ), \" & \" , errors ( 2 , s , d ), \" & / & /\" else print \"(A,F8.1,A,F10.3,A,E10.3,A,E10.3,A,F9.2,A,F9.2)\" , & \"  & \" , time_steps ( d ), \" & \" , f * time_steps ( d ), \" & \" , & errors ( 1 , s , d ), \" & \" , errors ( 2 , s , d ), \" & \" , & orders ( 1 , s , d - 1 ), \" & \" , orders ( 2 , s , d - 1 ) endif enddo enddo elseif ( present ( mean_time_steps )) then do s = 1 , size ( errors , dim = 2 ) if ( errors ( 1 , s , 1 ) < 0._R_P ) cycle print \"(A)\" , solver // '-' // trim ( str (. true ., s )) do d = 1 , size ( errors , dim = 3 ) if ( d == 1 ) then print \"(A,F8.1,A,F10.3,A,E10.3,A,E10.3,A)\" , & \"  & \" , mean_time_steps ( s , d ), \" & \" , f * mean_time_steps ( s , d ), \" & \" , & errors ( 1 , s , d ), \" & \" , errors ( 2 , s , d ), \" & / & /\" else print \"(A,F8.1,A,F10.3,A,E10.3,A,E10.3,A,F9.2,A,F9.2)\" , & \"  & \" , mean_time_steps ( s , d ), \" & \" , f * mean_time_steps ( s , d ), \" & \" , & errors ( 1 , s , d ), \" & \" , errors ( 2 , s , d ), \" & \" , & orders ( 1 , s , d - 1 ), \" & \" , orders ( 2 , s , d - 1 ) endif enddo enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_analysis endprogram integrate_oscillation","tags":"","loc":"program/integrate_oscillation.html","title":"integrate_oscillation – FOODIE"},{"text":"Uses: IR_Precision type_euler_1D_caf_no_foodie Data_Type_Command_Line_Interface pyplot_module program~~integrate_euler_1d_caf~~UsesGraph program~integrate_euler_1d_caf integrate_euler_1D_caf IR_Precision IR_Precision IR_Precision->program~integrate_euler_1d_caf module~type_euler_1d_caf_no_foodie type_euler_1D_caf_no_foodie IR_Precision->module~type_euler_1d_caf_no_foodie pyplot_module pyplot_module pyplot_module->program~integrate_euler_1d_caf module~type_euler_1d_caf_no_foodie->program~integrate_euler_1d_caf Data_Type_Command_Line_Interface Data_Type_Command_Line_Interface Data_Type_Command_Line_Interface->program~integrate_euler_1d_caf wenoof wenoof wenoof->module~type_euler_1d_caf_no_foodie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test without FOODIE with the integration of Euler 1D PDEs system by CAF paradigm. Calls program~~integrate_euler_1d_caf~~CallsGraph program~integrate_euler_1d_caf integrate_euler_1D_caf proc~init~10 init program~integrate_euler_1d_caf->proc~init~10 strz strz program~integrate_euler_1d_caf->strz str str program~integrate_euler_1d_caf->str proc~save_results~2 save_results program~integrate_euler_1d_caf->proc~save_results~2 proc~synchronize synchronize program~integrate_euler_1d_caf->proc~synchronize proc~save_time_serie save_time_serie program~integrate_euler_1d_caf->proc~save_time_serie proc~init~10->strz proc~init~10->str proc~init~10->proc~save_time_serie proc~save_results~2->str proc~save_time_serie->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( tvd_runge_kutta_integrator ) :: rk_integrator Runge-Kutta integrator. integer, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D_caf_nf) :: rk_stage (1:rk_stages) Runge-Kutta stages. integer, parameter :: ord = 7 Space reconstruciton order, real(kind=R_P) :: t Time. real(kind=R_P), parameter :: CFL = 0.7_R_P CFL value. integer(kind=I_P), parameter :: Ns = 1 Number of differnt initial gas species. integer(kind=I_P), parameter :: Nc = Ns+2 Number of conservative variables. integer(kind=I_P), parameter :: Np = Ns+4 Number of primitive variables. character(len=:), allocatable :: BC_L Left boundary condition type. character(len=:), allocatable :: BC_R Right boundary condition type. real(kind=R_P) :: Dx Space step discretization. real(kind=R_P) :: cp0 (1:Ns) Specific heat at constant pressure. real(kind=R_P) :: cv0 (1:Ns) Specific heat at constant volume. real(kind=R_P), allocatable :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), allocatable :: x (:) Cell center x-abscissa values. real(kind=R_P), allocatable :: final_state (:,:) Final state. integer(kind=I_P) :: error Error handler. integer(kind=I_P) :: profiling (1:2) Tic-toc profiling counters. integer(kind=I_P) :: count_rate Counting rate of system clock. real(kind=R_P) :: system_clocks Profiling result. integer(kind=I_P) :: steps Time steps counter. type(euler_1D_caf_nf) :: domain Domain of Euler equations. integer(kind=I_P) :: Ni_image Space dimension of local image. integer(kind=I_P) :: Ni [*] Number of grid cells. integer(kind=I_P) :: steps_max [*] Maximum number of time steps. logical :: results [*] Flag for activating results saving. logical :: plots [*] Flag for activating plots saving. logical :: time_serie [*] Flag for activating time serie-results saving. logical :: verbose [*] Flag for activating more verbose output. real(kind=R_P), allocatable :: Dt (:)[:] Time step. integer(kind=I_P) :: Ni Number of grid cells. integer(kind=I_P) :: steps_max Maximum number of time steps. logical :: results Flag for activating results saving. logical :: plots Flag for activating plots saving. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose Flag for activating more verbose output. real(kind=R_P), allocatable :: Dt (:) Time step. integer(kind=I_P) :: me ID of this_image() integer(kind=I_P) :: we Number of CAF images used. character(len=:), allocatable :: id My ID. Subroutines subroutine init () Arguments None Description Initialize the simulation. subroutine synchronize () Arguments None Description Synchronize CAF images. subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. subroutine save_time_serie (title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Source Code program integrate_euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !< Test without FOODIE with the integration of Euler 1D PDEs system by CAF paradigm. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str , strz use type_euler_1D_caf_no_foodie , only : euler_1D_caf_nf , tvd_runge_kutta_integrator use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_caf_nf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer , parameter :: ord = 7 !< Space reconstruciton order, real ( R_P ) :: t !< Time. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( len = :), allocatable :: BC_L !< Left boundary condition type. character ( len = :), allocatable :: BC_R !< Right boundary condition type. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. type ( euler_1D_caf_nf ) :: domain !< Domain of Euler equations. ! coarrays-related variables integer ( I_P ) :: Ni_image !< Space dimension of local image. #ifdef CAF integer ( I_P ) :: Ni [ * ] !< Number of grid cells. integer ( I_P ) :: steps_max [ * ] !< Maximum number of time steps. logical :: results [ * ] !< Flag for activating results saving. logical :: plots [ * ] !< Flag for activating plots saving. logical :: time_serie [ * ] !< Flag for activating time serie-results saving. logical :: verbose [ * ] !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:)[:] !< Time step. #else integer ( I_P ) :: Ni !< Number of grid cells. integer ( I_P ) :: steps_max !< Maximum number of time steps. logical :: results !< Flag for activating results saving. logical :: plots !< Flag for activating plots saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:) !< Time step. #endif integer ( I_P ) :: me !< ID of this_image() integer ( I_P ) :: we !< Number of CAF images used. character ( len = :), allocatable :: id !< My ID. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF me = this_image () we = num_images () #else me = 1 we = 1 #endif id = trim ( strz ( 3 , me )) // '> ' ! setting Command Line Interface call cli % init ( progname = 'euler-1D-caf-no-foodie' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test 1D Euler equations integration without FOODIE, CAF enabled' , & examples = [ \"euler-1D-caf-no-foodie --results  \" , & \"euler-1D-caf-no-foodie -r -t -v -p\" , & \"euler-1D-caf-no-foodie            \" , & \"euler-1D-caf-no-foodie --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) ! parsing Command Line Interface if ( me == 1 ) then ! only master image do CLI stuffs call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop endif call init () system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) Dt ( me ) = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call synchronize call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , Dt = Dt ( me ), t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + Dt ( me ) call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-image-' // trim ( strz ( 3 , me ))) print \"(A,I5,A,F23.15)\" , id , we , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_caf","tags":"","loc":"program/integrate_euler_1d_caf.html","title":"integrate_euler_1D_caf – FOODIE"},{"text":"Uses: IR_Precision type_euler_1D_caf Data_Type_Command_Line_Interface foodie pyplot_module program~~integrate_euler_1d_caf~2~~UsesGraph program~integrate_euler_1d_caf~2 integrate_euler_1D_caf IR_Precision IR_Precision IR_Precision->program~integrate_euler_1d_caf~2 module~type_euler_1d_caf type_euler_1D_caf IR_Precision->module~type_euler_1d_caf pyplot_module pyplot_module pyplot_module->program~integrate_euler_1d_caf~2 module~foodie foodie module~foodie->program~integrate_euler_1d_caf~2 module~foodie->module~type_euler_1d_caf module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 Data_Type_Command_Line_Interface Data_Type_Command_Line_Interface Data_Type_Command_Line_Interface->program~integrate_euler_1d_caf~2 module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_euler_explicit->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta wenoof wenoof wenoof->module~type_euler_1d_caf var panprogramintegrate_euler_1d_caf2UsesGraph = svgPanZoom('#programintegrate_euler_1d_caf2UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODIE with the integration of Euler 1D PDEs system. Calls program~~integrate_euler_1d_caf~2~~CallsGraph program~integrate_euler_1d_caf~2 integrate_euler_1D_caf proc~init~12 init program~integrate_euler_1d_caf~2->proc~init~12 strz strz program~integrate_euler_1d_caf~2->strz proc~synchronize~3 synchronize program~integrate_euler_1d_caf~2->proc~synchronize~3 proc~save_time_serie~2 save_time_serie program~integrate_euler_1d_caf~2->proc~save_time_serie~2 str str program~integrate_euler_1d_caf~2->str proc~save_results~3 save_results program~integrate_euler_1d_caf~2->proc~save_results~3 proc~init~12->strz proc~init~12->proc~save_time_serie~2 proc~init~12->str proc~save_time_serie~2->str proc~save_results~3->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( tvd_runge_kutta_integrator ) :: rk_integrator Runge-Kutta integrator. integer, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D_caf) :: rk_stage (1:rk_stages) Runge-Kutta stages. integer, parameter :: ord = 7 Space reconstruciton order, real(kind=R_P) :: t Time. real(kind=R_P), parameter :: CFL = 0.7_R_P CFL value. integer(kind=I_P), parameter :: Ns = 1 Number of differnt initial gas species. integer(kind=I_P), parameter :: Nc = Ns+2 Number of conservative variables. integer(kind=I_P), parameter :: Np = Ns+4 Number of primitive variables. character(len=:), allocatable :: BC_L Left boundary condition type. character(len=:), allocatable :: BC_R Right boundary condition type. real(kind=R_P) :: Dx Space step discretization. real(kind=R_P) :: cp0 (1:Ns) Specific heat at constant pressure. real(kind=R_P) :: cv0 (1:Ns) Specific heat at constant volume. real(kind=R_P), allocatable :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), allocatable :: x (:) Cell center x-abscissa values. real(kind=R_P), allocatable :: final_state (:,:) Final state. integer(kind=I_P) :: error Error handler. integer(kind=I_P) :: profiling (1:2) Tic-toc profiling counters. integer(kind=I_P) :: count_rate Counting rate of system clock. real(kind=R_P) :: system_clocks Profiling result. integer(kind=I_P) :: steps Time steps counter. type(euler_1D_caf) :: domain Domain of Euler equations. integer(kind=I_P) :: Ni_image Space dimension of local image. integer(kind=I_P) :: Ni [*] Number of grid cells. integer(kind=I_P) :: steps_max [*] Maximum number of time steps. logical :: results [*] Flag for activating results saving. logical :: plots [*] Flag for activating plots saving. logical :: time_serie [*] Flag for activating time serie-results saving. logical :: verbose [*] Flag for activating more verbose output. real(kind=R_P), allocatable :: Dt (:)[:] Time step. integer(kind=I_P) :: Ni Number of grid cells. integer(kind=I_P) :: steps_max Maximum number of time steps. logical :: results Flag for activating results saving. logical :: plots Flag for activating plots saving. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose Flag for activating more verbose output. real(kind=R_P), allocatable :: Dt (:) Time step. integer(kind=I_P) :: me ID of this_image() integer(kind=I_P) :: we Number of CAF images used. character(len=:), allocatable :: id My ID. Subroutines subroutine init () Arguments None Description Initialize the simulation. subroutine synchronize () Arguments None Description Synchronize CAF images. subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. subroutine save_time_serie (title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Source Code program integrate_euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str , strz use type_euler_1D_caf , only : euler_1D_caf use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_caf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer , parameter :: ord = 7 !< Space reconstruciton order, real ( R_P ) :: t !< Time. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( len = :), allocatable :: BC_L !< Left boundary condition type. character ( len = :), allocatable :: BC_R !< Right boundary condition type. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. type ( euler_1D_caf ) :: domain !< Domain of Euler equations. ! coarrays-related variables integer ( I_P ) :: Ni_image !< Space dimension of local image. #ifdef CAF integer ( I_P ) :: Ni [ * ] !< Number of grid cells. integer ( I_P ) :: steps_max [ * ] !< Maximum number of time steps. logical :: results [ * ] !< Flag for activating results saving. logical :: plots [ * ] !< Flag for activating plots saving. logical :: time_serie [ * ] !< Flag for activating time serie-results saving. logical :: verbose [ * ] !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:)[:] !< Time step. #else integer ( I_P ) :: Ni !< Number of grid cells. integer ( I_P ) :: steps_max !< Maximum number of time steps. logical :: results !< Flag for activating results saving. logical :: plots !< Flag for activating plots saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:) !< Time step. #endif integer ( I_P ) :: me !< ID of this_image() integer ( I_P ) :: we !< Number of CAF images used. character ( len = :), allocatable :: id !< My ID. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF me = this_image () we = num_images () #else me = 1 we = 1 #endif id = trim ( strz ( 3 , me )) // '> ' ! setting Command Line Interface call cli % init ( progname = 'euler-1D-caf' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration, CAF enabled' , & examples = [ \"euler-1D-caf --results  \" , & \"euler-1D-caf -r -t -v -p\" , & \"euler-1D-caf            \" , & \"euler-1D-caf --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) ! parsing Command Line Interface if ( me == 1 ) then ! only master image do CLI stuffs call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop endif call init () system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) Dt ( me ) = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call synchronize call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , Dt = Dt ( me ), t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + Dt ( me ) call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-image-' // trim ( strz ( 3 , me ))) print \"(A,I5,A,F23.15)\" , id , we , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_caf","tags":"","loc":"program/integrate_euler_1d_caf~2.html","title":"integrate_euler_1D_caf – FOODIE"},{"text":"Uses: IR_Precision type_euler_1D_openmp_no_foodie Data_Type_Command_Line_Interface pyplot_module omp_lib program~~integrate_euler_1d_openmp_no_foodie~~UsesGraph program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie IR_Precision IR_Precision IR_Precision->program~integrate_euler_1d_openmp_no_foodie module~type_euler_1d_openmp_no_foodie type_euler_1D_openmp_no_foodie IR_Precision->module~type_euler_1d_openmp_no_foodie Data_Type_Command_Line_Interface Data_Type_Command_Line_Interface Data_Type_Command_Line_Interface->program~integrate_euler_1d_openmp_no_foodie omp_lib omp_lib omp_lib->program~integrate_euler_1d_openmp_no_foodie pyplot_module pyplot_module pyplot_module->program~integrate_euler_1d_openmp_no_foodie module~type_euler_1d_openmp_no_foodie->program~integrate_euler_1d_openmp_no_foodie wenoof wenoof wenoof->module~type_euler_1d_openmp_no_foodie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test without FOODIE with the integration of Euler 1D PDEs system by OpenMP paradigm. Calls program~~integrate_euler_1d_openmp_no_foodie~~CallsGraph program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie proc~init~14 init program~integrate_euler_1d_openmp_no_foodie->proc~init~14 proc~save_results~4 save_results program~integrate_euler_1d_openmp_no_foodie->proc~save_results~4 proc~save_time_serie~3 save_time_serie program~integrate_euler_1d_openmp_no_foodie->proc~save_time_serie~3 str str program~integrate_euler_1d_openmp_no_foodie->str omp_set_dynamic omp_set_dynamic program~integrate_euler_1d_openmp_no_foodie->omp_set_dynamic omp_set_num_threads omp_set_num_threads program~integrate_euler_1d_openmp_no_foodie->omp_set_num_threads omp_get_num_threads omp_get_num_threads program~integrate_euler_1d_openmp_no_foodie->omp_get_num_threads proc~save_results~4->str proc~save_time_serie~3->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( tvd_runge_kutta_integrator ) :: rk_integrator Runge-Kutta integrator. integer, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D_omp_nf) :: rk_stage (1:rk_stages) Runge-Kutta stages. real(kind=R_P) :: dt Time step. real(kind=R_P) :: t Time. type(euler_1D_omp_nf) :: domain Domain of Euler equations. real(kind=R_P), parameter :: CFL = 0.7_R_P CFL value. integer(kind=I_P), parameter :: Ns = 1 Number of differnt initial gas species. integer(kind=I_P), parameter :: Nc = Ns+2 Number of conservative variables. integer(kind=I_P), parameter :: Np = Ns+4 Number of primitive variables. character(len=3) :: BC_L Left boundary condition type. character(len=3) :: BC_R Right boundary condition type. integer(kind=I_P) :: Ni Number of grid cells. real(kind=R_P) :: Dx Space step discretization. real(kind=R_P) :: cp0 (1:Ns) Specific heat at constant pressure. real(kind=R_P) :: cv0 (1:Ns) Specific heat at constant volume. real(kind=R_P), allocatable :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), allocatable :: x (:) Cell center x-abscissa values. real(kind=R_P), allocatable :: final_state (:,:) Final state. integer(kind=I_P) :: error Error handler. integer(kind=I_P) :: steps_max Maximum number of time steps. integer(kind=I_P) :: omp_threads Number of OpenMP threads. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose Flag for activating more verbose output. integer(kind=I_P) :: profiling (1:2) Tic-toc profiling counters. integer(kind=I_P) :: count_rate Counting rate of system clock. real(kind=R_P) :: system_clocks Profiling result. integer(kind=I_P) :: steps Time steps counter. Subroutines subroutine init () Arguments None Description Initialize the field. subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. subroutine save_time_serie (title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Source Code program integrate_euler_1D_openmp_no_foodie !----------------------------------------------------------------------------------------------------------------------------------- !< Test without FOODIE with the integration of Euler 1D PDEs system by OpenMP paradigm. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D_openmp_no_foodie , only : euler_1D_omp_nf , tvd_runge_kutta_integrator use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use pyplot_module , only : pyplot #ifdef OPENMP use OMP_LIB #endif !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_omp_nf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. type ( euler_1D_omp_nf ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: steps_max !< Maximum number of time steps. integer ( I_P ) :: omp_threads !< Number of OpenMP threads. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D-openmp-no-foodie' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test 1D Euler equations integration without FOODIE, OpenMP enabled' , & examples = [ \"euler-1D-openmp-no-foodie --results  \" , & \"euler-1D-openmp-no-foodie -r -t -v -p\" , & \"euler-1D-openmp-no-foodie            \" , & \"euler-1D-openmp-no-foodie --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) call cli % add ( switch = '--omp_threads' , help = 'Number of OpenMP threads used' , required = . false ., act = 'store' , def = '1' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--omp_threads' , val = omp_threads , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop #ifdef OPENMP call omp_set_dynamic (. false .) call omp_set_num_threads ( omp_threads ) ! check OpenMP parallel environment correctness !$OMP PARALLEL      & !$OMP DEFAULT(none) & !$OMP SHARED(omp_threads) omp_threads = omp_get_num_threads () !$OMP END PARALLEL #endif call init () call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) t = 0._R_P call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_omp_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-time_serie.dat' , & t = t ) system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + dt call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_omp_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages ))) print \"(I5,A,F23.15)\" , omp_threads , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_openmp_no_foodie","tags":"","loc":"program/integrate_euler_1d_openmp_no_foodie.html","title":"integrate_euler_1D_openmp_no_foodie – FOODIE"},{"text":"Uses: IR_Precision type_euler_1D_openmp Data_Type_Command_Line_Interface foodie pyplot_module omp_lib program~~integrate_euler_1d_openmp~~UsesGraph program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie foodie module~foodie->program~integrate_euler_1d_openmp module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp IR_Precision IR_Precision IR_Precision->program~integrate_euler_1d_openmp IR_Precision->module~type_euler_1d_openmp pyplot_module pyplot_module pyplot_module->program~integrate_euler_1d_openmp Data_Type_Command_Line_Interface Data_Type_Command_Line_Interface Data_Type_Command_Line_Interface->program~integrate_euler_1d_openmp omp_lib omp_lib omp_lib->program~integrate_euler_1d_openmp module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_euler_explicit->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta wenoof wenoof wenoof->module~type_euler_1d_openmp var panprogramintegrate_euler_1d_openmpUsesGraph = svgPanZoom('#programintegrate_euler_1d_openmpUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODIE with the integration of Euler 1D PDEs system. Calls program~~integrate_euler_1d_openmp~~CallsGraph program~integrate_euler_1d_openmp integrate_euler_1D_openmp omp_get_thread_num omp_get_thread_num program~integrate_euler_1d_openmp->omp_get_thread_num proc~save_results~5 save_results program~integrate_euler_1d_openmp->proc~save_results~5 proc~save_time_serie~4 save_time_serie program~integrate_euler_1d_openmp->proc~save_time_serie~4 omp_set_dynamic omp_set_dynamic program~integrate_euler_1d_openmp->omp_set_dynamic str str program~integrate_euler_1d_openmp->str omp_set_num_threads omp_set_num_threads program~integrate_euler_1d_openmp->omp_set_num_threads omp_get_num_threads omp_get_num_threads program~integrate_euler_1d_openmp->omp_get_num_threads proc~init~16 init program~integrate_euler_1d_openmp->proc~init~16 proc~save_results~5->str proc~save_time_serie~4->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( tvd_runge_kutta_integrator ) :: rk_integrator Runge-Kutta integrator. integer, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D_openmp) :: rk_stage (1:rk_stages) Runge-Kutta stages. real(kind=R_P) :: dt Time step. real(kind=R_P) :: t Time. type(euler_1D_openmp) :: domain Domain of Euler equations. real(kind=R_P), parameter :: CFL = 0.7_R_P CFL value. integer(kind=I_P), parameter :: Ns = 1 Number of differnt initial gas species. integer(kind=I_P), parameter :: Nc = Ns+2 Number of conservative variables. integer(kind=I_P), parameter :: Np = Ns+4 Number of primitive variables. character(len=3) :: BC_L Left boundary condition type. character(len=3) :: BC_R Right boundary condition type. integer(kind=I_P) :: Ni Number of grid cells. real(kind=R_P) :: Dx Space step discretization. real(kind=R_P) :: cp0 (1:Ns) Specific heat at constant pressure. real(kind=R_P) :: cv0 (1:Ns) Specific heat at constant volume. real(kind=R_P), allocatable :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), allocatable :: x (:) Cell center x-abscissa values. real(kind=R_P), allocatable :: final_state (:,:) Final state. integer(kind=I_P) :: error Error handler. integer(kind=I_P) :: steps_max Maximum number of time steps. integer(kind=I_P) :: omp_threads Number of OpenMP threads. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose Flag for activating more verbose output. integer(kind=I_P) :: profiling (1:2) Tic-toc profiling counters. integer(kind=I_P) :: count_rate Counting rate of system clock. real(kind=R_P) :: system_clocks Profiling result. integer(kind=I_P) :: steps Time steps counter. Subroutines subroutine init () Arguments None Description Initialize the field. subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. subroutine save_time_serie (title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Source Code program integrate_euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D_openmp , only : euler_1D_openmp use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot #ifdef OPENMP use OMP_LIB #endif !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_openmp ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. type ( euler_1D_openmp ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: steps_max !< Maximum number of time steps. integer ( I_P ) :: omp_threads !< Number of OpenMP threads. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D-openmp' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration, OpenMP enabled' , & examples = [ \"euler-1D-openmp --results  \" , & \"euler-1D-openmp -r -t -v -p\" , & \"euler-1D-openmp            \" , & \"euler-1D-openmp --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) call cli % add ( switch = '--omp_threads' , help = 'Number of OpenMP threads used' , required = . false ., act = 'store' , def = '1' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--omp_threads' , val = omp_threads , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop #ifdef OPENMP call omp_set_dynamic (. false .) call omp_set_num_threads ( omp_threads ) ! check OpenMP parallel environment correctness !$OMP PARALLEL      & !$OMP DEFAULT(none) & !$OMP SHARED(omp_threads, verbose) omp_threads = omp_get_num_threads () if ( verbose ) print \"(A)\" , ' Thread ' // trim ( str (. true ., omp_get_thread_num ())) // ' of: ' // trim ( str (. true ., omp_threads )) // ' is alive!' !$OMP END PARALLEL #endif call init () call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) t = 0._R_P call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_openmp_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-time_serie.dat' , & t = t ) system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + dt call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_openmp_integration-tvdrk-' // trim ( str (. true ., rk_stages ))) print \"(I5,A,F23.15)\" , omp_threads , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_openmp","tags":"","loc":"program/integrate_euler_1d_openmp.html","title":"integrate_euler_1D_openmp – FOODIE"},{"text":"Uses: IR_Precision type_burgers Data_Type_Command_Line_Interface foodie pyplot_module program~~integrate_burgers~~UsesGraph program~integrate_burgers integrate_burgers IR_Precision IR_Precision IR_Precision->program~integrate_burgers module~type_burgers type_burgers IR_Precision->module~type_burgers pyplot_module pyplot_module pyplot_module->program~integrate_burgers module~foodie foodie module~foodie->program~integrate_burgers module~foodie->module~type_burgers module~type_burgers->program~integrate_burgers Data_Type_Command_Line_Interface Data_Type_Command_Line_Interface Data_Type_Command_Line_Interface->program~integrate_burgers module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_euler_explicit->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta var panprogramintegrate_burgersUsesGraph = svgPanZoom('#programintegrate_burgersUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODIE with the integration of Burgers equation. Calls program~~integrate_burgers~~CallsGraph program~integrate_burgers integrate_burgers proc~test_ls_rk~2 test_ls_rk program~integrate_burgers->proc~test_ls_rk~2 proc~test_ab~2 test_ab program~integrate_burgers->proc~test_ab~2 proc~test_tvd_rk~2 test_tvd_rk program~integrate_burgers->proc~test_tvd_rk~2 proc~test_euler~2 test_euler program~integrate_burgers->proc~test_euler~2 proc~test_leapfrog~2 test_leapfrog program~integrate_burgers->proc~test_leapfrog~2 proc~init~18 init program~integrate_burgers->proc~init~18 str str proc~test_ls_rk~2->str proc~save_results~6 save_results proc~test_ls_rk~2->proc~save_results~6 proc~test_ab~2->str proc~test_ab~2->proc~save_results~6 proc~test_tvd_rk~2->str proc~test_tvd_rk~2->proc~save_results~6 proc~test_euler~2->str proc~test_euler~2->proc~save_results~6 proc~test_leapfrog~2->str proc~test_leapfrog~2->proc~save_results~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( burgers ) :: domain Burgers field domain. real(kind=R_P), parameter :: CFL = 0.1_R_P CFL value. real(kind=R_P), parameter :: t_final = 0.6_R_P Final time. real(kind=R_P), parameter :: nu = 1._R_P Viscosity. integer(kind=I_P), parameter :: Ni = 100 Number of grid nodes. real(kind=R_P) :: h Space step discretization. real(kind=R_P) :: initial_state (1:Ni) Initial state. real(kind=R_P) :: x (1:Ni) Nodes values. real(kind=R_P), allocatable :: final_state (:) Final state. integer(kind=I_P) :: error Error handler. character(len=99) :: solver Solver used. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. Subroutines subroutine init () Arguments None Description Initialize the field. subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. subroutine test_ab () Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. subroutine test_euler () Arguments None Description Test explicit forward Euler ODE solver. subroutine test_leapfrog () Arguments None Description Test explicit leapfrog class of ODE solvers. subroutine test_ls_rk () Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. subroutine test_tvd_rk () Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Source Code program integrate_burgers !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Burgers equation. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_burgers , only : burgers use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( burgers ) :: domain !< Burgers field domain. real ( R_P ), parameter :: CFL = 0.1_R_P !< CFL value. real ( R_P ), parameter :: t_final = 0.6_R_P !< Final time. real ( R_P ), parameter :: nu = 1._R_P !< Viscosity. integer ( I_P ), parameter :: Ni = 100 !< Number of grid nodes. real ( R_P ) :: h !< Space step discretization. real ( R_P ) :: initial_state ( 1 : Ni ) !< Initial state. real ( R_P ) :: x ( 1 : Ni ) !< Nodes values. real ( R_P ), allocatable :: final_state (:) !< Final state. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'burgers' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Burgers equation integration' , & examples = [ \"burgers --solver euler --results  \" , & \"burgers --solver ls-runge-kutta -r\" , & \"burgers --solver adams-bashforth  \" , & \"burgers --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! create Burgers field initial state call init () ! integrate Burgers equation select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- h = 2._R_P * pi / Ni do i = 1 , Ni x ( i ) = h * ( i - 1 ) initial_state ( i ) = 1 0._R_P * sin ( x ( i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"U\"' do i = 1 , Ni write ( rawfile , '(2(' // FR_P // ',1X))' ) x ( i ), final_state ( i ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) call plt % add_plot ( x = x , y = final_state , label = 'U' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( burgers ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = s ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t ( s ) < t_final ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), Dt = Dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit ' // & 'Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'burgers_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of explicit Euler solver' call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit Euler' , & filename = 'burgers_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( burgers ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( burgers ) :: previous ( 1 : 2 ) !< Previous time steps solutions. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = 2 ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t < t_final ) if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit leapfrog scheme' ,& filename = 'burgers_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit low storage Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit TVD Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_burgers","tags":"","loc":"program/integrate_burgers.html","title":"integrate_burgers – FOODIE"},{"text":"Uses: IR_Precision type_euler_1D Data_Type_Command_Line_Interface foodie pyplot_module program~~integrate_euler_1d~~UsesGraph program~integrate_euler_1d integrate_euler_1D IR_Precision IR_Precision IR_Precision->program~integrate_euler_1d module~type_euler_1d type_euler_1D IR_Precision->module~type_euler_1d pyplot_module pyplot_module pyplot_module->program~integrate_euler_1d module~foodie foodie module~foodie->program~integrate_euler_1d module~foodie->module~type_euler_1d module~type_euler_1d->program~integrate_euler_1d Data_Type_Command_Line_Interface Data_Type_Command_Line_Interface Data_Type_Command_Line_Interface->program~integrate_euler_1d module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_euler_explicit->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta wenoof wenoof wenoof->module~type_euler_1d var panprogramintegrate_euler_1dUsesGraph = svgPanZoom('#programintegrate_euler_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODIE with the integration of Euler 1D PDEs system. Calls program~~integrate_euler_1d~~CallsGraph program~integrate_euler_1d integrate_euler_1D proc~init~20 init program~integrate_euler_1d->proc~init~20 proc~test_euler~3 test_euler program~integrate_euler_1d->proc~test_euler~3 proc~test_leapfrog~3 test_leapfrog program~integrate_euler_1d->proc~test_leapfrog~3 proc~test_ab~3 test_ab program~integrate_euler_1d->proc~test_ab~3 proc~test_ls_rk~3 test_ls_rk program~integrate_euler_1d->proc~test_ls_rk~3 proc~test_tvd_rk~3 test_tvd_rk program~integrate_euler_1d->proc~test_tvd_rk~3 str str proc~init~20->str proc~test_euler~3->str proc~save_results~7 save_results proc~test_euler~3->proc~save_results~7 proc~save_time_serie~5 save_time_serie proc~test_euler~3->proc~save_time_serie~5 proc~test_leapfrog~3->str proc~test_leapfrog~3->proc~save_results~7 proc~test_leapfrog~3->proc~save_time_serie~5 proc~test_ab~3->str proc~test_ab~3->proc~save_results~7 proc~test_ab~3->proc~save_time_serie~5 proc~test_ls_rk~3->str proc~test_ls_rk~3->proc~save_results~7 proc~test_ls_rk~3->proc~save_time_serie~5 proc~test_tvd_rk~3->str proc~test_tvd_rk~3->proc~save_results~7 proc~test_tvd_rk~3->proc~save_time_serie~5 proc~save_results~7->str proc~average_solution average_solution proc~save_results~7->proc~average_solution proc~save_time_serie~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type(euler_1D) :: domain Domain of Euler equations. integer(kind=I_P) :: Ns Number of differnt initial gas species. integer(kind=I_P) :: Nc Number of conservative variables, Nc=Ns+2. integer(kind=I_P) :: Np Number of primitive variables, Np=Ns+4. integer(kind=I_P) :: Ni Number of grid cells. real(kind=R_P) :: Dx Space step discretization. real(kind=R_P) :: CFL CFL value. real(kind=R_P) :: t_final Final time. character(len=3) :: BC_L Left boundary condition type. character(len=3) :: BC_R Right boundary condition type. real(kind=R_P), allocatable :: cp0 (:) Specific heat at constant pressure [1:Ns]. real(kind=R_P), allocatable :: cv0 (:) Specific heat at constant volume [1:Ns]. real(kind=R_P), allocatable :: initial_state (:,:) Initial state of primitive variables [1:Np,1:Ni]. real(kind=R_P), allocatable :: xcenter (:) Cell center x-abscissa values, [1:Ni]. real(kind=R_P), allocatable :: xnode (:) Cell node x-abscissa values, [0:Ni]. real(kind=R_P), allocatable :: av_xnode (:) Average-grid cell node x-abscissa values, [0:Ni]. real(kind=R_P), allocatable :: final_state (:,:) Final state. real(kind=R_P), allocatable :: av_state (:,:) Average-grid final state. character(len=:), allocatable :: variables Variables names list. character(len=:), allocatable :: output Output files basename. integer(kind=I_P) :: error Error handler. integer(kind=I_P) :: stages_steps Number of stages/steps used. character(len=99) :: solver Solver used. character(len=99) :: problem Problem solved. character(len=99) :: output_cli Output files basename. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose Flag for activating more verbose output. integer(kind=I_P) :: av_Ni Average the solution over an average-grid. Subroutines subroutine init () Arguments None Description Initialize the field. subroutine average_solution () Arguments None Description Average the solution over an average grid. subroutine save_results (title, basename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: basename Output basename. Description Save results. subroutine save_time_serie (title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. subroutine test_ab () Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. subroutine test_euler () Arguments None Description Test explicit forward Euler ODE solver. subroutine test_leapfrog () Arguments None Description Test explicit leapfrog class of ODE solvers. subroutine test_ls_rk () Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. subroutine test_tvd_rk () Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Source Code program integrate_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D , only : euler_1D use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( euler_1D ) :: domain !< Domain of Euler equations. integer ( I_P ) :: Ns !< Number of differnt initial gas species. integer ( I_P ) :: Nc !< Number of conservative variables, Nc=Ns+2. integer ( I_P ) :: Np !< Number of primitive variables, Np=Ns+4. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: CFL !< CFL value. real ( R_P ) :: t_final !< Final time. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. real ( R_P ), allocatable :: cp0 (:) !< Specific heat at constant pressure [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat at constant volume [1:Ns]. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables [1:Np,1:Ni]. real ( R_P ), allocatable :: xcenter (:) !< Cell center x-abscissa values, [1:Ni]. real ( R_P ), allocatable :: xnode (:) !< Cell node x-abscissa values, [0:Ni]. real ( R_P ), allocatable :: av_xnode (:) !< Average-grid cell node x-abscissa values, [0:Ni]. real ( R_P ), allocatable :: final_state (:,:) !< Final state. real ( R_P ), allocatable :: av_state (:,:) !< Average-grid final state. character ( len = :), allocatable :: variables !< Variables names list. character ( len = :), allocatable :: output !< Output files basename. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: stages_steps !< Number of stages/steps used. character ( 99 ) :: solver !< Solver used. character ( 99 ) :: problem !< Problem solved. character ( 99 ) :: output_cli !< Output files basename. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: av_Ni !< Average the solution over an average-grid. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration' , & examples = [ \"euler-1D --solver euler --results  \" , & \"euler-1D --solver ls-runge-kutta -r\" , & \"euler-1D --solver adams-bashforth  \" , & \"euler-1D --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver' , required = . true ., act = 'store' ) call cli % add ( switch = '--problem' , help = 'Problem solved' , required = . false ., def = 'sod' , act = 'store' , choices = 'sod,smooth' ) call cli % add ( switch = '--Ni' , help = 'Number finite volumes' , required = . false ., act = 'store' , def = '100' ) call cli % add ( switch = '--av_Ni' , help = 'Number finite volumes over average the solution' , required = . false ., act = 'store' , def = '-1' ) call cli % add ( switch = '--ss' , help = 'Stages/steps used' , required = . false ., act = 'store' , def = '-1' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--output' , help = 'Output files basename' , required = . false ., act = 'store' , def = 'unset' ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--solver' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--problem' , val = problem , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--av_Ni' , val = av_Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--ss' , val = stages_steps , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--results' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--plots' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--tserie' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--output' , val = output_cli , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop ! create Euler field initial state call init () ! integrate Euler equation select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Species counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( xcenter ( 1 : Ni )) allocate ( xnode ( 0 : Ni )) Dx = 1._R_P / Ni do i = 1 , Ni xcenter ( i ) = Dx * i - 0.5_R_P * Dx enddo do i = 0 , Ni xnode ( i ) = Dx * i enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then allocate ( av_xnode ( 0 : av_Ni )) do i = 0 , av_Ni av_xnode ( i ) = 1._R_P / av_Ni * i enddo endif select case ( trim ( adjustl ( problem ))) case ( 'sod' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.2_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str (. true ., s )) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case ( 'smooth' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.1_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str (. true ., s )) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni initial_state (:, i ) = [ 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! rho(s) 0.5_R_P * ( xcenter ( i ) - 0.5_R_P ) ** 4 , & ! u 1 0._R_P + 2._R_P * xcenter ( i ) ** 4 , & ! p 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case default print \"(A)\" , 'Error: unknown problem \"' // trim ( adjustl ( problem )) // '\"' print \"(A)\" , 'Valid problem names are:' print \"(A)\" , '  + sod' print \"(A)\" , '  + smooth' stop endselect if ( trim ( adjustl ( output_cli )) /= 'unset' ) then output = trim ( adjustl ( output_cli )) // '-' // trim ( adjustl ( solver )) else output = 'euler_1D_integration-' // trim ( adjustl ( solver )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine average_solution () !--------------------------------------------------------------------------------------------------------------------------------- !< Average the solution over an average grid. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i , ii , i1 , i2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then if ( allocated ( av_state )) deallocate ( av_state ) ; allocate ( av_state ( 1 : Np , 1 : av_Ni )) do i = 1 , av_Ni i1 = minloc ( array = xcenter , dim = 1 , mask = ( xcenter >= av_xnode ( i - 1 ))) i2 = maxloc ( array = xcenter , dim = 1 , mask = ( xcenter <= av_xnode ( i ))) av_state (:, i ) = 0._R_P do ii = i1 , i2 av_state (:, i ) = av_state (:, i ) + final_state (:, ii ) enddo av_state (:, i ) = av_state (:, i ) / ( i2 - i1 + 1 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine average_solution subroutine save_results ( title , basename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: basename !< Output basename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = basename // '-' // trim ( str (. true ., Ni )) // '_cells.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) variables write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str (. true ., Ni )) // ' cells\", I=' // trim ( str (. true ., Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 1 )) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str (. true ., Ni + 1 )) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( rawfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then print \"(A)\" , ' Average solution from Ni: ' // trim ( str (. true ., Ni )) // ' to av_Ni: ' // trim ( str (. true ., av_Ni )) call average_solution write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str (. true ., Ni )) // ' cells averaged over ' // trim ( str (. true ., av_Ni )) // & ' cells\", I=' // trim ( str (. true ., av_Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 1 )) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str (. true ., av_Ni + 1 )) // '(' // FR_P // ',1X))' ) av_xnode do v = 1 , Np write ( rawfile , '(' // trim ( str (. true ., av_Ni )) // '(' // FR_P // ',1X))' ) av_state ( v , :) enddo endif close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = xcenter , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = xcenter , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( basename // '-' // trim ( str (. true ., Ni )) // '_cells.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) 'TITLE=\"' // title // '\"' endif write ( tsfile , '(A)' ) variables // ' \"t\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\", I=' // trim ( str (. true ., Ni + 1 )) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str (. true ., Np + 2 )) // ']=CELLCENTERED)' write ( tsfile , '(' // trim ( str (. true ., Ni + 1 )) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( tsfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo write ( tsfile , '(' // trim ( str (. true ., Ni )) // '(' // FR_P // ',1X))' )( t , v = 1 , Ni ) if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( euler_1D ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of Adams-Bashforth class of solvers' steps_range = [ 1 , ab_steps ] ; if ( stages_steps > 0 ) steps_range = [ stages_steps , stages_steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' AB-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' steps' call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 1 ) call rk_integrator % init ( stages = s ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 3 ) call rk_integrator % init ( stages = s ) case ( 4 , 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 7 ) call rk_integrator % init ( stages = 5 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , t = t ( s )) step = 1 do while ( t ( s ) < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t ( s ), CFL = 0.1_R_P * CFL ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), dt = dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 call save_time_serie ( t = t ( s )) enddo call save_time_serie ( t = t ( s ), finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of explicit Euler solver' title = '1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '  Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( euler_1D ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( euler_1D ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of leapfrog (RAW filtered) class of solvers' title = '1D Euler equations integration, explicit leapfrog (RAW filtered), t=' // str ( n = t_final ) call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = 2 , ord = 3 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) step = 1 do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = 0.1_R_P * CFL ) if ( 2 >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of low storage (2N) Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of TVD/SSP Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) title = '1D Euler equations integration, explicit TVD/SSP Runge-Kutta, t=' // str ( n = t_final ) // trim ( str (. true ., s )) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_euler_1D","tags":"","loc":"program/integrate_euler_1d.html","title":"integrate_euler_1D – FOODIE"},{"text":"Uses: IR_Precision type_lorenz Data_Type_Command_Line_Interface foodie pyplot_module program~~integrate_lorenz~~UsesGraph program~integrate_lorenz integrate_lorenz IR_Precision IR_Precision IR_Precision->program~integrate_lorenz module~type_lorenz type_lorenz IR_Precision->module~type_lorenz pyplot_module pyplot_module pyplot_module->program~integrate_lorenz module~foodie foodie module~foodie->program~integrate_lorenz module~foodie->module~type_lorenz module~type_lorenz->program~integrate_lorenz Data_Type_Command_Line_Interface Data_Type_Command_Line_Interface Data_Type_Command_Line_Interface->program~integrate_lorenz module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_euler_explicit->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta var panprogramintegrate_lorenzUsesGraph = svgPanZoom('#programintegrate_lorenzUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODIE with the integration of Lorenz equations. Calls program~~integrate_lorenz~~CallsGraph program~integrate_lorenz integrate_lorenz proc~test_ab~4 test_ab program~integrate_lorenz->proc~test_ab~4 proc~test_leapfrog~4 test_leapfrog program~integrate_lorenz->proc~test_leapfrog~4 proc~test_tvd_rk~4 test_tvd_rk program~integrate_lorenz->proc~test_tvd_rk~4 proc~test_ls_rk~4 test_ls_rk program~integrate_lorenz->proc~test_ls_rk~4 proc~test_euler~4 test_euler program~integrate_lorenz->proc~test_euler~4 str str proc~test_ab~4->str proc~save_results~8 save_results proc~test_ab~4->proc~save_results~8 proc~test_leapfrog~4->proc~save_results~8 proc~test_tvd_rk~4->str proc~test_tvd_rk~4->proc~save_results~8 proc~test_ls_rk~4->str proc~test_ls_rk~4->proc~save_results~8 proc~test_euler~4->proc~save_results~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( lorenz ) :: attractor Lorenz field. integer, parameter :: num_steps = 2000 Maximum time steps. integer, parameter :: space_dimension = 3 Space dimensions. real(kind=R_P), parameter :: sigma = 10._R_P Lorenz' \\sigma. real(kind=R_P), parameter :: rho = 28._R_P Lorenz' \\rho. real(kind=R_P), parameter :: beta = 8._R_P/3._R_P Lorenz' \\beta. real(kind=R_P), parameter :: dt = 0.01_R_P Time step. real(kind=R_P), parameter :: initial_state (1:space_dimension) = [1.,1.,1.] Initial state. real(kind=R_P) :: solution (0:space_dimension,0:num_steps) Solution at each time step. integer(kind=I_P) :: error Error handler. character(len=99) :: solver Solver used. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. Subroutines subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. subroutine test_ab () Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. subroutine test_euler () Arguments None Description Test explicit forward Euler ODE solver. subroutine test_leapfrog () Arguments None Description Test explicit leapfrog class of ODE solvers. subroutine test_ls_rk () Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. subroutine test_tvd_rk () Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Source Code program integrate_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Lorenz equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_lorenz , only : lorenz use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( lorenz ) :: attractor !< Lorenz field. integer , parameter :: num_steps = 2000 !< Maximum time steps. integer , parameter :: space_dimension = 3 !< Space dimensions. real ( R_P ), parameter :: sigma = 1 0._R_P !< Lorenz' \\sigma. real ( R_P ), parameter :: rho = 2 8._R_P !< Lorenz' \\rho. real ( R_P ), parameter :: beta = 8._R_P / 3._R_P !< Lorenz' \\beta. real ( R_P ), parameter :: dt = 0.01_R_P !< Time step. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 1. , 1. , 1. ] !< Initial state. real ( R_P ) :: solution ( 0 : space_dimension , 0 : num_steps ) !< Solution at each time step. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'lorenz' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Lorenz equations integration' , & examples = [ \"lorenz --solver euler --results  \" , & \"lorenz --solver ls-runge-kutta -r\" , & \"lorenz --solver adams-bashforth  \" , & \"lorenz --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! integrate Lorenz equations select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\" \"z\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 3 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'x' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'y' , linestyle = 'b-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 3 , :), label = 'z' , linestyle = 'g-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'x-y path' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 3 , :), label = 'x-z path' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 2 , :), y = solution ( 3 , :), label = 'y-z path' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( lorenz ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call ab_integrator % integrate ( U = attractor , previous = previous ( 1 : s ), dt = dt , t = solution ( 0 , step - s : step - 1 )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'lorenz_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of explicit Euler solver' call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call euler_integrator % integrate ( U = attractor , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Euler' , & filename = 'lorenz_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( lorenz ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. type ( lorenz ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = 2 ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call lf_integrator % integrate ( U = attractor , previous = previous , dt = dt , t = solution ( 0 , step ), filter = filter ) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit leapfrog scheme' ,& filename = 'lorenz_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit low storage Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'lorenz_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit TVD Runge-Kutta ' // trim ( str (. true ., s )) // ' stages' ,& filename = 'lorenz_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_lorenz","tags":"","loc":"program/integrate_lorenz.html","title":"integrate_lorenz – FOODIE"}]}